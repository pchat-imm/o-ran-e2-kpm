/*
 *
 * Copyright 2021-2023 Software Radio Systems Limited
 *
 * This file is part of srsRAN.
 *
 * srsRAN is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * srsRAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * A copy of the GNU Affero General Public License can be found in
 * the LICENSE file in the top-level directory of this distribution
 * and at http://www.gnu.org/licenses/.
 *
 */

#include "srsran/asn1/f1ap/f1ap_ies.h"
#include <sstream>

using namespace asn1;
using namespace asn1::f1ap;

/*******************************************************************************
 *                                Struct Methods
 ******************************************************************************/

// LocationUncertainty ::= SEQUENCE
SRSASN_CODE location_uncertainty_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, horizontal_uncertainty, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pack_integer(bref, horizontal_confidence, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, vertical_uncertainty, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pack_integer(bref, vertical_confidence, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_uncertainty_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(horizontal_uncertainty, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(unpack_integer(horizontal_confidence, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(vertical_uncertainty, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(unpack_integer(vertical_confidence, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void location_uncertainty_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("horizontalUncertainty", horizontal_uncertainty);
  j.write_int("horizontalConfidence", horizontal_confidence);
  j.write_int("verticalUncertainty", vertical_uncertainty);
  j.write_int("verticalConfidence", vertical_confidence);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RelativeCartesianLocation ::= SEQUENCE
SRSASN_CODE relative_cartesian_location_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(xy_zunit.pack(bref));
  HANDLE_CODE(pack_integer(bref, xvalue, (int32_t)-65536, (int32_t)65535, false, true));
  HANDLE_CODE(pack_integer(bref, yvalue, (int32_t)-65536, (int32_t)65535, false, true));
  HANDLE_CODE(pack_integer(bref, zvalue, (int32_t)-32768, (int32_t)32767, false, true));
  HANDLE_CODE(location_uncertainty.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE relative_cartesian_location_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(xy_zunit.unpack(bref));
  HANDLE_CODE(unpack_integer(xvalue, bref, (int32_t)-65536, (int32_t)65535, false, true));
  HANDLE_CODE(unpack_integer(yvalue, bref, (int32_t)-65536, (int32_t)65535, false, true));
  HANDLE_CODE(unpack_integer(zvalue, bref, (int32_t)-32768, (int32_t)32767, false, true));
  HANDLE_CODE(location_uncertainty.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void relative_cartesian_location_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("xYZunit", xy_zunit.to_string());
  j.write_int("xvalue", xvalue);
  j.write_int("yvalue", yvalue);
  j.write_int("zvalue", zvalue);
  j.write_fieldname("locationUncertainty");
  location_uncertainty.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* relative_cartesian_location_s::xy_zunit_opts::to_string() const
{
  static const char* names[] = {"mm", "cm", "dm"};
  return convert_enum_idx(names, 3, value, "relative_cartesian_location_s::xy_zunit_e_");
}

// RelativeGeodeticLocation ::= SEQUENCE
SRSASN_CODE relative_geodetic_location_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(milli_arc_second_units.pack(bref));
  HANDLE_CODE(height_units.pack(bref));
  HANDLE_CODE(pack_integer(bref, delta_latitude, (int16_t)-1024, (int16_t)1023, false, true));
  HANDLE_CODE(pack_integer(bref, delta_longitude, (int16_t)-1024, (int16_t)1023, false, true));
  HANDLE_CODE(pack_integer(bref, delta_height, (int16_t)-1024, (int16_t)1023, false, true));
  HANDLE_CODE(location_uncertainty.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE relative_geodetic_location_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(milli_arc_second_units.unpack(bref));
  HANDLE_CODE(height_units.unpack(bref));
  HANDLE_CODE(unpack_integer(delta_latitude, bref, (int16_t)-1024, (int16_t)1023, false, true));
  HANDLE_CODE(unpack_integer(delta_longitude, bref, (int16_t)-1024, (int16_t)1023, false, true));
  HANDLE_CODE(unpack_integer(delta_height, bref, (int16_t)-1024, (int16_t)1023, false, true));
  HANDLE_CODE(location_uncertainty.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void relative_geodetic_location_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("milli-Arc-SecondUnits", milli_arc_second_units.to_string());
  j.write_str("heightUnits", height_units.to_string());
  j.write_int("deltaLatitude", delta_latitude);
  j.write_int("deltaLongitude", delta_longitude);
  j.write_int("deltaHeight", delta_height);
  j.write_fieldname("locationUncertainty");
  location_uncertainty.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* relative_geodetic_location_s::milli_arc_second_units_opts::to_string() const
{
  static const char* names[] = {"zerodot03", "zerodot3", "three"};
  return convert_enum_idx(names, 3, value, "relative_geodetic_location_s::milli_arc_second_units_e_");
}

const char* relative_geodetic_location_s::height_units_opts::to_string() const
{
  static const char* names[] = {"mm", "cm", "m"};
  return convert_enum_idx(names, 3, value, "relative_geodetic_location_s::height_units_e_");
}

// ARPLocationType ::= CHOICE
void arp_location_type_c::destroy_()
{
  switch (type_) {
    case types::arp_position_relative_geodetic:
      c.destroy<relative_geodetic_location_s>();
      break;
    case types::arp_position_relative_cartesian:
      c.destroy<relative_cartesian_location_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<arp_location_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void arp_location_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::arp_position_relative_geodetic:
      c.init<relative_geodetic_location_s>();
      break;
    case types::arp_position_relative_cartesian:
      c.init<relative_cartesian_location_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<arp_location_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "arp_location_type_c");
  }
}
arp_location_type_c::arp_location_type_c(const arp_location_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::arp_position_relative_geodetic:
      c.init(other.c.get<relative_geodetic_location_s>());
      break;
    case types::arp_position_relative_cartesian:
      c.init(other.c.get<relative_cartesian_location_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<arp_location_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "arp_location_type_c");
  }
}
arp_location_type_c& arp_location_type_c::operator=(const arp_location_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::arp_position_relative_geodetic:
      c.set(other.c.get<relative_geodetic_location_s>());
      break;
    case types::arp_position_relative_cartesian:
      c.set(other.c.get<relative_cartesian_location_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<arp_location_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "arp_location_type_c");
  }

  return *this;
}
relative_geodetic_location_s& arp_location_type_c::set_arp_position_relative_geodetic()
{
  set(types::arp_position_relative_geodetic);
  return c.get<relative_geodetic_location_s>();
}
relative_cartesian_location_s& arp_location_type_c::set_arp_position_relative_cartesian()
{
  set(types::arp_position_relative_cartesian);
  return c.get<relative_cartesian_location_s>();
}
protocol_ie_single_container_s<arp_location_type_ext_ies_o>& arp_location_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<arp_location_type_ext_ies_o>>();
}
void arp_location_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::arp_position_relative_geodetic:
      j.write_fieldname("aRPPositionRelativeGeodetic");
      c.get<relative_geodetic_location_s>().to_json(j);
      break;
    case types::arp_position_relative_cartesian:
      j.write_fieldname("aRPPositionRelativeCartesian");
      c.get<relative_cartesian_location_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<arp_location_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "arp_location_type_c");
  }
  j.end_obj();
}
SRSASN_CODE arp_location_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::arp_position_relative_geodetic:
      HANDLE_CODE(c.get<relative_geodetic_location_s>().pack(bref));
      break;
    case types::arp_position_relative_cartesian:
      HANDLE_CODE(c.get<relative_cartesian_location_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<arp_location_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "arp_location_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE arp_location_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::arp_position_relative_geodetic:
      HANDLE_CODE(c.get<relative_geodetic_location_s>().unpack(bref));
      break;
    case types::arp_position_relative_cartesian:
      HANDLE_CODE(c.get<relative_cartesian_location_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<arp_location_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "arp_location_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* arp_location_type_c::types_opts::to_string() const
{
  static const char* names[] = {"aRPPositionRelativeGeodetic", "aRPPositionRelativeCartesian", "choice-extension"};
  return convert_enum_idx(names, 3, value, "arp_location_type_c::types");
}

// ARPLocationInformation-Item ::= SEQUENCE
SRSASN_CODE arp_location_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, arp_id, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(arp_location_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE arp_location_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(arp_id, bref, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(arp_location_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void arp_location_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("aRP-ID", arp_id);
  j.write_fieldname("aRPLocationType");
  arp_location_type.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AbortTransmission ::= CHOICE
void abort_tx_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<abort_tx_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void abort_tx_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::srs_res_set_id:
      break;
    case types::release_all:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<abort_tx_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "abort_tx_c");
  }
}
abort_tx_c::abort_tx_c(const abort_tx_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::srs_res_set_id:
      c.init(other.c.get<uint8_t>());
      break;
    case types::release_all:
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<abort_tx_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "abort_tx_c");
  }
}
abort_tx_c& abort_tx_c::operator=(const abort_tx_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::srs_res_set_id:
      c.set(other.c.get<uint8_t>());
      break;
    case types::release_all:
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<abort_tx_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "abort_tx_c");
  }

  return *this;
}
uint8_t& abort_tx_c::set_srs_res_set_id()
{
  set(types::srs_res_set_id);
  return c.get<uint8_t>();
}
void abort_tx_c::set_release_all()
{
  set(types::release_all);
}
protocol_ie_single_container_s<abort_tx_ext_ies_o>& abort_tx_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<abort_tx_ext_ies_o>>();
}
void abort_tx_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::srs_res_set_id:
      j.write_int("sRSResourceSetID", c.get<uint8_t>());
      break;
    case types::release_all:
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<abort_tx_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "abort_tx_c");
  }
  j.end_obj();
}
SRSASN_CODE abort_tx_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::srs_res_set_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)15u, true, true));
      break;
    case types::release_all:
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<abort_tx_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "abort_tx_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE abort_tx_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::srs_res_set_id:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)15u, true, true));
      break;
    case types::release_all:
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<abort_tx_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "abort_tx_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* abort_tx_c::types_opts::to_string() const
{
  static const char* names[] = {"sRSResourceSetID", "releaseALL", "choice-extension"};
  return convert_enum_idx(names, 3, value, "abort_tx_c::types");
}

// RACHReportInformationItem ::= SEQUENCE
SRSASN_CODE rach_report_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_assitant_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rach_report_container.pack(bref));
  if (ue_assitant_id_present) {
    HANDLE_CODE(pack_integer(bref, ue_assitant_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rach_report_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ue_assitant_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rach_report_container.unpack(bref));
  if (ue_assitant_id_present) {
    HANDLE_CODE(unpack_integer(ue_assitant_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rach_report_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rACHReportContainer", rach_report_container.to_string());
  if (ue_assitant_id_present) {
    j.write_int("uEAssitantIdentifier", ue_assitant_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RLFReportInformationItem ::= SEQUENCE
SRSASN_CODE rlf_report_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ue_assitant_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_ue_rlf_report_container.pack(bref));
  if (ue_assitant_id_present) {
    HANDLE_CODE(pack_integer(bref, ue_assitant_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rlf_report_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ue_assitant_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_ue_rlf_report_container.unpack(bref));
  if (ue_assitant_id_present) {
    HANDLE_CODE(unpack_integer(ue_assitant_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rlf_report_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nRUERLFReportContainer", nr_ue_rlf_report_container.to_string());
  if (ue_assitant_id_present) {
    j.write_int("uEAssitantIdentifier", ue_assitant_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SuccessfulHOReportInformation-Item ::= SEQUENCE
SRSASN_CODE successful_ho_report_info_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(successful_ho_report_container.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE successful_ho_report_info_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(successful_ho_report_container.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void successful_ho_report_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("successfulHOReportContainer", successful_ho_report_container.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AccessPointPosition ::= SEQUENCE
SRSASN_CODE access_point_position_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(latitude_sign.pack(bref));
  HANDLE_CODE(pack_integer(bref, latitude, (uint32_t)0u, (uint32_t)8388607u, false, true));
  HANDLE_CODE(pack_integer(bref, longitude, (int32_t)-8388608, (int32_t)8388607, false, true));
  HANDLE_CODE(direction_of_altitude.pack(bref));
  HANDLE_CODE(pack_integer(bref, altitude, (uint16_t)0u, (uint16_t)32767u, false, true));
  HANDLE_CODE(pack_integer(bref, uncertainty_semi_major, (uint8_t)0u, (uint8_t)127u, false, true));
  HANDLE_CODE(pack_integer(bref, uncertainty_semi_minor, (uint8_t)0u, (uint8_t)127u, false, true));
  HANDLE_CODE(pack_integer(bref, orientation_of_major_axis, (uint8_t)0u, (uint8_t)179u, false, true));
  HANDLE_CODE(pack_integer(bref, uncertainty_altitude, (uint8_t)0u, (uint8_t)127u, false, true));
  HANDLE_CODE(pack_integer(bref, confidence, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE access_point_position_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(latitude_sign.unpack(bref));
  HANDLE_CODE(unpack_integer(latitude, bref, (uint32_t)0u, (uint32_t)8388607u, false, true));
  HANDLE_CODE(unpack_integer(longitude, bref, (int32_t)-8388608, (int32_t)8388607, false, true));
  HANDLE_CODE(direction_of_altitude.unpack(bref));
  HANDLE_CODE(unpack_integer(altitude, bref, (uint16_t)0u, (uint16_t)32767u, false, true));
  HANDLE_CODE(unpack_integer(uncertainty_semi_major, bref, (uint8_t)0u, (uint8_t)127u, false, true));
  HANDLE_CODE(unpack_integer(uncertainty_semi_minor, bref, (uint8_t)0u, (uint8_t)127u, false, true));
  HANDLE_CODE(unpack_integer(orientation_of_major_axis, bref, (uint8_t)0u, (uint8_t)179u, false, true));
  HANDLE_CODE(unpack_integer(uncertainty_altitude, bref, (uint8_t)0u, (uint8_t)127u, false, true));
  HANDLE_CODE(unpack_integer(confidence, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void access_point_position_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("latitudeSign", latitude_sign.to_string());
  j.write_int("latitude", latitude);
  j.write_int("longitude", longitude);
  j.write_str("directionOfAltitude", direction_of_altitude.to_string());
  j.write_int("altitude", altitude);
  j.write_int("uncertaintySemi-major", uncertainty_semi_major);
  j.write_int("uncertaintySemi-minor", uncertainty_semi_minor);
  j.write_int("orientationOfMajorAxis", orientation_of_major_axis);
  j.write_int("uncertaintyAltitude", uncertainty_altitude);
  j.write_int("confidence", confidence);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* access_point_position_s::latitude_sign_opts::to_string() const
{
  static const char* names[] = {"north", "south"};
  return convert_enum_idx(names, 2, value, "access_point_position_s::latitude_sign_e_");
}

const char* access_point_position_s::direction_of_altitude_opts::to_string() const
{
  static const char* names[] = {"height", "depth"};
  return convert_enum_idx(names, 2, value, "access_point_position_s::direction_of_altitude_e_");
}
uint8_t access_point_position_s::direction_of_altitude_opts::to_number() const
{
  static const uint8_t numbers[] = {8};
  return map_enum_number(numbers, 1, value, "access_point_position_s::direction_of_altitude_e_");
}

// NRCGI ::= SEQUENCE
SRSASN_CODE nr_cgi_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(nr_cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_cgi_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(nr_cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_cgi_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  j.write_str("nRCellIdentity", nr_cell_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HSNADownlink ::= ENUMERATED
const char* h_sn_a_dl_opts::to_string() const
{
  static const char* names[] = {"hard", "soft", "notavailable"};
  return convert_enum_idx(names, 3, value, "h_sn_a_dl_e");
}

// HSNAFlexible ::= ENUMERATED
const char* h_sn_a_flex_opts::to_string() const
{
  static const char* names[] = {"hard", "soft", "notavailable"};
  return convert_enum_idx(names, 3, value, "h_sn_a_flex_e");
}

// HSNAUplink ::= ENUMERATED
const char* h_sn_a_ul_opts::to_string() const
{
  static const char* names[] = {"hard", "soft", "notavailable"};
  return convert_enum_idx(names, 3, value, "h_sn_a_ul_e");
}

// NADownlink ::= ENUMERATED
const char* na_dl_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "na_dl_e");
}

// NAFlexible ::= ENUMERATED
const char* na_flex_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "na_flex_e");
}

// NAUplink ::= ENUMERATED
const char* na_ul_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "na_ul_e");
}

// NRSCS ::= ENUMERATED
const char* nr_scs_opts::to_string() const
{
  static const char* names[] = {"scs15", "scs30", "scs60", "scs120", "scs480", "scs960"};
  return convert_enum_idx(names, 6, value, "nr_scs_e");
}
uint16_t nr_scs_opts::to_number() const
{
  static const uint16_t numbers[] = {15, 30, 60, 120, 480, 960};
  return map_enum_number(numbers, 6, value, "nr_scs_e");
}

// Frequency-Domain-HSNA-Slot-Configuration-Item ::= SEQUENCE
SRSASN_CODE freq_domain_h_sn_a_slot_cfg_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(slot_idx_present, 1));
  HANDLE_CODE(bref.pack(hsn_a_dl_present, 1));
  HANDLE_CODE(bref.pack(hsn_a_ul_present, 1));
  HANDLE_CODE(bref.pack(hsn_a_flex_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (slot_idx_present) {
    HANDLE_CODE(pack_integer(bref, slot_idx, (uint16_t)0u, (uint16_t)5119u, false, true));
  }
  if (hsn_a_dl_present) {
    HANDLE_CODE(hsn_a_dl.pack(bref));
  }
  if (hsn_a_ul_present) {
    HANDLE_CODE(hsn_a_ul.pack(bref));
  }
  if (hsn_a_flex_present) {
    HANDLE_CODE(hsn_a_flex.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE freq_domain_h_sn_a_slot_cfg_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(slot_idx_present, 1));
  HANDLE_CODE(bref.unpack(hsn_a_dl_present, 1));
  HANDLE_CODE(bref.unpack(hsn_a_ul_present, 1));
  HANDLE_CODE(bref.unpack(hsn_a_flex_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (slot_idx_present) {
    HANDLE_CODE(unpack_integer(slot_idx, bref, (uint16_t)0u, (uint16_t)5119u, false, true));
  }
  if (hsn_a_dl_present) {
    HANDLE_CODE(hsn_a_dl.unpack(bref));
  }
  if (hsn_a_ul_present) {
    HANDLE_CODE(hsn_a_ul.unpack(bref));
  }
  if (hsn_a_flex_present) {
    HANDLE_CODE(hsn_a_flex.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void freq_domain_h_sn_a_slot_cfg_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (slot_idx_present) {
    j.write_int("slotIndex", slot_idx);
  }
  if (hsn_a_dl_present) {
    j.write_str("hSNADownlink", hsn_a_dl.to_string());
  }
  if (hsn_a_ul_present) {
    j.write_str("hSNAUplink", hsn_a_ul.to_string());
  }
  if (hsn_a_flex_present) {
    j.write_str("hSNAFlexible", hsn_a_flex.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NA-Resource-Configuration-Item ::= SEQUENCE
SRSASN_CODE na_res_cfg_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(na_dl_present, 1));
  HANDLE_CODE(bref.pack(na_ul_present, 1));
  HANDLE_CODE(bref.pack(na_flex_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (na_dl_present) {
    HANDLE_CODE(na_dl.pack(bref));
  }
  if (na_ul_present) {
    HANDLE_CODE(na_ul.pack(bref));
  }
  if (na_flex_present) {
    HANDLE_CODE(na_flex.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE na_res_cfg_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(na_dl_present, 1));
  HANDLE_CODE(bref.unpack(na_ul_present, 1));
  HANDLE_CODE(bref.unpack(na_flex_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (na_dl_present) {
    HANDLE_CODE(na_dl.unpack(bref));
  }
  if (na_ul_present) {
    HANDLE_CODE(na_ul.unpack(bref));
  }
  if (na_flex_present) {
    HANDLE_CODE(na_flex.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void na_res_cfg_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (na_dl_present) {
    j.write_str("nADownlink", na_dl.to_string());
  }
  if (na_ul_present) {
    j.write_str("nAUplink", na_ul.to_string());
  }
  if (na_flex_present) {
    j.write_str("nAFlexible", na_flex.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRCarrierItem ::= SEQUENCE
SRSASN_CODE nr_carrier_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(carrier_scs.pack(bref));
  HANDLE_CODE(pack_integer(bref, offset_to_carrier, (uint16_t)0u, (uint16_t)2199u, true, true));
  HANDLE_CODE(pack_integer(bref, carrier_bw, (uint16_t)0u, (uint16_t)275u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_carrier_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(carrier_scs.unpack(bref));
  HANDLE_CODE(unpack_integer(offset_to_carrier, bref, (uint16_t)0u, (uint16_t)2199u, true, true));
  HANDLE_CODE(unpack_integer(carrier_bw, bref, (uint16_t)0u, (uint16_t)275u, true, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_carrier_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("carrierSCS", carrier_scs.to_string());
  j.write_int("offsetToCarrier", offset_to_carrier);
  j.write_int("carrierBandwidth", carrier_bw);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// FrequencyShift7p5khz ::= ENUMERATED
const char* freq_shift7p5khz_opts::to_string() const
{
  static const char* names[] = {"false", "true"};
  return convert_enum_idx(names, 2, value, "freq_shift7p5khz_e");
}

// NRNRB ::= ENUMERATED
const char* nr_nrb_opts::to_string() const
{
  static const char* names[] = {"nrb11",  "nrb18",  "nrb24",  "nrb25",  "nrb31",  "nrb32",  "nrb38",  "nrb51",
                                "nrb52",  "nrb65",  "nrb66",  "nrb78",  "nrb79",  "nrb93",  "nrb106", "nrb107",
                                "nrb121", "nrb132", "nrb133", "nrb135", "nrb160", "nrb162", "nrb189", "nrb216",
                                "nrb217", "nrb245", "nrb264", "nrb270", "nrb273", "nrb33",  "nrb62",  "nrb124",
                                "nrb148", "nrb248", "nrb44",  "nrb58",  "nrb92",  "nrb119", "nrb188", "nrb242"};
  return convert_enum_idx(names, 40, value, "nr_nrb_e");
}
uint16_t nr_nrb_opts::to_number() const
{
  static const uint16_t numbers[] = {11,  18,  24,  25,  31,  32,  38,  51,  52,  65,  66,  78,  79,  93,
                                     106, 107, 121, 132, 133, 135, 160, 162, 189, 216, 217, 245, 264, 270,
                                     273, 33,  62,  124, 148, 248, 44,  58,  92,  119, 188, 242};
  return map_enum_number(numbers, 40, value, "nr_nrb_e");
}

// Permutation ::= ENUMERATED
const char* permutation_opts::to_string() const
{
  static const char* names[] = {"dfu", "ufd"};
  return convert_enum_idx(names, 2, value, "permutation_e");
}

// Child-IAB-Nodes-NA-Resource-List-Item ::= SEQUENCE
SRSASN_CODE child_iab_nodes_na_res_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(na_res_cfg_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, gnb_cu_ue_f1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  HANDLE_CODE(pack_integer(bref, gnb_du_ue_f1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (na_res_cfg_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, na_res_cfg_list, 1, 5120, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE child_iab_nodes_na_res_list_item_s::unpack(cbit_ref& bref)
{
  bool na_res_cfg_list_present;
  HANDLE_CODE(bref.unpack(na_res_cfg_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(gnb_cu_ue_f1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  HANDLE_CODE(unpack_integer(gnb_du_ue_f1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (na_res_cfg_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(na_res_cfg_list, bref, 1, 5120, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void child_iab_nodes_na_res_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("gNB-CU-UE-F1AP-ID", gnb_cu_ue_f1ap_id);
  j.write_int("gNB-DU-UE-F1AP-ID", gnb_du_ue_f1ap_id);
  if (na_res_cfg_list.size() > 0) {
    j.start_array("nA-Resource-Configuration-List");
    for (const auto& e1 : na_res_cfg_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExplicitFormat ::= SEQUENCE
SRSASN_CODE explicit_format_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(noof_dl_symbols_present, 1));
  HANDLE_CODE(bref.pack(noof_ul_symbols_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(permutation.pack(bref));
  if (noof_dl_symbols_present) {
    HANDLE_CODE(pack_integer(bref, noof_dl_symbols, (uint8_t)0u, (uint8_t)14u, false, true));
  }
  if (noof_ul_symbols_present) {
    HANDLE_CODE(pack_integer(bref, noof_ul_symbols, (uint8_t)0u, (uint8_t)14u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE explicit_format_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(noof_dl_symbols_present, 1));
  HANDLE_CODE(bref.unpack(noof_ul_symbols_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(permutation.unpack(bref));
  if (noof_dl_symbols_present) {
    HANDLE_CODE(unpack_integer(noof_dl_symbols, bref, (uint8_t)0u, (uint8_t)14u, false, true));
  }
  if (noof_ul_symbols_present) {
    HANDLE_CODE(unpack_integer(noof_ul_symbols, bref, (uint8_t)0u, (uint8_t)14u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void explicit_format_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("permutation", permutation.to_string());
  if (noof_dl_symbols_present) {
    j.write_int("noofDownlinkSymbols", noof_dl_symbols);
  }
  if (noof_ul_symbols_present) {
    j.write_int("noofUplinkSymbols", noof_ul_symbols);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Frequency-Domain-HSNA-Configuration-Item ::= SEQUENCE
SRSASN_CODE freq_domain_h_sn_a_cfg_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, rb_set_idx, (uint8_t)0u, (uint8_t)7u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, freq_domain_h_sn_a_slot_cfg_list, 1, 5120, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE freq_domain_h_sn_a_cfg_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(rb_set_idx, bref, (uint8_t)0u, (uint8_t)7u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(freq_domain_h_sn_a_slot_cfg_list, bref, 1, 5120, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void freq_domain_h_sn_a_cfg_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("rBSetIndex", rb_set_idx);
  j.start_array("frequency-Domain-HSNA-Slot-Configuration-List");
  for (const auto& e1 : freq_domain_h_sn_a_slot_cfg_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ImplicitFormat ::= SEQUENCE
SRSASN_CODE implicit_format_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, du_f_slotformat_idx, (uint8_t)0u, (uint8_t)254u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE implicit_format_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(du_f_slotformat_idx, bref, (uint8_t)0u, (uint8_t)254u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void implicit_format_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dUFSlotformatIndex", du_f_slotformat_idx);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Parent-IAB-Nodes-NA-Resource-Configuration-Item ::= SEQUENCE
SRSASN_CODE parent_iab_nodes_na_res_cfg_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(na_dl_present, 1));
  HANDLE_CODE(bref.pack(na_ul_present, 1));
  HANDLE_CODE(bref.pack(na_flex_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (na_dl_present) {
    HANDLE_CODE(na_dl.pack(bref));
  }
  if (na_ul_present) {
    HANDLE_CODE(na_ul.pack(bref));
  }
  if (na_flex_present) {
    HANDLE_CODE(na_flex.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE parent_iab_nodes_na_res_cfg_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(na_dl_present, 1));
  HANDLE_CODE(bref.unpack(na_ul_present, 1));
  HANDLE_CODE(bref.unpack(na_flex_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (na_dl_present) {
    HANDLE_CODE(na_dl.unpack(bref));
  }
  if (na_ul_present) {
    HANDLE_CODE(na_ul.unpack(bref));
  }
  if (na_flex_present) {
    HANDLE_CODE(na_flex.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void parent_iab_nodes_na_res_cfg_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (na_dl_present) {
    j.write_str("nADownlink", na_dl.to_string());
  }
  if (na_ul_present) {
    j.write_str("nAUplink", na_ul.to_string());
  }
  if (na_flex_present) {
    j.write_str("nAFlexible", na_flex.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RBSetSize ::= ENUMERATED
const char* rb_set_size_opts::to_string() const
{
  static const char* names[] = {"rb2", "rb4", "rb8", "rb16", "rb32", "rb64"};
  return convert_enum_idx(names, 6, value, "rb_set_size_e");
}
uint8_t rb_set_size_opts::to_number() const
{
  static const uint8_t numbers[] = {2, 4, 8, 16, 32, 64};
  return map_enum_number(numbers, 6, value, "rb_set_size_e");
}

// SUL-InformationExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t sul_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {354, 356};
  return map_enum_number(names, 2, idx, "id");
}
bool sul_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {354, 356};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e sul_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 354:
      return crit_e::ignore;
    case 356:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
sul_info_ext_ies_o::ext_c sul_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 354:
      ret.set(ext_c::types::carrier_list);
      break;
    case 356:
      ret.set(ext_c::types::freq_shift7p5khz);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e sul_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 354:
      return presence_e::optional;
    case 356:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void sul_info_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::carrier_list:
      c.destroy<nr_carrier_list_l>();
      break;
    default:
      break;
  }
}
void sul_info_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::carrier_list:
      c.init<nr_carrier_list_l>();
      break;
    case types::freq_shift7p5khz:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sul_info_ext_ies_o::ext_c");
  }
}
sul_info_ext_ies_o::ext_c::ext_c(const sul_info_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::carrier_list:
      c.init(other.c.get<nr_carrier_list_l>());
      break;
    case types::freq_shift7p5khz:
      c.init(other.c.get<freq_shift7p5khz_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sul_info_ext_ies_o::ext_c");
  }
}
sul_info_ext_ies_o::ext_c& sul_info_ext_ies_o::ext_c::operator=(const sul_info_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::carrier_list:
      c.set(other.c.get<nr_carrier_list_l>());
      break;
    case types::freq_shift7p5khz:
      c.set(other.c.get<freq_shift7p5khz_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sul_info_ext_ies_o::ext_c");
  }

  return *this;
}
nr_carrier_list_l& sul_info_ext_ies_o::ext_c::carrier_list()
{
  assert_choice_type(types::carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
freq_shift7p5khz_e& sul_info_ext_ies_o::ext_c::freq_shift7p5khz()
{
  assert_choice_type(types::freq_shift7p5khz, type_, "Extension");
  return c.get<freq_shift7p5khz_e>();
}
const nr_carrier_list_l& sul_info_ext_ies_o::ext_c::carrier_list() const
{
  assert_choice_type(types::carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
const freq_shift7p5khz_e& sul_info_ext_ies_o::ext_c::freq_shift7p5khz() const
{
  assert_choice_type(types::freq_shift7p5khz, type_, "Extension");
  return c.get<freq_shift7p5khz_e>();
}
void sul_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::carrier_list:
      j.start_array("NRCarrierList");
      for (const auto& e1 : c.get<nr_carrier_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::freq_shift7p5khz:
      j.write_str("FrequencyShift7p5khz", c.get<freq_shift7p5khz_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "sul_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE sul_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::carrier_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_carrier_list_l>(), 1, 5, true));
      break;
    case types::freq_shift7p5khz:
      HANDLE_CODE(c.get<freq_shift7p5khz_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sul_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE sul_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::carrier_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_carrier_list_l>(), bref, 1, 5, true));
      break;
    case types::freq_shift7p5khz:
      HANDLE_CODE(c.get<freq_shift7p5khz_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sul_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// SubcarrierSpacing ::= ENUMERATED
const char* subcarrier_spacing_opts::to_string() const
{
  static const char* names[] = {"kHz15", "kHz30", "kHz60", "kHz120", "kHz240", "spare3", "spare2", "spare1"};
  return convert_enum_idx(names, 8, value, "subcarrier_spacing_e");
}
uint8_t subcarrier_spacing_opts::to_number() const
{
  static const uint8_t numbers[] = {15, 30, 60, 120, 240};
  return map_enum_number(numbers, 5, value, "subcarrier_spacing_e");
}

// SupportedSULFreqBandItem ::= SEQUENCE
SRSASN_CODE supported_sul_freq_band_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, freq_band_ind_nr, (uint16_t)1u, (uint16_t)1024u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE supported_sul_freq_band_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(freq_band_ind_nr, bref, (uint16_t)1u, (uint16_t)1024u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void supported_sul_freq_band_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("freqBandIndicatorNr", freq_band_ind_nr);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Transmission-Bandwidth ::= SEQUENCE
SRSASN_CODE tx_bw_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_scs.pack(bref));
  HANDLE_CODE(nr_nrb.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tx_bw_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_scs.unpack(bref));
  HANDLE_CODE(nr_nrb.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tx_bw_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nRSCS", nr_scs.to_string());
  j.write_str("nRNRB", nr_nrb.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DUF-Slot-Config-Item ::= CHOICE
void du_f_slot_cfg_item_c::destroy_()
{
  switch (type_) {
    case types::explicit_format:
      c.destroy<explicit_format_s>();
      break;
    case types::implicit_format:
      c.destroy<implicit_format_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void du_f_slot_cfg_item_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::explicit_format:
      c.init<explicit_format_s>();
      break;
    case types::implicit_format:
      c.init<implicit_format_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "du_f_slot_cfg_item_c");
  }
}
du_f_slot_cfg_item_c::du_f_slot_cfg_item_c(const du_f_slot_cfg_item_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::explicit_format:
      c.init(other.c.get<explicit_format_s>());
      break;
    case types::implicit_format:
      c.init(other.c.get<implicit_format_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "du_f_slot_cfg_item_c");
  }
}
du_f_slot_cfg_item_c& du_f_slot_cfg_item_c::operator=(const du_f_slot_cfg_item_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::explicit_format:
      c.set(other.c.get<explicit_format_s>());
      break;
    case types::implicit_format:
      c.set(other.c.get<implicit_format_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "du_f_slot_cfg_item_c");
  }

  return *this;
}
explicit_format_s& du_f_slot_cfg_item_c::set_explicit_format()
{
  set(types::explicit_format);
  return c.get<explicit_format_s>();
}
implicit_format_s& du_f_slot_cfg_item_c::set_implicit_format()
{
  set(types::implicit_format);
  return c.get<implicit_format_s>();
}
protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>& du_f_slot_cfg_item_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>();
}
void du_f_slot_cfg_item_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::explicit_format:
      j.write_fieldname("explicitFormat");
      c.get<explicit_format_s>().to_json(j);
      break;
    case types::implicit_format:
      j.write_fieldname("implicitFormat");
      c.get<implicit_format_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "du_f_slot_cfg_item_c");
  }
  j.end_obj();
}
SRSASN_CODE du_f_slot_cfg_item_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::explicit_format:
      HANDLE_CODE(c.get<explicit_format_s>().pack(bref));
      break;
    case types::implicit_format:
      HANDLE_CODE(c.get<implicit_format_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "du_f_slot_cfg_item_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE du_f_slot_cfg_item_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::explicit_format:
      HANDLE_CODE(c.get<explicit_format_s>().unpack(bref));
      break;
    case types::implicit_format:
      HANDLE_CODE(c.get<implicit_format_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<du_f_slot_cfg_item_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "du_f_slot_cfg_item_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* du_f_slot_cfg_item_c::types_opts::to_string() const
{
  static const char* names[] = {"explicitFormat", "implicitFormat", "choice-extension"};
  return convert_enum_idx(names, 3, value, "du_f_slot_cfg_item_c::types");
}

// FreqBandNrItem ::= SEQUENCE
SRSASN_CODE freq_band_nr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, freq_band_ind_nr, (uint16_t)1u, (uint16_t)1024u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, supported_sul_band_list, 0, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE freq_band_nr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(freq_band_ind_nr, bref, (uint16_t)1u, (uint16_t)1024u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(supported_sul_band_list, bref, 0, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void freq_band_nr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("freqBandIndicatorNr", freq_band_ind_nr);
  j.start_array("supportedSULBandList");
  for (const auto& e1 : supported_sul_band_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// HSNASlotConfigItem ::= SEQUENCE
SRSASN_CODE hs_nas_lot_cfg_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(hsn_a_dl_present, 1));
  HANDLE_CODE(bref.pack(hsn_a_ul_present, 1));
  HANDLE_CODE(bref.pack(hsn_a_flex_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (hsn_a_dl_present) {
    HANDLE_CODE(hsn_a_dl.pack(bref));
  }
  if (hsn_a_ul_present) {
    HANDLE_CODE(hsn_a_ul.pack(bref));
  }
  if (hsn_a_flex_present) {
    HANDLE_CODE(hsn_a_flex.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE hs_nas_lot_cfg_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(hsn_a_dl_present, 1));
  HANDLE_CODE(bref.unpack(hsn_a_ul_present, 1));
  HANDLE_CODE(bref.unpack(hsn_a_flex_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (hsn_a_dl_present) {
    HANDLE_CODE(hsn_a_dl.unpack(bref));
  }
  if (hsn_a_ul_present) {
    HANDLE_CODE(hsn_a_ul.unpack(bref));
  }
  if (hsn_a_flex_present) {
    HANDLE_CODE(hsn_a_flex.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void hs_nas_lot_cfg_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (hsn_a_dl_present) {
    j.write_str("hSNADownlink", hsn_a_dl.to_string());
  }
  if (hsn_a_ul_present) {
    j.write_str("hSNAUplink", hsn_a_ul.to_string());
  }
  if (hsn_a_flex_present) {
    j.write_str("hSNAFlexible", hsn_a_flex.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRFreqInfoExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t nr_freq_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {356};
  return map_enum_number(names, 1, idx, "id");
}
bool nr_freq_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 356 == id;
}
crit_e nr_freq_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 356) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
nr_freq_info_ext_ies_o::ext_c nr_freq_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 356) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e nr_freq_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 356) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void nr_freq_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("FrequencyShift7p5khz", c.to_string());
  j.end_obj();
}
SRSASN_CODE nr_freq_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_freq_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// RBSetConfiguration ::= SEQUENCE
SRSASN_CODE rb_set_cfg_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(subcarrier_spacing.pack(bref));
  HANDLE_CODE(rb_set_size.pack(bref));
  HANDLE_CODE(pack_integer(bref, num_r_bsets, (uint8_t)1u, (uint8_t)8u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rb_set_cfg_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(subcarrier_spacing.unpack(bref));
  HANDLE_CODE(rb_set_size.unpack(bref));
  HANDLE_CODE(unpack_integer(num_r_bsets, bref, (uint8_t)1u, (uint8_t)8u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rb_set_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("subcarrierSpacing", subcarrier_spacing.to_string());
  j.write_str("rBSetSize", rb_set_size.to_string());
  j.write_int("nUmberRBsets", num_r_bsets);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE sul_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += carrier_list_present ? 1 : 0;
  nof_ies += freq_shift7p5khz_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (carrier_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)354, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, carrier_list, 1, 5, true));
  }
  if (freq_shift7p5khz_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)356, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(freq_shift7p5khz.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sul_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 354: {
        carrier_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(carrier_list, bref, 1, 5, true));
        break;
      }
      case 356: {
        freq_shift7p5khz_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(freq_shift7p5khz.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void sul_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (carrier_list_present) {
    j.write_int("id", 354);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (freq_shift7p5khz_present) {
    j.write_int("id", 356);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", freq_shift7p5khz.to_string());
  }
  j.end_obj();
}

// SUL-Information ::= SEQUENCE
SRSASN_CODE sul_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sul_nr_arfcn, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(sul_tx_bw.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sul_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sul_nr_arfcn, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(sul_tx_bw.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sul_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sUL-NRARFCN", sul_nr_arfcn);
  j.write_fieldname("sUL-transmission-Bandwidth");
  sul_tx_bw.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DUFTransmissionPeriodicity ::= ENUMERATED
const char* du_f_tx_periodicity_opts::to_string() const
{
  static const char* names[] = {"ms0p5", "ms0p625", "ms1", "ms1p25", "ms2", "ms2p5", "ms5", "ms10"};
  return convert_enum_idx(names, 8, value, "du_f_tx_periodicity_e");
}

// GNB-DU-Cell-Resource-Configuration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t gnb_du_cell_res_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {520, 521, 522, 523};
  return map_enum_number(names, 4, idx, "id");
}
bool gnb_du_cell_res_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {520, 521, 522, 523};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e gnb_du_cell_res_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 520:
      return crit_e::reject;
    case 521:
      return crit_e::reject;
    case 522:
      return crit_e::reject;
    case 523:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
gnb_du_cell_res_cfg_ext_ies_o::ext_c gnb_du_cell_res_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 520:
      ret.set(ext_c::types::rb_set_cfg);
      break;
    case 521:
      ret.set(ext_c::types::freq_domain_h_sn_a_cfg_list);
      break;
    case 522:
      ret.set(ext_c::types::child_iab_nodes_na_res_list);
      break;
    case 523:
      ret.set(ext_c::types::parent_iab_nodes_na_res_cfg_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e gnb_du_cell_res_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 520:
      return presence_e::optional;
    case 521:
      return presence_e::optional;
    case 522:
      return presence_e::optional;
    case 523:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void gnb_du_cell_res_cfg_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::rb_set_cfg:
      c.destroy<rb_set_cfg_s>();
      break;
    case types::freq_domain_h_sn_a_cfg_list:
      c.destroy<freq_domain_h_sn_a_cfg_list_l>();
      break;
    case types::child_iab_nodes_na_res_list:
      c.destroy<child_iab_nodes_na_res_list_l>();
      break;
    case types::parent_iab_nodes_na_res_cfg_list:
      c.destroy<parent_iab_nodes_na_res_cfg_list_l>();
      break;
    default:
      break;
  }
}
void gnb_du_cell_res_cfg_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::rb_set_cfg:
      c.init<rb_set_cfg_s>();
      break;
    case types::freq_domain_h_sn_a_cfg_list:
      c.init<freq_domain_h_sn_a_cfg_list_l>();
      break;
    case types::child_iab_nodes_na_res_list:
      c.init<child_iab_nodes_na_res_list_l>();
      break;
    case types::parent_iab_nodes_na_res_cfg_list:
      c.init<parent_iab_nodes_na_res_cfg_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_du_cell_res_cfg_ext_ies_o::ext_c");
  }
}
gnb_du_cell_res_cfg_ext_ies_o::ext_c::ext_c(const gnb_du_cell_res_cfg_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::rb_set_cfg:
      c.init(other.c.get<rb_set_cfg_s>());
      break;
    case types::freq_domain_h_sn_a_cfg_list:
      c.init(other.c.get<freq_domain_h_sn_a_cfg_list_l>());
      break;
    case types::child_iab_nodes_na_res_list:
      c.init(other.c.get<child_iab_nodes_na_res_list_l>());
      break;
    case types::parent_iab_nodes_na_res_cfg_list:
      c.init(other.c.get<parent_iab_nodes_na_res_cfg_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_du_cell_res_cfg_ext_ies_o::ext_c");
  }
}
gnb_du_cell_res_cfg_ext_ies_o::ext_c&
gnb_du_cell_res_cfg_ext_ies_o::ext_c::operator=(const gnb_du_cell_res_cfg_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::rb_set_cfg:
      c.set(other.c.get<rb_set_cfg_s>());
      break;
    case types::freq_domain_h_sn_a_cfg_list:
      c.set(other.c.get<freq_domain_h_sn_a_cfg_list_l>());
      break;
    case types::child_iab_nodes_na_res_list:
      c.set(other.c.get<child_iab_nodes_na_res_list_l>());
      break;
    case types::parent_iab_nodes_na_res_cfg_list:
      c.set(other.c.get<parent_iab_nodes_na_res_cfg_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_du_cell_res_cfg_ext_ies_o::ext_c");
  }

  return *this;
}
rb_set_cfg_s& gnb_du_cell_res_cfg_ext_ies_o::ext_c::rb_set_cfg()
{
  assert_choice_type(types::rb_set_cfg, type_, "Extension");
  return c.get<rb_set_cfg_s>();
}
freq_domain_h_sn_a_cfg_list_l& gnb_du_cell_res_cfg_ext_ies_o::ext_c::freq_domain_h_sn_a_cfg_list()
{
  assert_choice_type(types::freq_domain_h_sn_a_cfg_list, type_, "Extension");
  return c.get<freq_domain_h_sn_a_cfg_list_l>();
}
child_iab_nodes_na_res_list_l& gnb_du_cell_res_cfg_ext_ies_o::ext_c::child_iab_nodes_na_res_list()
{
  assert_choice_type(types::child_iab_nodes_na_res_list, type_, "Extension");
  return c.get<child_iab_nodes_na_res_list_l>();
}
parent_iab_nodes_na_res_cfg_list_l& gnb_du_cell_res_cfg_ext_ies_o::ext_c::parent_iab_nodes_na_res_cfg_list()
{
  assert_choice_type(types::parent_iab_nodes_na_res_cfg_list, type_, "Extension");
  return c.get<parent_iab_nodes_na_res_cfg_list_l>();
}
const rb_set_cfg_s& gnb_du_cell_res_cfg_ext_ies_o::ext_c::rb_set_cfg() const
{
  assert_choice_type(types::rb_set_cfg, type_, "Extension");
  return c.get<rb_set_cfg_s>();
}
const freq_domain_h_sn_a_cfg_list_l& gnb_du_cell_res_cfg_ext_ies_o::ext_c::freq_domain_h_sn_a_cfg_list() const
{
  assert_choice_type(types::freq_domain_h_sn_a_cfg_list, type_, "Extension");
  return c.get<freq_domain_h_sn_a_cfg_list_l>();
}
const child_iab_nodes_na_res_list_l& gnb_du_cell_res_cfg_ext_ies_o::ext_c::child_iab_nodes_na_res_list() const
{
  assert_choice_type(types::child_iab_nodes_na_res_list, type_, "Extension");
  return c.get<child_iab_nodes_na_res_list_l>();
}
const parent_iab_nodes_na_res_cfg_list_l& gnb_du_cell_res_cfg_ext_ies_o::ext_c::parent_iab_nodes_na_res_cfg_list() const
{
  assert_choice_type(types::parent_iab_nodes_na_res_cfg_list, type_, "Extension");
  return c.get<parent_iab_nodes_na_res_cfg_list_l>();
}
void gnb_du_cell_res_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::rb_set_cfg:
      j.write_fieldname("RBSetConfiguration");
      c.get<rb_set_cfg_s>().to_json(j);
      break;
    case types::freq_domain_h_sn_a_cfg_list:
      j.start_array("Frequency-Domain-HSNA-Configuration-List");
      for (const auto& e1 : c.get<freq_domain_h_sn_a_cfg_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::child_iab_nodes_na_res_list:
      j.start_array("Child-IAB-Nodes-NA-Resource-List");
      for (const auto& e1 : c.get<child_iab_nodes_na_res_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::parent_iab_nodes_na_res_cfg_list:
      j.start_array("Parent-IAB-Nodes-NA-Resource-Configuration-List");
      for (const auto& e1 : c.get<parent_iab_nodes_na_res_cfg_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "gnb_du_cell_res_cfg_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE gnb_du_cell_res_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::rb_set_cfg:
      HANDLE_CODE(c.get<rb_set_cfg_s>().pack(bref));
      break;
    case types::freq_domain_h_sn_a_cfg_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<freq_domain_h_sn_a_cfg_list_l>(), 1, 8, true));
      break;
    case types::child_iab_nodes_na_res_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<child_iab_nodes_na_res_list_l>(), 1, 1024, true));
      break;
    case types::parent_iab_nodes_na_res_cfg_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<parent_iab_nodes_na_res_cfg_list_l>(), 1, 5120, true));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_du_cell_res_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_du_cell_res_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::rb_set_cfg:
      HANDLE_CODE(c.get<rb_set_cfg_s>().unpack(bref));
      break;
    case types::freq_domain_h_sn_a_cfg_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<freq_domain_h_sn_a_cfg_list_l>(), bref, 1, 8, true));
      break;
    case types::child_iab_nodes_na_res_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<child_iab_nodes_na_res_list_l>(), bref, 1, 1024, true));
      break;
    case types::parent_iab_nodes_na_res_cfg_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<parent_iab_nodes_na_res_cfg_list_l>(), bref, 1, 5120, true));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_du_cell_res_cfg_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// HSNATransmissionPeriodicity ::= ENUMERATED
const char* h_sn_a_tx_periodicity_opts::to_string() const
{
  static const char* names[] = {
      "ms0p5", "ms0p625", "ms1", "ms1p25", "ms2", "ms2p5", "ms5", "ms10", "ms20", "ms40", "ms80", "ms160"};
  return convert_enum_idx(names, 12, value, "h_sn_a_tx_periodicity_e");
}

// NRFreqInfo ::= SEQUENCE
SRSASN_CODE nr_freq_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sul_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, nr_arfcn, (uint32_t)0u, (uint32_t)3279165u, false, true));
  if (sul_info_present) {
    HANDLE_CODE(sul_info.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, freq_band_list_nr, 1, 32, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_freq_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(sul_info_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(nr_arfcn, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  if (sul_info_present) {
    HANDLE_CODE(sul_info.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(freq_band_list_nr, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void nr_freq_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nRARFCN", nr_arfcn);
  if (sul_info_present) {
    j.write_fieldname("sul-Information");
    sul_info.to_json(j);
  }
  j.start_array("freqBandListNr");
  for (const auto& e1 : freq_band_list_nr) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

SRSASN_CODE gnb_du_cell_res_cfg_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += rb_set_cfg_present ? 1 : 0;
  nof_ies += freq_domain_h_sn_a_cfg_list_present ? 1 : 0;
  nof_ies += child_iab_nodes_na_res_list_present ? 1 : 0;
  nof_ies += parent_iab_nodes_na_res_cfg_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (rb_set_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)520, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rb_set_cfg.pack(bref));
  }
  if (freq_domain_h_sn_a_cfg_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)521, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, freq_domain_h_sn_a_cfg_list, 1, 8, true));
  }
  if (child_iab_nodes_na_res_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)522, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, child_iab_nodes_na_res_list, 1, 1024, true));
  }
  if (parent_iab_nodes_na_res_cfg_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)523, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, parent_iab_nodes_na_res_cfg_list, 1, 5120, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_du_cell_res_cfg_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 520: {
        rb_set_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rb_set_cfg.unpack(bref));
        break;
      }
      case 521: {
        freq_domain_h_sn_a_cfg_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(freq_domain_h_sn_a_cfg_list, bref, 1, 8, true));
        break;
      }
      case 522: {
        child_iab_nodes_na_res_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(child_iab_nodes_na_res_list, bref, 1, 1024, true));
        break;
      }
      case 523: {
        parent_iab_nodes_na_res_cfg_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(parent_iab_nodes_na_res_cfg_list, bref, 1, 5120, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void gnb_du_cell_res_cfg_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (rb_set_cfg_present) {
    j.write_int("id", 520);
    j.write_str("criticality", "reject");
    rb_set_cfg.to_json(j);
  }
  if (freq_domain_h_sn_a_cfg_list_present) {
    j.write_int("id", 521);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : freq_domain_h_sn_a_cfg_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (child_iab_nodes_na_res_list_present) {
    j.write_int("id", 522);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : child_iab_nodes_na_res_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (parent_iab_nodes_na_res_cfg_list_present) {
    j.write_int("id", 523);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : parent_iab_nodes_na_res_cfg_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// GNB-DU-Cell-Resource-Configuration ::= SEQUENCE
SRSASN_CODE gnb_du_cell_res_cfg_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(du_f_tx_periodicity_present, 1));
  HANDLE_CODE(bref.pack(du_f_slot_cfg_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(hs_nsa_slot_cfg_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(subcarrier_spacing.pack(bref));
  if (du_f_tx_periodicity_present) {
    HANDLE_CODE(du_f_tx_periodicity.pack(bref));
  }
  if (du_f_slot_cfg_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, du_f_slot_cfg_list, 1, 320, true));
  }
  HANDLE_CODE(hsn_a_tx_periodicity.pack(bref));
  if (hs_nsa_slot_cfg_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, hs_nsa_slot_cfg_list, 1, 5120, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_du_cell_res_cfg_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(du_f_tx_periodicity_present, 1));
  bool du_f_slot_cfg_list_present;
  HANDLE_CODE(bref.unpack(du_f_slot_cfg_list_present, 1));
  bool hs_nsa_slot_cfg_list_present;
  HANDLE_CODE(bref.unpack(hs_nsa_slot_cfg_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(subcarrier_spacing.unpack(bref));
  if (du_f_tx_periodicity_present) {
    HANDLE_CODE(du_f_tx_periodicity.unpack(bref));
  }
  if (du_f_slot_cfg_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(du_f_slot_cfg_list, bref, 1, 320, true));
  }
  HANDLE_CODE(hsn_a_tx_periodicity.unpack(bref));
  if (hs_nsa_slot_cfg_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(hs_nsa_slot_cfg_list, bref, 1, 5120, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gnb_du_cell_res_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("subcarrierSpacing", subcarrier_spacing.to_string());
  if (du_f_tx_periodicity_present) {
    j.write_str("dUFTransmissionPeriodicity", du_f_tx_periodicity.to_string());
  }
  if (du_f_slot_cfg_list.size() > 0) {
    j.start_array("dUF-Slot-Config-List");
    for (const auto& e1 : du_f_slot_cfg_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_str("hSNATransmissionPeriodicity", hsn_a_tx_periodicity.to_string());
  if (hs_nsa_slot_cfg_list.size() > 0) {
    j.start_array("hsNSASlotConfigList");
    for (const auto& e1 : hs_nsa_slot_cfg_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-DU-Cell-Resource-Configuration-FDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t iab_du_cell_res_cfg_fdd_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {524, 525, 528, 526, 527, 529};
  return map_enum_number(names, 6, idx, "id");
}
bool iab_du_cell_res_cfg_fdd_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {524, 525, 528, 526, 527, 529};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e iab_du_cell_res_cfg_fdd_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 524:
      return crit_e::reject;
    case 525:
      return crit_e::reject;
    case 528:
      return crit_e::reject;
    case 526:
      return crit_e::reject;
    case 527:
      return crit_e::reject;
    case 529:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c iab_du_cell_res_cfg_fdd_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 524:
      ret.set(ext_c::types::ul_freq_info);
      break;
    case 525:
      ret.set(ext_c::types::ul_tx_bw);
      break;
    case 528:
      ret.set(ext_c::types::ul_nr_carrier_list);
      break;
    case 526:
      ret.set(ext_c::types::dl_freq_info);
      break;
    case 527:
      ret.set(ext_c::types::dl_tx_bw);
      break;
    case 529:
      ret.set(ext_c::types::dl_nr_carrier_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e iab_du_cell_res_cfg_fdd_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 524:
      return presence_e::optional;
    case 525:
      return presence_e::optional;
    case 528:
      return presence_e::optional;
    case 526:
      return presence_e::optional;
    case 527:
      return presence_e::optional;
    case 529:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::ul_freq_info:
      c.destroy<nr_freq_info_s>();
      break;
    case types::ul_tx_bw:
      c.destroy<tx_bw_s>();
      break;
    case types::ul_nr_carrier_list:
      c.destroy<nr_carrier_list_l>();
      break;
    case types::dl_freq_info:
      c.destroy<nr_freq_info_s>();
      break;
    case types::dl_tx_bw:
      c.destroy<tx_bw_s>();
      break;
    case types::dl_nr_carrier_list:
      c.destroy<nr_carrier_list_l>();
      break;
    default:
      break;
  }
}
void iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ul_freq_info:
      c.init<nr_freq_info_s>();
      break;
    case types::ul_tx_bw:
      c.init<tx_bw_s>();
      break;
    case types::ul_nr_carrier_list:
      c.init<nr_carrier_list_l>();
      break;
    case types::dl_freq_info:
      c.init<nr_freq_info_s>();
      break;
    case types::dl_tx_bw:
      c.init<tx_bw_s>();
      break;
    case types::dl_nr_carrier_list:
      c.init<nr_carrier_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c");
  }
}
iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::ext_c(const iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ul_freq_info:
      c.init(other.c.get<nr_freq_info_s>());
      break;
    case types::ul_tx_bw:
      c.init(other.c.get<tx_bw_s>());
      break;
    case types::ul_nr_carrier_list:
      c.init(other.c.get<nr_carrier_list_l>());
      break;
    case types::dl_freq_info:
      c.init(other.c.get<nr_freq_info_s>());
      break;
    case types::dl_tx_bw:
      c.init(other.c.get<tx_bw_s>());
      break;
    case types::dl_nr_carrier_list:
      c.init(other.c.get<nr_carrier_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c");
  }
}
iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c&
iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::operator=(const iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ul_freq_info:
      c.set(other.c.get<nr_freq_info_s>());
      break;
    case types::ul_tx_bw:
      c.set(other.c.get<tx_bw_s>());
      break;
    case types::ul_nr_carrier_list:
      c.set(other.c.get<nr_carrier_list_l>());
      break;
    case types::dl_freq_info:
      c.set(other.c.get<nr_freq_info_s>());
      break;
    case types::dl_tx_bw:
      c.set(other.c.get<tx_bw_s>());
      break;
    case types::dl_nr_carrier_list:
      c.set(other.c.get<nr_carrier_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c");
  }

  return *this;
}
nr_freq_info_s& iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::ul_freq_info()
{
  assert_choice_type(types::ul_freq_info, type_, "Extension");
  return c.get<nr_freq_info_s>();
}
tx_bw_s& iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::ul_tx_bw()
{
  assert_choice_type(types::ul_tx_bw, type_, "Extension");
  return c.get<tx_bw_s>();
}
nr_carrier_list_l& iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::ul_nr_carrier_list()
{
  assert_choice_type(types::ul_nr_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
nr_freq_info_s& iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::dl_freq_info()
{
  assert_choice_type(types::dl_freq_info, type_, "Extension");
  return c.get<nr_freq_info_s>();
}
tx_bw_s& iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::dl_tx_bw()
{
  assert_choice_type(types::dl_tx_bw, type_, "Extension");
  return c.get<tx_bw_s>();
}
nr_carrier_list_l& iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::dl_nr_carrier_list()
{
  assert_choice_type(types::dl_nr_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
const nr_freq_info_s& iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::ul_freq_info() const
{
  assert_choice_type(types::ul_freq_info, type_, "Extension");
  return c.get<nr_freq_info_s>();
}
const tx_bw_s& iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::ul_tx_bw() const
{
  assert_choice_type(types::ul_tx_bw, type_, "Extension");
  return c.get<tx_bw_s>();
}
const nr_carrier_list_l& iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::ul_nr_carrier_list() const
{
  assert_choice_type(types::ul_nr_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
const nr_freq_info_s& iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::dl_freq_info() const
{
  assert_choice_type(types::dl_freq_info, type_, "Extension");
  return c.get<nr_freq_info_s>();
}
const tx_bw_s& iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::dl_tx_bw() const
{
  assert_choice_type(types::dl_tx_bw, type_, "Extension");
  return c.get<tx_bw_s>();
}
const nr_carrier_list_l& iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::dl_nr_carrier_list() const
{
  assert_choice_type(types::dl_nr_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
void iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ul_freq_info:
      j.write_fieldname("NRFreqInfo");
      c.get<nr_freq_info_s>().to_json(j);
      break;
    case types::ul_tx_bw:
      j.write_fieldname("Transmission-Bandwidth");
      c.get<tx_bw_s>().to_json(j);
      break;
    case types::ul_nr_carrier_list:
      j.start_array("NRCarrierList");
      for (const auto& e1 : c.get<nr_carrier_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::dl_freq_info:
      j.write_fieldname("NRFreqInfo");
      c.get<nr_freq_info_s>().to_json(j);
      break;
    case types::dl_tx_bw:
      j.write_fieldname("Transmission-Bandwidth");
      c.get<tx_bw_s>().to_json(j);
      break;
    case types::dl_nr_carrier_list:
      j.start_array("NRCarrierList");
      for (const auto& e1 : c.get<nr_carrier_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ul_freq_info:
      HANDLE_CODE(c.get<nr_freq_info_s>().pack(bref));
      break;
    case types::ul_tx_bw:
      HANDLE_CODE(c.get<tx_bw_s>().pack(bref));
      break;
    case types::ul_nr_carrier_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_carrier_list_l>(), 1, 5, true));
      break;
    case types::dl_freq_info:
      HANDLE_CODE(c.get<nr_freq_info_s>().pack(bref));
      break;
    case types::dl_tx_bw:
      HANDLE_CODE(c.get<tx_bw_s>().pack(bref));
      break;
    case types::dl_nr_carrier_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_carrier_list_l>(), 1, 5, true));
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ul_freq_info:
      HANDLE_CODE(c.get<nr_freq_info_s>().unpack(bref));
      break;
    case types::ul_tx_bw:
      HANDLE_CODE(c.get<tx_bw_s>().unpack(bref));
      break;
    case types::ul_nr_carrier_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_carrier_list_l>(), bref, 1, 5, true));
      break;
    case types::dl_freq_info:
      HANDLE_CODE(c.get<nr_freq_info_s>().unpack(bref));
      break;
    case types::dl_tx_bw:
      HANDLE_CODE(c.get<tx_bw_s>().unpack(bref));
      break;
    case types::dl_nr_carrier_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_carrier_list_l>(), bref, 1, 5, true));
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_fdd_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// IAB-DU-Cell-Resource-Configuration-TDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t iab_du_cell_res_cfg_tdd_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {530, 531, 532};
  return map_enum_number(names, 3, idx, "id");
}
bool iab_du_cell_res_cfg_tdd_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {530, 531, 532};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e iab_du_cell_res_cfg_tdd_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 530:
      return crit_e::reject;
    case 531:
      return crit_e::reject;
    case 532:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c iab_du_cell_res_cfg_tdd_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 530:
      ret.set(ext_c::types::nr_freq_info);
      break;
    case 531:
      ret.set(ext_c::types::tx_bw);
      break;
    case 532:
      ret.set(ext_c::types::nr_carrier_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e iab_du_cell_res_cfg_tdd_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 530:
      return presence_e::optional;
    case 531:
      return presence_e::optional;
    case 532:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::nr_freq_info:
      c.destroy<nr_freq_info_s>();
      break;
    case types::tx_bw:
      c.destroy<tx_bw_s>();
      break;
    case types::nr_carrier_list:
      c.destroy<nr_carrier_list_l>();
      break;
    default:
      break;
  }
}
void iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nr_freq_info:
      c.init<nr_freq_info_s>();
      break;
    case types::tx_bw:
      c.init<tx_bw_s>();
      break;
    case types::nr_carrier_list:
      c.init<nr_carrier_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c");
  }
}
iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c::ext_c(const iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nr_freq_info:
      c.init(other.c.get<nr_freq_info_s>());
      break;
    case types::tx_bw:
      c.init(other.c.get<tx_bw_s>());
      break;
    case types::nr_carrier_list:
      c.init(other.c.get<nr_carrier_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c");
  }
}
iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c&
iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c::operator=(const iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nr_freq_info:
      c.set(other.c.get<nr_freq_info_s>());
      break;
    case types::tx_bw:
      c.set(other.c.get<tx_bw_s>());
      break;
    case types::nr_carrier_list:
      c.set(other.c.get<nr_carrier_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c");
  }

  return *this;
}
nr_freq_info_s& iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c::nr_freq_info()
{
  assert_choice_type(types::nr_freq_info, type_, "Extension");
  return c.get<nr_freq_info_s>();
}
tx_bw_s& iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c::tx_bw()
{
  assert_choice_type(types::tx_bw, type_, "Extension");
  return c.get<tx_bw_s>();
}
nr_carrier_list_l& iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c::nr_carrier_list()
{
  assert_choice_type(types::nr_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
const nr_freq_info_s& iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c::nr_freq_info() const
{
  assert_choice_type(types::nr_freq_info, type_, "Extension");
  return c.get<nr_freq_info_s>();
}
const tx_bw_s& iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c::tx_bw() const
{
  assert_choice_type(types::tx_bw, type_, "Extension");
  return c.get<tx_bw_s>();
}
const nr_carrier_list_l& iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c::nr_carrier_list() const
{
  assert_choice_type(types::nr_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
void iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nr_freq_info:
      j.write_fieldname("NRFreqInfo");
      c.get<nr_freq_info_s>().to_json(j);
      break;
    case types::tx_bw:
      j.write_fieldname("Transmission-Bandwidth");
      c.get<tx_bw_s>().to_json(j);
      break;
    case types::nr_carrier_list:
      j.start_array("NRCarrierList");
      for (const auto& e1 : c.get<nr_carrier_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::nr_freq_info:
      HANDLE_CODE(c.get<nr_freq_info_s>().pack(bref));
      break;
    case types::tx_bw:
      HANDLE_CODE(c.get<tx_bw_s>().pack(bref));
      break;
    case types::nr_carrier_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_carrier_list_l>(), 1, 5, true));
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::nr_freq_info:
      HANDLE_CODE(c.get<nr_freq_info_s>().unpack(bref));
      break;
    case types::tx_bw:
      HANDLE_CODE(c.get<tx_bw_s>().unpack(bref));
      break;
    case types::nr_carrier_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_carrier_list_l>(), bref, 1, 5, true));
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_tdd_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE iab_du_cell_res_cfg_fdd_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ul_freq_info_present ? 1 : 0;
  nof_ies += ul_tx_bw_present ? 1 : 0;
  nof_ies += ul_nr_carrier_list_present ? 1 : 0;
  nof_ies += dl_freq_info_present ? 1 : 0;
  nof_ies += dl_tx_bw_present ? 1 : 0;
  nof_ies += dl_nr_carrier_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (ul_freq_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)524, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_freq_info.pack(bref));
  }
  if (ul_tx_bw_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)525, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_tx_bw.pack(bref));
  }
  if (ul_nr_carrier_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)528, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ul_nr_carrier_list, 1, 5, true));
  }
  if (dl_freq_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)526, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dl_freq_info.pack(bref));
  }
  if (dl_tx_bw_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)527, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dl_tx_bw.pack(bref));
  }
  if (dl_nr_carrier_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)529, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, dl_nr_carrier_list, 1, 5, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_du_cell_res_cfg_fdd_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 524: {
        ul_freq_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_freq_info.unpack(bref));
        break;
      }
      case 525: {
        ul_tx_bw_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_tx_bw.unpack(bref));
        break;
      }
      case 528: {
        ul_nr_carrier_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ul_nr_carrier_list, bref, 1, 5, true));
        break;
      }
      case 526: {
        dl_freq_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dl_freq_info.unpack(bref));
        break;
      }
      case 527: {
        dl_tx_bw_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dl_tx_bw.unpack(bref));
        break;
      }
      case 529: {
        dl_nr_carrier_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(dl_nr_carrier_list, bref, 1, 5, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void iab_du_cell_res_cfg_fdd_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ul_freq_info_present) {
    j.write_int("id", 524);
    j.write_str("criticality", "reject");
    ul_freq_info.to_json(j);
  }
  if (ul_tx_bw_present) {
    j.write_int("id", 525);
    j.write_str("criticality", "reject");
    ul_tx_bw.to_json(j);
  }
  if (ul_nr_carrier_list_present) {
    j.write_int("id", 528);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : ul_nr_carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dl_freq_info_present) {
    j.write_int("id", 526);
    j.write_str("criticality", "reject");
    dl_freq_info.to_json(j);
  }
  if (dl_tx_bw_present) {
    j.write_int("id", 527);
    j.write_str("criticality", "reject");
    dl_tx_bw.to_json(j);
  }
  if (dl_nr_carrier_list_present) {
    j.write_int("id", 529);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : dl_nr_carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// IAB-DU-Cell-Resource-Configuration-FDD-Info ::= SEQUENCE
SRSASN_CODE iab_du_cell_res_cfg_fdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(gnb_du_cell_res_cfg_fdd_ul.pack(bref));
  HANDLE_CODE(gnb_du_cell_res_cfg_fdd_dl.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_du_cell_res_cfg_fdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(gnb_du_cell_res_cfg_fdd_ul.unpack(bref));
  HANDLE_CODE(gnb_du_cell_res_cfg_fdd_dl.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_du_cell_res_cfg_fdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("gNB-DU-Cell-Resource-Configuration-FDD-UL");
  gnb_du_cell_res_cfg_fdd_ul.to_json(j);
  j.write_fieldname("gNB-DU-Cell-Resource-Configuration-FDD-DL");
  gnb_du_cell_res_cfg_fdd_dl.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE iab_du_cell_res_cfg_tdd_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += nr_freq_info_present ? 1 : 0;
  nof_ies += tx_bw_present ? 1 : 0;
  nof_ies += nr_carrier_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (nr_freq_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)530, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_freq_info.pack(bref));
  }
  if (tx_bw_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)531, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tx_bw.pack(bref));
  }
  if (nr_carrier_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)532, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, nr_carrier_list, 1, 5, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_du_cell_res_cfg_tdd_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 530: {
        nr_freq_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_freq_info.unpack(bref));
        break;
      }
      case 531: {
        tx_bw_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tx_bw.unpack(bref));
        break;
      }
      case 532: {
        nr_carrier_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(nr_carrier_list, bref, 1, 5, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void iab_du_cell_res_cfg_tdd_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (nr_freq_info_present) {
    j.write_int("id", 530);
    j.write_str("criticality", "reject");
    nr_freq_info.to_json(j);
  }
  if (tx_bw_present) {
    j.write_int("id", 531);
    j.write_str("criticality", "reject");
    tx_bw.to_json(j);
  }
  if (nr_carrier_list_present) {
    j.write_int("id", 532);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : nr_carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// IAB-DU-Cell-Resource-Configuration-TDD-Info ::= SEQUENCE
SRSASN_CODE iab_du_cell_res_cfg_tdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(gnb_du_cell_resourc_cfg_tdd.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_du_cell_res_cfg_tdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(gnb_du_cell_resourc_cfg_tdd.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_du_cell_res_cfg_tdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("gNB-DU-Cell-Resourc-Configuration-TDD");
  gnb_du_cell_resourc_cfg_tdd.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-DU-Cell-Resource-Configuration-Mode-Info ::= CHOICE
void iab_du_cell_res_cfg_mode_info_c::destroy_()
{
  switch (type_) {
    case types::fdd:
      c.destroy<iab_du_cell_res_cfg_fdd_info_s>();
      break;
    case types::tdd:
      c.destroy<iab_du_cell_res_cfg_tdd_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void iab_du_cell_res_cfg_mode_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::fdd:
      c.init<iab_du_cell_res_cfg_fdd_info_s>();
      break;
    case types::tdd:
      c.init<iab_du_cell_res_cfg_tdd_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_mode_info_c");
  }
}
iab_du_cell_res_cfg_mode_info_c::iab_du_cell_res_cfg_mode_info_c(const iab_du_cell_res_cfg_mode_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::fdd:
      c.init(other.c.get<iab_du_cell_res_cfg_fdd_info_s>());
      break;
    case types::tdd:
      c.init(other.c.get<iab_du_cell_res_cfg_tdd_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_mode_info_c");
  }
}
iab_du_cell_res_cfg_mode_info_c&
iab_du_cell_res_cfg_mode_info_c::operator=(const iab_du_cell_res_cfg_mode_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::fdd:
      c.set(other.c.get<iab_du_cell_res_cfg_fdd_info_s>());
      break;
    case types::tdd:
      c.set(other.c.get<iab_du_cell_res_cfg_tdd_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_mode_info_c");
  }

  return *this;
}
iab_du_cell_res_cfg_fdd_info_s& iab_du_cell_res_cfg_mode_info_c::set_fdd()
{
  set(types::fdd);
  return c.get<iab_du_cell_res_cfg_fdd_info_s>();
}
iab_du_cell_res_cfg_tdd_info_s& iab_du_cell_res_cfg_mode_info_c::set_tdd()
{
  set(types::tdd);
  return c.get<iab_du_cell_res_cfg_tdd_info_s>();
}
protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>&
iab_du_cell_res_cfg_mode_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>();
}
void iab_du_cell_res_cfg_mode_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::fdd:
      j.write_fieldname("fDD");
      c.get<iab_du_cell_res_cfg_fdd_info_s>().to_json(j);
      break;
    case types::tdd:
      j.write_fieldname("tDD");
      c.get<iab_du_cell_res_cfg_tdd_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_mode_info_c");
  }
  j.end_obj();
}
SRSASN_CODE iab_du_cell_res_cfg_mode_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<iab_du_cell_res_cfg_fdd_info_s>().pack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<iab_du_cell_res_cfg_tdd_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_mode_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_du_cell_res_cfg_mode_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<iab_du_cell_res_cfg_fdd_info_s>().unpack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<iab_du_cell_res_cfg_tdd_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_du_cell_res_cfg_mode_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_du_cell_res_cfg_mode_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* iab_du_cell_res_cfg_mode_info_c::types_opts::to_string() const
{
  static const char* names[] = {"fDD", "tDD", "choice-extension"};
  return convert_enum_idx(names, 3, value, "iab_du_cell_res_cfg_mode_info_c::types");
}

// Activated-Cells-to-be-Updated-List-Item ::= SEQUENCE
SRSASN_CODE activ_cells_to_be_upd_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(iab_du_cell_res_cfg_mode_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE activ_cells_to_be_upd_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(iab_du_cell_res_cfg_mode_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void activ_cells_to_be_upd_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  j.write_fieldname("iAB-DU-Cell-Resource-Configuration-Mode-Info");
  iab_du_cell_res_cfg_mode_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PRSInformationPos ::= SEQUENCE
SRSASN_CODE pr_si_nformation_pos_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(prs_res_id_pos_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prs_id_pos, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pack_integer(bref, prs_res_set_id_pos, (uint8_t)0u, (uint8_t)7u, false, true));
  if (prs_res_id_pos_present) {
    HANDLE_CODE(pack_integer(bref, prs_res_id_pos, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pr_si_nformation_pos_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(prs_res_id_pos_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prs_id_pos, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(unpack_integer(prs_res_set_id_pos, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  if (prs_res_id_pos_present) {
    HANDLE_CODE(unpack_integer(prs_res_id_pos, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pr_si_nformation_pos_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pRS-IDPos", prs_id_pos);
  j.write_int("pRS-Resource-Set-IDPos", prs_res_set_id_pos);
  if (prs_res_id_pos_present) {
    j.write_int("pRS-Resource-IDPos", prs_res_id_pos);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PosResourceSetTypeAP ::= SEQUENCE
SRSASN_CODE pos_res_set_type_ap_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srs_res_trigger_list, (uint8_t)1u, (uint8_t)3u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_res_set_type_ap_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srs_res_trigger_list, bref, (uint8_t)1u, (uint8_t)3u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pos_res_set_type_ap_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRSResourceTrigger-List", srs_res_trigger_list);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PosResourceSetTypePR ::= SEQUENCE
SRSASN_CODE pos_res_set_type_pr_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(posperiodic_set.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_res_set_type_pr_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(posperiodic_set.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pos_res_set_type_pr_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("posperiodicSet", "true");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* pos_res_set_type_pr_s::posperiodic_set_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "pos_res_set_type_pr_s::posperiodic_set_e_");
}

// PosResourceSetTypeSP ::= SEQUENCE
SRSASN_CODE pos_res_set_type_sp_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(possemi_persistent_set.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_res_set_type_sp_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(possemi_persistent_set.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pos_res_set_type_sp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("possemi-persistentSet", "true");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* pos_res_set_type_sp_s::possemi_persistent_set_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "pos_res_set_type_sp_s::possemi_persistent_set_e_");
}

// ResourceSetTypeAperiodic ::= SEQUENCE
SRSASN_CODE res_set_type_aperiodic_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srs_res_trigger_list, (uint8_t)1u, (uint8_t)3u, false, true));
  HANDLE_CODE(pack_integer(bref, slotoffset, (uint8_t)0u, (uint8_t)32u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE res_set_type_aperiodic_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srs_res_trigger_list, bref, (uint8_t)1u, (uint8_t)3u, false, true));
  HANDLE_CODE(unpack_integer(slotoffset, bref, (uint8_t)0u, (uint8_t)32u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void res_set_type_aperiodic_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRSResourceTrigger-List", srs_res_trigger_list);
  j.write_int("slotoffset", slotoffset);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ResourceSetTypePeriodic ::= SEQUENCE
SRSASN_CODE res_set_type_periodic_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(periodic_set.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE res_set_type_periodic_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(periodic_set.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void res_set_type_periodic_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("periodicSet", "true");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* res_set_type_periodic_s::periodic_set_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "res_set_type_periodic_s::periodic_set_e_");
}

// ResourceSetTypeSemi-persistent ::= SEQUENCE
SRSASN_CODE res_set_type_semi_persistent_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(semi_persistent_set.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE res_set_type_semi_persistent_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(semi_persistent_set.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void res_set_type_semi_persistent_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("semi-persistentSet", "true");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* res_set_type_semi_persistent_s::semi_persistent_set_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "res_set_type_semi_persistent_s::semi_persistent_set_e_");
}

// ResourceTypeAperiodic ::= SEQUENCE
SRSASN_CODE res_type_aperiodic_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(aperiodic_res_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE res_type_aperiodic_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(aperiodic_res_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void res_type_aperiodic_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("aperiodicResourceType", "true");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* res_type_aperiodic_s::aperiodic_res_type_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "res_type_aperiodic_s::aperiodic_res_type_e_");
}

// ResourceTypeAperiodicPos ::= SEQUENCE
SRSASN_CODE res_type_aperiodic_pos_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, slot_offset, (uint8_t)0u, (uint8_t)32u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE res_type_aperiodic_pos_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(slot_offset, bref, (uint8_t)0u, (uint8_t)32u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void res_type_aperiodic_pos_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("slotOffset", slot_offset);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ResourceTypePeriodic ::= SEQUENCE
SRSASN_CODE res_type_periodic_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(periodicity.pack(bref));
  HANDLE_CODE(pack_integer(bref, offset, (uint16_t)0u, (uint16_t)2559u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE res_type_periodic_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(periodicity.unpack(bref));
  HANDLE_CODE(unpack_integer(offset, bref, (uint16_t)0u, (uint16_t)2559u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void res_type_periodic_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("periodicity", periodicity.to_string());
  j.write_int("offset", offset);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* res_type_periodic_s::periodicity_opts::to_string() const
{
  static const char* names[] = {"slot1",
                                "slot2",
                                "slot4",
                                "slot5",
                                "slot8",
                                "slot10",
                                "slot16",
                                "slot20",
                                "slot32",
                                "slot40",
                                "slot64",
                                "slot80",
                                "slot160",
                                "slot320",
                                "slot640",
                                "slot1280",
                                "slot2560"};
  return convert_enum_idx(names, 17, value, "res_type_periodic_s::periodicity_e_");
}
uint16_t res_type_periodic_s::periodicity_opts::to_number() const
{
  static const uint16_t numbers[] = {1, 2, 4, 5, 8, 10, 16, 20, 32, 40, 64, 80, 160, 320, 640, 1280, 2560};
  return map_enum_number(numbers, 17, value, "res_type_periodic_s::periodicity_e_");
}

// ResourceTypePeriodicPos ::= SEQUENCE
SRSASN_CODE res_type_periodic_pos_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(periodicity.pack(bref));
  HANDLE_CODE(pack_integer(bref, offset, (uint32_t)0u, (uint32_t)81919u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE res_type_periodic_pos_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(periodicity.unpack(bref));
  HANDLE_CODE(unpack_integer(offset, bref, (uint32_t)0u, (uint32_t)81919u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void res_type_periodic_pos_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("periodicity", periodicity.to_string());
  j.write_int("offset", offset);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* res_type_periodic_pos_s::periodicity_opts::to_string() const
{
  static const char* names[] = {"slot1",   "slot2",    "slot4",    "slot5",    "slot8",     "slot10",    "slot16",
                                "slot20",  "slot32",   "slot40",   "slot64",   "slot80",    "slot160",   "slot320",
                                "slot640", "slot1280", "slot2560", "slot5120", "slot10240", "slot40960", "slot81920",
                                "slot128", "slot256",  "slot512",  "slot20480"};
  return convert_enum_idx(names, 25, value, "res_type_periodic_pos_s::periodicity_e_");
}
uint32_t res_type_periodic_pos_s::periodicity_opts::to_number() const
{
  static const uint32_t numbers[] = {1,   2,   4,    5,    8,    10,    16,    20,    32,  40,  64,  80,   160,
                                     320, 640, 1280, 2560, 5120, 10240, 40960, 81920, 128, 256, 512, 20480};
  return map_enum_number(numbers, 25, value, "res_type_periodic_pos_s::periodicity_e_");
}

// ResourceTypeSemi-persistent ::= SEQUENCE
SRSASN_CODE res_type_semi_persistent_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(periodicity.pack(bref));
  HANDLE_CODE(pack_integer(bref, offset, (uint16_t)0u, (uint16_t)2559u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE res_type_semi_persistent_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(periodicity.unpack(bref));
  HANDLE_CODE(unpack_integer(offset, bref, (uint16_t)0u, (uint16_t)2559u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void res_type_semi_persistent_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("periodicity", periodicity.to_string());
  j.write_int("offset", offset);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* res_type_semi_persistent_s::periodicity_opts::to_string() const
{
  static const char* names[] = {"slot1",
                                "slot2",
                                "slot4",
                                "slot5",
                                "slot8",
                                "slot10",
                                "slot16",
                                "slot20",
                                "slot32",
                                "slot40",
                                "slot64",
                                "slot80",
                                "slot160",
                                "slot320",
                                "slot640",
                                "slot1280",
                                "slot2560"};
  return convert_enum_idx(names, 17, value, "res_type_semi_persistent_s::periodicity_e_");
}
uint16_t res_type_semi_persistent_s::periodicity_opts::to_number() const
{
  static const uint16_t numbers[] = {1, 2, 4, 5, 8, 10, 16, 20, 32, 40, 64, 80, 160, 320, 640, 1280, 2560};
  return map_enum_number(numbers, 17, value, "res_type_semi_persistent_s::periodicity_e_");
}

// ResourceTypeSemi-persistentPos ::= SEQUENCE
SRSASN_CODE res_type_semi_persistent_pos_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(periodicity.pack(bref));
  HANDLE_CODE(pack_integer(bref, offset, (uint32_t)0u, (uint32_t)81919u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE res_type_semi_persistent_pos_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(periodicity.unpack(bref));
  HANDLE_CODE(unpack_integer(offset, bref, (uint32_t)0u, (uint32_t)81919u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void res_type_semi_persistent_pos_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("periodicity", periodicity.to_string());
  j.write_int("offset", offset);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* res_type_semi_persistent_pos_s::periodicity_opts::to_string() const
{
  static const char* names[] = {"slot1",   "slot2",    "slot4",    "slot5",    "slot8",     "slot10",    "slot16",
                                "slot20",  "slot32",   "slot40",   "slot64",   "slot80",    "slot160",   "slot320",
                                "slot640", "slot1280", "slot2560", "slot5120", "slot10240", "slot40960", "slot81920",
                                "slot128", "slot256",  "slot512",  "slot20480"};
  return convert_enum_idx(names, 25, value, "res_type_semi_persistent_pos_s::periodicity_e_");
}
uint32_t res_type_semi_persistent_pos_s::periodicity_opts::to_number() const
{
  static const uint32_t numbers[] = {1,   2,   4,    5,    8,    10,    16,    20,    32,  40,  64,  80,   160,
                                     320, 640, 1280, 2560, 5120, 10240, 40960, 81920, 128, 256, 512, 20480};
  return map_enum_number(numbers, 25, value, "res_type_semi_persistent_pos_s::periodicity_e_");
}

// SSB ::= SEQUENCE
SRSASN_CODE ssb_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ssb_idx_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pci_nr, (uint16_t)0u, (uint16_t)1007u, false, true));
  if (ssb_idx_present) {
    HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ssb_idx_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pci_nr, bref, (uint16_t)0u, (uint16_t)1007u, false, true));
  if (ssb_idx_present) {
    HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pCI-NR", pci_nr);
  if (ssb_idx_present) {
    j.write_int("ssb-index", ssb_idx);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PosResourceSetType ::= CHOICE
void pos_res_set_type_c::destroy_()
{
  switch (type_) {
    case types::periodic:
      c.destroy<pos_res_set_type_pr_s>();
      break;
    case types::semi_persistent:
      c.destroy<pos_res_set_type_sp_s>();
      break;
    case types::aperiodic:
      c.destroy<pos_res_set_type_ap_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void pos_res_set_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::periodic:
      c.init<pos_res_set_type_pr_s>();
      break;
    case types::semi_persistent:
      c.init<pos_res_set_type_sp_s>();
      break;
    case types::aperiodic:
      c.init<pos_res_set_type_ap_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pos_res_set_type_c");
  }
}
pos_res_set_type_c::pos_res_set_type_c(const pos_res_set_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::periodic:
      c.init(other.c.get<pos_res_set_type_pr_s>());
      break;
    case types::semi_persistent:
      c.init(other.c.get<pos_res_set_type_sp_s>());
      break;
    case types::aperiodic:
      c.init(other.c.get<pos_res_set_type_ap_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pos_res_set_type_c");
  }
}
pos_res_set_type_c& pos_res_set_type_c::operator=(const pos_res_set_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::periodic:
      c.set(other.c.get<pos_res_set_type_pr_s>());
      break;
    case types::semi_persistent:
      c.set(other.c.get<pos_res_set_type_sp_s>());
      break;
    case types::aperiodic:
      c.set(other.c.get<pos_res_set_type_ap_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pos_res_set_type_c");
  }

  return *this;
}
pos_res_set_type_pr_s& pos_res_set_type_c::set_periodic()
{
  set(types::periodic);
  return c.get<pos_res_set_type_pr_s>();
}
pos_res_set_type_sp_s& pos_res_set_type_c::set_semi_persistent()
{
  set(types::semi_persistent);
  return c.get<pos_res_set_type_sp_s>();
}
pos_res_set_type_ap_s& pos_res_set_type_c::set_aperiodic()
{
  set(types::aperiodic);
  return c.get<pos_res_set_type_ap_s>();
}
protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>& pos_res_set_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>>();
}
void pos_res_set_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::periodic:
      j.write_fieldname("periodic");
      c.get<pos_res_set_type_pr_s>().to_json(j);
      break;
    case types::semi_persistent:
      j.write_fieldname("semi-persistent");
      c.get<pos_res_set_type_sp_s>().to_json(j);
      break;
    case types::aperiodic:
      j.write_fieldname("aperiodic");
      c.get<pos_res_set_type_ap_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pos_res_set_type_c");
  }
  j.end_obj();
}
SRSASN_CODE pos_res_set_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::periodic:
      HANDLE_CODE(c.get<pos_res_set_type_pr_s>().pack(bref));
      break;
    case types::semi_persistent:
      HANDLE_CODE(c.get<pos_res_set_type_sp_s>().pack(bref));
      break;
    case types::aperiodic:
      HANDLE_CODE(c.get<pos_res_set_type_ap_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pos_res_set_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_res_set_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::periodic:
      HANDLE_CODE(c.get<pos_res_set_type_pr_s>().unpack(bref));
      break;
    case types::semi_persistent:
      HANDLE_CODE(c.get<pos_res_set_type_sp_s>().unpack(bref));
      break;
    case types::aperiodic:
      HANDLE_CODE(c.get<pos_res_set_type_ap_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pos_res_set_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pos_res_set_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pos_res_set_type_c::types_opts::to_string() const
{
  static const char* names[] = {"periodic", "semi-persistent", "aperiodic", "choice-extension"};
  return convert_enum_idx(names, 4, value, "pos_res_set_type_c::types");
}

// ResourceSetType ::= CHOICE
void res_set_type_c::destroy_()
{
  switch (type_) {
    case types::periodic:
      c.destroy<res_set_type_periodic_s>();
      break;
    case types::semi_persistent:
      c.destroy<res_set_type_semi_persistent_s>();
      break;
    case types::aperiodic:
      c.destroy<res_set_type_aperiodic_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<res_set_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void res_set_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::periodic:
      c.init<res_set_type_periodic_s>();
      break;
    case types::semi_persistent:
      c.init<res_set_type_semi_persistent_s>();
      break;
    case types::aperiodic:
      c.init<res_set_type_aperiodic_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<res_set_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_set_type_c");
  }
}
res_set_type_c::res_set_type_c(const res_set_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::periodic:
      c.init(other.c.get<res_set_type_periodic_s>());
      break;
    case types::semi_persistent:
      c.init(other.c.get<res_set_type_semi_persistent_s>());
      break;
    case types::aperiodic:
      c.init(other.c.get<res_set_type_aperiodic_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<res_set_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_set_type_c");
  }
}
res_set_type_c& res_set_type_c::operator=(const res_set_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::periodic:
      c.set(other.c.get<res_set_type_periodic_s>());
      break;
    case types::semi_persistent:
      c.set(other.c.get<res_set_type_semi_persistent_s>());
      break;
    case types::aperiodic:
      c.set(other.c.get<res_set_type_aperiodic_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<res_set_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_set_type_c");
  }

  return *this;
}
res_set_type_periodic_s& res_set_type_c::set_periodic()
{
  set(types::periodic);
  return c.get<res_set_type_periodic_s>();
}
res_set_type_semi_persistent_s& res_set_type_c::set_semi_persistent()
{
  set(types::semi_persistent);
  return c.get<res_set_type_semi_persistent_s>();
}
res_set_type_aperiodic_s& res_set_type_c::set_aperiodic()
{
  set(types::aperiodic);
  return c.get<res_set_type_aperiodic_s>();
}
protocol_ie_single_container_s<res_set_type_ext_ies_o>& res_set_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<res_set_type_ext_ies_o>>();
}
void res_set_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::periodic:
      j.write_fieldname("periodic");
      c.get<res_set_type_periodic_s>().to_json(j);
      break;
    case types::semi_persistent:
      j.write_fieldname("semi-persistent");
      c.get<res_set_type_semi_persistent_s>().to_json(j);
      break;
    case types::aperiodic:
      j.write_fieldname("aperiodic");
      c.get<res_set_type_aperiodic_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<res_set_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "res_set_type_c");
  }
  j.end_obj();
}
SRSASN_CODE res_set_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::periodic:
      HANDLE_CODE(c.get<res_set_type_periodic_s>().pack(bref));
      break;
    case types::semi_persistent:
      HANDLE_CODE(c.get<res_set_type_semi_persistent_s>().pack(bref));
      break;
    case types::aperiodic:
      HANDLE_CODE(c.get<res_set_type_aperiodic_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<res_set_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "res_set_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE res_set_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::periodic:
      HANDLE_CODE(c.get<res_set_type_periodic_s>().unpack(bref));
      break;
    case types::semi_persistent:
      HANDLE_CODE(c.get<res_set_type_semi_persistent_s>().unpack(bref));
      break;
    case types::aperiodic:
      HANDLE_CODE(c.get<res_set_type_aperiodic_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<res_set_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "res_set_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* res_set_type_c::types_opts::to_string() const
{
  static const char* names[] = {"periodic", "semi-persistent", "aperiodic", "choice-extension"};
  return convert_enum_idx(names, 4, value, "res_set_type_c::types");
}

// ResourceType ::= CHOICE
void res_type_c::destroy_()
{
  switch (type_) {
    case types::periodic:
      c.destroy<res_type_periodic_s>();
      break;
    case types::semi_persistent:
      c.destroy<res_type_semi_persistent_s>();
      break;
    case types::aperiodic:
      c.destroy<res_type_aperiodic_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<res_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void res_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::periodic:
      c.init<res_type_periodic_s>();
      break;
    case types::semi_persistent:
      c.init<res_type_semi_persistent_s>();
      break;
    case types::aperiodic:
      c.init<res_type_aperiodic_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<res_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_type_c");
  }
}
res_type_c::res_type_c(const res_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::periodic:
      c.init(other.c.get<res_type_periodic_s>());
      break;
    case types::semi_persistent:
      c.init(other.c.get<res_type_semi_persistent_s>());
      break;
    case types::aperiodic:
      c.init(other.c.get<res_type_aperiodic_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<res_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_type_c");
  }
}
res_type_c& res_type_c::operator=(const res_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::periodic:
      c.set(other.c.get<res_type_periodic_s>());
      break;
    case types::semi_persistent:
      c.set(other.c.get<res_type_semi_persistent_s>());
      break;
    case types::aperiodic:
      c.set(other.c.get<res_type_aperiodic_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<res_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_type_c");
  }

  return *this;
}
res_type_periodic_s& res_type_c::set_periodic()
{
  set(types::periodic);
  return c.get<res_type_periodic_s>();
}
res_type_semi_persistent_s& res_type_c::set_semi_persistent()
{
  set(types::semi_persistent);
  return c.get<res_type_semi_persistent_s>();
}
res_type_aperiodic_s& res_type_c::set_aperiodic()
{
  set(types::aperiodic);
  return c.get<res_type_aperiodic_s>();
}
protocol_ie_single_container_s<res_type_ext_ies_o>& res_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<res_type_ext_ies_o>>();
}
void res_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::periodic:
      j.write_fieldname("periodic");
      c.get<res_type_periodic_s>().to_json(j);
      break;
    case types::semi_persistent:
      j.write_fieldname("semi-persistent");
      c.get<res_type_semi_persistent_s>().to_json(j);
      break;
    case types::aperiodic:
      j.write_fieldname("aperiodic");
      c.get<res_type_aperiodic_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<res_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "res_type_c");
  }
  j.end_obj();
}
SRSASN_CODE res_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::periodic:
      HANDLE_CODE(c.get<res_type_periodic_s>().pack(bref));
      break;
    case types::semi_persistent:
      HANDLE_CODE(c.get<res_type_semi_persistent_s>().pack(bref));
      break;
    case types::aperiodic:
      HANDLE_CODE(c.get<res_type_aperiodic_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<res_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "res_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE res_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::periodic:
      HANDLE_CODE(c.get<res_type_periodic_s>().unpack(bref));
      break;
    case types::semi_persistent:
      HANDLE_CODE(c.get<res_type_semi_persistent_s>().unpack(bref));
      break;
    case types::aperiodic:
      HANDLE_CODE(c.get<res_type_aperiodic_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<res_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "res_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* res_type_c::types_opts::to_string() const
{
  static const char* names[] = {"periodic", "semi-persistent", "aperiodic", "choice-extension"};
  return convert_enum_idx(names, 4, value, "res_type_c::types");
}

// ResourceTypePos ::= CHOICE
void res_type_pos_c::destroy_()
{
  switch (type_) {
    case types::periodic:
      c.destroy<res_type_periodic_pos_s>();
      break;
    case types::semi_persistent:
      c.destroy<res_type_semi_persistent_pos_s>();
      break;
    case types::aperiodic:
      c.destroy<res_type_aperiodic_pos_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<res_type_pos_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void res_type_pos_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::periodic:
      c.init<res_type_periodic_pos_s>();
      break;
    case types::semi_persistent:
      c.init<res_type_semi_persistent_pos_s>();
      break;
    case types::aperiodic:
      c.init<res_type_aperiodic_pos_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<res_type_pos_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_type_pos_c");
  }
}
res_type_pos_c::res_type_pos_c(const res_type_pos_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::periodic:
      c.init(other.c.get<res_type_periodic_pos_s>());
      break;
    case types::semi_persistent:
      c.init(other.c.get<res_type_semi_persistent_pos_s>());
      break;
    case types::aperiodic:
      c.init(other.c.get<res_type_aperiodic_pos_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<res_type_pos_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_type_pos_c");
  }
}
res_type_pos_c& res_type_pos_c::operator=(const res_type_pos_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::periodic:
      c.set(other.c.get<res_type_periodic_pos_s>());
      break;
    case types::semi_persistent:
      c.set(other.c.get<res_type_semi_persistent_pos_s>());
      break;
    case types::aperiodic:
      c.set(other.c.get<res_type_aperiodic_pos_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<res_type_pos_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "res_type_pos_c");
  }

  return *this;
}
res_type_periodic_pos_s& res_type_pos_c::set_periodic()
{
  set(types::periodic);
  return c.get<res_type_periodic_pos_s>();
}
res_type_semi_persistent_pos_s& res_type_pos_c::set_semi_persistent()
{
  set(types::semi_persistent);
  return c.get<res_type_semi_persistent_pos_s>();
}
res_type_aperiodic_pos_s& res_type_pos_c::set_aperiodic()
{
  set(types::aperiodic);
  return c.get<res_type_aperiodic_pos_s>();
}
protocol_ie_single_container_s<res_type_pos_ext_ies_o>& res_type_pos_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<res_type_pos_ext_ies_o>>();
}
void res_type_pos_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::periodic:
      j.write_fieldname("periodic");
      c.get<res_type_periodic_pos_s>().to_json(j);
      break;
    case types::semi_persistent:
      j.write_fieldname("semi-persistent");
      c.get<res_type_semi_persistent_pos_s>().to_json(j);
      break;
    case types::aperiodic:
      j.write_fieldname("aperiodic");
      c.get<res_type_aperiodic_pos_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<res_type_pos_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "res_type_pos_c");
  }
  j.end_obj();
}
SRSASN_CODE res_type_pos_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::periodic:
      HANDLE_CODE(c.get<res_type_periodic_pos_s>().pack(bref));
      break;
    case types::semi_persistent:
      HANDLE_CODE(c.get<res_type_semi_persistent_pos_s>().pack(bref));
      break;
    case types::aperiodic:
      HANDLE_CODE(c.get<res_type_aperiodic_pos_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<res_type_pos_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "res_type_pos_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE res_type_pos_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::periodic:
      HANDLE_CODE(c.get<res_type_periodic_pos_s>().unpack(bref));
      break;
    case types::semi_persistent:
      HANDLE_CODE(c.get<res_type_semi_persistent_pos_s>().unpack(bref));
      break;
    case types::aperiodic:
      HANDLE_CODE(c.get<res_type_aperiodic_pos_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<res_type_pos_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "res_type_pos_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* res_type_pos_c::types_opts::to_string() const
{
  static const char* names[] = {"periodic", "semi-persistent", "aperiodic", "choice-extension"};
  return convert_enum_idx(names, 4, value, "res_type_pos_c::types");
}

// SpatialRelationPos ::= CHOICE
void spatial_relation_pos_c::destroy_()
{
  switch (type_) {
    case types::ssb_pos:
      c.destroy<ssb_s>();
      break;
    case types::pr_si_nformation_pos:
      c.destroy<pr_si_nformation_pos_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void spatial_relation_pos_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ssb_pos:
      c.init<ssb_s>();
      break;
    case types::pr_si_nformation_pos:
      c.init<pr_si_nformation_pos_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "spatial_relation_pos_c");
  }
}
spatial_relation_pos_c::spatial_relation_pos_c(const spatial_relation_pos_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ssb_pos:
      c.init(other.c.get<ssb_s>());
      break;
    case types::pr_si_nformation_pos:
      c.init(other.c.get<pr_si_nformation_pos_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "spatial_relation_pos_c");
  }
}
spatial_relation_pos_c& spatial_relation_pos_c::operator=(const spatial_relation_pos_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ssb_pos:
      c.set(other.c.get<ssb_s>());
      break;
    case types::pr_si_nformation_pos:
      c.set(other.c.get<pr_si_nformation_pos_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "spatial_relation_pos_c");
  }

  return *this;
}
ssb_s& spatial_relation_pos_c::set_ssb_pos()
{
  set(types::ssb_pos);
  return c.get<ssb_s>();
}
pr_si_nformation_pos_s& spatial_relation_pos_c::set_pr_si_nformation_pos()
{
  set(types::pr_si_nformation_pos);
  return c.get<pr_si_nformation_pos_s>();
}
protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>& spatial_relation_pos_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>>();
}
void spatial_relation_pos_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ssb_pos:
      j.write_fieldname("sSBPos");
      c.get<ssb_s>().to_json(j);
      break;
    case types::pr_si_nformation_pos:
      j.write_fieldname("pRSInformationPos");
      c.get<pr_si_nformation_pos_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "spatial_relation_pos_c");
  }
  j.end_obj();
}
SRSASN_CODE spatial_relation_pos_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ssb_pos:
      HANDLE_CODE(c.get<ssb_s>().pack(bref));
      break;
    case types::pr_si_nformation_pos:
      HANDLE_CODE(c.get<pr_si_nformation_pos_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "spatial_relation_pos_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE spatial_relation_pos_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ssb_pos:
      HANDLE_CODE(c.get<ssb_s>().unpack(bref));
      break;
    case types::pr_si_nformation_pos:
      HANDLE_CODE(c.get<pr_si_nformation_pos_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<spatial_info_pos_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "spatial_relation_pos_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* spatial_relation_pos_c::types_opts::to_string() const
{
  static const char* names[] = {"sSBPos", "pRSInformationPos", "choice-extension"};
  return convert_enum_idx(names, 3, value, "spatial_relation_pos_c::types");
}

// TransmissionComb ::= CHOICE
void tx_comb_c::destroy_()
{
  switch (type_) {
    case types::n2:
      c.destroy<n2_s_>();
      break;
    case types::n4:
      c.destroy<n4_s_>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<tx_comb_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void tx_comb_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::n2:
      c.init<n2_s_>();
      break;
    case types::n4:
      c.init<n4_s_>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<tx_comb_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tx_comb_c");
  }
}
tx_comb_c::tx_comb_c(const tx_comb_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::n2:
      c.init(other.c.get<n2_s_>());
      break;
    case types::n4:
      c.init(other.c.get<n4_s_>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<tx_comb_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tx_comb_c");
  }
}
tx_comb_c& tx_comb_c::operator=(const tx_comb_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::n2:
      c.set(other.c.get<n2_s_>());
      break;
    case types::n4:
      c.set(other.c.get<n4_s_>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<tx_comb_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tx_comb_c");
  }

  return *this;
}
tx_comb_c::n2_s_& tx_comb_c::set_n2()
{
  set(types::n2);
  return c.get<n2_s_>();
}
tx_comb_c::n4_s_& tx_comb_c::set_n4()
{
  set(types::n4);
  return c.get<n4_s_>();
}
protocol_ie_single_container_s<tx_comb_ext_ies_o>& tx_comb_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<tx_comb_ext_ies_o>>();
}
void tx_comb_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::n2:
      j.write_fieldname("n2");
      j.start_obj();
      j.write_int("combOffset-n2", c.get<n2_s_>().comb_offset_n2);
      j.write_int("cyclicShift-n2", c.get<n2_s_>().cyclic_shift_n2);
      j.end_obj();
      break;
    case types::n4:
      j.write_fieldname("n4");
      j.start_obj();
      j.write_int("combOffset-n4", c.get<n4_s_>().comb_offset_n4);
      j.write_int("cyclicShift-n4", c.get<n4_s_>().cyclic_shift_n4);
      j.end_obj();
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<tx_comb_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "tx_comb_c");
  }
  j.end_obj();
}
SRSASN_CODE tx_comb_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::n2:
      HANDLE_CODE(pack_integer(bref, c.get<n2_s_>().comb_offset_n2, (uint8_t)0u, (uint8_t)1u, false, true));
      HANDLE_CODE(pack_integer(bref, c.get<n2_s_>().cyclic_shift_n2, (uint8_t)0u, (uint8_t)7u, false, true));
      break;
    case types::n4:
      HANDLE_CODE(pack_integer(bref, c.get<n4_s_>().comb_offset_n4, (uint8_t)0u, (uint8_t)3u, false, true));
      HANDLE_CODE(pack_integer(bref, c.get<n4_s_>().cyclic_shift_n4, (uint8_t)0u, (uint8_t)11u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<tx_comb_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "tx_comb_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE tx_comb_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::n2:
      HANDLE_CODE(unpack_integer(c.get<n2_s_>().comb_offset_n2, bref, (uint8_t)0u, (uint8_t)1u, false, true));
      HANDLE_CODE(unpack_integer(c.get<n2_s_>().cyclic_shift_n2, bref, (uint8_t)0u, (uint8_t)7u, false, true));
      break;
    case types::n4:
      HANDLE_CODE(unpack_integer(c.get<n4_s_>().comb_offset_n4, bref, (uint8_t)0u, (uint8_t)3u, false, true));
      HANDLE_CODE(unpack_integer(c.get<n4_s_>().cyclic_shift_n4, bref, (uint8_t)0u, (uint8_t)11u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<tx_comb_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "tx_comb_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* tx_comb_c::types_opts::to_string() const
{
  static const char* names[] = {"n2", "n4", "choice-extension"};
  return convert_enum_idx(names, 3, value, "tx_comb_c::types");
}
uint8_t tx_comb_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {2, 4};
  return map_enum_number(numbers, 2, value, "tx_comb_c::types");
}

// TransmissionCombPos ::= CHOICE
void tx_comb_pos_c::destroy_()
{
  switch (type_) {
    case types::n2:
      c.destroy<n2_s_>();
      break;
    case types::n4:
      c.destroy<n4_s_>();
      break;
    case types::n8:
      c.destroy<n8_s_>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void tx_comb_pos_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::n2:
      c.init<n2_s_>();
      break;
    case types::n4:
      c.init<n4_s_>();
      break;
    case types::n8:
      c.init<n8_s_>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tx_comb_pos_c");
  }
}
tx_comb_pos_c::tx_comb_pos_c(const tx_comb_pos_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::n2:
      c.init(other.c.get<n2_s_>());
      break;
    case types::n4:
      c.init(other.c.get<n4_s_>());
      break;
    case types::n8:
      c.init(other.c.get<n8_s_>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tx_comb_pos_c");
  }
}
tx_comb_pos_c& tx_comb_pos_c::operator=(const tx_comb_pos_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::n2:
      c.set(other.c.get<n2_s_>());
      break;
    case types::n4:
      c.set(other.c.get<n4_s_>());
      break;
    case types::n8:
      c.set(other.c.get<n8_s_>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tx_comb_pos_c");
  }

  return *this;
}
tx_comb_pos_c::n2_s_& tx_comb_pos_c::set_n2()
{
  set(types::n2);
  return c.get<n2_s_>();
}
tx_comb_pos_c::n4_s_& tx_comb_pos_c::set_n4()
{
  set(types::n4);
  return c.get<n4_s_>();
}
tx_comb_pos_c::n8_s_& tx_comb_pos_c::set_n8()
{
  set(types::n8);
  return c.get<n8_s_>();
}
protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>& tx_comb_pos_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>>();
}
void tx_comb_pos_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::n2:
      j.write_fieldname("n2");
      j.start_obj();
      j.write_int("combOffset-n2", c.get<n2_s_>().comb_offset_n2);
      j.write_int("cyclicShift-n2", c.get<n2_s_>().cyclic_shift_n2);
      j.end_obj();
      break;
    case types::n4:
      j.write_fieldname("n4");
      j.start_obj();
      j.write_int("combOffset-n4", c.get<n4_s_>().comb_offset_n4);
      j.write_int("cyclicShift-n4", c.get<n4_s_>().cyclic_shift_n4);
      j.end_obj();
      break;
    case types::n8:
      j.write_fieldname("n8");
      j.start_obj();
      j.write_int("combOffset-n8", c.get<n8_s_>().comb_offset_n8);
      j.write_int("cyclicShift-n8", c.get<n8_s_>().cyclic_shift_n8);
      j.end_obj();
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "tx_comb_pos_c");
  }
  j.end_obj();
}
SRSASN_CODE tx_comb_pos_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::n2:
      HANDLE_CODE(pack_integer(bref, c.get<n2_s_>().comb_offset_n2, (uint8_t)0u, (uint8_t)1u, false, true));
      HANDLE_CODE(pack_integer(bref, c.get<n2_s_>().cyclic_shift_n2, (uint8_t)0u, (uint8_t)7u, false, true));
      break;
    case types::n4:
      HANDLE_CODE(pack_integer(bref, c.get<n4_s_>().comb_offset_n4, (uint8_t)0u, (uint8_t)3u, false, true));
      HANDLE_CODE(pack_integer(bref, c.get<n4_s_>().cyclic_shift_n4, (uint8_t)0u, (uint8_t)11u, false, true));
      break;
    case types::n8:
      HANDLE_CODE(pack_integer(bref, c.get<n8_s_>().comb_offset_n8, (uint8_t)0u, (uint8_t)7u, false, true));
      HANDLE_CODE(pack_integer(bref, c.get<n8_s_>().cyclic_shift_n8, (uint8_t)0u, (uint8_t)5u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "tx_comb_pos_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE tx_comb_pos_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::n2:
      HANDLE_CODE(unpack_integer(c.get<n2_s_>().comb_offset_n2, bref, (uint8_t)0u, (uint8_t)1u, false, true));
      HANDLE_CODE(unpack_integer(c.get<n2_s_>().cyclic_shift_n2, bref, (uint8_t)0u, (uint8_t)7u, false, true));
      break;
    case types::n4:
      HANDLE_CODE(unpack_integer(c.get<n4_s_>().comb_offset_n4, bref, (uint8_t)0u, (uint8_t)3u, false, true));
      HANDLE_CODE(unpack_integer(c.get<n4_s_>().cyclic_shift_n4, bref, (uint8_t)0u, (uint8_t)11u, false, true));
      break;
    case types::n8:
      HANDLE_CODE(unpack_integer(c.get<n8_s_>().comb_offset_n8, bref, (uint8_t)0u, (uint8_t)7u, false, true));
      HANDLE_CODE(unpack_integer(c.get<n8_s_>().cyclic_shift_n8, bref, (uint8_t)0u, (uint8_t)5u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<tx_comb_pos_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "tx_comb_pos_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* tx_comb_pos_c::types_opts::to_string() const
{
  static const char* names[] = {"n2", "n4", "n8", "choice-extension"};
  return convert_enum_idx(names, 4, value, "tx_comb_pos_c::types");
}
uint8_t tx_comb_pos_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {2, 4, 8};
  return map_enum_number(numbers, 3, value, "tx_comb_pos_c::types");
}

// PosSRSResource-Item ::= SEQUENCE
SRSASN_CODE pos_srs_res_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(spatial_relation_pos_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srs_pos_res_id, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(tx_comb_pos.pack(bref));
  HANDLE_CODE(pack_integer(bref, start_position, (uint8_t)0u, (uint8_t)13u, false, true));
  HANDLE_CODE(nrof_symbols.pack(bref));
  HANDLE_CODE(pack_integer(bref, freq_domain_shift, (uint16_t)0u, (uint16_t)268u, false, true));
  HANDLE_CODE(pack_integer(bref, c_srs, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(group_or_seq_hop.pack(bref));
  HANDLE_CODE(res_type_pos.pack(bref));
  HANDLE_CODE(pack_integer(bref, seq_id, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (spatial_relation_pos_present) {
    HANDLE_CODE(spatial_relation_pos.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_srs_res_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(spatial_relation_pos_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srs_pos_res_id, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(tx_comb_pos.unpack(bref));
  HANDLE_CODE(unpack_integer(start_position, bref, (uint8_t)0u, (uint8_t)13u, false, true));
  HANDLE_CODE(nrof_symbols.unpack(bref));
  HANDLE_CODE(unpack_integer(freq_domain_shift, bref, (uint16_t)0u, (uint16_t)268u, false, true));
  HANDLE_CODE(unpack_integer(c_srs, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(group_or_seq_hop.unpack(bref));
  HANDLE_CODE(res_type_pos.unpack(bref));
  HANDLE_CODE(unpack_integer(seq_id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (spatial_relation_pos_present) {
    HANDLE_CODE(spatial_relation_pos.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pos_srs_res_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("srs-PosResourceId", srs_pos_res_id);
  j.write_fieldname("transmissionCombPos");
  tx_comb_pos.to_json(j);
  j.write_int("startPosition", start_position);
  j.write_str("nrofSymbols", nrof_symbols.to_string());
  j.write_int("freqDomainShift", freq_domain_shift);
  j.write_int("c-SRS", c_srs);
  j.write_str("groupOrSequenceHopping", group_or_seq_hop.to_string());
  j.write_fieldname("resourceTypePos");
  res_type_pos.to_json(j);
  j.write_int("sequenceId", seq_id);
  if (spatial_relation_pos_present) {
    j.write_fieldname("spatialRelationPos");
    spatial_relation_pos.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* pos_srs_res_item_s::nrof_symbols_opts::to_string() const
{
  static const char* names[] = {"n1", "n2", "n4", "n8", "n12"};
  return convert_enum_idx(names, 5, value, "pos_srs_res_item_s::nrof_symbols_e_");
}
uint8_t pos_srs_res_item_s::nrof_symbols_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 4, 8, 12};
  return map_enum_number(numbers, 5, value, "pos_srs_res_item_s::nrof_symbols_e_");
}

const char* pos_srs_res_item_s::group_or_seq_hop_opts::to_string() const
{
  static const char* names[] = {"neither", "groupHopping", "sequenceHopping"};
  return convert_enum_idx(names, 3, value, "pos_srs_res_item_s::group_or_seq_hop_e_");
}

// PosSRSResourceSet-Item ::= SEQUENCE
SRSASN_CODE pos_srs_res_set_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, possrs_res_set_id, (uint8_t)0u, (uint8_t)15u, false, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, poss_rs_res_id_list, 1, 16, integer_packer<uint8_t>(0, 63, false, true)));
  HANDLE_CODE(posres_set_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_srs_res_set_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(possrs_res_set_id, bref, (uint8_t)0u, (uint8_t)15u, false, true));
  HANDLE_CODE(unpack_dyn_seq_of(poss_rs_res_id_list, bref, 1, 16, integer_packer<uint8_t>(0, 63, false, true)));
  HANDLE_CODE(posres_set_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pos_srs_res_set_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("possrsResourceSetID", possrs_res_set_id);
  j.start_array("possRSResourceID-List");
  for (const auto& e1 : poss_rs_res_id_list) {
    j.write_int(e1);
  }
  j.end_array();
  j.write_fieldname("posresourceSetType");
  posres_set_type.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRSResource ::= SEQUENCE
SRSASN_CODE srs_res_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srs_res_id, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(nrof_srs_ports.pack(bref));
  HANDLE_CODE(tx_comb.pack(bref));
  HANDLE_CODE(pack_integer(bref, start_position, (uint8_t)0u, (uint8_t)13u, false, true));
  HANDLE_CODE(nrof_symbols.pack(bref));
  HANDLE_CODE(repeat_factor.pack(bref));
  HANDLE_CODE(pack_integer(bref, freq_domain_position, (uint8_t)0u, (uint8_t)67u, false, true));
  HANDLE_CODE(pack_integer(bref, freq_domain_shift, (uint16_t)0u, (uint16_t)268u, false, true));
  HANDLE_CODE(pack_integer(bref, c_srs, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(pack_integer(bref, b_srs, (uint8_t)0u, (uint8_t)3u, false, true));
  HANDLE_CODE(pack_integer(bref, b_hop, (uint8_t)0u, (uint8_t)3u, false, true));
  HANDLE_CODE(group_or_seq_hop.pack(bref));
  HANDLE_CODE(res_type.pack(bref));
  HANDLE_CODE(pack_integer(bref, seq_id, (uint16_t)0u, (uint16_t)1023u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srs_res_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srs_res_id, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(nrof_srs_ports.unpack(bref));
  HANDLE_CODE(tx_comb.unpack(bref));
  HANDLE_CODE(unpack_integer(start_position, bref, (uint8_t)0u, (uint8_t)13u, false, true));
  HANDLE_CODE(nrof_symbols.unpack(bref));
  HANDLE_CODE(repeat_factor.unpack(bref));
  HANDLE_CODE(unpack_integer(freq_domain_position, bref, (uint8_t)0u, (uint8_t)67u, false, true));
  HANDLE_CODE(unpack_integer(freq_domain_shift, bref, (uint16_t)0u, (uint16_t)268u, false, true));
  HANDLE_CODE(unpack_integer(c_srs, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(unpack_integer(b_srs, bref, (uint8_t)0u, (uint8_t)3u, false, true));
  HANDLE_CODE(unpack_integer(b_hop, bref, (uint8_t)0u, (uint8_t)3u, false, true));
  HANDLE_CODE(group_or_seq_hop.unpack(bref));
  HANDLE_CODE(res_type.unpack(bref));
  HANDLE_CODE(unpack_integer(seq_id, bref, (uint16_t)0u, (uint16_t)1023u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srs_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRSResourceID", srs_res_id);
  j.write_str("nrofSRS-Ports", nrof_srs_ports.to_string());
  j.write_fieldname("transmissionComb");
  tx_comb.to_json(j);
  j.write_int("startPosition", start_position);
  j.write_str("nrofSymbols", nrof_symbols.to_string());
  j.write_str("repetitionFactor", repeat_factor.to_string());
  j.write_int("freqDomainPosition", freq_domain_position);
  j.write_int("freqDomainShift", freq_domain_shift);
  j.write_int("c-SRS", c_srs);
  j.write_int("b-SRS", b_srs);
  j.write_int("b-hop", b_hop);
  j.write_str("groupOrSequenceHopping", group_or_seq_hop.to_string());
  j.write_fieldname("resourceType");
  res_type.to_json(j);
  j.write_int("sequenceId", seq_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* srs_res_s::nrof_srs_ports_opts::to_string() const
{
  static const char* names[] = {"port1", "ports2", "ports4"};
  return convert_enum_idx(names, 3, value, "srs_res_s::nrof_srs_ports_e_");
}
uint8_t srs_res_s::nrof_srs_ports_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 4};
  return map_enum_number(numbers, 3, value, "srs_res_s::nrof_srs_ports_e_");
}

const char* srs_res_s::nrof_symbols_opts::to_string() const
{
  static const char* names[] = {"n1", "n2", "n4"};
  return convert_enum_idx(names, 3, value, "srs_res_s::nrof_symbols_e_");
}
uint8_t srs_res_s::nrof_symbols_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 4};
  return map_enum_number(numbers, 3, value, "srs_res_s::nrof_symbols_e_");
}

const char* srs_res_s::repeat_factor_opts::to_string() const
{
  static const char* names[] = {"n1", "n2", "n4"};
  return convert_enum_idx(names, 3, value, "srs_res_s::repeat_factor_e_");
}
uint8_t srs_res_s::repeat_factor_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 4};
  return map_enum_number(numbers, 3, value, "srs_res_s::repeat_factor_e_");
}

const char* srs_res_s::group_or_seq_hop_opts::to_string() const
{
  static const char* names[] = {"neither", "groupHopping", "sequenceHopping"};
  return convert_enum_idx(names, 3, value, "srs_res_s::group_or_seq_hop_e_");
}

// SRSResourceSet ::= SEQUENCE
SRSASN_CODE srs_res_set_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srs_res_set_id, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, srs_res_id_list, 1, 16, integer_packer<uint8_t>(0, 63, false, true)));
  HANDLE_CODE(res_set_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srs_res_set_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srs_res_set_id, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(srs_res_id_list, bref, 1, 16, integer_packer<uint8_t>(0, 63, false, true)));
  HANDLE_CODE(res_set_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srs_res_set_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRSResourceSetID", srs_res_set_id);
  j.start_array("sRSResourceID-List");
  for (const auto& e1 : srs_res_id_list) {
    j.write_int(e1);
  }
  j.end_array();
  j.write_fieldname("resourceSetType");
  res_set_type.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRSConfig ::= SEQUENCE
SRSASN_CODE srs_cfg_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(srs_res_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(pos_srs_res_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(srs_res_set_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(pos_srs_res_set_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (srs_res_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, srs_res_list, 1, 64, true));
  }
  if (pos_srs_res_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, pos_srs_res_list, 1, 64, true));
  }
  if (srs_res_set_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, srs_res_set_list, 1, 16, true));
  }
  if (pos_srs_res_set_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, pos_srs_res_set_list, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srs_cfg_s::unpack(cbit_ref& bref)
{
  bool srs_res_list_present;
  HANDLE_CODE(bref.unpack(srs_res_list_present, 1));
  bool pos_srs_res_list_present;
  HANDLE_CODE(bref.unpack(pos_srs_res_list_present, 1));
  bool srs_res_set_list_present;
  HANDLE_CODE(bref.unpack(srs_res_set_list_present, 1));
  bool pos_srs_res_set_list_present;
  HANDLE_CODE(bref.unpack(pos_srs_res_set_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (srs_res_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(srs_res_list, bref, 1, 64, true));
  }
  if (pos_srs_res_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(pos_srs_res_list, bref, 1, 64, true));
  }
  if (srs_res_set_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(srs_res_set_list, bref, 1, 16, true));
  }
  if (pos_srs_res_set_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(pos_srs_res_set_list, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srs_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (srs_res_list.size() > 0) {
    j.start_array("sRSResource-List");
    for (const auto& e1 : srs_res_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pos_srs_res_list.size() > 0) {
    j.start_array("posSRSResource-List");
    for (const auto& e1 : pos_srs_res_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (srs_res_set_list.size() > 0) {
    j.start_array("sRSResourceSet-List");
    for (const auto& e1 : srs_res_set_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pos_srs_res_set_list.size() > 0) {
    j.start_array("posSRSResourceSet-List");
    for (const auto& e1 : pos_srs_res_set_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ActiveULBWP ::= SEQUENCE
SRSASN_CODE active_ul_bwp_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(shift7dot5k_hz_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, location_and_bw, (uint16_t)0u, (uint16_t)37949u, true, true));
  HANDLE_CODE(subcarrier_spacing.pack(bref));
  HANDLE_CODE(cp.pack(bref));
  HANDLE_CODE(pack_integer(bref, tx_direct_current_location, (uint16_t)0u, (uint16_t)3301u, true, true));
  if (shift7dot5k_hz_present) {
    HANDLE_CODE(shift7dot5k_hz.pack(bref));
  }
  HANDLE_CODE(srs_cfg.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE active_ul_bwp_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(shift7dot5k_hz_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(location_and_bw, bref, (uint16_t)0u, (uint16_t)37949u, true, true));
  HANDLE_CODE(subcarrier_spacing.unpack(bref));
  HANDLE_CODE(cp.unpack(bref));
  HANDLE_CODE(unpack_integer(tx_direct_current_location, bref, (uint16_t)0u, (uint16_t)3301u, true, true));
  if (shift7dot5k_hz_present) {
    HANDLE_CODE(shift7dot5k_hz.unpack(bref));
  }
  HANDLE_CODE(srs_cfg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void active_ul_bwp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("locationAndBandwidth", location_and_bw);
  j.write_str("subcarrierSpacing", subcarrier_spacing.to_string());
  j.write_str("cyclicPrefix", cp.to_string());
  j.write_int("txDirectCurrentLocation", tx_direct_current_location);
  if (shift7dot5k_hz_present) {
    j.write_str("shift7dot5kHz", "true");
  }
  j.write_fieldname("sRSConfig");
  srs_cfg.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* active_ul_bwp_s::subcarrier_spacing_opts::to_string() const
{
  static const char* names[] = {"kHz15", "kHz30", "kHz60", "kHz120"};
  return convert_enum_idx(names, 4, value, "active_ul_bwp_s::subcarrier_spacing_e_");
}
uint8_t active_ul_bwp_s::subcarrier_spacing_opts::to_number() const
{
  static const uint8_t numbers[] = {15, 30, 60, 120};
  return map_enum_number(numbers, 4, value, "active_ul_bwp_s::subcarrier_spacing_e_");
}

const char* active_ul_bwp_s::cp_opts::to_string() const
{
  static const char* names[] = {"normal", "extended"};
  return convert_enum_idx(names, 2, value, "active_ul_bwp_s::cp_e_");
}

const char* active_ul_bwp_s::shift7dot5k_hz_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "active_ul_bwp_s::shift7dot5k_hz_e_");
}

// EgressBHRLCCHItem ::= SEQUENCE
SRSASN_CODE egress_bh_rlc_ch_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(next_hop_bap_address.pack(bref));
  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE egress_bh_rlc_ch_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(next_hop_bap_address.unpack(bref));
  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void egress_bh_rlc_ch_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nextHopBAPAddress", next_hop_bap_address.to_string());
  j.write_str("bHRLCChannelID", bh_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NonF1terminatingTopologyIndicator ::= ENUMERATED
const char* non_f1terminating_topology_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "non_f1terminating_topology_ind_e");
}

// BAPRoutingID ::= SEQUENCE
SRSASN_CODE bap_routing_id_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bap_address.pack(bref));
  HANDLE_CODE(bap_path_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bap_routing_id_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bap_address.unpack(bref));
  HANDLE_CODE(bap_path_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bap_routing_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bAPAddress", bap_address.to_string());
  j.write_str("bAPPathID", bap_path_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BHInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t bh_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {517};
  return map_enum_number(names, 1, idx, "id");
}
bool bh_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 517 == id;
}
crit_e bh_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 517) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
bh_info_ext_ies_o::ext_c bh_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 517) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e bh_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 517) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void bh_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("NonF1terminatingTopologyIndicator", "true");
  j.end_obj();
}
SRSASN_CODE bh_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// BHInfo ::= SEQUENCE
SRSASN_CODE bh_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ba_prouting_id_present, 1));
  HANDLE_CODE(bref.pack(egress_bh_rlc_ch_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (ba_prouting_id_present) {
    HANDLE_CODE(ba_prouting_id.pack(bref));
  }
  if (egress_bh_rlc_ch_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, egress_bh_rlc_ch_list, 1, 2, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ba_prouting_id_present, 1));
  bool egress_bh_rlc_ch_list_present;
  HANDLE_CODE(bref.unpack(egress_bh_rlc_ch_list_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ba_prouting_id_present) {
    HANDLE_CODE(ba_prouting_id.unpack(bref));
  }
  if (egress_bh_rlc_ch_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(egress_bh_rlc_ch_list, bref, 1, 2, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void bh_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ba_prouting_id_present) {
    j.write_fieldname("bAProutingID");
    ba_prouting_id.to_json(j);
  }
  if (egress_bh_rlc_ch_list.size() > 0) {
    j.start_array("egressBHRLCCHList");
    for (const auto& e1 : egress_bh_rlc_ch_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// GTPTunnel ::= SEQUENCE
SRSASN_CODE gtp_tunnel_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(transport_layer_address.pack(bref));
  HANDLE_CODE(gtp_teid.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gtp_tunnel_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(transport_layer_address.unpack(bref));
  HANDLE_CODE(gtp_teid.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gtp_tunnel_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("transportLayerAddress", transport_layer_address.to_string());
  j.write_str("gTP-TEID", gtp_teid.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AdditionalPDCPDuplicationTNL-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t add_pdcp_dupl_tnl_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {280};
  return map_enum_number(names, 1, idx, "id");
}
bool add_pdcp_dupl_tnl_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 280 == id;
}
crit_e add_pdcp_dupl_tnl_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 280) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
add_pdcp_dupl_tnl_item_ext_ies_o::ext_c add_pdcp_dupl_tnl_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 280) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e add_pdcp_dupl_tnl_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 280) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void add_pdcp_dupl_tnl_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("BHInfo");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE add_pdcp_dupl_tnl_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE add_pdcp_dupl_tnl_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// UPTransportLayerInformation ::= CHOICE
void up_transport_layer_info_c::destroy_()
{
  switch (type_) {
    case types::gtp_tunnel:
      c.destroy<gtp_tunnel_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void up_transport_layer_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::gtp_tunnel:
      c.init<gtp_tunnel_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }
}
up_transport_layer_info_c::up_transport_layer_info_c(const up_transport_layer_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::gtp_tunnel:
      c.init(other.c.get<gtp_tunnel_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }
}
up_transport_layer_info_c& up_transport_layer_info_c::operator=(const up_transport_layer_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::gtp_tunnel:
      c.set(other.c.get<gtp_tunnel_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }

  return *this;
}
gtp_tunnel_s& up_transport_layer_info_c::set_gtp_tunnel()
{
  set(types::gtp_tunnel);
  return c.get<gtp_tunnel_s>();
}
protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>& up_transport_layer_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>();
}
void up_transport_layer_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::gtp_tunnel:
      j.write_fieldname("gTPTunnel");
      c.get<gtp_tunnel_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
  }
  j.end_obj();
}
SRSASN_CODE up_transport_layer_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::gtp_tunnel:
      HANDLE_CODE(c.get<gtp_tunnel_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE up_transport_layer_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::gtp_tunnel:
      HANDLE_CODE(c.get<gtp_tunnel_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<up_transport_layer_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "up_transport_layer_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* up_transport_layer_info_c::types_opts::to_string() const
{
  static const char* names[] = {"gTPTunnel", "choice-extension"};
  return convert_enum_idx(names, 2, value, "up_transport_layer_info_c::types");
}

// AdditionalPDCPDuplicationTNL-Item ::= SEQUENCE
SRSASN_CODE add_pdcp_dupl_tnl_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(add_pdcp_dupl_up_tnl_info.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE add_pdcp_dupl_tnl_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(add_pdcp_dupl_up_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void add_pdcp_dupl_tnl_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("additionalPDCPDuplicationUPTNLInformation");
  add_pdcp_dupl_up_tnl_info.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// LCS-to-GCS-Translation ::= SEQUENCE
SRSASN_CODE lcs_to_gcs_translation_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, alpha, (uint16_t)0u, (uint16_t)3599u, false, true));
  HANDLE_CODE(pack_integer(bref, beta, (uint16_t)0u, (uint16_t)3599u, false, true));
  HANDLE_CODE(pack_integer(bref, gamma, (uint16_t)0u, (uint16_t)3599u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE lcs_to_gcs_translation_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(alpha, bref, (uint16_t)0u, (uint16_t)3599u, false, true));
  HANDLE_CODE(unpack_integer(beta, bref, (uint16_t)0u, (uint16_t)3599u, false, true));
  HANDLE_CODE(unpack_integer(gamma, bref, (uint16_t)0u, (uint16_t)3599u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void lcs_to_gcs_translation_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("alpha", alpha);
  j.write_int("beta", beta);
  j.write_int("gamma", gamma);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UL-AoA ::= SEQUENCE
SRSASN_CODE ul_ao_a_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(zenith_ao_a_present, 1));
  HANDLE_CODE(bref.pack(lcs_to_gcs_translation_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, azimuth_ao_a, (uint16_t)0u, (uint16_t)3599u, false, true));
  if (zenith_ao_a_present) {
    HANDLE_CODE(pack_integer(bref, zenith_ao_a, (uint16_t)0u, (uint16_t)1799u, false, true));
  }
  if (lcs_to_gcs_translation_present) {
    HANDLE_CODE(lcs_to_gcs_translation.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ao_a_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(zenith_ao_a_present, 1));
  HANDLE_CODE(bref.unpack(lcs_to_gcs_translation_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(azimuth_ao_a, bref, (uint16_t)0u, (uint16_t)3599u, false, true));
  if (zenith_ao_a_present) {
    HANDLE_CODE(unpack_integer(zenith_ao_a, bref, (uint16_t)0u, (uint16_t)1799u, false, true));
  }
  if (lcs_to_gcs_translation_present) {
    HANDLE_CODE(lcs_to_gcs_translation.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_ao_a_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("azimuthAoA", azimuth_ao_a);
  if (zenith_ao_a_present) {
    j.write_int("zenithAoA", zenith_ao_a);
  }
  if (lcs_to_gcs_translation_present) {
    j.write_fieldname("lCS-to-GCS-Translation");
    lcs_to_gcs_translation.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ZoAInformation ::= SEQUENCE
SRSASN_CODE zo_a_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(lcs_to_gcs_translation_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, zenith_ao_a, (uint16_t)0u, (uint16_t)1799u, false, true));
  if (lcs_to_gcs_translation_present) {
    HANDLE_CODE(lcs_to_gcs_translation.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE zo_a_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(lcs_to_gcs_translation_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(zenith_ao_a, bref, (uint16_t)0u, (uint16_t)1799u, false, true));
  if (lcs_to_gcs_translation_present) {
    HANDLE_CODE(lcs_to_gcs_translation.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void zo_a_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("zenithAoA", zenith_ao_a);
  if (lcs_to_gcs_translation_present) {
    j.write_fieldname("lCS-to-GCS-Translation");
    lcs_to_gcs_translation.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MultipleULAoA-Item ::= CHOICE
void multiple_ul_ao_a_item_c::destroy_()
{
  switch (type_) {
    case types::ul_ao_a:
      c.destroy<ul_ao_a_s>();
      break;
    case types::ul_zo_a:
      c.destroy<zo_a_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void multiple_ul_ao_a_item_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ul_ao_a:
      c.init<ul_ao_a_s>();
      break;
    case types::ul_zo_a:
      c.init<zo_a_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multiple_ul_ao_a_item_c");
  }
}
multiple_ul_ao_a_item_c::multiple_ul_ao_a_item_c(const multiple_ul_ao_a_item_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ul_ao_a:
      c.init(other.c.get<ul_ao_a_s>());
      break;
    case types::ul_zo_a:
      c.init(other.c.get<zo_a_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multiple_ul_ao_a_item_c");
  }
}
multiple_ul_ao_a_item_c& multiple_ul_ao_a_item_c::operator=(const multiple_ul_ao_a_item_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ul_ao_a:
      c.set(other.c.get<ul_ao_a_s>());
      break;
    case types::ul_zo_a:
      c.set(other.c.get<zo_a_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multiple_ul_ao_a_item_c");
  }

  return *this;
}
ul_ao_a_s& multiple_ul_ao_a_item_c::set_ul_ao_a()
{
  set(types::ul_ao_a);
  return c.get<ul_ao_a_s>();
}
zo_a_info_s& multiple_ul_ao_a_item_c::set_ul_zo_a()
{
  set(types::ul_zo_a);
  return c.get<zo_a_info_s>();
}
protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>& multiple_ul_ao_a_item_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>>();
}
void multiple_ul_ao_a_item_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ul_ao_a:
      j.write_fieldname("uL-AoA");
      c.get<ul_ao_a_s>().to_json(j);
      break;
    case types::ul_zo_a:
      j.write_fieldname("ul-ZoA");
      c.get<zo_a_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multiple_ul_ao_a_item_c");
  }
  j.end_obj();
}
SRSASN_CODE multiple_ul_ao_a_item_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ul_ao_a:
      HANDLE_CODE(c.get<ul_ao_a_s>().pack(bref));
      break;
    case types::ul_zo_a:
      HANDLE_CODE(c.get<zo_a_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multiple_ul_ao_a_item_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multiple_ul_ao_a_item_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ul_ao_a:
      HANDLE_CODE(c.get<ul_ao_a_s>().unpack(bref));
      break;
    case types::ul_zo_a:
      HANDLE_CODE(c.get<zo_a_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<multiple_ul_ao_a_item_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multiple_ul_ao_a_item_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* multiple_ul_ao_a_item_c::types_opts::to_string() const
{
  static const char* names[] = {"uL-AoA", "ul-ZoA", "choice-extension"};
  return convert_enum_idx(names, 3, value, "multiple_ul_ao_a_item_c::types");
}

// AngleMeasurementQuality ::= SEQUENCE
SRSASN_CODE angle_meas_quality_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(zenith_quality_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, azimuth_quality, (uint16_t)0u, (uint16_t)255u, false, true));
  if (zenith_quality_present) {
    HANDLE_CODE(pack_integer(bref, zenith_quality, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  HANDLE_CODE(resolution.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE angle_meas_quality_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(zenith_quality_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(azimuth_quality, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  if (zenith_quality_present) {
    HANDLE_CODE(unpack_integer(zenith_quality, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  HANDLE_CODE(resolution.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void angle_meas_quality_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("azimuthQuality", azimuth_quality);
  if (zenith_quality_present) {
    j.write_int("zenithQuality", zenith_quality);
  }
  j.write_str("resolution", "deg0dot1");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* angle_meas_quality_s::resolution_opts::to_string() const
{
  static const char* names[] = {"deg0dot1"};
  return convert_enum_idx(names, 1, value, "angle_meas_quality_s::resolution_e_");
}
float angle_meas_quality_s::resolution_opts::to_number() const
{
  static const float numbers[] = {0.1};
  return map_enum_number(numbers, 1, value, "angle_meas_quality_s::resolution_e_");
}
const char* angle_meas_quality_s::resolution_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.1"};
  return convert_enum_idx(number_strs, 1, value, "angle_meas_quality_s::resolution_e_");
}

// TimingMeasurementQuality ::= SEQUENCE
SRSASN_CODE timing_meas_quality_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, meas_quality, (uint8_t)0u, (uint8_t)31u, false, true));
  HANDLE_CODE(resolution.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE timing_meas_quality_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(meas_quality, bref, (uint8_t)0u, (uint8_t)31u, false, true));
  HANDLE_CODE(resolution.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void timing_meas_quality_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("measurementQuality", meas_quality);
  j.write_str("resolution", resolution.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* timing_meas_quality_s::resolution_opts::to_string() const
{
  static const char* names[] = {"m0dot1", "m1", "m10", "m30"};
  return convert_enum_idx(names, 4, value, "timing_meas_quality_s::resolution_e_");
}
float timing_meas_quality_s::resolution_opts::to_number() const
{
  static const float numbers[] = {0.1, 1.0, 10.0, 30.0};
  return map_enum_number(numbers, 4, value, "timing_meas_quality_s::resolution_e_");
}
const char* timing_meas_quality_s::resolution_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.1", "1", "10", "30"};
  return convert_enum_idx(number_strs, 4, value, "timing_meas_quality_s::resolution_e_");
}

// MultipleULAoA ::= SEQUENCE
SRSASN_CODE multiple_ul_ao_a_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, multiple_ul_ao_a, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multiple_ul_ao_a_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(multiple_ul_ao_a, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multiple_ul_ao_a_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("multipleULAoA");
  for (const auto& e1 : multiple_ul_ao_a) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRPMeasurementQuality-Item ::= CHOICE
void trp_meas_quality_item_c::destroy_()
{
  switch (type_) {
    case types::timing_meas_quality:
      c.destroy<timing_meas_quality_s>();
      break;
    case types::angle_meas_quality:
      c.destroy<angle_meas_quality_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void trp_meas_quality_item_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::timing_meas_quality:
      c.init<timing_meas_quality_s>();
      break;
    case types::angle_meas_quality:
      c.init<angle_meas_quality_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_quality_item_c");
  }
}
trp_meas_quality_item_c::trp_meas_quality_item_c(const trp_meas_quality_item_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::timing_meas_quality:
      c.init(other.c.get<timing_meas_quality_s>());
      break;
    case types::angle_meas_quality:
      c.init(other.c.get<angle_meas_quality_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_quality_item_c");
  }
}
trp_meas_quality_item_c& trp_meas_quality_item_c::operator=(const trp_meas_quality_item_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::timing_meas_quality:
      c.set(other.c.get<timing_meas_quality_s>());
      break;
    case types::angle_meas_quality:
      c.set(other.c.get<angle_meas_quality_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_quality_item_c");
  }

  return *this;
}
timing_meas_quality_s& trp_meas_quality_item_c::set_timing_meas_quality()
{
  set(types::timing_meas_quality);
  return c.get<timing_meas_quality_s>();
}
angle_meas_quality_s& trp_meas_quality_item_c::set_angle_meas_quality()
{
  set(types::angle_meas_quality);
  return c.get<angle_meas_quality_s>();
}
protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>& trp_meas_quality_item_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>>();
}
void trp_meas_quality_item_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::timing_meas_quality:
      j.write_fieldname("timingMeasurementQuality");
      c.get<timing_meas_quality_s>().to_json(j);
      break;
    case types::angle_meas_quality:
      j.write_fieldname("angleMeasurementQuality");
      c.get<angle_meas_quality_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_quality_item_c");
  }
  j.end_obj();
}
SRSASN_CODE trp_meas_quality_item_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::timing_meas_quality:
      HANDLE_CODE(c.get<timing_meas_quality_s>().pack(bref));
      break;
    case types::angle_meas_quality:
      HANDLE_CODE(c.get<angle_meas_quality_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_quality_item_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_meas_quality_item_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::timing_meas_quality:
      HANDLE_CODE(c.get<timing_meas_quality_s>().unpack(bref));
      break;
    case types::angle_meas_quality:
      HANDLE_CODE(c.get<angle_meas_quality_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<trp_meas_quality_item_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_quality_item_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trp_meas_quality_item_c::types_opts::to_string() const
{
  static const char* names[] = {"timingMeasurementQuality", "angleMeasurementQuality", "choice-extension"};
  return convert_enum_idx(names, 3, value, "trp_meas_quality_item_c::types");
}

// UL-SRS-RSRPP ::= SEQUENCE
SRSASN_CODE ul_srs_rsrp_p_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, first_path_rsrp_p, (uint8_t)0u, (uint8_t)126u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_srs_rsrp_p_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(first_path_rsrp_p, bref, (uint8_t)0u, (uint8_t)126u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_srs_rsrp_p_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("firstPathRSRPP", first_path_rsrp_p);
  if (ie_exts_present) {
    j.write_fieldname("iE-extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AdditionalPath-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t add_path_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {558, 636};
  return map_enum_number(names, 2, idx, "id");
}
bool add_path_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {558, 636};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e add_path_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 558:
      return crit_e::ignore;
    case 636:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
add_path_item_ext_ies_o::ext_c add_path_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 558:
      ret.set(ext_c::types::multiple_ul_ao_a);
      break;
    case 636:
      ret.set(ext_c::types::path_pwr);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e add_path_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 558:
      return presence_e::optional;
    case 636:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void add_path_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::multiple_ul_ao_a:
      c.destroy<multiple_ul_ao_a_s>();
      break;
    case types::path_pwr:
      c.destroy<ul_srs_rsrp_p_s>();
      break;
    default:
      break;
  }
}
void add_path_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::multiple_ul_ao_a:
      c.init<multiple_ul_ao_a_s>();
      break;
    case types::path_pwr:
      c.init<ul_srs_rsrp_p_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "add_path_item_ext_ies_o::ext_c");
  }
}
add_path_item_ext_ies_o::ext_c::ext_c(const add_path_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::multiple_ul_ao_a:
      c.init(other.c.get<multiple_ul_ao_a_s>());
      break;
    case types::path_pwr:
      c.init(other.c.get<ul_srs_rsrp_p_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "add_path_item_ext_ies_o::ext_c");
  }
}
add_path_item_ext_ies_o::ext_c& add_path_item_ext_ies_o::ext_c::operator=(const add_path_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::multiple_ul_ao_a:
      c.set(other.c.get<multiple_ul_ao_a_s>());
      break;
    case types::path_pwr:
      c.set(other.c.get<ul_srs_rsrp_p_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "add_path_item_ext_ies_o::ext_c");
  }

  return *this;
}
multiple_ul_ao_a_s& add_path_item_ext_ies_o::ext_c::multiple_ul_ao_a()
{
  assert_choice_type(types::multiple_ul_ao_a, type_, "Extension");
  return c.get<multiple_ul_ao_a_s>();
}
ul_srs_rsrp_p_s& add_path_item_ext_ies_o::ext_c::path_pwr()
{
  assert_choice_type(types::path_pwr, type_, "Extension");
  return c.get<ul_srs_rsrp_p_s>();
}
const multiple_ul_ao_a_s& add_path_item_ext_ies_o::ext_c::multiple_ul_ao_a() const
{
  assert_choice_type(types::multiple_ul_ao_a, type_, "Extension");
  return c.get<multiple_ul_ao_a_s>();
}
const ul_srs_rsrp_p_s& add_path_item_ext_ies_o::ext_c::path_pwr() const
{
  assert_choice_type(types::path_pwr, type_, "Extension");
  return c.get<ul_srs_rsrp_p_s>();
}
void add_path_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::multiple_ul_ao_a:
      j.write_fieldname("MultipleULAoA");
      c.get<multiple_ul_ao_a_s>().to_json(j);
      break;
    case types::path_pwr:
      j.write_fieldname("UL-SRS-RSRPP");
      c.get<ul_srs_rsrp_p_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "add_path_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE add_path_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::multiple_ul_ao_a:
      HANDLE_CODE(c.get<multiple_ul_ao_a_s>().pack(bref));
      break;
    case types::path_pwr:
      HANDLE_CODE(c.get<ul_srs_rsrp_p_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "add_path_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE add_path_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::multiple_ul_ao_a:
      HANDLE_CODE(c.get<multiple_ul_ao_a_s>().unpack(bref));
      break;
    case types::path_pwr:
      HANDLE_CODE(c.get<ul_srs_rsrp_p_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "add_path_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RelativePathDelay ::= CHOICE
void relative_path_delay_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<relative_path_delay_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void relative_path_delay_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::k0:
      break;
    case types::k1:
      break;
    case types::k2:
      break;
    case types::k3:
      break;
    case types::k4:
      break;
    case types::k5:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<relative_path_delay_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "relative_path_delay_c");
  }
}
relative_path_delay_c::relative_path_delay_c(const relative_path_delay_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::k0:
      c.init(other.c.get<uint16_t>());
      break;
    case types::k1:
      c.init(other.c.get<uint16_t>());
      break;
    case types::k2:
      c.init(other.c.get<uint16_t>());
      break;
    case types::k3:
      c.init(other.c.get<uint16_t>());
      break;
    case types::k4:
      c.init(other.c.get<uint16_t>());
      break;
    case types::k5:
      c.init(other.c.get<uint16_t>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<relative_path_delay_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "relative_path_delay_c");
  }
}
relative_path_delay_c& relative_path_delay_c::operator=(const relative_path_delay_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::k0:
      c.set(other.c.get<uint16_t>());
      break;
    case types::k1:
      c.set(other.c.get<uint16_t>());
      break;
    case types::k2:
      c.set(other.c.get<uint16_t>());
      break;
    case types::k3:
      c.set(other.c.get<uint16_t>());
      break;
    case types::k4:
      c.set(other.c.get<uint16_t>());
      break;
    case types::k5:
      c.set(other.c.get<uint16_t>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<relative_path_delay_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "relative_path_delay_c");
  }

  return *this;
}
uint16_t& relative_path_delay_c::set_k0()
{
  set(types::k0);
  return c.get<uint16_t>();
}
uint16_t& relative_path_delay_c::set_k1()
{
  set(types::k1);
  return c.get<uint16_t>();
}
uint16_t& relative_path_delay_c::set_k2()
{
  set(types::k2);
  return c.get<uint16_t>();
}
uint16_t& relative_path_delay_c::set_k3()
{
  set(types::k3);
  return c.get<uint16_t>();
}
uint16_t& relative_path_delay_c::set_k4()
{
  set(types::k4);
  return c.get<uint16_t>();
}
uint16_t& relative_path_delay_c::set_k5()
{
  set(types::k5);
  return c.get<uint16_t>();
}
protocol_ie_single_container_s<relative_path_delay_ext_ies_o>& relative_path_delay_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<relative_path_delay_ext_ies_o>>();
}
void relative_path_delay_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::k0:
      j.write_int("k0", c.get<uint16_t>());
      break;
    case types::k1:
      j.write_int("k1", c.get<uint16_t>());
      break;
    case types::k2:
      j.write_int("k2", c.get<uint16_t>());
      break;
    case types::k3:
      j.write_int("k3", c.get<uint16_t>());
      break;
    case types::k4:
      j.write_int("k4", c.get<uint16_t>());
      break;
    case types::k5:
      j.write_int("k5", c.get<uint16_t>());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<relative_path_delay_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "relative_path_delay_c");
  }
  j.end_obj();
}
SRSASN_CODE relative_path_delay_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::k0:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)16351u, false, true));
      break;
    case types::k1:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)8176u, false, true));
      break;
    case types::k2:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)4088u, false, true));
      break;
    case types::k3:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)2044u, false, true));
      break;
    case types::k4:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)1022u, false, true));
      break;
    case types::k5:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)511u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<relative_path_delay_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "relative_path_delay_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE relative_path_delay_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::k0:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)16351u, false, true));
      break;
    case types::k1:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)8176u, false, true));
      break;
    case types::k2:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)4088u, false, true));
      break;
    case types::k3:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)2044u, false, true));
      break;
    case types::k4:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)1022u, false, true));
      break;
    case types::k5:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)511u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<relative_path_delay_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "relative_path_delay_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* relative_path_delay_c::types_opts::to_string() const
{
  static const char* names[] = {"k0", "k1", "k2", "k3", "k4", "k5", "choice-extension"};
  return convert_enum_idx(names, 7, value, "relative_path_delay_c::types");
}
uint8_t relative_path_delay_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0, 1, 2, 3, 4, 5};
  return map_enum_number(numbers, 6, value, "relative_path_delay_c::types");
}

// TRPMeasurementQuality ::= SEQUENCE
SRSASN_CODE trp_meas_quality_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tr_pmeas_quality_item.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_meas_quality_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tr_pmeas_quality_item.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_meas_quality_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tRPmeasurementQuality-Item");
  tr_pmeas_quality_item.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE add_path_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += multiple_ul_ao_a_present ? 1 : 0;
  nof_ies += path_pwr_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (multiple_ul_ao_a_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)558, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(multiple_ul_ao_a.pack(bref));
  }
  if (path_pwr_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)636, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(path_pwr.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE add_path_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 558: {
        multiple_ul_ao_a_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multiple_ul_ao_a.unpack(bref));
        break;
      }
      case 636: {
        path_pwr_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(path_pwr.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void add_path_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (multiple_ul_ao_a_present) {
    j.write_int("id", 558);
    j.write_str("criticality", "ignore");
    multiple_ul_ao_a.to_json(j);
  }
  if (path_pwr_present) {
    j.write_int("id", 636);
    j.write_str("criticality", "ignore");
    path_pwr.to_json(j);
  }
  j.end_obj();
}

// AdditionalPath-Item ::= SEQUENCE
SRSASN_CODE add_path_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(path_quality_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(relative_path_delay.pack(bref));
  if (path_quality_present) {
    HANDLE_CODE(path_quality.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE add_path_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(path_quality_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(relative_path_delay.unpack(bref));
  if (path_quality_present) {
    HANDLE_CODE(path_quality.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void add_path_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("relativePathDelay");
  relative_path_delay.to_json(j);
  if (path_quality_present) {
    j.write_fieldname("pathQuality");
    path_quality.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AdditionalSIBMessageList-Item ::= SEQUENCE
SRSASN_CODE add_sib_msg_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(add_sib.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE add_sib_msg_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(add_sib.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void add_sib_msg_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("additionalSIB", add_sib.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AffectedSSB-Item ::= SEQUENCE
SRSASN_CODE affected_ssb_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE affected_ssb_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void affected_ssb_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSB-Index", ssb_idx);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AffectedCellsAndBeams-Item ::= SEQUENCE
SRSASN_CODE affected_cells_and_beams_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(affected_ssb_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (affected_ssb_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, affected_ssb_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE affected_cells_and_beams_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool affected_ssb_list_present;
  HANDLE_CODE(bref.unpack(affected_ssb_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (affected_ssb_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(affected_ssb_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void affected_cells_and_beams_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (affected_ssb_list.size() > 0) {
    j.start_array("affectedSSB-List");
    for (const auto& e1 : affected_ssb_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AggressorCellList-Item ::= SEQUENCE
SRSASN_CODE aggressor_cell_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(aggressor_cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE aggressor_cell_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(aggressor_cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void aggressor_cell_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("aggressorCell-ID");
  aggressor_cell_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AggressorgNBSetID ::= SEQUENCE
SRSASN_CODE aggressor_gnb_set_id_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(aggressor_gnb_set_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE aggressor_gnb_set_id_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(aggressor_gnb_set_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void aggressor_gnb_set_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("aggressorgNBSetID", aggressor_gnb_set_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Pre-emptionCapability ::= ENUMERATED
const char* pre_emption_cap_opts::to_string() const
{
  static const char* names[] = {"shall-not-trigger-pre-emption", "may-trigger-pre-emption"};
  return convert_enum_idx(names, 2, value, "pre_emption_cap_e");
}

// Pre-emptionVulnerability ::= ENUMERATED
const char* pre_emption_vulnerability_opts::to_string() const
{
  static const char* names[] = {"not-pre-emptable", "pre-emptable"};
  return convert_enum_idx(names, 2, value, "pre_emption_vulnerability_e");
}

// AllocationAndRetentionPriority ::= SEQUENCE
SRSASN_CODE alloc_and_retention_prio_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prio_level, (uint8_t)0u, (uint8_t)15u, false, true));
  HANDLE_CODE(pre_emption_cap.pack(bref));
  HANDLE_CODE(pre_emption_vulnerability.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE alloc_and_retention_prio_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prio_level, bref, (uint8_t)0u, (uint8_t)15u, false, true));
  HANDLE_CODE(pre_emption_cap.unpack(bref));
  HANDLE_CODE(pre_emption_vulnerability.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void alloc_and_retention_prio_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("priorityLevel", prio_level);
  j.write_str("pre-emptionCapability", pre_emption_cap.to_string());
  j.write_str("pre-emptionVulnerability", pre_emption_vulnerability.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PacketErrorRate ::= SEQUENCE
SRSASN_CODE packet_error_rate_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, per_scalar, (uint8_t)0u, (uint8_t)9u, true, true));
  HANDLE_CODE(pack_integer(bref, per_exponent, (uint8_t)0u, (uint8_t)9u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE packet_error_rate_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(per_scalar, bref, (uint8_t)0u, (uint8_t)9u, true, true));
  HANDLE_CODE(unpack_integer(per_exponent, bref, (uint8_t)0u, (uint8_t)9u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void packet_error_rate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pER-Scalar", per_scalar);
  j.write_int("pER-Exponent", per_exponent);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AlternativeQoSParaSetItem ::= SEQUENCE
SRSASN_CODE alt_qos_para_set_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(guaranteed_flow_bit_rate_dl_present, 1));
  HANDLE_CODE(bref.pack(guaranteed_flow_bit_rate_ul_present, 1));
  HANDLE_CODE(bref.pack(packet_delay_budget_present, 1));
  HANDLE_CODE(bref.pack(packet_error_rate_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, alt_qos_para_set_idx, (uint8_t)1u, (uint8_t)8u, true, true));
  if (guaranteed_flow_bit_rate_dl_present) {
    HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (guaranteed_flow_bit_rate_ul_present) {
    HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (packet_delay_budget_present) {
    HANDLE_CODE(pack_integer(bref, packet_delay_budget, (uint16_t)0u, (uint16_t)1023u, true, true));
  }
  if (packet_error_rate_present) {
    HANDLE_CODE(packet_error_rate.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE alt_qos_para_set_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(guaranteed_flow_bit_rate_dl_present, 1));
  HANDLE_CODE(bref.unpack(guaranteed_flow_bit_rate_ul_present, 1));
  HANDLE_CODE(bref.unpack(packet_delay_budget_present, 1));
  HANDLE_CODE(bref.unpack(packet_error_rate_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(alt_qos_para_set_idx, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  if (guaranteed_flow_bit_rate_dl_present) {
    HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (guaranteed_flow_bit_rate_ul_present) {
    HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (packet_delay_budget_present) {
    HANDLE_CODE(unpack_integer(packet_delay_budget, bref, (uint16_t)0u, (uint16_t)1023u, true, true));
  }
  if (packet_error_rate_present) {
    HANDLE_CODE(packet_error_rate.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void alt_qos_para_set_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("alternativeQoSParaSetIndex", alt_qos_para_set_idx);
  if (guaranteed_flow_bit_rate_dl_present) {
    j.write_int("guaranteedFlowBitRateDL", guaranteed_flow_bit_rate_dl);
  }
  if (guaranteed_flow_bit_rate_ul_present) {
    j.write_int("guaranteedFlowBitRateUL", guaranteed_flow_bit_rate_ul);
  }
  if (packet_delay_budget_present) {
    j.write_int("packetDelayBudget", packet_delay_budget);
  }
  if (packet_error_rate_present) {
    j.write_fieldname("packetErrorRate");
    packet_error_rate.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Expected-Azimuth-AoA ::= SEQUENCE
SRSASN_CODE expected_azimuth_ao_a_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, expected_azimuth_ao_a_value, (uint16_t)0u, (uint16_t)3599u, false, true));
  HANDLE_CODE(pack_integer(bref, expected_azimuth_ao_a_uncertainty, (uint16_t)0u, (uint16_t)3599u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_azimuth_ao_a_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(expected_azimuth_ao_a_value, bref, (uint16_t)0u, (uint16_t)3599u, false, true));
  HANDLE_CODE(unpack_integer(expected_azimuth_ao_a_uncertainty, bref, (uint16_t)0u, (uint16_t)3599u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_azimuth_ao_a_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("expected-Azimuth-AoA-value", expected_azimuth_ao_a_value);
  j.write_int("expected-Azimuth-AoA-uncertainty", expected_azimuth_ao_a_uncertainty);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Expected-Zenith-AoA ::= SEQUENCE
SRSASN_CODE expected_zenith_ao_a_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, expected_zenith_ao_a_value, (uint16_t)0u, (uint16_t)1799u, false, true));
  HANDLE_CODE(pack_integer(bref, expected_zenith_ao_a_uncertainty, (uint16_t)0u, (uint16_t)1799u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_zenith_ao_a_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(expected_zenith_ao_a_value, bref, (uint16_t)0u, (uint16_t)1799u, false, true));
  HANDLE_CODE(unpack_integer(expected_zenith_ao_a_uncertainty, bref, (uint16_t)0u, (uint16_t)1799u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_zenith_ao_a_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("expected-Zenith-AoA-value", expected_zenith_ao_a_value);
  j.write_int("expected-Zenith-AoA-uncertainty", expected_zenith_ao_a_uncertainty);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Expected-UL-AoA ::= SEQUENCE
SRSASN_CODE expected_ul_ao_a_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(expected_zenith_ao_a_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(expected_azimuth_ao_a.pack(bref));
  if (expected_zenith_ao_a_present) {
    HANDLE_CODE(expected_zenith_ao_a.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_ul_ao_a_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(expected_zenith_ao_a_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(expected_azimuth_ao_a.unpack(bref));
  if (expected_zenith_ao_a_present) {
    HANDLE_CODE(expected_zenith_ao_a.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_ul_ao_a_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("expected-Azimuth-AoA");
  expected_azimuth_ao_a.to_json(j);
  if (expected_zenith_ao_a_present) {
    j.write_fieldname("expected-Zenith-AoA");
    expected_zenith_ao_a.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Expected-ZoA-only ::= SEQUENCE
SRSASN_CODE expected_zo_a_only_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(expected_zo_a_only.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE expected_zo_a_only_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(expected_zo_a_only.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void expected_zo_a_only_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("expected-ZoA-only");
  expected_zo_a_only.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AngleMeasurementType ::= CHOICE
void angle_meas_type_c::destroy_()
{
  switch (type_) {
    case types::expected_ul_ao_a:
      c.destroy<expected_ul_ao_a_s>();
      break;
    case types::expected_zo_a:
      c.destroy<expected_zo_a_only_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<angle_meas_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void angle_meas_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::expected_ul_ao_a:
      c.init<expected_ul_ao_a_s>();
      break;
    case types::expected_zo_a:
      c.init<expected_zo_a_only_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<angle_meas_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "angle_meas_type_c");
  }
}
angle_meas_type_c::angle_meas_type_c(const angle_meas_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::expected_ul_ao_a:
      c.init(other.c.get<expected_ul_ao_a_s>());
      break;
    case types::expected_zo_a:
      c.init(other.c.get<expected_zo_a_only_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<angle_meas_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "angle_meas_type_c");
  }
}
angle_meas_type_c& angle_meas_type_c::operator=(const angle_meas_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::expected_ul_ao_a:
      c.set(other.c.get<expected_ul_ao_a_s>());
      break;
    case types::expected_zo_a:
      c.set(other.c.get<expected_zo_a_only_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<angle_meas_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "angle_meas_type_c");
  }

  return *this;
}
expected_ul_ao_a_s& angle_meas_type_c::set_expected_ul_ao_a()
{
  set(types::expected_ul_ao_a);
  return c.get<expected_ul_ao_a_s>();
}
expected_zo_a_only_s& angle_meas_type_c::set_expected_zo_a()
{
  set(types::expected_zo_a);
  return c.get<expected_zo_a_only_s>();
}
protocol_ie_single_container_s<angle_meas_type_ext_ies_o>& angle_meas_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<angle_meas_type_ext_ies_o>>();
}
void angle_meas_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::expected_ul_ao_a:
      j.write_fieldname("expected-ULAoA");
      c.get<expected_ul_ao_a_s>().to_json(j);
      break;
    case types::expected_zo_a:
      j.write_fieldname("expected-ZoA");
      c.get<expected_zo_a_only_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<angle_meas_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "angle_meas_type_c");
  }
  j.end_obj();
}
SRSASN_CODE angle_meas_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::expected_ul_ao_a:
      HANDLE_CODE(c.get<expected_ul_ao_a_s>().pack(bref));
      break;
    case types::expected_zo_a:
      HANDLE_CODE(c.get<expected_zo_a_only_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<angle_meas_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "angle_meas_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE angle_meas_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::expected_ul_ao_a:
      HANDLE_CODE(c.get<expected_ul_ao_a_s>().unpack(bref));
      break;
    case types::expected_zo_a:
      HANDLE_CODE(c.get<expected_zo_a_only_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<angle_meas_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "angle_meas_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* angle_meas_type_c::types_opts::to_string() const
{
  static const char* names[] = {"expected-ULAoA", "expected-ZoA", "choice-extension"};
  return convert_enum_idx(names, 3, value, "angle_meas_type_c::types");
}

// AoA-AssistanceInfo ::= SEQUENCE
SRSASN_CODE ao_a_assist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(lcs_to_gcs_translation_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(angle_meas.pack(bref));
  if (lcs_to_gcs_translation_present) {
    HANDLE_CODE(lcs_to_gcs_translation.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ao_a_assist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(lcs_to_gcs_translation_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(angle_meas.unpack(bref));
  if (lcs_to_gcs_translation_present) {
    HANDLE_CODE(lcs_to_gcs_translation.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ao_a_assist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("angleMeasurement");
  angle_meas.to_json(j);
  if (lcs_to_gcs_translation_present) {
    j.write_fieldname("lCS-to-GCS-Translation");
    lcs_to_gcs_translation.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRSResourceTrigger ::= SEQUENCE
SRSASN_CODE srs_res_trigger_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, aperiodic_srs_res_trigger_list, 1, 3, integer_packer<uint8_t>(1, 3, false, true)));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srs_res_trigger_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(
      unpack_dyn_seq_of(aperiodic_srs_res_trigger_list, bref, 1, 3, integer_packer<uint8_t>(1, 3, false, true)));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srs_res_trigger_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("aperiodicSRSResourceTriggerList");
  for (const auto& e1 : aperiodic_srs_res_trigger_list) {
    j.write_int(e1);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Associated-SCell-Item ::= SEQUENCE
SRSASN_CODE associated_scell_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(scell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE associated_scell_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(scell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void associated_scell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sCell-ID");
  scell_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AvailablePLMNList-Item ::= SEQUENCE
SRSASN_CODE available_plmn_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE available_plmn_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void available_plmn_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AvailableSNPN-ID-List-Item ::= SEQUENCE
SRSASN_CODE available_sn_pn_id_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, available_n_id_list, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE available_sn_pn_id_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(available_n_id_list, bref, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void available_sn_pn_id_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  j.start_array("availableNIDList");
  for (const auto& e1 : available_n_id_list) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BAP-Header-Rewriting-Added-List-Item ::= SEQUENCE
SRSASN_CODE bap_hdr_rewriting_added_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(non_f1terminating_topology_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ingress_bap_routing_id.pack(bref));
  HANDLE_CODE(egress_bap_routing_id.pack(bref));
  if (non_f1terminating_topology_ind_present) {
    HANDLE_CODE(non_f1terminating_topology_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bap_hdr_rewriting_added_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(non_f1terminating_topology_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ingress_bap_routing_id.unpack(bref));
  HANDLE_CODE(egress_bap_routing_id.unpack(bref));
  if (non_f1terminating_topology_ind_present) {
    HANDLE_CODE(non_f1terminating_topology_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bap_hdr_rewriting_added_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ingressBAPRoutingID");
  ingress_bap_routing_id.to_json(j);
  j.write_fieldname("egressBAPRoutingID");
  egress_bap_routing_id.to_json(j);
  if (non_f1terminating_topology_ind_present) {
    j.write_str("nonF1terminatingTopologyIndicator", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BAP-Header-Rewriting-Removed-List-Item ::= SEQUENCE
SRSASN_CODE bap_hdr_rewriting_remd_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ingress_bap_routing_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bap_hdr_rewriting_remd_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ingress_bap_routing_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bap_hdr_rewriting_remd_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("ingressBAPRoutingID");
  ingress_bap_routing_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EgressNonF1terminatingTopologyIndicator ::= ENUMERATED
const char* egress_non_f1terminating_topology_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "egress_non_f1terminating_topology_ind_e");
}

// IABTNLAddress ::= CHOICE
void iab_tnl_address_c::destroy_()
{
  switch (type_) {
    case types::ip_v4_address:
      c.destroy<fixed_bitstring<32, false, true>>();
      break;
    case types::ip_v6_address:
      c.destroy<fixed_bitstring<128, false, true>>();
      break;
    case types::ip_v6_prefix:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void iab_tnl_address_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ip_v4_address:
      c.init<fixed_bitstring<32, false, true>>();
      break;
    case types::ip_v6_address:
      c.init<fixed_bitstring<128, false, true>>();
      break;
    case types::ip_v6_prefix:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_tnl_address_c");
  }
}
iab_tnl_address_c::iab_tnl_address_c(const iab_tnl_address_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ip_v4_address:
      c.init(other.c.get<fixed_bitstring<32, false, true>>());
      break;
    case types::ip_v6_address:
      c.init(other.c.get<fixed_bitstring<128, false, true>>());
      break;
    case types::ip_v6_prefix:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_tnl_address_c");
  }
}
iab_tnl_address_c& iab_tnl_address_c::operator=(const iab_tnl_address_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ip_v4_address:
      c.set(other.c.get<fixed_bitstring<32, false, true>>());
      break;
    case types::ip_v6_address:
      c.set(other.c.get<fixed_bitstring<128, false, true>>());
      break;
    case types::ip_v6_prefix:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_tnl_address_c");
  }

  return *this;
}
fixed_bitstring<32, false, true>& iab_tnl_address_c::set_ip_v4_address()
{
  set(types::ip_v4_address);
  return c.get<fixed_bitstring<32, false, true>>();
}
fixed_bitstring<128, false, true>& iab_tnl_address_c::set_ip_v6_address()
{
  set(types::ip_v6_address);
  return c.get<fixed_bitstring<128, false, true>>();
}
fixed_bitstring<64, false, true>& iab_tnl_address_c::set_ip_v6_prefix()
{
  set(types::ip_v6_prefix);
  return c.get<fixed_bitstring<64, false, true>>();
}
protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>& iab_tnl_address_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>();
}
void iab_tnl_address_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ip_v4_address:
      j.write_str("iPv4Address", c.get<fixed_bitstring<32, false, true>>().to_string());
      break;
    case types::ip_v6_address:
      j.write_str("iPv6Address", c.get<fixed_bitstring<128, false, true>>().to_string());
      break;
    case types::ip_v6_prefix:
      j.write_str("iPv6Prefix", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "iab_tnl_address_c");
  }
  j.end_obj();
}
SRSASN_CODE iab_tnl_address_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ip_v4_address:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true>>().pack(bref)));
      break;
    case types::ip_v6_address:
      HANDLE_CODE((c.get<fixed_bitstring<128, false, true>>().pack(bref)));
      break;
    case types::ip_v6_prefix:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_tnl_address_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_tnl_address_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ip_v4_address:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true>>().unpack(bref)));
      break;
    case types::ip_v6_address:
      HANDLE_CODE((c.get<fixed_bitstring<128, false, true>>().unpack(bref)));
      break;
    case types::ip_v6_prefix:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_tnl_address_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_tnl_address_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* iab_tnl_address_c::types_opts::to_string() const
{
  static const char* names[] = {"iPv4Address", "iPv6Address", "iPv6Prefix", "choice-extension"};
  return convert_enum_idx(names, 4, value, "iab_tnl_address_c::types");
}

// IngressNonF1terminatingTopologyIndicator ::= ENUMERATED
const char* ingress_non_f1terminating_topology_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "ingress_non_f1terminating_topology_ind_e");
}

// BAPlayerBHRLCchannelMappingInfo-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t ba_player_bh_rlc_ch_map_info_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {519, 518};
  return map_enum_number(names, 2, idx, "id");
}
bool ba_player_bh_rlc_ch_map_info_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {519, 518};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ba_player_bh_rlc_ch_map_info_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 519:
      return crit_e::ignore;
    case 518:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c
ba_player_bh_rlc_ch_map_info_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 519:
      ret.set(ext_c::types::ingress_non_f1terminating_topology_ind);
      break;
    case 518:
      ret.set(ext_c::types::egress_non_f1terminating_topology_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ba_player_bh_rlc_ch_map_info_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 519:
      return presence_e::optional;
    case 518:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c::destroy_() {}
void ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c::ext_c(
    const ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ingress_non_f1terminating_topology_ind:
      c.init(other.c.get<ingress_non_f1terminating_topology_ind_e>());
      break;
    case types::egress_non_f1terminating_topology_ind:
      c.init(other.c.get<egress_non_f1terminating_topology_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c");
  }
}
ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c& ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c::operator=(
    const ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ingress_non_f1terminating_topology_ind:
      c.set(other.c.get<ingress_non_f1terminating_topology_ind_e>());
      break;
    case types::egress_non_f1terminating_topology_ind:
      c.set(other.c.get<egress_non_f1terminating_topology_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c");
  }

  return *this;
}
ingress_non_f1terminating_topology_ind_e&
ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c::ingress_non_f1terminating_topology_ind()
{
  assert_choice_type(types::ingress_non_f1terminating_topology_ind, type_, "Extension");
  return c.get<ingress_non_f1terminating_topology_ind_e>();
}
egress_non_f1terminating_topology_ind_e&
ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c::egress_non_f1terminating_topology_ind()
{
  assert_choice_type(types::egress_non_f1terminating_topology_ind, type_, "Extension");
  return c.get<egress_non_f1terminating_topology_ind_e>();
}
const ingress_non_f1terminating_topology_ind_e&
ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c::ingress_non_f1terminating_topology_ind() const
{
  assert_choice_type(types::ingress_non_f1terminating_topology_ind, type_, "Extension");
  return c.get<ingress_non_f1terminating_topology_ind_e>();
}
const egress_non_f1terminating_topology_ind_e&
ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c::egress_non_f1terminating_topology_ind() const
{
  assert_choice_type(types::egress_non_f1terminating_topology_ind, type_, "Extension");
  return c.get<egress_non_f1terminating_topology_ind_e>();
}
void ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ingress_non_f1terminating_topology_ind:
      j.write_str("IngressNonF1terminatingTopologyIndicator", "true");
      break;
    case types::egress_non_f1terminating_topology_ind:
      j.write_str("EgressNonF1terminatingTopologyIndicator", "true");
      break;
    default:
      log_invalid_choice_id(type_, "ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ingress_non_f1terminating_topology_ind:
      HANDLE_CODE(c.get<ingress_non_f1terminating_topology_ind_e>().pack(bref));
      break;
    case types::egress_non_f1terminating_topology_ind:
      HANDLE_CODE(c.get<egress_non_f1terminating_topology_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ingress_non_f1terminating_topology_ind:
      HANDLE_CODE(c.get<ingress_non_f1terminating_topology_ind_e>().unpack(bref));
      break;
    case types::egress_non_f1terminating_topology_ind:
      HANDLE_CODE(c.get<egress_non_f1terminating_topology_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ba_player_bh_rlc_ch_map_info_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// IPHeaderInformation ::= SEQUENCE
SRSASN_CODE ip_hdr_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ds_info_list_present, 1));
  HANDLE_CODE(bref.pack(ip_v6_flow_label_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dest_iab_tnl_address.pack(bref));
  if (ds_info_list_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ds_info_list, 0, 64, true));
  }
  if (ip_v6_flow_label_present) {
    HANDLE_CODE(ip_v6_flow_label.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ip_hdr_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ds_info_list_present, 1));
  HANDLE_CODE(bref.unpack(ip_v6_flow_label_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dest_iab_tnl_address.unpack(bref));
  if (ds_info_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ds_info_list, bref, 0, 64, true));
  }
  if (ip_v6_flow_label_present) {
    HANDLE_CODE(ip_v6_flow_label.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ip_hdr_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("destinationIABTNLAddress");
  dest_iab_tnl_address.to_json(j);
  if (ds_info_list_present) {
    j.start_array("dsInformationList");
    for (const auto& e1 : ds_info_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ip_v6_flow_label_present) {
    j.write_str("iPv6FlowLabel", ip_v6_flow_label.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ba_player_bh_rlc_ch_map_info_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ingress_non_f1terminating_topology_ind_present ? 1 : 0;
  nof_ies += egress_non_f1terminating_topology_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (ingress_non_f1terminating_topology_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)519, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ingress_non_f1terminating_topology_ind.pack(bref));
  }
  if (egress_non_f1terminating_topology_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)518, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(egress_non_f1terminating_topology_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ba_player_bh_rlc_ch_map_info_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 519: {
        ingress_non_f1terminating_topology_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ingress_non_f1terminating_topology_ind.unpack(bref));
        break;
      }
      case 518: {
        egress_non_f1terminating_topology_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(egress_non_f1terminating_topology_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ba_player_bh_rlc_ch_map_info_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ingress_non_f1terminating_topology_ind_present) {
    j.write_int("id", 519);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (egress_non_f1terminating_topology_ind_present) {
    j.write_int("id", 518);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  j.end_obj();
}

// BAPlayerBHRLCchannelMappingInfo-Item ::= SEQUENCE
SRSASN_CODE ba_player_bh_rlc_ch_map_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(prior_hop_bap_address_present, 1));
  HANDLE_CODE(bref.pack(ingressb_h_rlc_ch_id_present, 1));
  HANDLE_CODE(bref.pack(next_hop_bap_address_present, 1));
  HANDLE_CODE(bref.pack(egressb_h_rlc_ch_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(map_info_idx.pack(bref));
  if (prior_hop_bap_address_present) {
    HANDLE_CODE(prior_hop_bap_address.pack(bref));
  }
  if (ingressb_h_rlc_ch_id_present) {
    HANDLE_CODE(ingressb_h_rlc_ch_id.pack(bref));
  }
  if (next_hop_bap_address_present) {
    HANDLE_CODE(next_hop_bap_address.pack(bref));
  }
  if (egressb_h_rlc_ch_id_present) {
    HANDLE_CODE(egressb_h_rlc_ch_id.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ba_player_bh_rlc_ch_map_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(prior_hop_bap_address_present, 1));
  HANDLE_CODE(bref.unpack(ingressb_h_rlc_ch_id_present, 1));
  HANDLE_CODE(bref.unpack(next_hop_bap_address_present, 1));
  HANDLE_CODE(bref.unpack(egressb_h_rlc_ch_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(map_info_idx.unpack(bref));
  if (prior_hop_bap_address_present) {
    HANDLE_CODE(prior_hop_bap_address.unpack(bref));
  }
  if (ingressb_h_rlc_ch_id_present) {
    HANDLE_CODE(ingressb_h_rlc_ch_id.unpack(bref));
  }
  if (next_hop_bap_address_present) {
    HANDLE_CODE(next_hop_bap_address.unpack(bref));
  }
  if (egressb_h_rlc_ch_id_present) {
    HANDLE_CODE(egressb_h_rlc_ch_id.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ba_player_bh_rlc_ch_map_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mappingInformationIndex", map_info_idx.to_string());
  if (prior_hop_bap_address_present) {
    j.write_str("priorHopBAPAddress", prior_hop_bap_address.to_string());
  }
  if (ingressb_h_rlc_ch_id_present) {
    j.write_str("ingressbHRLCChannelID", ingressb_h_rlc_ch_id.to_string());
  }
  if (next_hop_bap_address_present) {
    j.write_str("nextHopBAPAddress", next_hop_bap_address.to_string());
  }
  if (egressb_h_rlc_ch_id_present) {
    j.write_str("egressbHRLCChannelID", egressb_h_rlc_ch_id.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BH-Routing-Information-Added-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t bh_routing_info_added_list_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {517};
  return map_enum_number(names, 1, idx, "id");
}
bool bh_routing_info_added_list_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 517 == id;
}
crit_e bh_routing_info_added_list_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 517) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
bh_routing_info_added_list_item_ext_ies_o::ext_c bh_routing_info_added_list_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 517) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e bh_routing_info_added_list_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 517) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void bh_routing_info_added_list_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("NonF1terminatingTopologyIndicator", "true");
  j.end_obj();
}
SRSASN_CODE bh_routing_info_added_list_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_routing_info_added_list_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// IPtolayer2TrafficMappingInfo-Item ::= SEQUENCE
SRSASN_CODE ip_tolayer2_traffic_map_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(map_info_idx.pack(bref));
  HANDLE_CODE(ip_hdr_info.pack(bref));
  HANDLE_CODE(bh_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ip_tolayer2_traffic_map_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(map_info_idx.unpack(bref));
  HANDLE_CODE(ip_hdr_info.unpack(bref));
  HANDLE_CODE(bh_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ip_tolayer2_traffic_map_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mappingInformationIndex", map_info_idx.to_string());
  j.write_fieldname("iPHeaderInformation");
  ip_hdr_info.to_json(j);
  j.write_fieldname("bHInfo");
  bh_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BH-Routing-Information-Added-List-Item ::= SEQUENCE
SRSASN_CODE bh_routing_info_added_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(bap_routing_id.pack(bref));
  HANDLE_CODE(next_hop_bap_address.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_routing_info_added_list_item_s::unpack(cbit_ref& bref)
{
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bap_routing_id.unpack(bref));
  HANDLE_CODE(next_hop_bap_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void bh_routing_info_added_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("bAPRoutingID");
  bap_routing_id.to_json(j);
  j.write_str("nextHopBAPAddress", next_hop_bap_address.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// BH-Routing-Information-Removed-List-Item ::= SEQUENCE
SRSASN_CODE bh_routing_info_remd_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bap_routing_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_routing_info_remd_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bap_routing_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_routing_info_remd_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("bAPRoutingID");
  bap_routing_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BAPlayerBHRLCchannelMappingInfo ::= SEQUENCE
SRSASN_CODE ba_player_bh_rlc_ch_map_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ba_player_bh_rlc_ch_map_info_to_add.size() > 0, 1));
  HANDLE_CODE(bref.pack(ba_player_bh_rlc_ch_map_info_to_rem.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ba_player_bh_rlc_ch_map_info_to_add.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ba_player_bh_rlc_ch_map_info_to_add, 1, 67108864, true));
  }
  if (ba_player_bh_rlc_ch_map_info_to_rem.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ba_player_bh_rlc_ch_map_info_to_rem, 1, 67108864, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ba_player_bh_rlc_ch_map_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ba_player_bh_rlc_ch_map_info_to_add_present;
  HANDLE_CODE(bref.unpack(ba_player_bh_rlc_ch_map_info_to_add_present, 1));
  bool ba_player_bh_rlc_ch_map_info_to_rem_present;
  HANDLE_CODE(bref.unpack(ba_player_bh_rlc_ch_map_info_to_rem_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ba_player_bh_rlc_ch_map_info_to_add_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ba_player_bh_rlc_ch_map_info_to_add, bref, 1, 67108864, true));
  }
  if (ba_player_bh_rlc_ch_map_info_to_rem_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ba_player_bh_rlc_ch_map_info_to_rem, bref, 1, 67108864, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ba_player_bh_rlc_ch_map_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ba_player_bh_rlc_ch_map_info_to_add.size() > 0) {
    j.start_array("bAPlayerBHRLCchannelMappingInfoToAdd");
    for (const auto& e1 : ba_player_bh_rlc_ch_map_info_to_add) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ba_player_bh_rlc_ch_map_info_to_rem.size() > 0) {
    j.start_array("bAPlayerBHRLCchannelMappingInfoToRemove");
    for (const auto& e1 : ba_player_bh_rlc_ch_map_info_to_rem) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IPtolayer2TrafficMappingInfo ::= SEQUENCE
SRSASN_CODE ip_tolayer2_traffic_map_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ip_tolayer2_traffic_map_info_to_add.size() > 0, 1));
  HANDLE_CODE(bref.pack(ip_tolayer2_traffic_map_info_to_rem.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ip_tolayer2_traffic_map_info_to_add.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ip_tolayer2_traffic_map_info_to_add, 1, 67108864, true));
  }
  if (ip_tolayer2_traffic_map_info_to_rem.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ip_tolayer2_traffic_map_info_to_rem, 1, 67108864, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ip_tolayer2_traffic_map_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ip_tolayer2_traffic_map_info_to_add_present;
  HANDLE_CODE(bref.unpack(ip_tolayer2_traffic_map_info_to_add_present, 1));
  bool ip_tolayer2_traffic_map_info_to_rem_present;
  HANDLE_CODE(bref.unpack(ip_tolayer2_traffic_map_info_to_rem_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ip_tolayer2_traffic_map_info_to_add_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ip_tolayer2_traffic_map_info_to_add, bref, 1, 67108864, true));
  }
  if (ip_tolayer2_traffic_map_info_to_rem_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ip_tolayer2_traffic_map_info_to_rem, bref, 1, 67108864, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ip_tolayer2_traffic_map_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ip_tolayer2_traffic_map_info_to_add.size() > 0) {
    j.start_array("iPtolayer2TrafficMappingInfoToAdd");
    for (const auto& e1 : ip_tolayer2_traffic_map_info_to_add) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ip_tolayer2_traffic_map_info_to_rem.size() > 0) {
    j.start_array("iPtolayer2TrafficMappingInfoToRemove");
    for (const auto& e1 : ip_tolayer2_traffic_map_info_to_rem) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Re-routingEnableIndicator ::= ENUMERATED
const char* re_routing_enable_ind_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "re_routing_enable_ind_e");
}

// TrafficMappingInfo ::= CHOICE
void traffic_map_info_c::destroy_()
{
  switch (type_) {
    case types::ip_tolayer2_traffic_map_info:
      c.destroy<ip_tolayer2_traffic_map_info_s>();
      break;
    case types::ba_player_bh_rlc_ch_map_info:
      c.destroy<ba_player_bh_rlc_ch_map_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<traffic_map_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void traffic_map_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ip_tolayer2_traffic_map_info:
      c.init<ip_tolayer2_traffic_map_info_s>();
      break;
    case types::ba_player_bh_rlc_ch_map_info:
      c.init<ba_player_bh_rlc_ch_map_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<traffic_map_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "traffic_map_info_c");
  }
}
traffic_map_info_c::traffic_map_info_c(const traffic_map_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ip_tolayer2_traffic_map_info:
      c.init(other.c.get<ip_tolayer2_traffic_map_info_s>());
      break;
    case types::ba_player_bh_rlc_ch_map_info:
      c.init(other.c.get<ba_player_bh_rlc_ch_map_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<traffic_map_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "traffic_map_info_c");
  }
}
traffic_map_info_c& traffic_map_info_c::operator=(const traffic_map_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ip_tolayer2_traffic_map_info:
      c.set(other.c.get<ip_tolayer2_traffic_map_info_s>());
      break;
    case types::ba_player_bh_rlc_ch_map_info:
      c.set(other.c.get<ba_player_bh_rlc_ch_map_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<traffic_map_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "traffic_map_info_c");
  }

  return *this;
}
ip_tolayer2_traffic_map_info_s& traffic_map_info_c::set_ip_tolayer2_traffic_map_info()
{
  set(types::ip_tolayer2_traffic_map_info);
  return c.get<ip_tolayer2_traffic_map_info_s>();
}
ba_player_bh_rlc_ch_map_info_s& traffic_map_info_c::set_ba_player_bh_rlc_ch_map_info()
{
  set(types::ba_player_bh_rlc_ch_map_info);
  return c.get<ba_player_bh_rlc_ch_map_info_s>();
}
protocol_ie_single_container_s<traffic_map_info_ext_ies_o>& traffic_map_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<traffic_map_info_ext_ies_o>>();
}
void traffic_map_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ip_tolayer2_traffic_map_info:
      j.write_fieldname("iPtolayer2TrafficMappingInfo");
      c.get<ip_tolayer2_traffic_map_info_s>().to_json(j);
      break;
    case types::ba_player_bh_rlc_ch_map_info:
      j.write_fieldname("bAPlayerBHRLCchannelMappingInfo");
      c.get<ba_player_bh_rlc_ch_map_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<traffic_map_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "traffic_map_info_c");
  }
  j.end_obj();
}
SRSASN_CODE traffic_map_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ip_tolayer2_traffic_map_info:
      HANDLE_CODE(c.get<ip_tolayer2_traffic_map_info_s>().pack(bref));
      break;
    case types::ba_player_bh_rlc_ch_map_info:
      HANDLE_CODE(c.get<ba_player_bh_rlc_ch_map_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<traffic_map_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "traffic_map_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE traffic_map_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ip_tolayer2_traffic_map_info:
      HANDLE_CODE(c.get<ip_tolayer2_traffic_map_info_s>().unpack(bref));
      break;
    case types::ba_player_bh_rlc_ch_map_info:
      HANDLE_CODE(c.get<ba_player_bh_rlc_ch_map_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<traffic_map_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "traffic_map_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* traffic_map_info_c::types_opts::to_string() const
{
  static const char* names[] = {"iPtolayer2TrafficMappingInfo", "bAPlayerBHRLCchannelMappingInfo", "choice-extension"};
  return convert_enum_idx(names, 3, value, "traffic_map_info_c::types");
}
uint8_t traffic_map_info_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {2};
  return map_enum_number(numbers, 1, value, "traffic_map_info_c::types");
}

// TypeOfError ::= ENUMERATED
const char* type_of_error_opts::to_string() const
{
  static const char* names[] = {"not-understood", "missing"};
  return convert_enum_idx(names, 2, value, "type_of_error_e");
}

// CriticalityDiagnostics-IE-Item ::= SEQUENCE
SRSASN_CODE crit_diagnostics_ie_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ie_crit.pack(bref));
  HANDLE_CODE(pack_integer(bref, ie_id, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(type_of_error.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE crit_diagnostics_ie_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ie_crit.unpack(bref));
  HANDLE_CODE(unpack_integer(ie_id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  HANDLE_CODE(type_of_error.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void crit_diagnostics_ie_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("iECriticality", ie_crit.to_string());
  j.write_int("iE-ID", ie_id);
  j.write_str("typeOfError", type_of_error.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TriggeringMessage ::= ENUMERATED
const char* trigger_msg_opts::to_string() const
{
  static const char* names[] = {"initiating-message", "successful-outcome", "unsuccessful-outcome"};
  return convert_enum_idx(names, 3, value, "trigger_msg_e");
}

// CriticalityDiagnostics ::= SEQUENCE
SRSASN_CODE crit_diagnostics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(proc_code_present, 1));
  HANDLE_CODE(bref.pack(trigger_msg_present, 1));
  HANDLE_CODE(bref.pack(proc_crit_present, 1));
  HANDLE_CODE(bref.pack(transaction_id_present, 1));
  HANDLE_CODE(bref.pack(ies_crit_diagnostics.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (proc_code_present) {
    HANDLE_CODE(pack_integer(bref, proc_code, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (trigger_msg_present) {
    HANDLE_CODE(trigger_msg.pack(bref));
  }
  if (proc_crit_present) {
    HANDLE_CODE(proc_crit.pack(bref));
  }
  if (transaction_id_present) {
    HANDLE_CODE(pack_integer(bref, transaction_id, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ies_crit_diagnostics.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ies_crit_diagnostics, 1, 256, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE crit_diagnostics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(proc_code_present, 1));
  HANDLE_CODE(bref.unpack(trigger_msg_present, 1));
  HANDLE_CODE(bref.unpack(proc_crit_present, 1));
  HANDLE_CODE(bref.unpack(transaction_id_present, 1));
  bool ies_crit_diagnostics_present;
  HANDLE_CODE(bref.unpack(ies_crit_diagnostics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (proc_code_present) {
    HANDLE_CODE(unpack_integer(proc_code, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (trigger_msg_present) {
    HANDLE_CODE(trigger_msg.unpack(bref));
  }
  if (proc_crit_present) {
    HANDLE_CODE(proc_crit.unpack(bref));
  }
  if (transaction_id_present) {
    HANDLE_CODE(unpack_integer(transaction_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ies_crit_diagnostics_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ies_crit_diagnostics, bref, 1, 256, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void crit_diagnostics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (proc_code_present) {
    j.write_int("procedureCode", proc_code);
  }
  if (trigger_msg_present) {
    j.write_str("triggeringMessage", trigger_msg.to_string());
  }
  if (proc_crit_present) {
    j.write_str("procedureCriticality", proc_crit.to_string());
  }
  if (transaction_id_present) {
    j.write_int("transactionID", transaction_id);
  }
  if (ies_crit_diagnostics.size() > 0) {
    j.start_array("iEsCriticalityDiagnostics");
    for (const auto& e1 : ies_crit_diagnostics) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CauseMisc ::= ENUMERATED
const char* cause_misc_opts::to_string() const
{
  static const char* names[] = {"control-processing-overload",
                                "not-enough-user-plane-processing-resources",
                                "hardware-failure",
                                "om-intervention",
                                "unspecified"};
  return convert_enum_idx(names, 5, value, "cause_misc_e");
}

// CauseProtocol ::= ENUMERATED
const char* cause_protocol_opts::to_string() const
{
  static const char* names[] = {"transfer-syntax-error",
                                "abstract-syntax-error-reject",
                                "abstract-syntax-error-ignore-and-notify",
                                "message-not-compatible-with-receiver-state",
                                "semantic-error",
                                "abstract-syntax-error-falsely-constructed-message",
                                "unspecified"};
  return convert_enum_idx(names, 7, value, "cause_protocol_e");
}

// CauseRadioNetwork ::= ENUMERATED
const char* cause_radio_network_opts::to_string() const
{
  static const char* names[] = {"unspecified",
                                "rl-failure-rlc",
                                "unknown-or-already-allocated-gnb-cu-ue-f1ap-id",
                                "unknown-or-already-allocated-gnb-du-ue-f1ap-id",
                                "unknown-or-inconsistent-pair-of-ue-f1ap-id",
                                "interaction-with-other-procedure",
                                "not-supported-qci-Value",
                                "action-desirable-for-radio-reasons",
                                "no-radio-resources-available",
                                "procedure-cancelled",
                                "normal-release",
                                "cell-not-available",
                                "rl-failure-others",
                                "ue-rejection",
                                "resources-not-available-for-the-slice",
                                "amf-initiated-abnormal-release",
                                "release-due-to-pre-emption",
                                "plmn-not-served-by-the-gNB-CU",
                                "multiple-drb-id-instances",
                                "unknown-drb-id",
                                "multiple-bh-rlc-ch-id-instances",
                                "unknown-bh-rlc-ch-id",
                                "cho-cpc-resources-tobechanged",
                                "nPN-not-supported",
                                "nPN-access-denied",
                                "gNB-CU-Cell-Capacity-Exceeded",
                                "report-characteristics-empty",
                                "existing-measurement-ID",
                                "measurement-temporarily-not-available",
                                "measurement-not-supported-for-the-object",
                                "unknown-bh-address",
                                "unknown-bap-routing-id",
                                "insufficient-ue-capabilities",
                                "scg-activation-deactivation-failure",
                                "scg-deactivation-failure-due-to-data-transmission",
                                "requested-item-not-supported-on-time",
                                "unknown-or-already-allocated-gNB-CU-MBS-F1AP-ID",
                                "unknown-or-already-allocated-gNB-DU-MBS-F1AP-ID",
                                "unknown-or-inconsistent-pair-of-MBS-F1AP-ID",
                                "unknown-or-inconsistent-MRB-ID",
                                "tat-sdt-expiry"};
  return convert_enum_idx(names, 41, value, "cause_radio_network_e");
}

// CauseTransport ::= ENUMERATED
const char* cause_transport_opts::to_string() const
{
  static const char* names[] = {"unspecified",
                                "transport-resource-unavailable",
                                "unknown-TNL-address-for-IAB",
                                "unknown-UP-TNL-information-for-IAB"};
  return convert_enum_idx(names, 4, value, "cause_transport_e");
}

// Cause ::= CHOICE
void cause_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<cause_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cause_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::radio_network:
      break;
    case types::transport:
      break;
    case types::protocol:
      break;
    case types::misc:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<cause_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
}
cause_c::cause_c(const cause_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::radio_network:
      c.init(other.c.get<cause_radio_network_e>());
      break;
    case types::transport:
      c.init(other.c.get<cause_transport_e>());
      break;
    case types::protocol:
      c.init(other.c.get<cause_protocol_e>());
      break;
    case types::misc:
      c.init(other.c.get<cause_misc_e>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<cause_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
}
cause_c& cause_c::operator=(const cause_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::radio_network:
      c.set(other.c.get<cause_radio_network_e>());
      break;
    case types::transport:
      c.set(other.c.get<cause_transport_e>());
      break;
    case types::protocol:
      c.set(other.c.get<cause_protocol_e>());
      break;
    case types::misc:
      c.set(other.c.get<cause_misc_e>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<cause_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }

  return *this;
}
cause_radio_network_e& cause_c::set_radio_network()
{
  set(types::radio_network);
  return c.get<cause_radio_network_e>();
}
cause_transport_e& cause_c::set_transport()
{
  set(types::transport);
  return c.get<cause_transport_e>();
}
cause_protocol_e& cause_c::set_protocol()
{
  set(types::protocol);
  return c.get<cause_protocol_e>();
}
cause_misc_e& cause_c::set_misc()
{
  set(types::misc);
  return c.get<cause_misc_e>();
}
protocol_ie_single_container_s<cause_ext_ies_o>& cause_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<cause_ext_ies_o>>();
}
void cause_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::radio_network:
      j.write_str("radioNetwork", c.get<cause_radio_network_e>().to_string());
      break;
    case types::transport:
      j.write_str("transport", c.get<cause_transport_e>().to_string());
      break;
    case types::protocol:
      j.write_str("protocol", c.get<cause_protocol_e>().to_string());
      break;
    case types::misc:
      j.write_str("misc", c.get<cause_misc_e>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<cause_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
  }
  j.end_obj();
}
SRSASN_CODE cause_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::radio_network:
      HANDLE_CODE(c.get<cause_radio_network_e>().pack(bref));
      break;
    case types::transport:
      HANDLE_CODE(c.get<cause_transport_e>().pack(bref));
      break;
    case types::protocol:
      HANDLE_CODE(c.get<cause_protocol_e>().pack(bref));
      break;
    case types::misc:
      HANDLE_CODE(c.get<cause_misc_e>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cause_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cause_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::radio_network:
      HANDLE_CODE(c.get<cause_radio_network_e>().unpack(bref));
      break;
    case types::transport:
      HANDLE_CODE(c.get<cause_transport_e>().unpack(bref));
      break;
    case types::protocol:
      HANDLE_CODE(c.get<cause_protocol_e>().unpack(bref));
      break;
    case types::misc:
      HANDLE_CODE(c.get<cause_misc_e>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cause_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cause_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cause_c::types_opts::to_string() const
{
  static const char* names[] = {"radioNetwork", "transport", "protocol", "misc", "choice-extension"};
  return convert_enum_idx(names, 5, value, "cause_c::types");
}
uint8_t cause_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {2};
  return map_enum_number(numbers, 1, value, "cause_c::types");
}

// TimeToWait ::= ENUMERATED
const char* time_to_wait_opts::to_string() const
{
  static const char* names[] = {"v1s", "v2s", "v5s", "v10s", "v20s", "v60s"};
  return convert_enum_idx(names, 6, value, "time_to_wait_e");
}
uint8_t time_to_wait_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 5, 10, 20, 60};
  return map_enum_number(numbers, 6, value, "time_to_wait_e");
}

// LocationDependentMBSF1UInformation-Item ::= SEQUENCE
SRSASN_CODE location_dependent_mbsf1_u_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(mbs_f1u_info_at_cu.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_dependent_mbsf1_u_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(mbs_f1u_info_at_cu.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void location_dependent_mbsf1_u_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mbsAreaSession-ID", mbs_area_session_id);
  j.write_fieldname("mbs-f1u-info-at-CU");
  mbs_f1u_info_at_cu.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBSF1UInformation ::= SEQUENCE
SRSASN_CODE mbsf1_u_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_f1u_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbsf1_u_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_f1u_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbsf1_u_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mbs-f1u-info");
  mbs_f1u_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BCBearerContextF1U-TNLInfo ::= CHOICE
void bc_bearer_context_f1_u_tnl_info_c::destroy_()
{
  switch (type_) {
    case types::locationindpendent:
      c.destroy<mbsf1_u_info_s>();
      break;
    case types::locationdependent:
      c.destroy<location_dependent_mbsf1_u_info_l>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void bc_bearer_context_f1_u_tnl_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::locationindpendent:
      c.init<mbsf1_u_info_s>();
      break;
    case types::locationdependent:
      c.init<location_dependent_mbsf1_u_info_l>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bc_bearer_context_f1_u_tnl_info_c");
  }
}
bc_bearer_context_f1_u_tnl_info_c::bc_bearer_context_f1_u_tnl_info_c(const bc_bearer_context_f1_u_tnl_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::locationindpendent:
      c.init(other.c.get<mbsf1_u_info_s>());
      break;
    case types::locationdependent:
      c.init(other.c.get<location_dependent_mbsf1_u_info_l>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bc_bearer_context_f1_u_tnl_info_c");
  }
}
bc_bearer_context_f1_u_tnl_info_c&
bc_bearer_context_f1_u_tnl_info_c::operator=(const bc_bearer_context_f1_u_tnl_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::locationindpendent:
      c.set(other.c.get<mbsf1_u_info_s>());
      break;
    case types::locationdependent:
      c.set(other.c.get<location_dependent_mbsf1_u_info_l>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bc_bearer_context_f1_u_tnl_info_c");
  }

  return *this;
}
mbsf1_u_info_s& bc_bearer_context_f1_u_tnl_info_c::set_locationindpendent()
{
  set(types::locationindpendent);
  return c.get<mbsf1_u_info_s>();
}
location_dependent_mbsf1_u_info_l& bc_bearer_context_f1_u_tnl_info_c::set_locationdependent()
{
  set(types::locationdependent);
  return c.get<location_dependent_mbsf1_u_info_l>();
}
protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>&
bc_bearer_context_f1_u_tnl_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>>();
}
void bc_bearer_context_f1_u_tnl_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::locationindpendent:
      j.write_fieldname("locationindpendent");
      c.get<mbsf1_u_info_s>().to_json(j);
      break;
    case types::locationdependent:
      j.start_array("locationdependent");
      for (const auto& e1 : c.get<location_dependent_mbsf1_u_info_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "bc_bearer_context_f1_u_tnl_info_c");
  }
  j.end_obj();
}
SRSASN_CODE bc_bearer_context_f1_u_tnl_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::locationindpendent:
      HANDLE_CODE(c.get<mbsf1_u_info_s>().pack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<location_dependent_mbsf1_u_info_l>(), 1, 256, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "bc_bearer_context_f1_u_tnl_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE bc_bearer_context_f1_u_tnl_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::locationindpendent:
      HANDLE_CODE(c.get<mbsf1_u_info_s>().unpack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<location_dependent_mbsf1_u_info_l>(), bref, 1, 256, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<bc_bearer_context_f1_u_tnl_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "bc_bearer_context_f1_u_tnl_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* bc_bearer_context_f1_u_tnl_info_c::types_opts::to_string() const
{
  static const char* names[] = {"locationindpendent", "locationdependent", "choice-extension"};
  return convert_enum_idx(names, 3, value, "bc_bearer_context_f1_u_tnl_info_c::types");
}

// BHChannels-FailedToBeModified-Item ::= SEQUENCE
SRSASN_CODE bh_chs_failed_to_be_modified_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_chs_failed_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_chs_failed_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bHRLCChannelID", bh_rlc_ch_id.to_string());
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BHChannels-FailedToBeSetup-Item ::= SEQUENCE
SRSASN_CODE bh_chs_failed_to_be_setup_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_chs_failed_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_chs_failed_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bHRLCChannelID", bh_rlc_ch_id.to_string());
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BHChannels-FailedToBeSetupMod-Item ::= SEQUENCE
SRSASN_CODE bh_chs_failed_to_be_setup_mod_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_chs_failed_to_be_setup_mod_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_chs_failed_to_be_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bHRLCChannelID", bh_rlc_ch_id.to_string());
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BHChannels-Modified-Item ::= SEQUENCE
SRSASN_CODE bh_chs_modified_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_chs_modified_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_chs_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bHRLCChannelID", bh_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BHChannels-Required-ToBeReleased-Item ::= SEQUENCE
SRSASN_CODE bh_chs_required_to_be_released_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_chs_required_to_be_released_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_chs_required_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bHRLCChannelID", bh_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BHChannels-Setup-Item ::= SEQUENCE
SRSASN_CODE bh_chs_setup_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_chs_setup_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_chs_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bHRLCChannelID", bh_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BHChannels-SetupMod-Item ::= SEQUENCE
SRSASN_CODE bh_chs_setup_mod_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_chs_setup_mod_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_chs_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bHRLCChannelID", bh_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Dynamic5QIDescriptor-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t dyn_5qi_descriptor_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {363, 362, 369};
  return map_enum_number(names, 3, idx, "id");
}
bool dyn_5qi_descriptor_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {363, 362, 369};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dyn_5qi_descriptor_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 363:
      return crit_e::ignore;
    case 362:
      return crit_e::ignore;
    case 369:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dyn_5qi_descriptor_ext_ies_o::ext_c dyn_5qi_descriptor_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 363:
      ret.set(ext_c::types::extended_packet_delay_budget);
      break;
    case 362:
      ret.set(ext_c::types::cn_packet_delay_budget_dl);
      break;
    case 369:
      ret.set(ext_c::types::cn_packet_delay_budget_ul);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dyn_5qi_descriptor_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 363:
      return presence_e::optional;
    case 362:
      return presence_e::optional;
    case 369:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void dyn_5qi_descriptor_ext_ies_o::ext_c::destroy_() {}
void dyn_5qi_descriptor_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
dyn_5qi_descriptor_ext_ies_o::ext_c::ext_c(const dyn_5qi_descriptor_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::extended_packet_delay_budget:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_dl:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      c.init(other.c.get<uint32_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
}
dyn_5qi_descriptor_ext_ies_o::ext_c&
dyn_5qi_descriptor_ext_ies_o::ext_c::operator=(const dyn_5qi_descriptor_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::extended_packet_delay_budget:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_dl:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      c.set(other.c.get<uint32_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
  }

  return *this;
}
uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::extended_packet_delay_budget()
{
  assert_choice_type(types::extended_packet_delay_budget, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl()
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul()
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::extended_packet_delay_budget() const
{
  assert_choice_type(types::extended_packet_delay_budget, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl() const
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul() const
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
void dyn_5qi_descriptor_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::extended_packet_delay_budget:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_dl:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE dyn_5qi_descriptor_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_packet_delay_budget:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dyn_5qi_descriptor_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_packet_delay_budget:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NonDynamic5QIDescriptor-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t non_dyn_5qi_descriptor_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {362, 369};
  return map_enum_number(names, 2, idx, "id");
}
bool non_dyn_5qi_descriptor_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {362, 369};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e non_dyn_5qi_descriptor_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 362:
      return crit_e::ignore;
    case 369:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
non_dyn_5qi_descriptor_ext_ies_o::ext_c non_dyn_5qi_descriptor_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 362:
      ret.set(ext_c::types::cn_packet_delay_budget_dl);
      break;
    case 369:
      ret.set(ext_c::types::cn_packet_delay_budget_ul);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e non_dyn_5qi_descriptor_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 362:
      return presence_e::optional;
    case 369:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void non_dyn_5qi_descriptor_ext_ies_o::ext_c::destroy_() {}
void non_dyn_5qi_descriptor_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
non_dyn_5qi_descriptor_ext_ies_o::ext_c::ext_c(const non_dyn_5qi_descriptor_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      c.init(other.c.get<uint32_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
}
non_dyn_5qi_descriptor_ext_ies_o::ext_c&
non_dyn_5qi_descriptor_ext_ies_o::ext_c::operator=(const non_dyn_5qi_descriptor_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      c.set(other.c.get<uint32_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
  }

  return *this;
}
uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl()
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul()
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_dl() const
{
  assert_choice_type(types::cn_packet_delay_budget_dl, type_, "Extension");
  return c.get<uint32_t>();
}
const uint32_t& non_dyn_5qi_descriptor_ext_ies_o::ext_c::cn_packet_delay_budget_ul() const
{
  assert_choice_type(types::cn_packet_delay_budget_ul, type_, "Extension");
  return c.get<uint32_t>();
}
void non_dyn_5qi_descriptor_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    case types::cn_packet_delay_budget_ul:
      j.write_int("INTEGER (1..65535,...)", c.get<uint32_t>());
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cn_packet_delay_budget_dl:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    case types::cn_packet_delay_budget_ul:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)1u, (uint32_t)65535u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "non_dyn_5qi_descriptor_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE dyn_5qi_descriptor_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += extended_packet_delay_budget_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_dl_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (extended_packet_delay_budget_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)363, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, extended_packet_delay_budget, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (cn_packet_delay_budget_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)362, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_dl, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (cn_packet_delay_budget_ul_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)369, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_ul, (uint32_t)1u, (uint32_t)65535u, true, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dyn_5qi_descriptor_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 363: {
        extended_packet_delay_budget_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(extended_packet_delay_budget, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
        break;
      }
      case 362: {
        cn_packet_delay_budget_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_dl, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
        break;
      }
      case 369: {
        cn_packet_delay_budget_ul_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_ul, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void dyn_5qi_descriptor_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (extended_packet_delay_budget_present) {
    j.write_int("id", 363);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", extended_packet_delay_budget);
  }
  if (cn_packet_delay_budget_dl_present) {
    j.write_int("id", 362);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_dl);
  }
  if (cn_packet_delay_budget_ul_present) {
    j.write_int("id", 369);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_ul);
  }
  j.end_obj();
}

// Dynamic5QIDescriptor ::= SEQUENCE
SRSASN_CODE dyn_5qi_descriptor_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(five_qi_present, 1));
  HANDLE_CODE(bref.pack(delay_crit_present, 1));
  HANDLE_CODE(bref.pack(averaging_win_present, 1));
  HANDLE_CODE(bref.pack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_prio_level, (uint8_t)1u, (uint8_t)127u, false, true));
  HANDLE_CODE(pack_integer(bref, packet_delay_budget, (uint16_t)0u, (uint16_t)1023u, true, true));
  HANDLE_CODE(packet_error_rate.pack(bref));
  if (five_qi_present) {
    HANDLE_CODE(pack_integer(bref, five_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (delay_crit_present) {
    HANDLE_CODE(delay_crit.pack(bref));
  }
  if (averaging_win_present) {
    HANDLE_CODE(pack_integer(bref, averaging_win, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(pack_integer(bref, max_data_burst_volume, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dyn_5qi_descriptor_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(five_qi_present, 1));
  HANDLE_CODE(bref.unpack(delay_crit_present, 1));
  HANDLE_CODE(bref.unpack(averaging_win_present, 1));
  HANDLE_CODE(bref.unpack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_prio_level, bref, (uint8_t)1u, (uint8_t)127u, false, true));
  HANDLE_CODE(unpack_integer(packet_delay_budget, bref, (uint16_t)0u, (uint16_t)1023u, true, true));
  HANDLE_CODE(packet_error_rate.unpack(bref));
  if (five_qi_present) {
    HANDLE_CODE(unpack_integer(five_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (delay_crit_present) {
    HANDLE_CODE(delay_crit.unpack(bref));
  }
  if (averaging_win_present) {
    HANDLE_CODE(unpack_integer(averaging_win, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(unpack_integer(max_data_burst_volume, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dyn_5qi_descriptor_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qoSPriorityLevel", qos_prio_level);
  j.write_int("packetDelayBudget", packet_delay_budget);
  j.write_fieldname("packetErrorRate");
  packet_error_rate.to_json(j);
  if (five_qi_present) {
    j.write_int("fiveQI", five_qi);
  }
  if (delay_crit_present) {
    j.write_str("delayCritical", delay_crit.to_string());
  }
  if (averaging_win_present) {
    j.write_int("averagingWindow", averaging_win);
  }
  if (max_data_burst_volume_present) {
    j.write_int("maxDataBurstVolume", max_data_burst_volume);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* dyn_5qi_descriptor_s::delay_crit_opts::to_string() const
{
  static const char* names[] = {"delay-critical", "non-delay-critical"};
  return convert_enum_idx(names, 2, value, "dyn_5qi_descriptor_s::delay_crit_e_");
}

// GBR-QosFlowInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t gbr_qos_flow_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {343};
  return map_enum_number(names, 1, idx, "id");
}
bool gbr_qos_flow_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 343 == id;
}
crit_e gbr_qos_flow_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 343) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
gbr_qos_flow_info_ext_ies_o::ext_c gbr_qos_flow_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 343) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e gbr_qos_flow_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 343) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void gbr_qos_flow_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("AlternativeQoSParaSetList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE gbr_qos_flow_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 8, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE gbr_qos_flow_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 8, true));
  return SRSASN_SUCCESS;
}

SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += cn_packet_delay_budget_dl_present ? 1 : 0;
  nof_ies += cn_packet_delay_budget_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (cn_packet_delay_budget_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)362, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_dl, (uint32_t)1u, (uint32_t)65535u, true, true));
  }
  if (cn_packet_delay_budget_ul_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)369, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, cn_packet_delay_budget_ul, (uint32_t)1u, (uint32_t)65535u, true, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE non_dyn_5qi_descriptor_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 362: {
        cn_packet_delay_budget_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_dl, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
        break;
      }
      case 369: {
        cn_packet_delay_budget_ul_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(cn_packet_delay_budget_ul, bref, (uint32_t)1u, (uint32_t)65535u, true, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void non_dyn_5qi_descriptor_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (cn_packet_delay_budget_dl_present) {
    j.write_int("id", 362);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_dl);
  }
  if (cn_packet_delay_budget_ul_present) {
    j.write_int("id", 369);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", cn_packet_delay_budget_ul);
  }
  j.end_obj();
}

// NonDynamic5QIDescriptor ::= SEQUENCE
SRSASN_CODE non_dyn_5qi_descriptor_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(qos_prio_level_present, 1));
  HANDLE_CODE(bref.pack(averaging_win_present, 1));
  HANDLE_CODE(bref.pack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, five_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  if (qos_prio_level_present) {
    HANDLE_CODE(pack_integer(bref, qos_prio_level, (uint8_t)1u, (uint8_t)127u, false, true));
  }
  if (averaging_win_present) {
    HANDLE_CODE(pack_integer(bref, averaging_win, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(pack_integer(bref, max_data_burst_volume, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE non_dyn_5qi_descriptor_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(qos_prio_level_present, 1));
  HANDLE_CODE(bref.unpack(averaging_win_present, 1));
  HANDLE_CODE(bref.unpack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(five_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  if (qos_prio_level_present) {
    HANDLE_CODE(unpack_integer(qos_prio_level, bref, (uint8_t)1u, (uint8_t)127u, false, true));
  }
  if (averaging_win_present) {
    HANDLE_CODE(unpack_integer(averaging_win, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(unpack_integer(max_data_burst_volume, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void non_dyn_5qi_descriptor_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveQI", five_qi);
  if (qos_prio_level_present) {
    j.write_int("qoSPriorityLevel", qos_prio_level);
  }
  if (averaging_win_present) {
    j.write_int("averagingWindow", averaging_win);
  }
  if (max_data_burst_volume_present) {
    j.write_int("maxDataBurstVolume", max_data_burst_volume);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QosMonitoringRequest ::= ENUMERATED
const char* qos_monitoring_request_opts::to_string() const
{
  static const char* names[] = {"ul", "dl", "both", "stop"};
  return convert_enum_idx(names, 4, value, "qos_monitoring_request_e");
}

// EUTRANQoS-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t eutran_qos_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {437};
  return map_enum_number(names, 1, idx, "id");
}
bool eutran_qos_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 437 == id;
}
crit_e eutran_qos_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 437) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
eutran_qos_ext_ies_o::ext_c eutran_qos_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 437) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e eutran_qos_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 437) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void eutran_qos_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("BIT STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE eutran_qos_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_qos_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// GBR-QoSFlowInformation ::= SEQUENCE
SRSASN_CODE gbr_qos_flow_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(max_packet_loss_rate_dl_present, 1));
  HANDLE_CODE(bref.pack(max_packet_loss_rate_ul_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, max_flow_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, max_flow_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (max_packet_loss_rate_dl_present) {
    HANDLE_CODE(pack_integer(bref, max_packet_loss_rate_dl, (uint16_t)0u, (uint16_t)1000u, false, true));
  }
  if (max_packet_loss_rate_ul_present) {
    HANDLE_CODE(pack_integer(bref, max_packet_loss_rate_ul, (uint16_t)0u, (uint16_t)1000u, false, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gbr_qos_flow_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(max_packet_loss_rate_dl_present, 1));
  HANDLE_CODE(bref.unpack(max_packet_loss_rate_ul_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(max_flow_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(max_flow_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (max_packet_loss_rate_dl_present) {
    HANDLE_CODE(unpack_integer(max_packet_loss_rate_dl, bref, (uint16_t)0u, (uint16_t)1000u, false, true));
  }
  if (max_packet_loss_rate_ul_present) {
    HANDLE_CODE(unpack_integer(max_packet_loss_rate_ul, bref, (uint16_t)0u, (uint16_t)1000u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void gbr_qos_flow_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("maxFlowBitRateDownlink", max_flow_bit_rate_dl);
  j.write_int("maxFlowBitRateUplink", max_flow_bit_rate_ul);
  j.write_int("guaranteedFlowBitRateDownlink", guaranteed_flow_bit_rate_dl);
  j.write_int("guaranteedFlowBitRateUplink", guaranteed_flow_bit_rate_ul);
  if (max_packet_loss_rate_dl_present) {
    j.write_int("maxPacketLossRateDownlink", max_packet_loss_rate_dl);
  }
  if (max_packet_loss_rate_ul_present) {
    j.write_int("maxPacketLossRateUplink", max_packet_loss_rate_ul);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// GBR-QosInformation ::= SEQUENCE
SRSASN_CODE gbr_qos_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, erab_max_bitrate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, erab_max_bitrate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, erab_guaranteed_bitrate_dl, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, erab_guaranteed_bitrate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gbr_qos_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(erab_max_bitrate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(erab_max_bitrate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(erab_guaranteed_bitrate_dl, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(erab_guaranteed_bitrate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gbr_qos_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("e-RAB-MaximumBitrateDL", erab_max_bitrate_dl);
  j.write_int("e-RAB-MaximumBitrateUL", erab_max_bitrate_ul);
  j.write_int("e-RAB-GuaranteedBitrateDL", erab_guaranteed_bitrate_dl);
  j.write_int("e-RAB-GuaranteedBitrateUL", erab_guaranteed_bitrate_ul);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NGRANAllocationAndRetentionPriority ::= SEQUENCE
SRSASN_CODE ngran_alloc_and_retention_prio_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prio_level, (uint8_t)0u, (uint8_t)15u, false, true));
  HANDLE_CODE(pre_emption_cap.pack(bref));
  HANDLE_CODE(pre_emption_vulnerability.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_alloc_and_retention_prio_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prio_level, bref, (uint8_t)0u, (uint8_t)15u, false, true));
  HANDLE_CODE(pre_emption_cap.unpack(bref));
  HANDLE_CODE(pre_emption_vulnerability.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_alloc_and_retention_prio_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("priorityLevel", prio_level);
  j.write_str("pre-emptionCapability", pre_emption_cap.to_string());
  j.write_str("pre-emptionVulnerability", pre_emption_vulnerability.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QoS-Characteristics ::= CHOICE
void qos_characteristics_c::destroy_()
{
  switch (type_) {
    case types::non_dyn_5qi:
      c.destroy<non_dyn_5qi_descriptor_s>();
      break;
    case types::dyn_5qi:
      c.destroy<dyn_5qi_descriptor_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void qos_characteristics_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::non_dyn_5qi:
      c.init<non_dyn_5qi_descriptor_s>();
      break;
    case types::dyn_5qi:
      c.init<dyn_5qi_descriptor_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }
}
qos_characteristics_c::qos_characteristics_c(const qos_characteristics_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::non_dyn_5qi:
      c.init(other.c.get<non_dyn_5qi_descriptor_s>());
      break;
    case types::dyn_5qi:
      c.init(other.c.get<dyn_5qi_descriptor_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }
}
qos_characteristics_c& qos_characteristics_c::operator=(const qos_characteristics_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::non_dyn_5qi:
      c.set(other.c.get<non_dyn_5qi_descriptor_s>());
      break;
    case types::dyn_5qi:
      c.set(other.c.get<dyn_5qi_descriptor_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }

  return *this;
}
non_dyn_5qi_descriptor_s& qos_characteristics_c::set_non_dyn_5qi()
{
  set(types::non_dyn_5qi);
  return c.get<non_dyn_5qi_descriptor_s>();
}
dyn_5qi_descriptor_s& qos_characteristics_c::set_dyn_5qi()
{
  set(types::dyn_5qi);
  return c.get<dyn_5qi_descriptor_s>();
}
protocol_ie_single_container_s<qos_characteristics_ext_ies_o>& qos_characteristics_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>();
}
void qos_characteristics_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::non_dyn_5qi:
      j.write_fieldname("non-Dynamic-5QI");
      c.get<non_dyn_5qi_descriptor_s>().to_json(j);
      break;
    case types::dyn_5qi:
      j.write_fieldname("dynamic-5QI");
      c.get<dyn_5qi_descriptor_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_characteristics_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::non_dyn_5qi:
      HANDLE_CODE(c.get<non_dyn_5qi_descriptor_s>().pack(bref));
      break;
    case types::dyn_5qi:
      HANDLE_CODE(c.get<dyn_5qi_descriptor_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_characteristics_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::non_dyn_5qi:
      HANDLE_CODE(c.get<non_dyn_5qi_descriptor_s>().unpack(bref));
      break;
    case types::dyn_5qi:
      HANDLE_CODE(c.get<dyn_5qi_descriptor_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<qos_characteristics_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_characteristics_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_characteristics_c::types_opts::to_string() const
{
  static const char* names[] = {"non-Dynamic-5QI", "dynamic-5QI", "choice-extension"};
  return convert_enum_idx(names, 3, value, "qos_characteristics_c::types");
}

// QoSFlowLevelQoSParameters-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t qos_flow_level_qos_params_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {180, 181, 257, 436};
  return map_enum_number(names, 4, idx, "id");
}
bool qos_flow_level_qos_params_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {180, 181, 257, 436};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e qos_flow_level_qos_params_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 180:
      return crit_e::ignore;
    case 181:
      return crit_e::ignore;
    case 257:
      return crit_e::ignore;
    case 436:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
qos_flow_level_qos_params_ext_ies_o::ext_c qos_flow_level_qos_params_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 180:
      ret.set(ext_c::types::pdu_session_id);
      break;
    case 181:
      ret.set(ext_c::types::ul_pdu_session_aggr_max_bit_rate);
      break;
    case 257:
      ret.set(ext_c::types::qos_monitoring_request);
      break;
    case 436:
      ret.set(ext_c::types::pdcp_terminating_node_dl_tnl_addr_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_flow_level_qos_params_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 180:
      return presence_e::optional;
    case 181:
      return presence_e::optional;
    case 257:
      return presence_e::optional;
    case 436:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void qos_flow_level_qos_params_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::pdcp_terminating_node_dl_tnl_addr_info:
      c.destroy<bounded_bitstring<1, 160, true, true>>();
      break;
    default:
      break;
  }
}
void qos_flow_level_qos_params_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pdu_session_id:
      break;
    case types::ul_pdu_session_aggr_max_bit_rate:
      break;
    case types::qos_monitoring_request:
      break;
    case types::pdcp_terminating_node_dl_tnl_addr_info:
      c.init<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
  }
}
qos_flow_level_qos_params_ext_ies_o::ext_c::ext_c(const qos_flow_level_qos_params_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pdu_session_id:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ul_pdu_session_aggr_max_bit_rate:
      c.init(other.c.get<uint64_t>());
      break;
    case types::qos_monitoring_request:
      c.init(other.c.get<qos_monitoring_request_e>());
      break;
    case types::pdcp_terminating_node_dl_tnl_addr_info:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
  }
}
qos_flow_level_qos_params_ext_ies_o::ext_c&
qos_flow_level_qos_params_ext_ies_o::ext_c::operator=(const qos_flow_level_qos_params_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pdu_session_id:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ul_pdu_session_aggr_max_bit_rate:
      c.set(other.c.get<uint64_t>());
      break;
    case types::qos_monitoring_request:
      c.set(other.c.get<qos_monitoring_request_e>());
      break;
    case types::pdcp_terminating_node_dl_tnl_addr_info:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
  }

  return *this;
}
uint16_t& qos_flow_level_qos_params_ext_ies_o::ext_c::pdu_session_id()
{
  assert_choice_type(types::pdu_session_id, type_, "Extension");
  return c.get<uint16_t>();
}
uint64_t& qos_flow_level_qos_params_ext_ies_o::ext_c::ul_pdu_session_aggr_max_bit_rate()
{
  assert_choice_type(types::ul_pdu_session_aggr_max_bit_rate, type_, "Extension");
  return c.get<uint64_t>();
}
qos_monitoring_request_e& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_request()
{
  assert_choice_type(types::qos_monitoring_request, type_, "Extension");
  return c.get<qos_monitoring_request_e>();
}
bounded_bitstring<1, 160, true, true>&
qos_flow_level_qos_params_ext_ies_o::ext_c::pdcp_terminating_node_dl_tnl_addr_info()
{
  assert_choice_type(types::pdcp_terminating_node_dl_tnl_addr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const uint16_t& qos_flow_level_qos_params_ext_ies_o::ext_c::pdu_session_id() const
{
  assert_choice_type(types::pdu_session_id, type_, "Extension");
  return c.get<uint16_t>();
}
const uint64_t& qos_flow_level_qos_params_ext_ies_o::ext_c::ul_pdu_session_aggr_max_bit_rate() const
{
  assert_choice_type(types::ul_pdu_session_aggr_max_bit_rate, type_, "Extension");
  return c.get<uint64_t>();
}
const qos_monitoring_request_e& qos_flow_level_qos_params_ext_ies_o::ext_c::qos_monitoring_request() const
{
  assert_choice_type(types::qos_monitoring_request, type_, "Extension");
  return c.get<qos_monitoring_request_e>();
}
const bounded_bitstring<1, 160, true, true>&
qos_flow_level_qos_params_ext_ies_o::ext_c::pdcp_terminating_node_dl_tnl_addr_info() const
{
  assert_choice_type(types::pdcp_terminating_node_dl_tnl_addr_info, type_, "Extension");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
void qos_flow_level_qos_params_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pdu_session_id:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ul_pdu_session_aggr_max_bit_rate:
      j.write_int("INTEGER (0..4000000000000,...)", c.get<uint64_t>());
      break;
    case types::qos_monitoring_request:
      j.write_str("QosMonitoringRequest", c.get<qos_monitoring_request_e>().to_string());
      break;
    case types::pdcp_terminating_node_dl_tnl_addr_info:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_flow_level_qos_params_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pdu_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ul_pdu_session_aggr_max_bit_rate:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4000000000000u, true, true));
      break;
    case types::qos_monitoring_request:
      HANDLE_CODE(c.get<qos_monitoring_request_e>().pack(bref));
      break;
    case types::pdcp_terminating_node_dl_tnl_addr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_level_qos_params_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pdu_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ul_pdu_session_aggr_max_bit_rate:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
      break;
    case types::qos_monitoring_request:
      HANDLE_CODE(c.get<qos_monitoring_request_e>().unpack(bref));
      break;
    case types::pdcp_terminating_node_dl_tnl_addr_info:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "qos_flow_level_qos_params_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// EUTRANQoS ::= SEQUENCE
SRSASN_CODE eutran_qos_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(gbr_qos_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, qci, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(alloc_and_retention_prio.pack(bref));
  if (gbr_qos_info_present) {
    HANDLE_CODE(gbr_qos_info.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutran_qos_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(gbr_qos_info_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qci, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(alloc_and_retention_prio.unpack(bref));
  if (gbr_qos_info_present) {
    HANDLE_CODE(gbr_qos_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void eutran_qos_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qCI", qci);
  j.write_fieldname("allocationAndRetentionPriority");
  alloc_and_retention_prio.to_json(j);
  if (gbr_qos_info_present) {
    j.write_fieldname("gbrQosInformation");
    gbr_qos_info.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

SRSASN_CODE qos_flow_level_qos_params_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += pdu_session_id_present ? 1 : 0;
  nof_ies += ul_pdu_session_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += qos_monitoring_request_present ? 1 : 0;
  nof_ies += pdcp_terminating_node_dl_tnl_addr_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (pdu_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)180, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, pdu_session_id, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ul_pdu_session_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)181, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(
        pack_integer(bref, ul_pdu_session_aggr_max_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  }
  if (qos_monitoring_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)257, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(qos_monitoring_request.pack(bref));
  }
  if (pdcp_terminating_node_dl_tnl_addr_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)436, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pdcp_terminating_node_dl_tnl_addr_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_level_qos_params_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 180: {
        pdu_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(pdu_session_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 181: {
        ul_pdu_session_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(
            unpack_integer(ul_pdu_session_aggr_max_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
        break;
      }
      case 257: {
        qos_monitoring_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qos_monitoring_request.unpack(bref));
        break;
      }
      case 436: {
        pdcp_terminating_node_dl_tnl_addr_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdcp_terminating_node_dl_tnl_addr_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void qos_flow_level_qos_params_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (pdu_session_id_present) {
    j.write_int("id", 180);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", pdu_session_id);
  }
  if (ul_pdu_session_aggr_max_bit_rate_present) {
    j.write_int("id", 181);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", ul_pdu_session_aggr_max_bit_rate);
  }
  if (qos_monitoring_request_present) {
    j.write_int("id", 257);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", qos_monitoring_request.to_string());
  }
  if (pdcp_terminating_node_dl_tnl_addr_info_present) {
    j.write_int("id", 436);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", pdcp_terminating_node_dl_tnl_addr_info.to_string());
  }
  j.end_obj();
}

// QoSFlowLevelQoSParameters ::= SEQUENCE
SRSASN_CODE qos_flow_level_qos_params_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.pack(reflective_qos_attribute_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(qos_characteristics.pack(bref));
  HANDLE_CODE(ngra_nalloc_retention_prio.pack(bref));
  if (gbr_qos_flow_info_present) {
    HANDLE_CODE(gbr_qos_flow_info.pack(bref));
  }
  if (reflective_qos_attribute_present) {
    HANDLE_CODE(reflective_qos_attribute.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_flow_level_qos_params_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(gbr_qos_flow_info_present, 1));
  HANDLE_CODE(bref.unpack(reflective_qos_attribute_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(qos_characteristics.unpack(bref));
  HANDLE_CODE(ngra_nalloc_retention_prio.unpack(bref));
  if (gbr_qos_flow_info_present) {
    HANDLE_CODE(gbr_qos_flow_info.unpack(bref));
  }
  if (reflective_qos_attribute_present) {
    HANDLE_CODE(reflective_qos_attribute.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qos_flow_level_qos_params_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("qoS-Characteristics");
  qos_characteristics.to_json(j);
  j.write_fieldname("nGRANallocationRetentionPriority");
  ngra_nalloc_retention_prio.to_json(j);
  if (gbr_qos_flow_info_present) {
    j.write_fieldname("gBR-QoS-Flow-Information");
    gbr_qos_flow_info.to_json(j);
  }
  if (reflective_qos_attribute_present) {
    j.write_str("reflective-QoS-Attribute", "subject-to");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* qos_flow_level_qos_params_s::reflective_qos_attribute_opts::to_string() const
{
  static const char* names[] = {"subject-to"};
  return convert_enum_idx(names, 1, value, "qos_flow_level_qos_params_s::reflective_qos_attribute_e_");
}

// BAPCtrlPDUChannel ::= ENUMERATED
const char* bap_ctrl_pdu_ch_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "bap_ctrl_pdu_ch_e");
}

// BHQoSInformation ::= CHOICE
void bh_qos_info_c::destroy_()
{
  switch (type_) {
    case types::bh_rlc_ch_qos:
      c.destroy<qos_flow_level_qos_params_s>();
      break;
    case types::eutran_bh_rlc_ch_qos:
      c.destroy<eutran_qos_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<bh_qos_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void bh_qos_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::bh_rlc_ch_qos:
      c.init<qos_flow_level_qos_params_s>();
      break;
    case types::eutran_bh_rlc_ch_qos:
      c.init<eutran_qos_s>();
      break;
    case types::cp_traffic_type:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<bh_qos_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bh_qos_info_c");
  }
}
bh_qos_info_c::bh_qos_info_c(const bh_qos_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::bh_rlc_ch_qos:
      c.init(other.c.get<qos_flow_level_qos_params_s>());
      break;
    case types::eutran_bh_rlc_ch_qos:
      c.init(other.c.get<eutran_qos_s>());
      break;
    case types::cp_traffic_type:
      c.init(other.c.get<uint8_t>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<bh_qos_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bh_qos_info_c");
  }
}
bh_qos_info_c& bh_qos_info_c::operator=(const bh_qos_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::bh_rlc_ch_qos:
      c.set(other.c.get<qos_flow_level_qos_params_s>());
      break;
    case types::eutran_bh_rlc_ch_qos:
      c.set(other.c.get<eutran_qos_s>());
      break;
    case types::cp_traffic_type:
      c.set(other.c.get<uint8_t>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<bh_qos_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bh_qos_info_c");
  }

  return *this;
}
qos_flow_level_qos_params_s& bh_qos_info_c::set_bh_rlc_ch_qos()
{
  set(types::bh_rlc_ch_qos);
  return c.get<qos_flow_level_qos_params_s>();
}
eutran_qos_s& bh_qos_info_c::set_eutran_bh_rlc_ch_qos()
{
  set(types::eutran_bh_rlc_ch_qos);
  return c.get<eutran_qos_s>();
}
uint8_t& bh_qos_info_c::set_cp_traffic_type()
{
  set(types::cp_traffic_type);
  return c.get<uint8_t>();
}
protocol_ie_single_container_s<bh_qos_info_ext_ies_o>& bh_qos_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<bh_qos_info_ext_ies_o>>();
}
void bh_qos_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::bh_rlc_ch_qos:
      j.write_fieldname("bHRLCCHQoS");
      c.get<qos_flow_level_qos_params_s>().to_json(j);
      break;
    case types::eutran_bh_rlc_ch_qos:
      j.write_fieldname("eUTRANBHRLCCHQoS");
      c.get<eutran_qos_s>().to_json(j);
      break;
    case types::cp_traffic_type:
      j.write_int("cPTrafficType", c.get<uint8_t>());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<bh_qos_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "bh_qos_info_c");
  }
  j.end_obj();
}
SRSASN_CODE bh_qos_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::bh_rlc_ch_qos:
      HANDLE_CODE(c.get<qos_flow_level_qos_params_s>().pack(bref));
      break;
    case types::eutran_bh_rlc_ch_qos:
      HANDLE_CODE(c.get<eutran_qos_s>().pack(bref));
      break;
    case types::cp_traffic_type:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)1u, (uint8_t)3u, true, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<bh_qos_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "bh_qos_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_qos_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::bh_rlc_ch_qos:
      HANDLE_CODE(c.get<qos_flow_level_qos_params_s>().unpack(bref));
      break;
    case types::eutran_bh_rlc_ch_qos:
      HANDLE_CODE(c.get<eutran_qos_s>().unpack(bref));
      break;
    case types::cp_traffic_type:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)1u, (uint8_t)3u, true, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<bh_qos_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "bh_qos_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* bh_qos_info_c::types_opts::to_string() const
{
  static const char* names[] = {"bHRLCCHQoS", "eUTRANBHRLCCHQoS", "cPTrafficType", "choice-extension"};
  return convert_enum_idx(names, 4, value, "bh_qos_info_c::types");
}

// RLCMode ::= ENUMERATED
const char* rlc_mode_opts::to_string() const
{
  static const char* names[] = {
      "rlc-am", "rlc-um-bidirectional", "rlc-um-unidirectional-ul", "rlc-um-unidirectional-dl"};
  return convert_enum_idx(names, 4, value, "rlc_mode_e");
}

// BHChannels-ToBeModified-Item ::= SEQUENCE
SRSASN_CODE bh_chs_to_be_modified_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(rlc_mode_present, 1));
  HANDLE_CODE(bref.pack(bap_ctrl_pdu_ch_present, 1));
  HANDLE_CODE(bref.pack(traffic_map_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  HANDLE_CODE(bh_qos_info.pack(bref));
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.pack(bref));
  }
  if (bap_ctrl_pdu_ch_present) {
    HANDLE_CODE(bap_ctrl_pdu_ch.pack(bref));
  }
  if (traffic_map_info_present) {
    HANDLE_CODE(traffic_map_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_chs_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(rlc_mode_present, 1));
  HANDLE_CODE(bref.unpack(bap_ctrl_pdu_ch_present, 1));
  HANDLE_CODE(bref.unpack(traffic_map_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  HANDLE_CODE(bh_qos_info.unpack(bref));
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.unpack(bref));
  }
  if (bap_ctrl_pdu_ch_present) {
    HANDLE_CODE(bap_ctrl_pdu_ch.unpack(bref));
  }
  if (traffic_map_info_present) {
    HANDLE_CODE(traffic_map_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_chs_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bHRLCChannelID", bh_rlc_ch_id.to_string());
  j.write_fieldname("bHQoSInformation");
  bh_qos_info.to_json(j);
  if (rlc_mode_present) {
    j.write_str("rLCmode", rlc_mode.to_string());
  }
  if (bap_ctrl_pdu_ch_present) {
    j.write_str("bAPCtrlPDUChannel", "true");
  }
  if (traffic_map_info_present) {
    j.write_fieldname("trafficMappingInfo");
    traffic_map_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BHChannels-ToBeReleased-Item ::= SEQUENCE
SRSASN_CODE bh_chs_to_be_released_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_chs_to_be_released_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_chs_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bHRLCChannelID", bh_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BHChannels-ToBeSetup-Item ::= SEQUENCE
SRSASN_CODE bh_chs_to_be_setup_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(bap_ctrl_pdu_ch_present, 1));
  HANDLE_CODE(bref.pack(traffic_map_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  HANDLE_CODE(bh_qos_info.pack(bref));
  HANDLE_CODE(rlc_mode.pack(bref));
  if (bap_ctrl_pdu_ch_present) {
    HANDLE_CODE(bap_ctrl_pdu_ch.pack(bref));
  }
  if (traffic_map_info_present) {
    HANDLE_CODE(traffic_map_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_chs_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(bap_ctrl_pdu_ch_present, 1));
  HANDLE_CODE(bref.unpack(traffic_map_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  HANDLE_CODE(bh_qos_info.unpack(bref));
  HANDLE_CODE(rlc_mode.unpack(bref));
  if (bap_ctrl_pdu_ch_present) {
    HANDLE_CODE(bap_ctrl_pdu_ch.unpack(bref));
  }
  if (traffic_map_info_present) {
    HANDLE_CODE(traffic_map_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_chs_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bHRLCChannelID", bh_rlc_ch_id.to_string());
  j.write_fieldname("bHQoSInformation");
  bh_qos_info.to_json(j);
  j.write_str("rLCmode", rlc_mode.to_string());
  if (bap_ctrl_pdu_ch_present) {
    j.write_str("bAPCtrlPDUChannel", "true");
  }
  if (traffic_map_info_present) {
    j.write_fieldname("trafficMappingInfo");
    traffic_map_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BHChannels-ToBeSetupMod-Item ::= SEQUENCE
SRSASN_CODE bh_chs_to_be_setup_mod_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(bap_ctrl_pdu_ch_present, 1));
  HANDLE_CODE(bref.pack(traffic_map_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  HANDLE_CODE(bh_qos_info.pack(bref));
  HANDLE_CODE(rlc_mode.pack(bref));
  if (bap_ctrl_pdu_ch_present) {
    HANDLE_CODE(bap_ctrl_pdu_ch.pack(bref));
  }
  if (traffic_map_info_present) {
    HANDLE_CODE(traffic_map_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_chs_to_be_setup_mod_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(bap_ctrl_pdu_ch_present, 1));
  HANDLE_CODE(bref.unpack(traffic_map_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  HANDLE_CODE(bh_qos_info.unpack(bref));
  HANDLE_CODE(rlc_mode.unpack(bref));
  if (bap_ctrl_pdu_ch_present) {
    HANDLE_CODE(bap_ctrl_pdu_ch.unpack(bref));
  }
  if (traffic_map_info_present) {
    HANDLE_CODE(traffic_map_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_chs_to_be_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bHRLCChannelID", bh_rlc_ch_id.to_string());
  j.write_fieldname("bHQoSInformation");
  bh_qos_info.to_json(j);
  j.write_str("rLCmode", rlc_mode.to_string());
  if (bap_ctrl_pdu_ch_present) {
    j.write_str("bAPCtrlPDUChannel", "true");
  }
  if (traffic_map_info_present) {
    j.write_fieldname("trafficMappingInfo");
    traffic_map_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BHRLCCHItem ::= SEQUENCE
SRSASN_CODE bh_rlc_ch_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bh_rlc_ch_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(bh_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bh_rlc_ch_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("bHRLCChannelID", bh_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastPNI-NPN-ID-List-Item ::= SEQUENCE
SRSASN_CODE broadcast_pni_npn_id_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_cag_list, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_pni_npn_id_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(broadcast_cag_list, bref, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_pni_npn_id_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  j.start_array("broadcastCAGList");
  for (const auto& e1 : broadcast_cag_list) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastSNPN-ID-List-Item ::= SEQUENCE
SRSASN_CODE broadcast_sn_pn_id_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_n_id_list, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_sn_pn_id_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(broadcast_n_id_list, bref, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_sn_pn_id_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  j.start_array("broadcastNIDList");
  for (const auto& e1 : broadcast_n_id_list) {
    j.write_str(e1.to_string());
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NPN-Broadcast-Information-PNI-NPN ::= SEQUENCE
SRSASN_CODE npn_broadcast_info_pni_npn_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_pni_npn_id_info, 1, 12, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_broadcast_info_pni_npn_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(broadcast_pni_npn_id_info, bref, 1, 12, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void npn_broadcast_info_pni_npn_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("broadcastPNI-NPN-ID-Information");
  for (const auto& e1 : broadcast_pni_npn_id_info) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// NPN-Broadcast-Information-SNPN ::= SEQUENCE
SRSASN_CODE npn_broadcast_info_sn_pn_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_sn_pn_id_list, 1, 12, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_broadcast_info_sn_pn_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(broadcast_sn_pn_id_list, bref, 1, 12, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void npn_broadcast_info_sn_pn_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("broadcastSNPNID-List");
  for (const auto& e1 : broadcast_sn_pn_id_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// ConfiguredTACIndication ::= ENUMERATED
const char* cfg_tac_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "cfg_tac_ind_e");
}

// ExtendedAvailablePLMN-Item ::= SEQUENCE
SRSASN_CODE extended_available_plmn_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_available_plmn_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void extended_available_plmn_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NPNBroadcastInformation ::= CHOICE
void npn_broadcast_info_c::destroy_()
{
  switch (type_) {
    case types::sn_pn_broadcast_info:
      c.destroy<npn_broadcast_info_sn_pn_s>();
      break;
    case types::pni_npn_broadcast_info:
      c.destroy<npn_broadcast_info_pni_npn_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_broadcast_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::sn_pn_broadcast_info:
      c.init<npn_broadcast_info_sn_pn_s>();
      break;
    case types::pni_npn_broadcast_info:
      c.init<npn_broadcast_info_pni_npn_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_broadcast_info_c");
  }
}
npn_broadcast_info_c::npn_broadcast_info_c(const npn_broadcast_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::sn_pn_broadcast_info:
      c.init(other.c.get<npn_broadcast_info_sn_pn_s>());
      break;
    case types::pni_npn_broadcast_info:
      c.init(other.c.get<npn_broadcast_info_pni_npn_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_broadcast_info_c");
  }
}
npn_broadcast_info_c& npn_broadcast_info_c::operator=(const npn_broadcast_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::sn_pn_broadcast_info:
      c.set(other.c.get<npn_broadcast_info_sn_pn_s>());
      break;
    case types::pni_npn_broadcast_info:
      c.set(other.c.get<npn_broadcast_info_pni_npn_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_broadcast_info_c");
  }

  return *this;
}
npn_broadcast_info_sn_pn_s& npn_broadcast_info_c::set_sn_pn_broadcast_info()
{
  set(types::sn_pn_broadcast_info);
  return c.get<npn_broadcast_info_sn_pn_s>();
}
npn_broadcast_info_pni_npn_s& npn_broadcast_info_c::set_pni_npn_broadcast_info()
{
  set(types::pni_npn_broadcast_info);
  return c.get<npn_broadcast_info_pni_npn_s>();
}
protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>& npn_broadcast_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>();
}
void npn_broadcast_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::sn_pn_broadcast_info:
      j.write_fieldname("sNPN-Broadcast-Information");
      c.get<npn_broadcast_info_sn_pn_s>().to_json(j);
      break;
    case types::pni_npn_broadcast_info:
      j.write_fieldname("pNI-NPN-Broadcast-Information");
      c.get<npn_broadcast_info_pni_npn_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_broadcast_info_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_broadcast_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::sn_pn_broadcast_info:
      HANDLE_CODE(c.get<npn_broadcast_info_sn_pn_s>().pack(bref));
      break;
    case types::pni_npn_broadcast_info:
      HANDLE_CODE(c.get<npn_broadcast_info_pni_npn_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_broadcast_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_broadcast_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::sn_pn_broadcast_info:
      HANDLE_CODE(c.get<npn_broadcast_info_sn_pn_s>().unpack(bref));
      break;
    case types::pni_npn_broadcast_info:
      HANDLE_CODE(c.get<npn_broadcast_info_pni_npn_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_broadcast_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_broadcast_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_broadcast_info_c::types_opts::to_string() const
{
  static const char* names[] = {"sNPN-Broadcast-Information", "pNI-NPN-Broadcast-Information", "choice-extension"};
  return convert_enum_idx(names, 3, value, "npn_broadcast_info_c::types");
}

// BPLMN-ID-Info-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t bplmn_id_info_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {425, 383};
  return map_enum_number(names, 2, idx, "id");
}
bool bplmn_id_info_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {425, 383};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e bplmn_id_info_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 425:
      return crit_e::ignore;
    case 383:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
bplmn_id_info_item_ext_ies_o::ext_c bplmn_id_info_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 425:
      ret.set(ext_c::types::cfg_tac_ind);
      break;
    case 383:
      ret.set(ext_c::types::npn_broadcast_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e bplmn_id_info_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 425:
      return presence_e::optional;
    case 383:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void bplmn_id_info_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::npn_broadcast_info:
      c.destroy<npn_broadcast_info_c>();
      break;
    default:
      break;
  }
}
void bplmn_id_info_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cfg_tac_ind:
      break;
    case types::npn_broadcast_info:
      c.init<npn_broadcast_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bplmn_id_info_item_ext_ies_o::ext_c");
  }
}
bplmn_id_info_item_ext_ies_o::ext_c::ext_c(const bplmn_id_info_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cfg_tac_ind:
      c.init(other.c.get<cfg_tac_ind_e>());
      break;
    case types::npn_broadcast_info:
      c.init(other.c.get<npn_broadcast_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bplmn_id_info_item_ext_ies_o::ext_c");
  }
}
bplmn_id_info_item_ext_ies_o::ext_c&
bplmn_id_info_item_ext_ies_o::ext_c::operator=(const bplmn_id_info_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cfg_tac_ind:
      c.set(other.c.get<cfg_tac_ind_e>());
      break;
    case types::npn_broadcast_info:
      c.set(other.c.get<npn_broadcast_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bplmn_id_info_item_ext_ies_o::ext_c");
  }

  return *this;
}
cfg_tac_ind_e& bplmn_id_info_item_ext_ies_o::ext_c::cfg_tac_ind()
{
  assert_choice_type(types::cfg_tac_ind, type_, "Extension");
  return c.get<cfg_tac_ind_e>();
}
npn_broadcast_info_c& bplmn_id_info_item_ext_ies_o::ext_c::npn_broadcast_info()
{
  assert_choice_type(types::npn_broadcast_info, type_, "Extension");
  return c.get<npn_broadcast_info_c>();
}
const cfg_tac_ind_e& bplmn_id_info_item_ext_ies_o::ext_c::cfg_tac_ind() const
{
  assert_choice_type(types::cfg_tac_ind, type_, "Extension");
  return c.get<cfg_tac_ind_e>();
}
const npn_broadcast_info_c& bplmn_id_info_item_ext_ies_o::ext_c::npn_broadcast_info() const
{
  assert_choice_type(types::npn_broadcast_info, type_, "Extension");
  return c.get<npn_broadcast_info_c>();
}
void bplmn_id_info_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cfg_tac_ind:
      j.write_str("ConfiguredTACIndication", "true");
      break;
    case types::npn_broadcast_info:
      j.write_fieldname("NPNBroadcastInformation");
      c.get<npn_broadcast_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "bplmn_id_info_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE bplmn_id_info_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cfg_tac_ind:
      HANDLE_CODE(c.get<cfg_tac_ind_e>().pack(bref));
      break;
    case types::npn_broadcast_info:
      HANDLE_CODE(c.get<npn_broadcast_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "bplmn_id_info_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE bplmn_id_info_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cfg_tac_ind:
      HANDLE_CODE(c.get<cfg_tac_ind_e>().unpack(bref));
      break;
    case types::npn_broadcast_info:
      HANDLE_CODE(c.get<npn_broadcast_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "bplmn_id_info_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE bplmn_id_info_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += cfg_tac_ind_present ? 1 : 0;
  nof_ies += npn_broadcast_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (cfg_tac_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)425, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cfg_tac_ind.pack(bref));
  }
  if (npn_broadcast_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)383, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_broadcast_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bplmn_id_info_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 425: {
        cfg_tac_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cfg_tac_ind.unpack(bref));
        break;
      }
      case 383: {
        npn_broadcast_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_broadcast_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void bplmn_id_info_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (cfg_tac_ind_present) {
    j.write_int("id", 425);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (npn_broadcast_info_present) {
    j.write_int("id", 383);
    j.write_str("criticality", "reject");
    npn_broadcast_info.to_json(j);
  }
  j.end_obj();
}

// BPLMN-ID-Info-Item ::= SEQUENCE
SRSASN_CODE bplmn_id_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(extended_plmn_id_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(five_gs_tac_present, 1));
  HANDLE_CODE(bref.pack(ranac_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, plmn_id_list, 1, 6, true));
  if (extended_plmn_id_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, extended_plmn_id_list, 1, 6, true));
  }
  if (five_gs_tac_present) {
    HANDLE_CODE(five_gs_tac.pack(bref));
  }
  HANDLE_CODE(nr_cell_id.pack(bref));
  if (ranac_present) {
    HANDLE_CODE(pack_integer(bref, ranac, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE bplmn_id_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool extended_plmn_id_list_present;
  HANDLE_CODE(bref.unpack(extended_plmn_id_list_present, 1));
  HANDLE_CODE(bref.unpack(five_gs_tac_present, 1));
  HANDLE_CODE(bref.unpack(ranac_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(plmn_id_list, bref, 1, 6, true));
  if (extended_plmn_id_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(extended_plmn_id_list, bref, 1, 6, true));
  }
  if (five_gs_tac_present) {
    HANDLE_CODE(five_gs_tac.unpack(bref));
  }
  HANDLE_CODE(nr_cell_id.unpack(bref));
  if (ranac_present) {
    HANDLE_CODE(unpack_integer(ranac, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void bplmn_id_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("pLMN-Identity-List");
  for (const auto& e1 : plmn_id_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (extended_plmn_id_list.size() > 0) {
    j.start_array("extended-PLMN-Identity-List");
    for (const auto& e1 : extended_plmn_id_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (five_gs_tac_present) {
    j.write_str("fiveGS-TAC", five_gs_tac.to_string());
  }
  j.write_str("nr-cell-ID", nr_cell_id.to_string());
  if (ranac_present) {
    j.write_int("ranac", ranac);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FR1-Bandwidth ::= ENUMERATED
const char* fr1_bw_opts::to_string() const
{
  static const char* names[] = {"bw5", "bw10", "bw20", "bw40", "bw50", "bw80", "bw100"};
  return convert_enum_idx(names, 7, value, "fr1_bw_e");
}
uint8_t fr1_bw_opts::to_number() const
{
  static const uint8_t numbers[] = {5, 10, 20, 40, 50, 80, 100};
  return map_enum_number(numbers, 7, value, "fr1_bw_e");
}

// FR2-Bandwidth ::= ENUMERATED
const char* fr2_bw_opts::to_string() const
{
  static const char* names[] = {"bw50", "bw100", "bw200", "bw400", "bw800", "bw1600", "bw2000"};
  return convert_enum_idx(names, 7, value, "fr2_bw_e");
}
uint16_t fr2_bw_opts::to_number() const
{
  static const uint16_t numbers[] = {50, 100, 200, 400, 800, 1600, 2000};
  return map_enum_number(numbers, 7, value, "fr2_bw_e");
}

// BandwidthSRS ::= CHOICE
void bw_srs_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<bw_srs_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void bw_srs_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::fr1:
      break;
    case types::fr2:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<bw_srs_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bw_srs_c");
  }
}
bw_srs_c::bw_srs_c(const bw_srs_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::fr1:
      c.init(other.c.get<fr1_bw_e>());
      break;
    case types::fr2:
      c.init(other.c.get<fr2_bw_e>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<bw_srs_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bw_srs_c");
  }
}
bw_srs_c& bw_srs_c::operator=(const bw_srs_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::fr1:
      c.set(other.c.get<fr1_bw_e>());
      break;
    case types::fr2:
      c.set(other.c.get<fr2_bw_e>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<bw_srs_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "bw_srs_c");
  }

  return *this;
}
fr1_bw_e& bw_srs_c::set_fr1()
{
  set(types::fr1);
  return c.get<fr1_bw_e>();
}
fr2_bw_e& bw_srs_c::set_fr2()
{
  set(types::fr2);
  return c.get<fr2_bw_e>();
}
protocol_ie_single_container_s<bw_srs_ext_ies_o>& bw_srs_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<bw_srs_ext_ies_o>>();
}
void bw_srs_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::fr1:
      j.write_str("fR1", c.get<fr1_bw_e>().to_string());
      break;
    case types::fr2:
      j.write_str("fR2", c.get<fr2_bw_e>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<bw_srs_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "bw_srs_c");
  }
  j.end_obj();
}
SRSASN_CODE bw_srs_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::fr1:
      HANDLE_CODE(c.get<fr1_bw_e>().pack(bref));
      break;
    case types::fr2:
      HANDLE_CODE(c.get<fr2_bw_e>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<bw_srs_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "bw_srs_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE bw_srs_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::fr1:
      HANDLE_CODE(c.get<fr1_bw_e>().unpack(bref));
      break;
    case types::fr2:
      HANDLE_CODE(c.get<fr2_bw_e>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<bw_srs_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "bw_srs_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* bw_srs_c::types_opts::to_string() const
{
  static const char* names[] = {"fR1", "fR2", "choice-extension"};
  return convert_enum_idx(names, 3, value, "bw_srs_c::types");
}
uint8_t bw_srs_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2};
  return map_enum_number(numbers, 2, value, "bw_srs_c::types");
}

// Broadcast-Cell-List-Item ::= SEQUENCE
SRSASN_CODE broadcast_cell_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_cell_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_cell_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cellID");
  cell_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Broadcast-To-Be-Cancelled-Item ::= SEQUENCE
SRSASN_CODE broadcast_to_be_cancelled_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_to_be_cancelled_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_to_be_cancelled_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PartialSuccessCell ::= SEQUENCE
SRSASN_CODE partial_success_cell_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, broadcast_cell_list, 1, 512, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE partial_success_cell_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(broadcast_cell_list, bref, 1, 512, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void partial_success_cell_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("broadcastCellList");
  for (const auto& e1 : broadcast_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastAreaScope ::= CHOICE
void broadcast_area_scope_c::destroy_()
{
  switch (type_) {
    case types::partial_success:
      c.destroy<partial_success_cell_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void broadcast_area_scope_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::complete_success:
      break;
    case types::partial_success:
      c.init<partial_success_cell_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_area_scope_c");
  }
}
broadcast_area_scope_c::broadcast_area_scope_c(const broadcast_area_scope_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::complete_success:
      break;
    case types::partial_success:
      c.init(other.c.get<partial_success_cell_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_area_scope_c");
  }
}
broadcast_area_scope_c& broadcast_area_scope_c::operator=(const broadcast_area_scope_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::complete_success:
      break;
    case types::partial_success:
      c.set(other.c.get<partial_success_cell_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_area_scope_c");
  }

  return *this;
}
void broadcast_area_scope_c::set_complete_success()
{
  set(types::complete_success);
}
partial_success_cell_s& broadcast_area_scope_c::set_partial_success()
{
  set(types::partial_success);
  return c.get<partial_success_cell_s>();
}
protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>& broadcast_area_scope_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>>();
}
void broadcast_area_scope_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::complete_success:
      break;
    case types::partial_success:
      j.write_fieldname("partialSuccess");
      c.get<partial_success_cell_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_area_scope_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_area_scope_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::complete_success:
      break;
    case types::partial_success:
      HANDLE_CODE(c.get<partial_success_cell_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_area_scope_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_area_scope_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::complete_success:
      break;
    case types::partial_success:
      HANDLE_CODE(c.get<partial_success_cell_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<broadcast_area_scope_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_area_scope_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* broadcast_area_scope_c::types_opts::to_string() const
{
  static const char* names[] = {"completeSuccess", "partialSuccess", "choice-extension"};
  return convert_enum_idx(names, 3, value, "broadcast_area_scope_c::types");
}

// MBS-ServiceAreaTAIList-Item ::= SEQUENCE
SRSASN_CODE mbs_service_area_tai_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(five5_tac.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_tai_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(five5_tac.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_service_area_tai_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("plmn-ID", plmn_id.to_string());
  j.write_str("five5-TAC", five5_tac.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-Flows-Mapped-To-MRB-Item ::= SEQUENCE
SRSASN_CODE mbs_flows_mapped_to_mrb_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_qos_flow_id, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(mbs_qos_flow_level_qos_params.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_flows_mapped_to_mrb_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(mbs_qos_flow_level_qos_params.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_flows_mapped_to_mrb_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-QoSFlowIdentifier", mbs_qos_flow_id);
  j.write_fieldname("mbs-QoSFlowLevelQoSParameters");
  mbs_qos_flow_level_qos_params.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-ServiceAreaInformation ::= SEQUENCE
SRSASN_CODE mbs_service_area_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_service_area_cell_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(mbs_service_area_tai_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mbs_service_area_cell_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_service_area_cell_list, 1, 512, true));
  }
  if (mbs_service_area_tai_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_service_area_tai_list, 1, 512, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool mbs_service_area_cell_list_present;
  HANDLE_CODE(bref.unpack(mbs_service_area_cell_list_present, 1));
  bool mbs_service_area_tai_list_present;
  HANDLE_CODE(bref.unpack(mbs_service_area_tai_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mbs_service_area_cell_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_service_area_cell_list, bref, 1, 512, true));
  }
  if (mbs_service_area_tai_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_service_area_tai_list, bref, 1, 512, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_service_area_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mbs_service_area_cell_list.size() > 0) {
    j.start_array("mBS-ServiceAreaCellList");
    for (const auto& e1 : mbs_service_area_cell_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mbs_service_area_tai_list.size() > 0) {
    j.start_array("mBS-ServiceAreaTAIList");
    for (const auto& e1 : mbs_service_area_tai_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastMRBs-ToBeModified-Item ::= SEQUENCE
SRSASN_CODE broadcast_m_rbs_to_be_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mrb_qos_info_present, 1));
  HANDLE_CODE(bref.pack(mbs_flows_mapped_to_mrb_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(bc_bearer_ctxt_f1_u_tnl_infoat_cu_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (mrb_qos_info_present) {
    HANDLE_CODE(mrb_qos_info.pack(bref));
  }
  if (mbs_flows_mapped_to_mrb_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_flows_mapped_to_mrb_list, 1, 64, true));
  }
  if (bc_bearer_ctxt_f1_u_tnl_infoat_cu_present) {
    HANDLE_CODE(bc_bearer_ctxt_f1_u_tnl_infoat_cu.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_m_rbs_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mrb_qos_info_present, 1));
  bool mbs_flows_mapped_to_mrb_list_present;
  HANDLE_CODE(bref.unpack(mbs_flows_mapped_to_mrb_list_present, 1));
  HANDLE_CODE(bref.unpack(bc_bearer_ctxt_f1_u_tnl_infoat_cu_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (mrb_qos_info_present) {
    HANDLE_CODE(mrb_qos_info.unpack(bref));
  }
  if (mbs_flows_mapped_to_mrb_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_flows_mapped_to_mrb_list, bref, 1, 64, true));
  }
  if (bc_bearer_ctxt_f1_u_tnl_infoat_cu_present) {
    HANDLE_CODE(bc_bearer_ctxt_f1_u_tnl_infoat_cu.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_m_rbs_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (mrb_qos_info_present) {
    j.write_fieldname("mRB-QoSInformation");
    mrb_qos_info.to_json(j);
  }
  if (mbs_flows_mapped_to_mrb_list.size() > 0) {
    j.start_array("mBS-Flows-Mapped-To-MRB-List");
    for (const auto& e1 : mbs_flows_mapped_to_mrb_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (bc_bearer_ctxt_f1_u_tnl_infoat_cu_present) {
    j.write_fieldname("bcBearerCtxtF1U-TNLInfoatCU");
    bc_bearer_ctxt_f1_u_tnl_infoat_cu.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastMRBs-ToBeReleased-Item ::= SEQUENCE
SRSASN_CODE broadcast_m_rbs_to_be_released_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_m_rbs_to_be_released_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_m_rbs_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastMRBs-ToBeSetupMod-Item ::= SEQUENCE
SRSASN_CODE broadcast_m_rbs_to_be_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mrb_qos_info.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_flows_mapped_to_mrb_list, 1, 64, true));
  HANDLE_CODE(bc_bearer_ctxt_f1_u_tnl_infoat_cu.pack(bref));
  HANDLE_CODE(ie_exts.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_m_rbs_to_be_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mrb_qos_info.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(mbs_flows_mapped_to_mrb_list, bref, 1, 64, true));
  HANDLE_CODE(bc_bearer_ctxt_f1_u_tnl_infoat_cu.unpack(bref));
  HANDLE_CODE(ie_exts.unpack(bref));

  return SRSASN_SUCCESS;
}
void broadcast_m_rbs_to_be_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.write_fieldname("mRB-QoSInformation");
  mrb_qos_info.to_json(j);
  j.start_array("mBS-Flows-Mapped-To-MRB-List");
  for (const auto& e1 : mbs_flows_mapped_to_mrb_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_fieldname("bcBearerCtxtF1U-TNLInfoatCU");
  bc_bearer_ctxt_f1_u_tnl_infoat_cu.to_json(j);
  j.write_fieldname("iE-Extensions");
  ie_exts.to_json(j);
  j.end_obj();
}

// MBS-Broadcast-Cell-Item ::= SEQUENCE
SRSASN_CODE mbs_broadcast_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mtch_neighbour_cell.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (mtch_neighbour_cell.size() > 0) {
    HANDLE_CODE(mtch_neighbour_cell.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_broadcast_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool mtch_neighbour_cell_present;
  HANDLE_CODE(bref.unpack(mtch_neighbour_cell_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (mtch_neighbour_cell_present) {
    HANDLE_CODE(mtch_neighbour_cell.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_broadcast_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (mtch_neighbour_cell.size() > 0) {
    j.write_str("mtch-neighbourCell", mtch_neighbour_cell.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-Broadcast-MRB-Item ::= SEQUENCE
SRSASN_CODE mbs_broadcast_mrb_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mrb_pdcp_cfg_broadcast.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_broadcast_mrb_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mrb_pdcp_cfg_broadcast.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_broadcast_mrb_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.write_str("mRB-PDCP-Config-Broadcast", mrb_pdcp_cfg_broadcast.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-ServiceAreaInformationItem ::= SEQUENCE
SRSASN_CODE mbs_service_area_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(mbs_service_area_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(mbs_service_area_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_service_area_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mBS-AreaSessionID", mbs_area_session_id);
  j.write_fieldname("mBS-ServiceAreaInformation");
  mbs_service_area_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-CUtoDURRCInformation ::= SEQUENCE
SRSASN_CODE mbs_cu_to_du_rrc_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_broadcast_cell_list, 1, 512, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_broadcast_mrb_list, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_cu_to_du_rrc_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(mbs_broadcast_cell_list, bref, 1, 512, true));
  HANDLE_CODE(unpack_dyn_seq_of(mbs_broadcast_mrb_list, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_cu_to_du_rrc_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("mBS-Broadcast-Cell-List");
  for (const auto& e1 : mbs_broadcast_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.start_array("mBS-Broadcast-MRB-List");
  for (const auto& e1 : mbs_broadcast_mrb_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MBS-ServiceArea ::= CHOICE
void mbs_service_area_c::destroy_()
{
  switch (type_) {
    case types::locationindependent:
      c.destroy<mbs_service_area_info_s>();
      break;
    case types::locationdependent:
      c.destroy<mbs_service_area_info_list_l>();
      break;
    case types::choice_exts:
      c.destroy<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mbs_service_area_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::locationindependent:
      c.init<mbs_service_area_info_s>();
      break;
    case types::locationdependent:
      c.init<mbs_service_area_info_list_l>();
      break;
    case types::choice_exts:
      c.init<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }
}
mbs_service_area_c::mbs_service_area_c(const mbs_service_area_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::locationindependent:
      c.init(other.c.get<mbs_service_area_info_s>());
      break;
    case types::locationdependent:
      c.init(other.c.get<mbs_service_area_info_list_l>());
      break;
    case types::choice_exts:
      c.init(other.c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }
}
mbs_service_area_c& mbs_service_area_c::operator=(const mbs_service_area_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::locationindependent:
      c.set(other.c.get<mbs_service_area_info_s>());
      break;
    case types::locationdependent:
      c.set(other.c.get<mbs_service_area_info_list_l>());
      break;
    case types::choice_exts:
      c.set(other.c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }

  return *this;
}
mbs_service_area_info_s& mbs_service_area_c::set_locationindependent()
{
  set(types::locationindependent);
  return c.get<mbs_service_area_info_s>();
}
mbs_service_area_info_list_l& mbs_service_area_c::set_locationdependent()
{
  set(types::locationdependent);
  return c.get<mbs_service_area_info_list_l>();
}
protocol_ie_single_container_s<mbs_service_area_ext_ies_o>& mbs_service_area_c::set_choice_exts()
{
  set(types::choice_exts);
  return c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>();
}
void mbs_service_area_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::locationindependent:
      j.write_fieldname("locationindependent");
      c.get<mbs_service_area_info_s>().to_json(j);
      break;
    case types::locationdependent:
      j.start_array("locationdependent");
      for (const auto& e1 : c.get<mbs_service_area_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_exts:
      j.write_fieldname("choice-Extensions");
      c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
  }
  j.end_obj();
}
SRSASN_CODE mbs_service_area_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<mbs_service_area_info_s>().pack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mbs_service_area_info_list_l>(), 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_service_area_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::locationindependent:
      HANDLE_CODE(c.get<mbs_service_area_info_s>().unpack(bref));
      break;
    case types::locationdependent:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mbs_service_area_info_list_l>(), bref, 1, 256, true));
      break;
    case types::choice_exts:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mbs_service_area_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mbs_service_area_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mbs_service_area_c::types_opts::to_string() const
{
  static const char* names[] = {"locationindependent", "locationdependent", "choice-Extensions"};
  return convert_enum_idx(names, 3, value, "mbs_service_area_c::types");
}

// BroadcastMRBs-FailedToBeModified-Item ::= SEQUENCE
SRSASN_CODE broadcast_m_rbs_failed_to_be_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_m_rbs_failed_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_m_rbs_failed_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastMRBs-FailedToBeSetupMod-Item ::= SEQUENCE
SRSASN_CODE broadcast_m_rbs_failed_to_be_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_m_rbs_failed_to_be_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_m_rbs_failed_to_be_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastMRBs-Modified-Item ::= SEQUENCE
SRSASN_CODE broadcast_m_rbs_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(bc_bearer_ctxt_f1_u_tnl_infoat_du_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (bc_bearer_ctxt_f1_u_tnl_infoat_du_present) {
    HANDLE_CODE(bc_bearer_ctxt_f1_u_tnl_infoat_du.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_m_rbs_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(bc_bearer_ctxt_f1_u_tnl_infoat_du_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (bc_bearer_ctxt_f1_u_tnl_infoat_du_present) {
    HANDLE_CODE(bc_bearer_ctxt_f1_u_tnl_infoat_du.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_m_rbs_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (bc_bearer_ctxt_f1_u_tnl_infoat_du_present) {
    j.write_fieldname("bcBearerCtxtF1U-TNLInfoatDU");
    bc_bearer_ctxt_f1_u_tnl_infoat_du.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastMRBs-SetupMod-Item ::= SEQUENCE
SRSASN_CODE broadcast_m_rbs_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(bc_bearer_ctxt_f1_u_tnl_infoat_du.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_m_rbs_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(bc_bearer_ctxt_f1_u_tnl_infoat_du.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_m_rbs_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.write_fieldname("bcBearerCtxtF1U-TNLInfoatDU");
  bc_bearer_ctxt_f1_u_tnl_infoat_du.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastMRBs-ToBeSetup-Item ::= SEQUENCE
SRSASN_CODE broadcast_m_rbs_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mrb_qos_info.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_flows_mapped_to_mrb_list, 1, 64, true));
  HANDLE_CODE(bc_bearer_ctxt_f1_u_tnl_infoat_cu.pack(bref));
  HANDLE_CODE(ie_exts.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_m_rbs_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mrb_qos_info.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(mbs_flows_mapped_to_mrb_list, bref, 1, 64, true));
  HANDLE_CODE(bc_bearer_ctxt_f1_u_tnl_infoat_cu.unpack(bref));
  HANDLE_CODE(ie_exts.unpack(bref));

  return SRSASN_SUCCESS;
}
void broadcast_m_rbs_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.write_fieldname("mRB-QoSInformation");
  mrb_qos_info.to_json(j);
  j.start_array("mBS-Flows-Mapped-To-MRB-List");
  for (const auto& e1 : mbs_flows_mapped_to_mrb_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_fieldname("bcBearerCtxtF1U-TNLInfoatCU");
  bc_bearer_ctxt_f1_u_tnl_infoat_cu.to_json(j);
  j.write_fieldname("iE-Extensions");
  ie_exts.to_json(j);
  j.end_obj();
}

// MBS-Session-ID ::= SEQUENCE
SRSASN_CODE mbs_session_id_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nid_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tmgi.pack(bref));
  if (nid_present) {
    HANDLE_CODE(nid.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_session_id_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nid_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tmgi.unpack(bref));
  if (nid_present) {
    HANDLE_CODE(nid.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_session_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("tMGI", tmgi.to_string());
  if (nid_present) {
    j.write_str("nID", nid.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SNSSAI ::= SEQUENCE
SRSASN_CODE snssai_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(sd_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sst.pack(bref));
  if (sd_present) {
    HANDLE_CODE(sd.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE snssai_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(sd_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sst.unpack(bref));
  if (sd_present) {
    HANDLE_CODE(sd.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void snssai_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("sST", sst.to_string());
  if (sd_present) {
    j.write_str("sD", sd.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastMRBs-FailedToBeSetup-Item ::= SEQUENCE
SRSASN_CODE broadcast_m_rbs_failed_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_m_rbs_failed_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_m_rbs_failed_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// BroadcastMRBs-Setup-Item ::= SEQUENCE
SRSASN_CODE broadcast_m_rbs_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(bc_bearer_ctxt_f1_u_tnl_infoat_du.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_m_rbs_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(bc_bearer_ctxt_f1_u_tnl_infoat_du.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void broadcast_m_rbs_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.write_fieldname("bcBearerCtxtF1U-TNLInfoatDU");
  bc_bearer_ctxt_f1_u_tnl_infoat_du.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CCO-issue-detection ::= ENUMERATED
const char* cco_issue_detection_opts::to_string() const
{
  static const char* names[] = {"coverage", "cell-edge-capacity"};
  return convert_enum_idx(names, 2, value, "cco_issue_detection_e");
}

// CCO-Assistance-Information ::= SEQUENCE
SRSASN_CODE cco_assist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cco_issue_detection_present, 1));
  HANDLE_CODE(bref.pack(affected_cells_and_beams_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (cco_issue_detection_present) {
    HANDLE_CODE(cco_issue_detection.pack(bref));
  }
  if (affected_cells_and_beams_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, affected_cells_and_beams_list, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cco_assist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cco_issue_detection_present, 1));
  bool affected_cells_and_beams_list_present;
  HANDLE_CODE(bref.unpack(affected_cells_and_beams_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (cco_issue_detection_present) {
    HANDLE_CODE(cco_issue_detection.unpack(bref));
  }
  if (affected_cells_and_beams_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(affected_cells_and_beams_list, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cco_assist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (cco_issue_detection_present) {
    j.write_str("cCO-issue-detection", cco_issue_detection.to_string());
  }
  if (affected_cells_and_beams_list.size() > 0) {
    j.start_array("affectedCellsAndBeams-List");
    for (const auto& e1 : affected_cells_and_beams_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CG-SDTSessionInfo ::= SEQUENCE
SRSASN_CODE cg_sdt_session_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, gnb_cu_ue_f1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  HANDLE_CODE(pack_integer(bref, gnb_du_ue_f1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cg_sdt_session_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(gnb_cu_ue_f1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  HANDLE_CODE(unpack_integer(gnb_du_ue_f1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cg_sdt_session_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("gNB-CU-UE-F1AP-ID", gnb_cu_ue_f1ap_id);
  j.write_int("gNB-DU-UE-F1AP-ID", gnb_du_ue_f1ap_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CNUEPagingIdentity ::= CHOICE
void cn_ue_paging_id_c::destroy_()
{
  switch (type_) {
    case types::five_g_s_tmsi:
      c.destroy<fixed_bitstring<48, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cn_ue_paging_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::five_g_s_tmsi:
      c.init<fixed_bitstring<48, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cn_ue_paging_id_c");
  }
}
cn_ue_paging_id_c::cn_ue_paging_id_c(const cn_ue_paging_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::five_g_s_tmsi:
      c.init(other.c.get<fixed_bitstring<48, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cn_ue_paging_id_c");
  }
}
cn_ue_paging_id_c& cn_ue_paging_id_c::operator=(const cn_ue_paging_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::five_g_s_tmsi:
      c.set(other.c.get<fixed_bitstring<48, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cn_ue_paging_id_c");
  }

  return *this;
}
fixed_bitstring<48, false, true>& cn_ue_paging_id_c::set_five_g_s_tmsi()
{
  set(types::five_g_s_tmsi);
  return c.get<fixed_bitstring<48, false, true>>();
}
protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>& cn_ue_paging_id_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>>();
}
void cn_ue_paging_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::five_g_s_tmsi:
      j.write_str("fiveG-S-TMSI", c.get<fixed_bitstring<48, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cn_ue_paging_id_c");
  }
  j.end_obj();
}
SRSASN_CODE cn_ue_paging_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE((c.get<fixed_bitstring<48, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cn_ue_paging_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cn_ue_paging_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE((c.get<fixed_bitstring<48, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cn_ue_paging_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cn_ue_paging_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cn_ue_paging_id_c::types_opts::to_string() const
{
  static const char* names[] = {"fiveG-S-TMSI", "choice-extension"};
  return convert_enum_idx(names, 2, value, "cn_ue_paging_id_c::types");
}
uint8_t cn_ue_paging_id_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {5};
  return map_enum_number(numbers, 1, value, "cn_ue_paging_id_c::types");
}

// Endpoint-IP-address-and-port-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t endpoint_ip_address_and_port_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {230};
  return map_enum_number(names, 1, idx, "id");
}
bool endpoint_ip_address_and_port_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 230 == id;
}
crit_e endpoint_ip_address_and_port_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 230) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
endpoint_ip_address_and_port_ext_ies_o::ext_c endpoint_ip_address_and_port_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 230) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e endpoint_ip_address_and_port_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 230) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void endpoint_ip_address_and_port_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("BIT STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE endpoint_ip_address_and_port_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE endpoint_ip_address_and_port_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// Endpoint-IP-address-and-port ::= SEQUENCE
SRSASN_CODE endpoint_ip_address_and_port_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(endpoint_ip_address.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE endpoint_ip_address_and_port_s::unpack(cbit_ref& bref)
{
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(endpoint_ip_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void endpoint_ip_address_and_port_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("endpointIPAddress", endpoint_ip_address.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// CP-TransportLayerAddress ::= CHOICE
void cp_transport_layer_address_c::destroy_()
{
  switch (type_) {
    case types::endpoint_ip_address:
      c.destroy<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::endpoint_ip_address_and_port:
      c.destroy<endpoint_ip_address_and_port_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cp_transport_layer_address_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::endpoint_ip_address:
      c.init<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::endpoint_ip_address_and_port:
      c.init<endpoint_ip_address_and_port_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_address_c");
  }
}
cp_transport_layer_address_c::cp_transport_layer_address_c(const cp_transport_layer_address_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::endpoint_ip_address:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::endpoint_ip_address_and_port:
      c.init(other.c.get<endpoint_ip_address_and_port_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_address_c");
  }
}
cp_transport_layer_address_c& cp_transport_layer_address_c::operator=(const cp_transport_layer_address_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::endpoint_ip_address:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::endpoint_ip_address_and_port:
      c.set(other.c.get<endpoint_ip_address_and_port_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_address_c");
  }

  return *this;
}
bounded_bitstring<1, 160, true, true>& cp_transport_layer_address_c::set_endpoint_ip_address()
{
  set(types::endpoint_ip_address);
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
endpoint_ip_address_and_port_s& cp_transport_layer_address_c::set_endpoint_ip_address_and_port()
{
  set(types::endpoint_ip_address_and_port);
  return c.get<endpoint_ip_address_and_port_s>();
}
protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>& cp_transport_layer_address_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>>();
}
void cp_transport_layer_address_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::endpoint_ip_address:
      j.write_str("endpoint-IP-address", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    case types::endpoint_ip_address_and_port:
      j.write_fieldname("endpoint-IP-address-and-port");
      c.get<endpoint_ip_address_and_port_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_address_c");
  }
  j.end_obj();
}
SRSASN_CODE cp_transport_layer_address_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::endpoint_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    case types::endpoint_ip_address_and_port:
      HANDLE_CODE(c.get<endpoint_ip_address_and_port_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_address_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_transport_layer_address_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::endpoint_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    case types::endpoint_ip_address_and_port:
      HANDLE_CODE(c.get<endpoint_ip_address_and_port_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cp_transport_layer_address_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cp_transport_layer_address_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cp_transport_layer_address_c::types_opts::to_string() const
{
  static const char* names[] = {"endpoint-IP-address", "endpoint-IP-address-and-port", "choice-extension"};
  return convert_enum_idx(names, 3, value, "cp_transport_layer_address_c::types");
}

// CPAC-trigger ::= ENUMERATED
const char* cp_ac_trigger_opts::to_string() const
{
  static const char* names[] = {"cpac-preparation", "cpac-executed"};
  return convert_enum_idx(names, 2, value, "cp_ac_trigger_e");
}

// CPACMCGInformation ::= SEQUENCE
SRSASN_CODE cp_acmcg_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cpac_trigger.pack(bref));
  HANDLE_CODE(pscellid.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cp_acmcg_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cpac_trigger.unpack(bref));
  HANDLE_CODE(pscellid.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cp_acmcg_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cpac-trigger", cpac_trigger.to_string());
  j.write_fieldname("pscellid");
  pscellid.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RIMRSDetectionStatus ::= ENUMERATED
const char* rimrs_detection_status_opts::to_string() const
{
  static const char* names[] = {"rs-detected", "rs-disappeared"};
  return convert_enum_idx(names, 2, value, "rimrs_detection_status_e");
}

// CUDURIMInformation ::= SEQUENCE
SRSASN_CODE cu_du_rim_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(victim_gnb_set_id.pack(bref));
  HANDLE_CODE(rimrs_detection_status.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cu_du_rim_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(victim_gnb_set_id.unpack(bref));
  HANDLE_CODE(rimrs_detection_status.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cu_du_rim_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("victimgNBSetID", victim_gnb_set_id.to_string());
  j.write_str("rIMRSDetectionStatus", rimrs_detection_status.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CUDURadioInformationType ::= CHOICE
void cu_du_radio_info_type_c::destroy_()
{
  switch (type_) {
    case types::rim:
      c.destroy<cu_du_rim_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void cu_du_radio_info_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::rim:
      c.init<cu_du_rim_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cu_du_radio_info_type_c");
  }
}
cu_du_radio_info_type_c::cu_du_radio_info_type_c(const cu_du_radio_info_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::rim:
      c.init(other.c.get<cu_du_rim_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cu_du_radio_info_type_c");
  }
}
cu_du_radio_info_type_c& cu_du_radio_info_type_c::operator=(const cu_du_radio_info_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::rim:
      c.set(other.c.get<cu_du_rim_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cu_du_radio_info_type_c");
  }

  return *this;
}
cu_du_rim_info_s& cu_du_radio_info_type_c::set_rim()
{
  set(types::rim);
  return c.get<cu_du_rim_info_s>();
}
protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>& cu_du_radio_info_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>>();
}
void cu_du_radio_info_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::rim:
      j.write_fieldname("rIM");
      c.get<cu_du_rim_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "cu_du_radio_info_type_c");
  }
  j.end_obj();
}
SRSASN_CODE cu_du_radio_info_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::rim:
      HANDLE_CODE(c.get<cu_du_rim_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cu_du_radio_info_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cu_du_radio_info_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::rim:
      HANDLE_CODE(c.get<cu_du_rim_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<cu_du_radio_info_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cu_du_radio_info_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* cu_du_radio_info_type_c::types_opts::to_string() const
{
  static const char* names[] = {"rIM", "choice-extension"};
  return convert_enum_idx(names, 2, value, "cu_du_radio_info_type_c::types");
}

// CUtoDURRCInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t cu_to_du_rrc_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {119, 173, 163, 214, 234, 339, 440, 621, 587, 652, 665, 666, 667, 678};
  return map_enum_number(names, 14, idx, "id");
}
bool cu_to_du_rrc_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {119, 173, 163, 214, 234, 339, 440, 621, 587, 652, 665, 666, 667, 678};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e cu_to_du_rrc_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 119:
      return crit_e::ignore;
    case 173:
      return crit_e::ignore;
    case 163:
      return crit_e::ignore;
    case 214:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 339:
      return crit_e::ignore;
    case 440:
      return crit_e::ignore;
    case 621:
      return crit_e::reject;
    case 587:
      return crit_e::ignore;
    case 652:
      return crit_e::ignore;
    case 665:
      return crit_e::ignore;
    case 666:
      return crit_e::ignore;
    case 667:
      return crit_e::ignore;
    case 678:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
cu_to_du_rrc_info_ext_ies_o::ext_c cu_to_du_rrc_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 119:
      ret.set(ext_c::types::ho_prep_info);
      break;
    case 173:
      ret.set(ext_c::types::cell_group_cfg);
      break;
    case 163:
      ret.set(ext_c::types::meas_timing_cfg);
      break;
    case 214:
      ret.set(ext_c::types::ue_assist_info);
      break;
    case 234:
      ret.set(ext_c::types::cg_cfg);
      break;
    case 339:
      ret.set(ext_c::types::ue_assist_info_eutra);
      break;
    case 440:
      ret.set(ext_c::types::location_meas_info);
      break;
    case 621:
      ret.set(ext_c::types::mu_si_m_gap_cfg);
      break;
    case 587:
      ret.set(ext_c::types::sdt_mac_phy_cg_cfg);
      break;
    case 652:
      ret.set(ext_c::types::mb_si_nterest_ind);
      break;
    case 665:
      ret.set(ext_c::types::need_for_gaps_info_nr);
      break;
    case 666:
      ret.set(ext_c::types::need_for_gap_ncsg_info_nr);
      break;
    case 667:
      ret.set(ext_c::types::need_for_gap_ncsg_info_eutra);
      break;
    case 678:
      ret.set(ext_c::types::cfg_restrict_info_daps);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e cu_to_du_rrc_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 119:
      return presence_e::optional;
    case 173:
      return presence_e::optional;
    case 163:
      return presence_e::optional;
    case 214:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 339:
      return presence_e::optional;
    case 440:
      return presence_e::optional;
    case 621:
      return presence_e::optional;
    case 587:
      return presence_e::optional;
    case 652:
      return presence_e::optional;
    case 665:
      return presence_e::optional;
    case 666:
      return presence_e::optional;
    case 667:
      return presence_e::optional;
    case 678:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void cu_to_du_rrc_info_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::ho_prep_info:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cell_group_cfg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::meas_timing_cfg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_assist_info:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cg_cfg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_assist_info_eutra:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::location_meas_info:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::mu_si_m_gap_cfg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::sdt_mac_phy_cg_cfg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::mb_si_nterest_ind:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::need_for_gaps_info_nr:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::need_for_gap_ncsg_info_nr:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::need_for_gap_ncsg_info_eutra:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cfg_restrict_info_daps:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void cu_to_du_rrc_info_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ho_prep_info:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cell_group_cfg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::meas_timing_cfg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_assist_info:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cg_cfg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_assist_info_eutra:
      c.init<unbounded_octstring<true>>();
      break;
    case types::location_meas_info:
      c.init<unbounded_octstring<true>>();
      break;
    case types::mu_si_m_gap_cfg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::sdt_mac_phy_cg_cfg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::mb_si_nterest_ind:
      c.init<unbounded_octstring<true>>();
      break;
    case types::need_for_gaps_info_nr:
      c.init<unbounded_octstring<true>>();
      break;
    case types::need_for_gap_ncsg_info_nr:
      c.init<unbounded_octstring<true>>();
      break;
    case types::need_for_gap_ncsg_info_eutra:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cfg_restrict_info_daps:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cu_to_du_rrc_info_ext_ies_o::ext_c");
  }
}
cu_to_du_rrc_info_ext_ies_o::ext_c::ext_c(const cu_to_du_rrc_info_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ho_prep_info:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cell_group_cfg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::meas_timing_cfg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_assist_info:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cg_cfg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_assist_info_eutra:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::location_meas_info:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mu_si_m_gap_cfg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sdt_mac_phy_cg_cfg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mb_si_nterest_ind:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::need_for_gaps_info_nr:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::need_for_gap_ncsg_info_nr:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::need_for_gap_ncsg_info_eutra:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cfg_restrict_info_daps:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cu_to_du_rrc_info_ext_ies_o::ext_c");
  }
}
cu_to_du_rrc_info_ext_ies_o::ext_c&
cu_to_du_rrc_info_ext_ies_o::ext_c::operator=(const cu_to_du_rrc_info_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ho_prep_info:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cell_group_cfg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::meas_timing_cfg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_assist_info:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cg_cfg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_assist_info_eutra:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::location_meas_info:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mu_si_m_gap_cfg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sdt_mac_phy_cg_cfg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mb_si_nterest_ind:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::need_for_gaps_info_nr:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::need_for_gap_ncsg_info_nr:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::need_for_gap_ncsg_info_eutra:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cfg_restrict_info_daps:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cu_to_du_rrc_info_ext_ies_o::ext_c");
  }

  return *this;
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::ho_prep_info()
{
  assert_choice_type(types::ho_prep_info, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::cell_group_cfg()
{
  assert_choice_type(types::cell_group_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::meas_timing_cfg()
{
  assert_choice_type(types::meas_timing_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::ue_assist_info()
{
  assert_choice_type(types::ue_assist_info, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::cg_cfg()
{
  assert_choice_type(types::cg_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::ue_assist_info_eutra()
{
  assert_choice_type(types::ue_assist_info_eutra, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::location_meas_info()
{
  assert_choice_type(types::location_meas_info, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::mu_si_m_gap_cfg()
{
  assert_choice_type(types::mu_si_m_gap_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::sdt_mac_phy_cg_cfg()
{
  assert_choice_type(types::sdt_mac_phy_cg_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::mb_si_nterest_ind()
{
  assert_choice_type(types::mb_si_nterest_ind, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::need_for_gaps_info_nr()
{
  assert_choice_type(types::need_for_gaps_info_nr, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::need_for_gap_ncsg_info_nr()
{
  assert_choice_type(types::need_for_gap_ncsg_info_nr, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::need_for_gap_ncsg_info_eutra()
{
  assert_choice_type(types::need_for_gap_ncsg_info_eutra, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::cfg_restrict_info_daps()
{
  assert_choice_type(types::cfg_restrict_info_daps, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::ho_prep_info() const
{
  assert_choice_type(types::ho_prep_info, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::cell_group_cfg() const
{
  assert_choice_type(types::cell_group_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::meas_timing_cfg() const
{
  assert_choice_type(types::meas_timing_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::ue_assist_info() const
{
  assert_choice_type(types::ue_assist_info, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::cg_cfg() const
{
  assert_choice_type(types::cg_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::ue_assist_info_eutra() const
{
  assert_choice_type(types::ue_assist_info_eutra, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::location_meas_info() const
{
  assert_choice_type(types::location_meas_info, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::mu_si_m_gap_cfg() const
{
  assert_choice_type(types::mu_si_m_gap_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::sdt_mac_phy_cg_cfg() const
{
  assert_choice_type(types::sdt_mac_phy_cg_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::mb_si_nterest_ind() const
{
  assert_choice_type(types::mb_si_nterest_ind, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::need_for_gaps_info_nr() const
{
  assert_choice_type(types::need_for_gaps_info_nr, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::need_for_gap_ncsg_info_nr() const
{
  assert_choice_type(types::need_for_gap_ncsg_info_nr, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::need_for_gap_ncsg_info_eutra() const
{
  assert_choice_type(types::need_for_gap_ncsg_info_eutra, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& cu_to_du_rrc_info_ext_ies_o::ext_c::cfg_restrict_info_daps() const
{
  assert_choice_type(types::cfg_restrict_info_daps, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
void cu_to_du_rrc_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ho_prep_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cell_group_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::meas_timing_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_assist_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cg_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_assist_info_eutra:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::location_meas_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::mu_si_m_gap_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::sdt_mac_phy_cg_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::mb_si_nterest_ind:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::need_for_gaps_info_nr:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::need_for_gap_ncsg_info_nr:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::need_for_gap_ncsg_info_eutra:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cfg_restrict_info_daps:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "cu_to_du_rrc_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE cu_to_du_rrc_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ho_prep_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cell_group_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::meas_timing_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_assist_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cg_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_assist_info_eutra:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::location_meas_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::mu_si_m_gap_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::sdt_mac_phy_cg_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::mb_si_nterest_ind:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::need_for_gaps_info_nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::need_for_gap_ncsg_info_nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::need_for_gap_ncsg_info_eutra:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cfg_restrict_info_daps:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cu_to_du_rrc_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cu_to_du_rrc_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ho_prep_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cell_group_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::meas_timing_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_assist_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cg_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_assist_info_eutra:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::location_meas_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::mu_si_m_gap_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::sdt_mac_phy_cg_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::mb_si_nterest_ind:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::need_for_gaps_info_nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::need_for_gap_ncsg_info_nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::need_for_gap_ncsg_info_eutra:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cfg_restrict_info_daps:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cu_to_du_rrc_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE cu_to_du_rrc_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ho_prep_info_present ? 1 : 0;
  nof_ies += cell_group_cfg_present ? 1 : 0;
  nof_ies += meas_timing_cfg_present ? 1 : 0;
  nof_ies += ue_assist_info_present ? 1 : 0;
  nof_ies += cg_cfg_present ? 1 : 0;
  nof_ies += ue_assist_info_eutra_present ? 1 : 0;
  nof_ies += location_meas_info_present ? 1 : 0;
  nof_ies += mu_si_m_gap_cfg_present ? 1 : 0;
  nof_ies += sdt_mac_phy_cg_cfg_present ? 1 : 0;
  nof_ies += mb_si_nterest_ind_present ? 1 : 0;
  nof_ies += need_for_gaps_info_nr_present ? 1 : 0;
  nof_ies += need_for_gap_ncsg_info_nr_present ? 1 : 0;
  nof_ies += need_for_gap_ncsg_info_eutra_present ? 1 : 0;
  nof_ies += cfg_restrict_info_daps_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (ho_prep_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)119, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ho_prep_info.pack(bref));
  }
  if (cell_group_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)173, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cell_group_cfg.pack(bref));
  }
  if (meas_timing_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)163, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(meas_timing_cfg.pack(bref));
  }
  if (ue_assist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)214, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_assist_info.pack(bref));
  }
  if (cg_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)234, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cg_cfg.pack(bref));
  }
  if (ue_assist_info_eutra_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)339, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_assist_info_eutra.pack(bref));
  }
  if (location_meas_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)440, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(location_meas_info.pack(bref));
  }
  if (mu_si_m_gap_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)621, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mu_si_m_gap_cfg.pack(bref));
  }
  if (sdt_mac_phy_cg_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)587, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sdt_mac_phy_cg_cfg.pack(bref));
  }
  if (mb_si_nterest_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)652, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mb_si_nterest_ind.pack(bref));
  }
  if (need_for_gaps_info_nr_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)665, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(need_for_gaps_info_nr.pack(bref));
  }
  if (need_for_gap_ncsg_info_nr_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)666, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(need_for_gap_ncsg_info_nr.pack(bref));
  }
  if (need_for_gap_ncsg_info_eutra_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)667, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(need_for_gap_ncsg_info_eutra.pack(bref));
  }
  if (cfg_restrict_info_daps_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)678, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cfg_restrict_info_daps.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cu_to_du_rrc_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 119: {
        ho_prep_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ho_prep_info.unpack(bref));
        break;
      }
      case 173: {
        cell_group_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cell_group_cfg.unpack(bref));
        break;
      }
      case 163: {
        meas_timing_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(meas_timing_cfg.unpack(bref));
        break;
      }
      case 214: {
        ue_assist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_assist_info.unpack(bref));
        break;
      }
      case 234: {
        cg_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cg_cfg.unpack(bref));
        break;
      }
      case 339: {
        ue_assist_info_eutra_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_assist_info_eutra.unpack(bref));
        break;
      }
      case 440: {
        location_meas_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_meas_info.unpack(bref));
        break;
      }
      case 621: {
        mu_si_m_gap_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mu_si_m_gap_cfg.unpack(bref));
        break;
      }
      case 587: {
        sdt_mac_phy_cg_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sdt_mac_phy_cg_cfg.unpack(bref));
        break;
      }
      case 652: {
        mb_si_nterest_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mb_si_nterest_ind.unpack(bref));
        break;
      }
      case 665: {
        need_for_gaps_info_nr_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(need_for_gaps_info_nr.unpack(bref));
        break;
      }
      case 666: {
        need_for_gap_ncsg_info_nr_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(need_for_gap_ncsg_info_nr.unpack(bref));
        break;
      }
      case 667: {
        need_for_gap_ncsg_info_eutra_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(need_for_gap_ncsg_info_eutra.unpack(bref));
        break;
      }
      case 678: {
        cfg_restrict_info_daps_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cfg_restrict_info_daps.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void cu_to_du_rrc_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ho_prep_info_present) {
    j.write_int("id", 119);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", ho_prep_info.to_string());
  }
  if (cell_group_cfg_present) {
    j.write_int("id", 173);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", cell_group_cfg.to_string());
  }
  if (meas_timing_cfg_present) {
    j.write_int("id", 163);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", meas_timing_cfg.to_string());
  }
  if (ue_assist_info_present) {
    j.write_int("id", 214);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", ue_assist_info.to_string());
  }
  if (cg_cfg_present) {
    j.write_int("id", 234);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", cg_cfg.to_string());
  }
  if (ue_assist_info_eutra_present) {
    j.write_int("id", 339);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", ue_assist_info_eutra.to_string());
  }
  if (location_meas_info_present) {
    j.write_int("id", 440);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", location_meas_info.to_string());
  }
  if (mu_si_m_gap_cfg_present) {
    j.write_int("id", 621);
    j.write_str("criticality", "reject");
    j.write_str("Extension", mu_si_m_gap_cfg.to_string());
  }
  if (sdt_mac_phy_cg_cfg_present) {
    j.write_int("id", 587);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sdt_mac_phy_cg_cfg.to_string());
  }
  if (mb_si_nterest_ind_present) {
    j.write_int("id", 652);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", mb_si_nterest_ind.to_string());
  }
  if (need_for_gaps_info_nr_present) {
    j.write_int("id", 665);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", need_for_gaps_info_nr.to_string());
  }
  if (need_for_gap_ncsg_info_nr_present) {
    j.write_int("id", 666);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", need_for_gap_ncsg_info_nr.to_string());
  }
  if (need_for_gap_ncsg_info_eutra_present) {
    j.write_int("id", 667);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", need_for_gap_ncsg_info_eutra.to_string());
  }
  if (cfg_restrict_info_daps_present) {
    j.write_int("id", 678);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", cfg_restrict_info_daps.to_string());
  }
  j.end_obj();
}

// CUtoDURRCInformation ::= SEQUENCE
SRSASN_CODE cu_to_du_rrc_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cg_cfg_info.size() > 0, 1));
  HANDLE_CODE(bref.pack(ue_cap_rat_container_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(meas_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (cg_cfg_info.size() > 0) {
    HANDLE_CODE(cg_cfg_info.pack(bref));
  }
  if (ue_cap_rat_container_list.size() > 0) {
    HANDLE_CODE(ue_cap_rat_container_list.pack(bref));
  }
  if (meas_cfg.size() > 0) {
    HANDLE_CODE(meas_cfg.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cu_to_du_rrc_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool cg_cfg_info_present;
  HANDLE_CODE(bref.unpack(cg_cfg_info_present, 1));
  bool ue_cap_rat_container_list_present;
  HANDLE_CODE(bref.unpack(ue_cap_rat_container_list_present, 1));
  bool meas_cfg_present;
  HANDLE_CODE(bref.unpack(meas_cfg_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (cg_cfg_info_present) {
    HANDLE_CODE(cg_cfg_info.unpack(bref));
  }
  if (ue_cap_rat_container_list_present) {
    HANDLE_CODE(ue_cap_rat_container_list.unpack(bref));
  }
  if (meas_cfg_present) {
    HANDLE_CODE(meas_cfg.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cu_to_du_rrc_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (cg_cfg_info.size() > 0) {
    j.write_str("cG-ConfigInfo", cg_cfg_info.to_string());
  }
  if (ue_cap_rat_container_list.size() > 0) {
    j.write_str("uE-CapabilityRAT-ContainerList", ue_cap_rat_container_list.to_string());
  }
  if (meas_cfg.size() > 0) {
    j.write_str("measConfig", meas_cfg.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Candidate-SpCell-Item ::= SEQUENCE
SRSASN_CODE candidate_sp_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(candidate_sp_cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE candidate_sp_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(candidate_sp_cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void candidate_sp_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("candidate-SpCell-ID");
  candidate_sp_cell_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SSBAreaCapacityValueItem ::= SEQUENCE
SRSASN_CODE ssb_area_capacity_value_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_capacity_value, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_area_capacity_value_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_capacity_value, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_area_capacity_value_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSBIndex", ssb_idx);
  j.write_int("sSBAreaCapacityValue", ssb_area_capacity_value);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CapacityValue ::= SEQUENCE
SRSASN_CODE capacity_value_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ssb_area_capacity_value_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, capacity_value, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ssb_area_capacity_value_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ssb_area_capacity_value_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE capacity_value_s::unpack(cbit_ref& bref)
{
  bool ssb_area_capacity_value_list_present;
  HANDLE_CODE(bref.unpack(ssb_area_capacity_value_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(capacity_value, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ssb_area_capacity_value_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ssb_area_capacity_value_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void capacity_value_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("capacityValue", capacity_value);
  if (ssb_area_capacity_value_list.size() > 0) {
    j.start_array("sSBAreaCapacityValueList");
    for (const auto& e1 : ssb_area_capacity_value_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SNSSAIRadioResourceStatus-Item ::= SEQUENCE
SRSASN_CODE snssai_rr_status_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(snssai.pack(bref));
  HANDLE_CODE(pack_integer(bref, snssai_dl_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, snssai_ul_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, snssai_dl_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, snssai_ul_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, snssai_dl_total_prb_alloc, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, snssai_ul_total_prb_alloc, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE snssai_rr_status_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(snssai.unpack(bref));
  HANDLE_CODE(unpack_integer(snssai_dl_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(snssai_ul_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(snssai_dl_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(snssai_ul_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(snssai_dl_total_prb_alloc, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(snssai_ul_total_prb_alloc, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void snssai_rr_status_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sNSSAI");
  snssai.to_json(j);
  j.write_int("sNSSAIdlGBRPRBusage", snssai_dl_gbr_prb_usage);
  j.write_int("sNSSAIulGBRPRBusage", snssai_ul_gbr_prb_usage);
  j.write_int("sNSSAIdlNonGBRPRBusage", snssai_dl_non_gbr_prb_usage);
  j.write_int("sNSSAIulNonGBRPRBusage", snssai_ul_non_gbr_prb_usage);
  j.write_int("sNSSAIdlTotalPRBallocation", snssai_dl_total_prb_alloc);
  j.write_int("sNSSAIulTotalPRBallocation", snssai_ul_total_prb_alloc);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SNSSAIAvailableCapacity-Item ::= SEQUENCE
SRSASN_CODE snssai_available_capacity_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(slice_available_capacity_value_dl_present, 1));
  HANDLE_CODE(bref.pack(slice_available_capacity_value_ul_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(snssai.pack(bref));
  if (slice_available_capacity_value_dl_present) {
    HANDLE_CODE(pack_integer(bref, slice_available_capacity_value_dl, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (slice_available_capacity_value_ul_present) {
    HANDLE_CODE(pack_integer(bref, slice_available_capacity_value_ul, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE snssai_available_capacity_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(slice_available_capacity_value_dl_present, 1));
  HANDLE_CODE(bref.unpack(slice_available_capacity_value_ul_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(snssai.unpack(bref));
  if (slice_available_capacity_value_dl_present) {
    HANDLE_CODE(unpack_integer(slice_available_capacity_value_dl, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (slice_available_capacity_value_ul_present) {
    HANDLE_CODE(unpack_integer(slice_available_capacity_value_ul, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void snssai_available_capacity_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sNSSAI");
  snssai.to_json(j);
  if (slice_available_capacity_value_dl_present) {
    j.write_int("sliceAvailableCapacityValueDownlink", slice_available_capacity_value_dl);
  }
  if (slice_available_capacity_value_ul_present) {
    j.write_int("sliceAvailableCapacityValueUplink", slice_available_capacity_value_ul);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SliceRadioResourceStatus-Item ::= SEQUENCE
SRSASN_CODE slice_rr_status_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, snssai_rr_status_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_rr_status_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(snssai_rr_status_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_rr_status_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.start_array("sNSSAIRadioResourceStatus-List");
  for (const auto& e1 : snssai_rr_status_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CompositeAvailableCapacity ::= SEQUENCE
SRSASN_CODE composite_available_capacity_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(cell_capacity_class_value_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (cell_capacity_class_value_present) {
    HANDLE_CODE(pack_integer(bref, cell_capacity_class_value, (uint8_t)1u, (uint8_t)100u, true, true));
  }
  HANDLE_CODE(capacity_value.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE composite_available_capacity_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(cell_capacity_class_value_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (cell_capacity_class_value_present) {
    HANDLE_CODE(unpack_integer(cell_capacity_class_value, bref, (uint8_t)1u, (uint8_t)100u, true, true));
  }
  HANDLE_CODE(capacity_value.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void composite_available_capacity_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (cell_capacity_class_value_present) {
    j.write_int("cellCapacityClassValue", cell_capacity_class_value);
  }
  j.write_fieldname("capacityValue");
  capacity_value.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MIMOPRBusageInformation ::= SEQUENCE
SRSASN_CODE mimo_prb_usage_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_non_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_non_gbr_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_total_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ul_total_prb_usage_for_mimo, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mimo_prb_usage_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_non_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_non_gbr_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(dl_total_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ul_total_prb_usage_for_mimo, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mimo_prb_usage_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dl-GBR-PRB-usage-for-MIMO", dl_gbr_prb_usage_for_mimo);
  j.write_int("ul-GBR-PRB-usage-for-MIMO", ul_gbr_prb_usage_for_mimo);
  j.write_int("dl-non-GBR-PRB-usage-for-MIMO", dl_non_gbr_prb_usage_for_mimo);
  j.write_int("ul-non-GBR-PRB-usage-for-MIMO", ul_non_gbr_prb_usage_for_mimo);
  j.write_int("dl-Total-PRB-usage-for-MIMO", dl_total_prb_usage_for_mimo);
  j.write_int("ul-Total-PRB-usage-for-MIMO", ul_total_prb_usage_for_mimo);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NR-U-Channel-Item ::= SEQUENCE
SRSASN_CODE nr_u_ch_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, nr_u_ch_id, (uint8_t)1u, (uint8_t)16u, false, true));
  HANDLE_CODE(pack_integer(bref, ch_occupancy_time_percentage_dl, (uint8_t)0u, (uint8_t)100u, true, true));
  HANDLE_CODE(pack_integer(bref, energy_detection_thres, (int8_t)-100, (int8_t)-50, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_u_ch_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(nr_u_ch_id, bref, (uint8_t)1u, (uint8_t)16u, false, true));
  HANDLE_CODE(unpack_integer(ch_occupancy_time_percentage_dl, bref, (uint8_t)0u, (uint8_t)100u, true, true));
  HANDLE_CODE(unpack_integer(energy_detection_thres, bref, (int8_t)-100, (int8_t)-50, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_u_ch_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nR-U-ChannelID", nr_u_ch_id);
  j.write_int("channelOccupancyTimePercentageDL", ch_occupancy_time_percentage_dl);
  j.write_int("energyDetectionThreshold", energy_detection_thres);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SSBAreaRadioResourceStatusItem ::= SEQUENCE
SRSASN_CODE ssb_area_rr_status_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(dl_sched_pdcch_cc_eusage_present, 1));
  HANDLE_CODE(bref.pack(ul_sched_pdcch_cc_eusage_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_dl_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_ul_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_dl_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_ul_non_gbr_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_dl_total_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_area_ul_total_prb_usage, (uint8_t)0u, (uint8_t)100u, false, true));
  if (dl_sched_pdcch_cc_eusage_present) {
    HANDLE_CODE(pack_integer(bref, dl_sched_pdcch_cc_eusage, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ul_sched_pdcch_cc_eusage_present) {
    HANDLE_CODE(pack_integer(bref, ul_sched_pdcch_cc_eusage, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_area_rr_status_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(dl_sched_pdcch_cc_eusage_present, 1));
  HANDLE_CODE(bref.unpack(ul_sched_pdcch_cc_eusage_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_dl_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_ul_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_dl_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_ul_non_gbr_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_dl_total_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(ssb_area_ul_total_prb_usage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (dl_sched_pdcch_cc_eusage_present) {
    HANDLE_CODE(unpack_integer(dl_sched_pdcch_cc_eusage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ul_sched_pdcch_cc_eusage_present) {
    HANDLE_CODE(unpack_integer(ul_sched_pdcch_cc_eusage, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_area_rr_status_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSBIndex", ssb_idx);
  j.write_int("sSBAreaDLGBRPRBusage", ssb_area_dl_gbr_prb_usage);
  j.write_int("sSBAreaULGBRPRBusage", ssb_area_ul_gbr_prb_usage);
  j.write_int("sSBAreaDLnon-GBRPRBusage", ssb_area_dl_non_gbr_prb_usage);
  j.write_int("sSBAreaULnon-GBRPRBusage", ssb_area_ul_non_gbr_prb_usage);
  j.write_int("sSBAreaDLTotalPRBusage", ssb_area_dl_total_prb_usage);
  j.write_int("sSBAreaULTotalPRBusage", ssb_area_ul_total_prb_usage);
  if (dl_sched_pdcch_cc_eusage_present) {
    j.write_int("dLschedulingPDCCHCCEusage", dl_sched_pdcch_cc_eusage);
  }
  if (ul_sched_pdcch_cc_eusage_present) {
    j.write_int("uLschedulingPDCCHCCEusage", ul_sched_pdcch_cc_eusage);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SliceAvailableCapacityItem ::= SEQUENCE
SRSASN_CODE slice_available_capacity_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, snssai_available_capacity_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_available_capacity_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(snssai_available_capacity_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_available_capacity_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.start_array("sNSSAIAvailableCapacity-List");
  for (const auto& e1 : snssai_available_capacity_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SliceRadioResourceStatus ::= SEQUENCE
SRSASN_CODE slice_rr_status_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, slice_rr_status, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_rr_status_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(slice_rr_status, bref, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_rr_status_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("sliceRadioResourceStatus");
  for (const auto& e1 : slice_rr_status) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CompositeAvailableCapacityGroup-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t composite_available_capacity_group_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {442};
  return map_enum_number(names, 1, idx, "id");
}
bool composite_available_capacity_group_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 442 == id;
}
crit_e composite_available_capacity_group_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 442) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
composite_available_capacity_group_ext_ies_o::ext_c
composite_available_capacity_group_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 442) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e composite_available_capacity_group_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 442) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void composite_available_capacity_group_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("CompositeAvailableCapacity");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE composite_available_capacity_group_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE composite_available_capacity_group_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// RadioResourceStatus-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t rr_status_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {441, 450};
  return map_enum_number(names, 2, idx, "id");
}
bool rr_status_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {441, 450};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e rr_status_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 441:
      return crit_e::ignore;
    case 450:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
rr_status_ext_ies_o::ext_c rr_status_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 441:
      ret.set(ext_c::types::slice_rr_status);
      break;
    case 450:
      ret.set(ext_c::types::mimo_prb_usage_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e rr_status_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 441:
      return presence_e::optional;
    case 450:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void rr_status_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::slice_rr_status:
      c.destroy<slice_rr_status_s>();
      break;
    case types::mimo_prb_usage_info:
      c.destroy<mimo_prb_usage_info_s>();
      break;
    default:
      break;
  }
}
void rr_status_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::slice_rr_status:
      c.init<slice_rr_status_s>();
      break;
    case types::mimo_prb_usage_info:
      c.init<mimo_prb_usage_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rr_status_ext_ies_o::ext_c");
  }
}
rr_status_ext_ies_o::ext_c::ext_c(const rr_status_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::slice_rr_status:
      c.init(other.c.get<slice_rr_status_s>());
      break;
    case types::mimo_prb_usage_info:
      c.init(other.c.get<mimo_prb_usage_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rr_status_ext_ies_o::ext_c");
  }
}
rr_status_ext_ies_o::ext_c& rr_status_ext_ies_o::ext_c::operator=(const rr_status_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::slice_rr_status:
      c.set(other.c.get<slice_rr_status_s>());
      break;
    case types::mimo_prb_usage_info:
      c.set(other.c.get<mimo_prb_usage_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rr_status_ext_ies_o::ext_c");
  }

  return *this;
}
slice_rr_status_s& rr_status_ext_ies_o::ext_c::slice_rr_status()
{
  assert_choice_type(types::slice_rr_status, type_, "Extension");
  return c.get<slice_rr_status_s>();
}
mimo_prb_usage_info_s& rr_status_ext_ies_o::ext_c::mimo_prb_usage_info()
{
  assert_choice_type(types::mimo_prb_usage_info, type_, "Extension");
  return c.get<mimo_prb_usage_info_s>();
}
const slice_rr_status_s& rr_status_ext_ies_o::ext_c::slice_rr_status() const
{
  assert_choice_type(types::slice_rr_status, type_, "Extension");
  return c.get<slice_rr_status_s>();
}
const mimo_prb_usage_info_s& rr_status_ext_ies_o::ext_c::mimo_prb_usage_info() const
{
  assert_choice_type(types::mimo_prb_usage_info, type_, "Extension");
  return c.get<mimo_prb_usage_info_s>();
}
void rr_status_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::slice_rr_status:
      j.write_fieldname("SliceRadioResourceStatus");
      c.get<slice_rr_status_s>().to_json(j);
      break;
    case types::mimo_prb_usage_info:
      j.write_fieldname("MIMOPRBusageInformation");
      c.get<mimo_prb_usage_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "rr_status_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE rr_status_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::slice_rr_status:
      HANDLE_CODE(c.get<slice_rr_status_s>().pack(bref));
      break;
    case types::mimo_prb_usage_info:
      HANDLE_CODE(c.get<mimo_prb_usage_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rr_status_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE rr_status_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::slice_rr_status:
      HANDLE_CODE(c.get<slice_rr_status_s>().unpack(bref));
      break;
    case types::mimo_prb_usage_info:
      HANDLE_CODE(c.get<mimo_prb_usage_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rr_status_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// CellMeasurementResultItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t cell_meas_result_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {444};
  return map_enum_number(names, 1, idx, "id");
}
bool cell_meas_result_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 444 == id;
}
crit_e cell_meas_result_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 444) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
cell_meas_result_item_ext_ies_o::ext_c cell_meas_result_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 444) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e cell_meas_result_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 444) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void cell_meas_result_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("NR-U-Channel-List");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE cell_meas_result_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 16, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_meas_result_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 16, true));
  return SRSASN_SUCCESS;
}

// CompositeAvailableCapacityGroup ::= SEQUENCE
SRSASN_CODE composite_available_capacity_group_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(composite_available_capacity_dl.pack(bref));
  HANDLE_CODE(composite_available_capacity_ul.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE composite_available_capacity_group_s::unpack(cbit_ref& bref)
{
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(composite_available_capacity_dl.unpack(bref));
  HANDLE_CODE(composite_available_capacity_ul.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void composite_available_capacity_group_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("compositeAvailableCapacityDownlink");
  composite_available_capacity_dl.to_json(j);
  j.write_fieldname("compositeAvailableCapacityUplink");
  composite_available_capacity_ul.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

SRSASN_CODE rr_status_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += slice_rr_status_present ? 1 : 0;
  nof_ies += mimo_prb_usage_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (slice_rr_status_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)441, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(slice_rr_status.pack(bref));
  }
  if (mimo_prb_usage_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)450, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mimo_prb_usage_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rr_status_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 441: {
        slice_rr_status_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(slice_rr_status.unpack(bref));
        break;
      }
      case 450: {
        mimo_prb_usage_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mimo_prb_usage_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void rr_status_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (slice_rr_status_present) {
    j.write_int("id", 441);
    j.write_str("criticality", "ignore");
    slice_rr_status.to_json(j);
  }
  if (mimo_prb_usage_info_present) {
    j.write_int("id", 450);
    j.write_str("criticality", "ignore");
    mimo_prb_usage_info.to_json(j);
  }
  j.end_obj();
}

// RadioResourceStatus ::= SEQUENCE
SRSASN_CODE rr_status_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ssb_area_rr_status_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rr_status_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ssb_area_rr_status_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rr_status_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("sSBAreaRadioResourceStatusList");
  for (const auto& e1 : ssb_area_rr_status_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SliceAvailableCapacity ::= SEQUENCE
SRSASN_CODE slice_available_capacity_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, slice_available_capacity_list, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_available_capacity_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(slice_available_capacity_list, bref, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_available_capacity_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("sliceAvailableCapacityList");
  for (const auto& e1 : slice_available_capacity_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellMeasurementResultItem ::= SEQUENCE
SRSASN_CODE cell_meas_result_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(rr_status_present, 1));
  HANDLE_CODE(bref.pack(composite_available_capacity_group_present, 1));
  HANDLE_CODE(bref.pack(slice_available_capacity_present, 1));
  HANDLE_CODE(bref.pack(numof_active_ues_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(cell_id.pack(bref));
  if (rr_status_present) {
    HANDLE_CODE(rr_status.pack(bref));
  }
  if (composite_available_capacity_group_present) {
    HANDLE_CODE(composite_available_capacity_group.pack(bref));
  }
  if (slice_available_capacity_present) {
    HANDLE_CODE(slice_available_capacity.pack(bref));
  }
  if (numof_active_ues_present) {
    HANDLE_CODE(pack_integer(bref, numof_active_ues, (uint32_t)0u, (uint32_t)16777215u, true, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_meas_result_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(rr_status_present, 1));
  HANDLE_CODE(bref.unpack(composite_available_capacity_group_present, 1));
  HANDLE_CODE(bref.unpack(slice_available_capacity_present, 1));
  HANDLE_CODE(bref.unpack(numof_active_ues_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cell_id.unpack(bref));
  if (rr_status_present) {
    HANDLE_CODE(rr_status.unpack(bref));
  }
  if (composite_available_capacity_group_present) {
    HANDLE_CODE(composite_available_capacity_group.unpack(bref));
  }
  if (slice_available_capacity_present) {
    HANDLE_CODE(slice_available_capacity.unpack(bref));
  }
  if (numof_active_ues_present) {
    HANDLE_CODE(unpack_integer(numof_active_ues, bref, (uint32_t)0u, (uint32_t)16777215u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void cell_meas_result_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cellID");
  cell_id.to_json(j);
  if (rr_status_present) {
    j.write_fieldname("radioResourceStatus");
    rr_status.to_json(j);
  }
  if (composite_available_capacity_group_present) {
    j.write_fieldname("compositeAvailableCapacityGroup");
    composite_available_capacity_group.to_json(j);
  }
  if (slice_available_capacity_present) {
    j.write_fieldname("sliceAvailableCapacity");
    slice_available_capacity.to_json(j);
  }
  if (numof_active_ues_present) {
    j.write_int("numberofActiveUEs", numof_active_ues);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// SNSSAI-Item ::= SEQUENCE
SRSASN_CODE snssai_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(snssai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE snssai_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(snssai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void snssai_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sNSSAI");
  snssai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SSBToReportItem ::= SEQUENCE
SRSASN_CODE ssb_to_report_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_to_report_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_to_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSBIndex", ssb_idx);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SliceToReportItem ::= SEQUENCE
SRSASN_CODE slice_to_report_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, snssai_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_to_report_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(snssai_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_to_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.start_array("sNSSAIlist");
  for (const auto& e1 : snssai_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellToReportItem ::= SEQUENCE
SRSASN_CODE cell_to_report_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ssb_to_report_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(slice_to_report_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cell_id.pack(bref));
  if (ssb_to_report_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ssb_to_report_list, 1, 64, true));
  }
  if (slice_to_report_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, slice_to_report_list, 1, 12, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_to_report_item_s::unpack(cbit_ref& bref)
{
  bool ssb_to_report_list_present;
  HANDLE_CODE(bref.unpack(ssb_to_report_list_present, 1));
  bool slice_to_report_list_present;
  HANDLE_CODE(bref.unpack(slice_to_report_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cell_id.unpack(bref));
  if (ssb_to_report_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ssb_to_report_list, bref, 1, 64, true));
  }
  if (slice_to_report_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(slice_to_report_list, bref, 1, 12, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_to_report_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("cellID");
  cell_id.to_json(j);
  if (ssb_to_report_list.size() > 0) {
    j.start_array("sSBToReportList");
    for (const auto& e1 : ssb_to_report_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (slice_to_report_list.size() > 0) {
    j.start_array("sliceToReportList");
    for (const auto& e1 : slice_to_report_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PrivacyIndicator ::= ENUMERATED
const char* privacy_ind_opts::to_string() const
{
  static const char* names[] = {"immediate-MDT", "logged-MDT"};
  return convert_enum_idx(names, 2, value, "privacy_ind_e");
}

// CellSize ::= ENUMERATED
const char* cell_size_opts::to_string() const
{
  static const char* names[] = {"verysmall", "small", "medium", "large"};
  return convert_enum_idx(names, 4, value, "cell_size_e");
}

// CellType ::= SEQUENCE
SRSASN_CODE cell_type_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cell_size.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_type_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cell_size.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cell_type_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cellSize", cell_size.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Cells-Broadcast-Cancelled-Item ::= SEQUENCE
SRSASN_CODE cells_broadcast_cancelled_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cells_broadcast_cancelled_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cells_broadcast_cancelled_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Cells-Broadcast-Completed-Item ::= SEQUENCE
SRSASN_CODE cells_broadcast_completed_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cells_broadcast_completed_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cells_broadcast_completed_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Cells-Failed-to-be-Activated-List-Item ::= SEQUENCE
SRSASN_CODE cells_failed_to_be_activ_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cells_failed_to_be_activ_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cells_failed_to_be_activ_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Service-State ::= ENUMERATED
const char* service_state_opts::to_string() const
{
  static const char* names[] = {"in-service", "out-of-service"};
  return convert_enum_idx(names, 2, value, "service_state_e");
}

// Service-Status ::= SEQUENCE
SRSASN_CODE service_status_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(switching_off_ongoing_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(service_state.pack(bref));
  if (switching_off_ongoing_present) {
    HANDLE_CODE(switching_off_ongoing.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE service_status_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(switching_off_ongoing_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(service_state.unpack(bref));
  if (switching_off_ongoing_present) {
    HANDLE_CODE(switching_off_ongoing.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void service_status_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("service-state", service_state.to_string());
  if (switching_off_ongoing_present) {
    j.write_str("switchingOffOngoing", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* service_status_s::switching_off_ongoing_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "service_status_s::switching_off_ongoing_e_");
}

// Cells-Status-Item ::= SEQUENCE
SRSASN_CODE cells_status_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(service_status.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cells_status_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(service_status.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cells_status_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  j.write_fieldname("service-status");
  service_status.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Cells-To-Be-Broadcast-Item ::= SEQUENCE
SRSASN_CODE cells_to_be_broadcast_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cells_to_be_broadcast_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cells_to_be_broadcast_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SSB-subcarrierSpacing ::= ENUMERATED
const char* ssb_subcarrier_spacing_opts::to_string() const
{
  static const char* names[] = {"kHz15", "kHz30", "kHz120", "kHz240", "spare3", "spare2", "spare1"};
  return convert_enum_idx(names, 7, value, "ssb_subcarrier_spacing_e");
}
uint8_t ssb_subcarrier_spacing_opts::to_number() const
{
  static const uint8_t numbers[] = {15, 30, 120, 240};
  return map_enum_number(numbers, 4, value, "ssb_subcarrier_spacing_e");
}

// SSB-transmissionBitmap ::= CHOICE
void ssb_tx_bitmap_c::destroy_()
{
  switch (type_) {
    case types::short_bitmap:
      c.destroy<fixed_bitstring<4, false, true>>();
      break;
    case types::medium_bitmap:
      c.destroy<fixed_bitstring<8, false, true>>();
      break;
    case types::long_bitmap:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ssb_tx_bitmap_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::short_bitmap:
      c.init<fixed_bitstring<4, false, true>>();
      break;
    case types::medium_bitmap:
      c.init<fixed_bitstring<8, false, true>>();
      break;
    case types::long_bitmap:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ssb_tx_bitmap_c");
  }
}
ssb_tx_bitmap_c::ssb_tx_bitmap_c(const ssb_tx_bitmap_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::short_bitmap:
      c.init(other.c.get<fixed_bitstring<4, false, true>>());
      break;
    case types::medium_bitmap:
      c.init(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::long_bitmap:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ssb_tx_bitmap_c");
  }
}
ssb_tx_bitmap_c& ssb_tx_bitmap_c::operator=(const ssb_tx_bitmap_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::short_bitmap:
      c.set(other.c.get<fixed_bitstring<4, false, true>>());
      break;
    case types::medium_bitmap:
      c.set(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::long_bitmap:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ssb_tx_bitmap_c");
  }

  return *this;
}
fixed_bitstring<4, false, true>& ssb_tx_bitmap_c::set_short_bitmap()
{
  set(types::short_bitmap);
  return c.get<fixed_bitstring<4, false, true>>();
}
fixed_bitstring<8, false, true>& ssb_tx_bitmap_c::set_medium_bitmap()
{
  set(types::medium_bitmap);
  return c.get<fixed_bitstring<8, false, true>>();
}
fixed_bitstring<64, false, true>& ssb_tx_bitmap_c::set_long_bitmap()
{
  set(types::long_bitmap);
  return c.get<fixed_bitstring<64, false, true>>();
}
protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>& ssb_tx_bitmap_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>();
}
void ssb_tx_bitmap_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::short_bitmap:
      j.write_str("shortBitmap", c.get<fixed_bitstring<4, false, true>>().to_string());
      break;
    case types::medium_bitmap:
      j.write_str("mediumBitmap", c.get<fixed_bitstring<8, false, true>>().to_string());
      break;
    case types::long_bitmap:
      j.write_str("longBitmap", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ssb_tx_bitmap_c");
  }
  j.end_obj();
}
SRSASN_CODE ssb_tx_bitmap_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::short_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<4, false, true>>().pack(bref)));
      break;
    case types::medium_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().pack(bref)));
      break;
    case types::long_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ssb_tx_bitmap_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_tx_bitmap_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::short_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<4, false, true>>().unpack(bref)));
      break;
    case types::medium_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().unpack(bref)));
      break;
    case types::long_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ssb_transmisison_bitmap_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ssb_tx_bitmap_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ssb_tx_bitmap_c::types_opts::to_string() const
{
  static const char* names[] = {"shortBitmap", "mediumBitmap", "longBitmap", "choice-extension"};
  return convert_enum_idx(names, 4, value, "ssb_tx_bitmap_c::types");
}

// SSB-transmissionPeriodicity ::= ENUMERATED
const char* ssb_tx_periodicity_opts::to_string() const
{
  static const char* names[] = {"sf10", "sf20", "sf40", "sf80", "sf160", "sf320", "sf640"};
  return convert_enum_idx(names, 7, value, "ssb_tx_periodicity_e");
}
uint16_t ssb_tx_periodicity_opts::to_number() const
{
  static const uint16_t numbers[] = {10, 20, 40, 80, 160, 320, 640};
  return map_enum_number(numbers, 7, value, "ssb_tx_periodicity_e");
}

// AreaScope ::= ENUMERATED
const char* area_scope_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "area_scope_e");
}

// IAB-STC-Info-Item ::= SEQUENCE
SRSASN_CODE iab_stc_info_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_freq_info, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(ssb_subcarrier_spacing.pack(bref));
  HANDLE_CODE(ssb_tx_periodicity.pack(bref));
  HANDLE_CODE(pack_integer(bref, ssb_tx_timing_offset, (uint8_t)0u, (uint8_t)127u, true, true));
  HANDLE_CODE(ssb_tx_bitmap.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_stc_info_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ssb_freq_info, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(ssb_subcarrier_spacing.unpack(bref));
  HANDLE_CODE(ssb_tx_periodicity.unpack(bref));
  HANDLE_CODE(unpack_integer(ssb_tx_timing_offset, bref, (uint8_t)0u, (uint8_t)127u, true, true));
  HANDLE_CODE(ssb_tx_bitmap.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_stc_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSB-freqInfo", ssb_freq_info);
  j.write_str("sSB-subcarrierSpacing", ssb_subcarrier_spacing.to_string());
  j.write_str("sSB-transmissionPeriodicity", ssb_tx_periodicity.to_string());
  j.write_int("sSB-transmissionTimingOffset", ssb_tx_timing_offset);
  j.write_fieldname("sSB-transmissionBitmap");
  ssb_tx_bitmap.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SibtypetobeupdatedListItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t sibtypetobeupd_list_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {240};
  return map_enum_number(names, 1, idx, "id");
}
bool sibtypetobeupd_list_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 240 == id;
}
crit_e sibtypetobeupd_list_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 240) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
sibtypetobeupd_list_item_ext_ies_o::ext_c sibtypetobeupd_list_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 240) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e sibtypetobeupd_list_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 240) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void sibtypetobeupd_list_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("AreaScope", "true");
  j.end_obj();
}
SRSASN_CODE sibtypetobeupd_list_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE sibtypetobeupd_list_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// GNB-CUSystemInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t gnb_cu_sys_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {239};
  return map_enum_number(names, 1, idx, "id");
}
bool gnb_cu_sys_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 239 == id;
}
crit_e gnb_cu_sys_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 239) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
gnb_cu_sys_info_ext_ies_o::ext_c gnb_cu_sys_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 239) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e gnb_cu_sys_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 239) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void gnb_cu_sys_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("BIT STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE gnb_cu_sys_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_cu_sys_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// IAB-STC-Info ::= SEQUENCE
SRSASN_CODE iab_stc_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, iab_stc_info_list, 1, 45, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_stc_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(iab_stc_info_list, bref, 1, 45, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_stc_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("iAB-STC-Info-List");
  for (const auto& e1 : iab_stc_info_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SibtypetobeupdatedListItem ::= SEQUENCE
SRSASN_CODE sibtypetobeupd_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, sib_type, (uint8_t)2u, (uint8_t)32u, true, true));
  HANDLE_CODE(sib_msg.pack(bref));
  HANDLE_CODE(pack_integer(bref, value_tag, (uint8_t)0u, (uint8_t)31u, true, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sibtypetobeupd_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sib_type, bref, (uint8_t)2u, (uint8_t)32u, true, true));
  HANDLE_CODE(sib_msg.unpack(bref));
  HANDLE_CODE(unpack_integer(value_tag, bref, (uint8_t)0u, (uint8_t)31u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void sibtypetobeupd_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sIBtype", sib_type);
  j.write_str("sIBmessage", sib_msg.to_string());
  j.write_int("valueTag", value_tag);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// GNB-CUSystemInformation ::= SEQUENCE
SRSASN_CODE gnb_cu_sys_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, sibtypetobeupdlist, 1, 32, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_cu_sys_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(sibtypetobeupdlist, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void gnb_cu_sys_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("sibtypetobeupdatedlist");
  for (const auto& e1 : sibtypetobeupdlist) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// IAB-Info-IAB-donor-CU ::= SEQUENCE
SRSASN_CODE iab_info_iab_donor_cu_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(iab_stc_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (iab_stc_info_present) {
    HANDLE_CODE(iab_stc_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_info_iab_donor_cu_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(iab_stc_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (iab_stc_info_present) {
    HANDLE_CODE(iab_stc_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_info_iab_donor_cu_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (iab_stc_info_present) {
    j.write_fieldname("iAB-STC-Info");
    iab_stc_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Cells-to-be-Activated-List-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t cells_to_be_activ_list_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {118, 179, 197, 291, 386, 457};
  return map_enum_number(names, 6, idx, "id");
}
bool cells_to_be_activ_list_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {118, 179, 197, 291, 386, 457};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e cells_to_be_activ_list_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 118:
      return crit_e::reject;
    case 179:
      return crit_e::ignore;
    case 197:
      return crit_e::ignore;
    case 291:
      return crit_e::ignore;
    case 386:
      return crit_e::ignore;
    case 457:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
cells_to_be_activ_list_item_ext_ies_o::ext_c cells_to_be_activ_list_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 118:
      ret.set(ext_c::types::gnb_cu_sys_info);
      break;
    case 179:
      ret.set(ext_c::types::available_plmn_list);
      break;
    case 197:
      ret.set(ext_c::types::extended_available_plmn_list);
      break;
    case 291:
      ret.set(ext_c::types::iab_info_iab_donor_cu);
      break;
    case 386:
      ret.set(ext_c::types::available_sn_pn_id_list);
      break;
    case 457:
      ret.set(ext_c::types::mbs_broadcast_neighbour_cell_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e cells_to_be_activ_list_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 118:
      return presence_e::optional;
    case 179:
      return presence_e::optional;
    case 197:
      return presence_e::optional;
    case 291:
      return presence_e::optional;
    case 386:
      return presence_e::optional;
    case 457:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void cells_to_be_activ_list_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::gnb_cu_sys_info:
      c.destroy<gnb_cu_sys_info_s>();
      break;
    case types::available_plmn_list:
      c.destroy<available_plmn_list_l>();
      break;
    case types::extended_available_plmn_list:
      c.destroy<extended_available_plmn_list_l>();
      break;
    case types::iab_info_iab_donor_cu:
      c.destroy<iab_info_iab_donor_cu_s>();
      break;
    case types::available_sn_pn_id_list:
      c.destroy<available_sn_pn_id_list_l>();
      break;
    case types::mbs_broadcast_neighbour_cell_list:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void cells_to_be_activ_list_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::gnb_cu_sys_info:
      c.init<gnb_cu_sys_info_s>();
      break;
    case types::available_plmn_list:
      c.init<available_plmn_list_l>();
      break;
    case types::extended_available_plmn_list:
      c.init<extended_available_plmn_list_l>();
      break;
    case types::iab_info_iab_donor_cu:
      c.init<iab_info_iab_donor_cu_s>();
      break;
    case types::available_sn_pn_id_list:
      c.init<available_sn_pn_id_list_l>();
      break;
    case types::mbs_broadcast_neighbour_cell_list:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cells_to_be_activ_list_item_ext_ies_o::ext_c");
  }
}
cells_to_be_activ_list_item_ext_ies_o::ext_c::ext_c(const cells_to_be_activ_list_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::gnb_cu_sys_info:
      c.init(other.c.get<gnb_cu_sys_info_s>());
      break;
    case types::available_plmn_list:
      c.init(other.c.get<available_plmn_list_l>());
      break;
    case types::extended_available_plmn_list:
      c.init(other.c.get<extended_available_plmn_list_l>());
      break;
    case types::iab_info_iab_donor_cu:
      c.init(other.c.get<iab_info_iab_donor_cu_s>());
      break;
    case types::available_sn_pn_id_list:
      c.init(other.c.get<available_sn_pn_id_list_l>());
      break;
    case types::mbs_broadcast_neighbour_cell_list:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cells_to_be_activ_list_item_ext_ies_o::ext_c");
  }
}
cells_to_be_activ_list_item_ext_ies_o::ext_c&
cells_to_be_activ_list_item_ext_ies_o::ext_c::operator=(const cells_to_be_activ_list_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::gnb_cu_sys_info:
      c.set(other.c.get<gnb_cu_sys_info_s>());
      break;
    case types::available_plmn_list:
      c.set(other.c.get<available_plmn_list_l>());
      break;
    case types::extended_available_plmn_list:
      c.set(other.c.get<extended_available_plmn_list_l>());
      break;
    case types::iab_info_iab_donor_cu:
      c.set(other.c.get<iab_info_iab_donor_cu_s>());
      break;
    case types::available_sn_pn_id_list:
      c.set(other.c.get<available_sn_pn_id_list_l>());
      break;
    case types::mbs_broadcast_neighbour_cell_list:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cells_to_be_activ_list_item_ext_ies_o::ext_c");
  }

  return *this;
}
gnb_cu_sys_info_s& cells_to_be_activ_list_item_ext_ies_o::ext_c::gnb_cu_sys_info()
{
  assert_choice_type(types::gnb_cu_sys_info, type_, "Extension");
  return c.get<gnb_cu_sys_info_s>();
}
available_plmn_list_l& cells_to_be_activ_list_item_ext_ies_o::ext_c::available_plmn_list()
{
  assert_choice_type(types::available_plmn_list, type_, "Extension");
  return c.get<available_plmn_list_l>();
}
extended_available_plmn_list_l& cells_to_be_activ_list_item_ext_ies_o::ext_c::extended_available_plmn_list()
{
  assert_choice_type(types::extended_available_plmn_list, type_, "Extension");
  return c.get<extended_available_plmn_list_l>();
}
iab_info_iab_donor_cu_s& cells_to_be_activ_list_item_ext_ies_o::ext_c::iab_info_iab_donor_cu()
{
  assert_choice_type(types::iab_info_iab_donor_cu, type_, "Extension");
  return c.get<iab_info_iab_donor_cu_s>();
}
available_sn_pn_id_list_l& cells_to_be_activ_list_item_ext_ies_o::ext_c::available_sn_pn_id_list()
{
  assert_choice_type(types::available_sn_pn_id_list, type_, "Extension");
  return c.get<available_sn_pn_id_list_l>();
}
unbounded_octstring<true>& cells_to_be_activ_list_item_ext_ies_o::ext_c::mbs_broadcast_neighbour_cell_list()
{
  assert_choice_type(types::mbs_broadcast_neighbour_cell_list, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const gnb_cu_sys_info_s& cells_to_be_activ_list_item_ext_ies_o::ext_c::gnb_cu_sys_info() const
{
  assert_choice_type(types::gnb_cu_sys_info, type_, "Extension");
  return c.get<gnb_cu_sys_info_s>();
}
const available_plmn_list_l& cells_to_be_activ_list_item_ext_ies_o::ext_c::available_plmn_list() const
{
  assert_choice_type(types::available_plmn_list, type_, "Extension");
  return c.get<available_plmn_list_l>();
}
const extended_available_plmn_list_l& cells_to_be_activ_list_item_ext_ies_o::ext_c::extended_available_plmn_list() const
{
  assert_choice_type(types::extended_available_plmn_list, type_, "Extension");
  return c.get<extended_available_plmn_list_l>();
}
const iab_info_iab_donor_cu_s& cells_to_be_activ_list_item_ext_ies_o::ext_c::iab_info_iab_donor_cu() const
{
  assert_choice_type(types::iab_info_iab_donor_cu, type_, "Extension");
  return c.get<iab_info_iab_donor_cu_s>();
}
const available_sn_pn_id_list_l& cells_to_be_activ_list_item_ext_ies_o::ext_c::available_sn_pn_id_list() const
{
  assert_choice_type(types::available_sn_pn_id_list, type_, "Extension");
  return c.get<available_sn_pn_id_list_l>();
}
const unbounded_octstring<true>& cells_to_be_activ_list_item_ext_ies_o::ext_c::mbs_broadcast_neighbour_cell_list() const
{
  assert_choice_type(types::mbs_broadcast_neighbour_cell_list, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
void cells_to_be_activ_list_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::gnb_cu_sys_info:
      j.write_fieldname("GNB-CUSystemInformation");
      c.get<gnb_cu_sys_info_s>().to_json(j);
      break;
    case types::available_plmn_list:
      j.start_array("AvailablePLMNList");
      for (const auto& e1 : c.get<available_plmn_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::extended_available_plmn_list:
      j.start_array("ExtendedAvailablePLMN-List");
      for (const auto& e1 : c.get<extended_available_plmn_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::iab_info_iab_donor_cu:
      j.write_fieldname("IAB-Info-IAB-donor-CU");
      c.get<iab_info_iab_donor_cu_s>().to_json(j);
      break;
    case types::available_sn_pn_id_list:
      j.start_array("AvailableSNPN-ID-List");
      for (const auto& e1 : c.get<available_sn_pn_id_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::mbs_broadcast_neighbour_cell_list:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "cells_to_be_activ_list_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE cells_to_be_activ_list_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::gnb_cu_sys_info:
      HANDLE_CODE(c.get<gnb_cu_sys_info_s>().pack(bref));
      break;
    case types::available_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<available_plmn_list_l>(), 1, 6, true));
      break;
    case types::extended_available_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<extended_available_plmn_list_l>(), 1, 6, true));
      break;
    case types::iab_info_iab_donor_cu:
      HANDLE_CODE(c.get<iab_info_iab_donor_cu_s>().pack(bref));
      break;
    case types::available_sn_pn_id_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<available_sn_pn_id_list_l>(), 1, 12, true));
      break;
    case types::mbs_broadcast_neighbour_cell_list:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cells_to_be_activ_list_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cells_to_be_activ_list_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::gnb_cu_sys_info:
      HANDLE_CODE(c.get<gnb_cu_sys_info_s>().unpack(bref));
      break;
    case types::available_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<available_plmn_list_l>(), bref, 1, 6, true));
      break;
    case types::extended_available_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<extended_available_plmn_list_l>(), bref, 1, 6, true));
      break;
    case types::iab_info_iab_donor_cu:
      HANDLE_CODE(c.get<iab_info_iab_donor_cu_s>().unpack(bref));
      break;
    case types::available_sn_pn_id_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<available_sn_pn_id_list_l>(), bref, 1, 12, true));
      break;
    case types::mbs_broadcast_neighbour_cell_list:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "cells_to_be_activ_list_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE cells_to_be_activ_list_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += gnb_cu_sys_info_present ? 1 : 0;
  nof_ies += available_plmn_list_present ? 1 : 0;
  nof_ies += extended_available_plmn_list_present ? 1 : 0;
  nof_ies += iab_info_iab_donor_cu_present ? 1 : 0;
  nof_ies += available_sn_pn_id_list_present ? 1 : 0;
  nof_ies += mbs_broadcast_neighbour_cell_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (gnb_cu_sys_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)118, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(gnb_cu_sys_info.pack(bref));
  }
  if (available_plmn_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)179, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, available_plmn_list, 1, 6, true));
  }
  if (extended_available_plmn_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)197, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, extended_available_plmn_list, 1, 6, true));
  }
  if (iab_info_iab_donor_cu_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)291, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(iab_info_iab_donor_cu.pack(bref));
  }
  if (available_sn_pn_id_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)386, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, available_sn_pn_id_list, 1, 12, true));
  }
  if (mbs_broadcast_neighbour_cell_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)457, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_broadcast_neighbour_cell_list.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cells_to_be_activ_list_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 118: {
        gnb_cu_sys_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(gnb_cu_sys_info.unpack(bref));
        break;
      }
      case 179: {
        available_plmn_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(available_plmn_list, bref, 1, 6, true));
        break;
      }
      case 197: {
        extended_available_plmn_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(extended_available_plmn_list, bref, 1, 6, true));
        break;
      }
      case 291: {
        iab_info_iab_donor_cu_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_info_iab_donor_cu.unpack(bref));
        break;
      }
      case 386: {
        available_sn_pn_id_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(available_sn_pn_id_list, bref, 1, 12, true));
        break;
      }
      case 457: {
        mbs_broadcast_neighbour_cell_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_broadcast_neighbour_cell_list.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void cells_to_be_activ_list_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (gnb_cu_sys_info_present) {
    j.write_int("id", 118);
    j.write_str("criticality", "reject");
    gnb_cu_sys_info.to_json(j);
  }
  if (available_plmn_list_present) {
    j.write_int("id", 179);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : available_plmn_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (extended_available_plmn_list_present) {
    j.write_int("id", 197);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : extended_available_plmn_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (iab_info_iab_donor_cu_present) {
    j.write_int("id", 291);
    j.write_str("criticality", "ignore");
    iab_info_iab_donor_cu.to_json(j);
  }
  if (available_sn_pn_id_list_present) {
    j.write_int("id", 386);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : available_sn_pn_id_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mbs_broadcast_neighbour_cell_list_present) {
    j.write_int("id", 457);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", mbs_broadcast_neighbour_cell_list.to_string());
  }
  j.end_obj();
}

// Cells-to-be-Activated-List-Item ::= SEQUENCE
SRSASN_CODE cells_to_be_activ_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nr_pci_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (nr_pci_present) {
    HANDLE_CODE(pack_integer(bref, nr_pci, (uint16_t)0u, (uint16_t)1007u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cells_to_be_activ_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nr_pci_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (nr_pci_present) {
    HANDLE_CODE(unpack_integer(nr_pci, bref, (uint16_t)0u, (uint16_t)1007u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cells_to_be_activ_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (nr_pci_present) {
    j.write_int("nRPCI", nr_pci);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-Barred ::= ENUMERATED
const char* iab_barred_opts::to_string() const
{
  static const char* names[] = {"barred", "not-barred"};
  return convert_enum_idx(names, 2, value, "iab_barred_e");
}

// CellBarred ::= ENUMERATED
const char* cell_barred_opts::to_string() const
{
  static const char* names[] = {"barred", "not-barred"};
  return convert_enum_idx(names, 2, value, "cell_barred_e");
}

// Cells-to-be-Barred-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t cells_to_be_barred_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {298};
  return map_enum_number(names, 1, idx, "id");
}
bool cells_to_be_barred_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 298 == id;
}
crit_e cells_to_be_barred_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 298) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
cells_to_be_barred_item_ext_ies_o::ext_c cells_to_be_barred_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 298) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e cells_to_be_barred_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 298) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void cells_to_be_barred_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("IAB-Barred", c.to_string());
  j.end_obj();
}
SRSASN_CODE cells_to_be_barred_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE cells_to_be_barred_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// Cells-to-be-Barred-Item ::= SEQUENCE
SRSASN_CODE cells_to_be_barred_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(cell_barred.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cells_to_be_barred_item_s::unpack(cbit_ref& bref)
{
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(cell_barred.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void cells_to_be_barred_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  j.write_str("cellBarred", cell_barred.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// Cells-to-be-Deactivated-List-Item ::= SEQUENCE
SRSASN_CODE cells_to_be_deactiv_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cells_to_be_deactiv_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cells_to_be_deactiv_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// L1151Info ::= SEQUENCE
SRSASN_CODE l1151_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(prach_scs_for_l1151.pack(bref));
  HANDLE_CODE(pack_integer(bref, root_seq_idx, (uint16_t)0u, (uint16_t)1149u, false, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE l1151_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(prach_scs_for_l1151.unpack(bref));
  HANDLE_CODE(unpack_integer(root_seq_idx, bref, (uint16_t)0u, (uint16_t)1149u, false, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void l1151_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("prachSCSForL1151", prach_scs_for_l1151.to_string());
  j.write_int("rootSequenceIndex", root_seq_idx);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

const char* l1151_info_s::prach_scs_for_l1151_opts::to_string() const
{
  static const char* names[] = {"scs15", "scs120"};
  return convert_enum_idx(names, 2, value, "l1151_info_s::prach_scs_for_l1151_e_");
}
uint8_t l1151_info_s::prach_scs_for_l1151_opts::to_number() const
{
  static const uint8_t numbers[] = {15, 120};
  return map_enum_number(numbers, 2, value, "l1151_info_s::prach_scs_for_l1151_e_");
}

// L571Info ::= SEQUENCE
SRSASN_CODE l571_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(prach_scs_for_l571.pack(bref));
  HANDLE_CODE(pack_integer(bref, root_seq_idx, (uint16_t)0u, (uint16_t)569u, false, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE l571_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(prach_scs_for_l571.unpack(bref));
  HANDLE_CODE(unpack_integer(root_seq_idx, bref, (uint16_t)0u, (uint16_t)569u, false, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void l571_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("prachSCSForL571", prach_scs_for_l571.to_string());
  j.write_int("rootSequenceIndex", root_seq_idx);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

const char* l571_info_s::prach_scs_for_l571_opts::to_string() const
{
  static const char* names[] = {"scs30", "scs120", "scs480"};
  return convert_enum_idx(names, 3, value, "l571_info_s::prach_scs_for_l571_e_");
}
uint16_t l571_info_s::prach_scs_for_l571_opts::to_number() const
{
  static const uint16_t numbers[] = {30, 120, 480};
  return map_enum_number(numbers, 3, value, "l571_info_s::prach_scs_for_l571_e_");
}

// FreqDomainLength-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
uint32_t freq_domain_len_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {659, 660};
  return map_enum_number(names, 2, idx, "id");
}
bool freq_domain_len_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {659, 660};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e freq_domain_len_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 659:
      return crit_e::reject;
    case 660:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
freq_domain_len_ext_ies_o::value_c freq_domain_len_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 659:
      ret.set(value_c::types::l571_info);
      break;
    case 660:
      ret.set(value_c::types::l1151_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e freq_domain_len_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 659:
      return presence_e::mandatory;
    case 660:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void freq_domain_len_ext_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::l571_info:
      c.destroy<l571_info_s>();
      break;
    case types::l1151_info:
      c.destroy<l1151_info_s>();
      break;
    default:
      break;
  }
}
void freq_domain_len_ext_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::l571_info:
      c.init<l571_info_s>();
      break;
    case types::l1151_info:
      c.init<l1151_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "freq_domain_len_ext_ies_o::value_c");
  }
}
freq_domain_len_ext_ies_o::value_c::value_c(const freq_domain_len_ext_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::l571_info:
      c.init(other.c.get<l571_info_s>());
      break;
    case types::l1151_info:
      c.init(other.c.get<l1151_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "freq_domain_len_ext_ies_o::value_c");
  }
}
freq_domain_len_ext_ies_o::value_c&
freq_domain_len_ext_ies_o::value_c::operator=(const freq_domain_len_ext_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::l571_info:
      c.set(other.c.get<l571_info_s>());
      break;
    case types::l1151_info:
      c.set(other.c.get<l1151_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "freq_domain_len_ext_ies_o::value_c");
  }

  return *this;
}
l571_info_s& freq_domain_len_ext_ies_o::value_c::l571_info()
{
  assert_choice_type(types::l571_info, type_, "Value");
  return c.get<l571_info_s>();
}
l1151_info_s& freq_domain_len_ext_ies_o::value_c::l1151_info()
{
  assert_choice_type(types::l1151_info, type_, "Value");
  return c.get<l1151_info_s>();
}
const l571_info_s& freq_domain_len_ext_ies_o::value_c::l571_info() const
{
  assert_choice_type(types::l571_info, type_, "Value");
  return c.get<l571_info_s>();
}
const l1151_info_s& freq_domain_len_ext_ies_o::value_c::l1151_info() const
{
  assert_choice_type(types::l1151_info, type_, "Value");
  return c.get<l1151_info_s>();
}
void freq_domain_len_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::l571_info:
      j.write_fieldname("L571Info");
      c.get<l571_info_s>().to_json(j);
      break;
    case types::l1151_info:
      j.write_fieldname("L1151Info");
      c.get<l1151_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "freq_domain_len_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE freq_domain_len_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::l571_info:
      HANDLE_CODE(c.get<l571_info_s>().pack(bref));
      break;
    case types::l1151_info:
      HANDLE_CODE(c.get<l1151_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "freq_domain_len_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE freq_domain_len_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::l571_info:
      HANDLE_CODE(c.get<l571_info_s>().unpack(bref));
      break;
    case types::l1151_info:
      HANDLE_CODE(c.get<l1151_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "freq_domain_len_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// L139Info ::= SEQUENCE
SRSASN_CODE l139_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(root_seq_idx_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(prach_scs.pack(bref));
  if (root_seq_idx_present) {
    HANDLE_CODE(pack_integer(bref, root_seq_idx, (uint8_t)0u, (uint8_t)137u, false, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE l139_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(root_seq_idx_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(prach_scs.unpack(bref));
  if (root_seq_idx_present) {
    HANDLE_CODE(unpack_integer(root_seq_idx, bref, (uint8_t)0u, (uint8_t)137u, false, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void l139_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("prachSCS", prach_scs.to_string());
  if (root_seq_idx_present) {
    j.write_int("rootSequenceIndex", root_seq_idx);
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

const char* l139_info_s::prach_scs_opts::to_string() const
{
  static const char* names[] = {"scs15", "scs30", "scs60", "scs120", "scs480", "scs960"};
  return convert_enum_idx(names, 6, value, "l139_info_s::prach_scs_e_");
}
uint16_t l139_info_s::prach_scs_opts::to_number() const
{
  static const uint16_t numbers[] = {15, 30, 60, 120, 480, 960};
  return map_enum_number(numbers, 6, value, "l139_info_s::prach_scs_e_");
}

// L839Info ::= SEQUENCE
SRSASN_CODE l839_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, root_seq_idx, (uint16_t)0u, (uint16_t)837u, false, true));
  HANDLE_CODE(restricted_set_cfg.pack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE l839_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(root_seq_idx, bref, (uint16_t)0u, (uint16_t)837u, false, true));
  HANDLE_CODE(restricted_set_cfg.unpack(bref));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void l839_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("rootSequenceIndex", root_seq_idx);
  j.write_str("restrictedSetConfig", restricted_set_cfg.to_string());
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

const char* l839_info_s::restricted_set_cfg_opts::to_string() const
{
  static const char* names[] = {"unrestrictedSet", "restrictedSetTypeA", "restrictedSetTypeB"};
  return convert_enum_idx(names, 3, value, "l839_info_s::restricted_set_cfg_e_");
}

template struct asn1::protocol_ie_single_container_s<freq_domain_len_ext_ies_o>;

// FreqDomainLength ::= CHOICE
void freq_domain_len_c::destroy_()
{
  switch (type_) {
    case types::l839:
      c.destroy<l839_info_s>();
      break;
    case types::l139:
      c.destroy<l139_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<freq_domain_len_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void freq_domain_len_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::l839:
      c.init<l839_info_s>();
      break;
    case types::l139:
      c.init<l139_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<freq_domain_len_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "freq_domain_len_c");
  }
}
freq_domain_len_c::freq_domain_len_c(const freq_domain_len_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::l839:
      c.init(other.c.get<l839_info_s>());
      break;
    case types::l139:
      c.init(other.c.get<l139_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<freq_domain_len_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "freq_domain_len_c");
  }
}
freq_domain_len_c& freq_domain_len_c::operator=(const freq_domain_len_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::l839:
      c.set(other.c.get<l839_info_s>());
      break;
    case types::l139:
      c.set(other.c.get<l139_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<freq_domain_len_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "freq_domain_len_c");
  }

  return *this;
}
l839_info_s& freq_domain_len_c::set_l839()
{
  set(types::l839);
  return c.get<l839_info_s>();
}
l139_info_s& freq_domain_len_c::set_l139()
{
  set(types::l139);
  return c.get<l139_info_s>();
}
protocol_ie_single_container_s<freq_domain_len_ext_ies_o>& freq_domain_len_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<freq_domain_len_ext_ies_o>>();
}
void freq_domain_len_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::l839:
      j.write_fieldname("l839");
      c.get<l839_info_s>().to_json(j);
      break;
    case types::l139:
      j.write_fieldname("l139");
      c.get<l139_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<freq_domain_len_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "freq_domain_len_c");
  }
  j.end_obj();
}
SRSASN_CODE freq_domain_len_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::l839:
      HANDLE_CODE(c.get<l839_info_s>().pack(bref));
      break;
    case types::l139:
      HANDLE_CODE(c.get<l139_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<freq_domain_len_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "freq_domain_len_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE freq_domain_len_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::l839:
      HANDLE_CODE(c.get<l839_info_s>().unpack(bref));
      break;
    case types::l139:
      HANDLE_CODE(c.get<l139_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<freq_domain_len_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "freq_domain_len_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* freq_domain_len_c::types_opts::to_string() const
{
  static const char* names[] = {"l839", "l139", "choice-extension"};
  return convert_enum_idx(names, 3, value, "freq_domain_len_c::types");
}
uint16_t freq_domain_len_c::types_opts::to_number() const
{
  static const uint16_t numbers[] = {839, 139};
  return map_enum_number(numbers, 2, value, "freq_domain_len_c::types");
}

// FreqInfoRel16 ::= SEQUENCE
SRSASN_CODE freq_info_rel16_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nr_arfcn_present, 1));
  HANDLE_CODE(bref.pack(freq_shift7p5khz_present, 1));
  HANDLE_CODE(bref.pack(carrier_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (nr_arfcn_present) {
    HANDLE_CODE(pack_integer(bref, nr_arfcn, (uint32_t)0u, (uint32_t)3279165u, false, true));
  }
  if (freq_shift7p5khz_present) {
    HANDLE_CODE(freq_shift7p5khz.pack(bref));
  }
  if (carrier_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, carrier_list, 1, 5, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE freq_info_rel16_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nr_arfcn_present, 1));
  HANDLE_CODE(bref.unpack(freq_shift7p5khz_present, 1));
  bool carrier_list_present;
  HANDLE_CODE(bref.unpack(carrier_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (nr_arfcn_present) {
    HANDLE_CODE(unpack_integer(nr_arfcn, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  }
  if (freq_shift7p5khz_present) {
    HANDLE_CODE(freq_shift7p5khz.unpack(bref));
  }
  if (carrier_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(carrier_list, bref, 1, 5, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void freq_info_rel16_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (nr_arfcn_present) {
    j.write_int("nRARFCN", nr_arfcn);
  }
  if (freq_shift7p5khz_present) {
    j.write_str("frequencyShift7p5khz", freq_shift7p5khz.to_string());
  }
  if (carrier_list.size() > 0) {
    j.start_array("carrierList");
    for (const auto& e1 : carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRPRACHConfigItem ::= SEQUENCE
SRSASN_CODE nr_prach_cfg_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(nr_scs.pack(bref));
  HANDLE_CODE(pack_integer(bref, prach_freq_startfrom_carrier, (uint16_t)0u, (uint16_t)274u, true, true));
  HANDLE_CODE(prach_fdm.pack(bref));
  HANDLE_CODE(pack_integer(bref, prach_cfg_idx, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(ssb_per_rach_occasion.pack(bref));
  HANDLE_CODE(freq_domain_len.pack(bref));
  HANDLE_CODE(pack_integer(bref, zero_correl_zone_cfg, (uint8_t)0u, (uint8_t)15u, false, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_prach_cfg_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(nr_scs.unpack(bref));
  HANDLE_CODE(unpack_integer(prach_freq_startfrom_carrier, bref, (uint16_t)0u, (uint16_t)274u, true, true));
  HANDLE_CODE(prach_fdm.unpack(bref));
  HANDLE_CODE(unpack_integer(prach_cfg_idx, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(ssb_per_rach_occasion.unpack(bref));
  HANDLE_CODE(freq_domain_len.unpack(bref));
  HANDLE_CODE(unpack_integer(zero_correl_zone_cfg, bref, (uint8_t)0u, (uint8_t)15u, false, true));
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_prach_cfg_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nRSCS", nr_scs.to_string());
  j.write_int("prachFreqStartfromCarrier", prach_freq_startfrom_carrier);
  j.write_str("prachFDM", prach_fdm.to_string());
  j.write_int("prachConfigIndex", prach_cfg_idx);
  j.write_str("ssb-perRACH-Occasion", ssb_per_rach_occasion.to_string());
  j.write_fieldname("freqDomainLength");
  freq_domain_len.to_json(j);
  j.write_int("zeroCorrelZoneConfig", zero_correl_zone_cfg);
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

const char* nr_prach_cfg_item_s::prach_fdm_opts::to_string() const
{
  static const char* names[] = {"one", "two", "four", "eight"};
  return convert_enum_idx(names, 4, value, "nr_prach_cfg_item_s::prach_fdm_e_");
}
uint8_t nr_prach_cfg_item_s::prach_fdm_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 4, 8};
  return map_enum_number(numbers, 4, value, "nr_prach_cfg_item_s::prach_fdm_e_");
}

const char* nr_prach_cfg_item_s::ssb_per_rach_occasion_opts::to_string() const
{
  static const char* names[] = {"oneEighth", "oneFourth", "oneHalf", "one", "two", "four", "eight", "sixteen"};
  return convert_enum_idx(names, 8, value, "nr_prach_cfg_item_s::ssb_per_rach_occasion_e_");
}
float nr_prach_cfg_item_s::ssb_per_rach_occasion_opts::to_number() const
{
  static const float numbers[] = {0.125, 0.25, 0.5, 1.0, 2.0, 4.0, 8.0, 6.0};
  return map_enum_number(numbers, 8, value, "nr_prach_cfg_item_s::ssb_per_rach_occasion_e_");
}
const char* nr_prach_cfg_item_s::ssb_per_rach_occasion_opts::to_number_string() const
{
  static const char* number_strs[] = {"1/8", "1/4", "1/2", "1", "2", "4", "8", "6"};
  return convert_enum_idx(number_strs, 8, value, "nr_prach_cfg_item_s::ssb_per_rach_occasion_e_");
}

// FDD-InfoRel16 ::= SEQUENCE
SRSASN_CODE fdd_info_rel16_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ul_freq_info_present, 1));
  HANDLE_CODE(bref.pack(sul_freq_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ul_freq_info_present) {
    HANDLE_CODE(ul_freq_info.pack(bref));
  }
  if (sul_freq_info_present) {
    HANDLE_CODE(sul_freq_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE fdd_info_rel16_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ul_freq_info_present, 1));
  HANDLE_CODE(bref.unpack(sul_freq_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ul_freq_info_present) {
    HANDLE_CODE(ul_freq_info.unpack(bref));
  }
  if (sul_freq_info_present) {
    HANDLE_CODE(sul_freq_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void fdd_info_rel16_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ul_freq_info_present) {
    j.write_fieldname("uL-FreqInfo");
    ul_freq_info.to_json(j);
  }
  if (sul_freq_info_present) {
    j.write_fieldname("sUL-FreqInfo");
    sul_freq_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TDD-InfoRel16 ::= SEQUENCE
SRSASN_CODE tdd_info_rel16_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(tdd_freq_info_present, 1));
  HANDLE_CODE(bref.pack(sul_freq_info_present, 1));
  HANDLE_CODE(bref.pack(tdd_ul_dl_cfg_common_nr.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (tdd_freq_info_present) {
    HANDLE_CODE(tdd_freq_info.pack(bref));
  }
  if (sul_freq_info_present) {
    HANDLE_CODE(sul_freq_info.pack(bref));
  }
  if (tdd_ul_dl_cfg_common_nr.size() > 0) {
    HANDLE_CODE(tdd_ul_dl_cfg_common_nr.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tdd_info_rel16_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(tdd_freq_info_present, 1));
  HANDLE_CODE(bref.unpack(sul_freq_info_present, 1));
  bool tdd_ul_dl_cfg_common_nr_present;
  HANDLE_CODE(bref.unpack(tdd_ul_dl_cfg_common_nr_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (tdd_freq_info_present) {
    HANDLE_CODE(tdd_freq_info.unpack(bref));
  }
  if (sul_freq_info_present) {
    HANDLE_CODE(sul_freq_info.unpack(bref));
  }
  if (tdd_ul_dl_cfg_common_nr_present) {
    HANDLE_CODE(tdd_ul_dl_cfg_common_nr.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tdd_info_rel16_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (tdd_freq_info_present) {
    j.write_fieldname("tDD-FreqInfo");
    tdd_freq_info.to_json(j);
  }
  if (sul_freq_info_present) {
    j.write_fieldname("sUL-FreqInfo");
    sul_freq_info.to_json(j);
  }
  if (tdd_ul_dl_cfg_common_nr.size() > 0) {
    j.write_str("tDD-UL-DLConfigCommonNR", tdd_ul_dl_cfg_common_nr.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NR-ModeInfoRel16 ::= CHOICE
void nr_mode_info_rel16_c::destroy_()
{
  switch (type_) {
    case types::fdd:
      c.destroy<fdd_info_rel16_s>();
      break;
    case types::tdd:
      c.destroy<tdd_info_rel16_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void nr_mode_info_rel16_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::fdd:
      c.init<fdd_info_rel16_s>();
      break;
    case types::tdd:
      c.init<tdd_info_rel16_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_rel16_c");
  }
}
nr_mode_info_rel16_c::nr_mode_info_rel16_c(const nr_mode_info_rel16_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::fdd:
      c.init(other.c.get<fdd_info_rel16_s>());
      break;
    case types::tdd:
      c.init(other.c.get<tdd_info_rel16_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_rel16_c");
  }
}
nr_mode_info_rel16_c& nr_mode_info_rel16_c::operator=(const nr_mode_info_rel16_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::fdd:
      c.set(other.c.get<fdd_info_rel16_s>());
      break;
    case types::tdd:
      c.set(other.c.get<tdd_info_rel16_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_rel16_c");
  }

  return *this;
}
fdd_info_rel16_s& nr_mode_info_rel16_c::set_fdd()
{
  set(types::fdd);
  return c.get<fdd_info_rel16_s>();
}
tdd_info_rel16_s& nr_mode_info_rel16_c::set_tdd()
{
  set(types::tdd);
  return c.get<tdd_info_rel16_s>();
}
protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>& nr_mode_info_rel16_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>>();
}
void nr_mode_info_rel16_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::fdd:
      j.write_fieldname("fDD");
      c.get<fdd_info_rel16_s>().to_json(j);
      break;
    case types::tdd:
      j.write_fieldname("tDD");
      c.get<tdd_info_rel16_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_rel16_c");
  }
  j.end_obj();
}
SRSASN_CODE nr_mode_info_rel16_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<fdd_info_rel16_s>().pack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<tdd_info_rel16_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_rel16_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_mode_info_rel16_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<fdd_info_rel16_s>().unpack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<tdd_info_rel16_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<nr_mode_info_rel16_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_rel16_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* nr_mode_info_rel16_c::types_opts::to_string() const
{
  static const char* names[] = {"fDD", "tDD", "choice-extension"};
  return convert_enum_idx(names, 3, value, "nr_mode_info_rel16_c::types");
}

// NRPRACHConfig ::= SEQUENCE
SRSASN_CODE nr_prach_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ul_prach_cfg_list_present, 1));
  HANDLE_CODE(bref.pack(sul_prach_cfg_list_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  if (ul_prach_cfg_list_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ul_prach_cfg_list, 0, 16, true));
  }
  if (sul_prach_cfg_list_present) {
    HANDLE_CODE(pack_dyn_seq_of(bref, sul_prach_cfg_list, 0, 16, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_prach_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ul_prach_cfg_list_present, 1));
  HANDLE_CODE(bref.unpack(sul_prach_cfg_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  if (ul_prach_cfg_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ul_prach_cfg_list, bref, 0, 16, true));
  }
  if (sul_prach_cfg_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(sul_prach_cfg_list, bref, 0, 16, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_prach_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ul_prach_cfg_list_present) {
    j.start_array("ulPRACHConfigList");
    for (const auto& e1 : ul_prach_cfg_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (sul_prach_cfg_list_present) {
    j.start_array("sulPRACHConfigList");
    for (const auto& e1 : sul_prach_cfg_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// SSB-PositionsInBurst ::= CHOICE
void ssb_positions_in_burst_c::destroy_()
{
  switch (type_) {
    case types::short_bitmap:
      c.destroy<fixed_bitstring<4, false, true>>();
      break;
    case types::medium_bitmap:
      c.destroy<fixed_bitstring<8, false, true>>();
      break;
    case types::long_bitmap:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ssb_positions_in_burst_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::short_bitmap:
      c.init<fixed_bitstring<4, false, true>>();
      break;
    case types::medium_bitmap:
      c.init<fixed_bitstring<8, false, true>>();
      break;
    case types::long_bitmap:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ssb_positions_in_burst_c");
  }
}
ssb_positions_in_burst_c::ssb_positions_in_burst_c(const ssb_positions_in_burst_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::short_bitmap:
      c.init(other.c.get<fixed_bitstring<4, false, true>>());
      break;
    case types::medium_bitmap:
      c.init(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::long_bitmap:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ssb_positions_in_burst_c");
  }
}
ssb_positions_in_burst_c& ssb_positions_in_burst_c::operator=(const ssb_positions_in_burst_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::short_bitmap:
      c.set(other.c.get<fixed_bitstring<4, false, true>>());
      break;
    case types::medium_bitmap:
      c.set(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::long_bitmap:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ssb_positions_in_burst_c");
  }

  return *this;
}
fixed_bitstring<4, false, true>& ssb_positions_in_burst_c::set_short_bitmap()
{
  set(types::short_bitmap);
  return c.get<fixed_bitstring<4, false, true>>();
}
fixed_bitstring<8, false, true>& ssb_positions_in_burst_c::set_medium_bitmap()
{
  set(types::medium_bitmap);
  return c.get<fixed_bitstring<8, false, true>>();
}
fixed_bitstring<64, false, true>& ssb_positions_in_burst_c::set_long_bitmap()
{
  set(types::long_bitmap);
  return c.get<fixed_bitstring<64, false, true>>();
}
protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>& ssb_positions_in_burst_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>();
}
void ssb_positions_in_burst_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::short_bitmap:
      j.write_str("shortBitmap", c.get<fixed_bitstring<4, false, true>>().to_string());
      break;
    case types::medium_bitmap:
      j.write_str("mediumBitmap", c.get<fixed_bitstring<8, false, true>>().to_string());
      break;
    case types::long_bitmap:
      j.write_str("longBitmap", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ssb_positions_in_burst_c");
  }
  j.end_obj();
}
SRSASN_CODE ssb_positions_in_burst_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::short_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<4, false, true>>().pack(bref)));
      break;
    case types::medium_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().pack(bref)));
      break;
    case types::long_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ssb_positions_in_burst_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_positions_in_burst_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::short_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<4, false, true>>().unpack(bref)));
      break;
    case types::medium_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().unpack(bref)));
      break;
    case types::long_bitmap:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ssb_positions_in_burst_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ssb_positions_in_burst_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ssb_positions_in_burst_c::types_opts::to_string() const
{
  static const char* names[] = {"shortBitmap", "mediumBitmap", "longBitmap", "choice-extension"};
  return convert_enum_idx(names, 4, value, "ssb_positions_in_burst_c::types");
}

// NeighbourNR-CellsForSON-Item ::= SEQUENCE
SRSASN_CODE neighbour_nr_cells_for_son_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nr_mode_info_rel16_present, 1));
  HANDLE_CODE(bref.pack(ssb_positions_in_burst_present, 1));
  HANDLE_CODE(bref.pack(nr_prach_cfg_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (nr_mode_info_rel16_present) {
    HANDLE_CODE(nr_mode_info_rel16.pack(bref));
  }
  if (ssb_positions_in_burst_present) {
    HANDLE_CODE(ssb_positions_in_burst.pack(bref));
  }
  if (nr_prach_cfg_present) {
    HANDLE_CODE(nr_prach_cfg.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE neighbour_nr_cells_for_son_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nr_mode_info_rel16_present, 1));
  HANDLE_CODE(bref.unpack(ssb_positions_in_burst_present, 1));
  HANDLE_CODE(bref.unpack(nr_prach_cfg_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (nr_mode_info_rel16_present) {
    HANDLE_CODE(nr_mode_info_rel16.unpack(bref));
  }
  if (ssb_positions_in_burst_present) {
    HANDLE_CODE(ssb_positions_in_burst.unpack(bref));
  }
  if (nr_prach_cfg_present) {
    HANDLE_CODE(nr_prach_cfg.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void neighbour_nr_cells_for_son_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (nr_mode_info_rel16_present) {
    j.write_fieldname("nR-ModeInfoRel16");
    nr_mode_info_rel16.to_json(j);
  }
  if (ssb_positions_in_burst_present) {
    j.write_fieldname("sSB-PositionsInBurst");
    ssb_positions_in_burst.to_json(j);
  }
  if (nr_prach_cfg_present) {
    j.write_fieldname("nRPRACHConfig");
    nr_prach_cfg.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellsForSON-Item ::= SEQUENCE
SRSASN_CODE cells_for_son_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(neighbour_nr_cells_for_son_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (neighbour_nr_cells_for_son_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, neighbour_nr_cells_for_son_list, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cells_for_son_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool neighbour_nr_cells_for_son_list_present;
  HANDLE_CODE(bref.unpack(neighbour_nr_cells_for_son_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (neighbour_nr_cells_for_son_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(neighbour_nr_cells_for_son_list, bref, 1, 32, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void cells_for_son_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (neighbour_nr_cells_for_son_list.size() > 0) {
    j.start_array("neighbourNR-CellsForSON-List");
    for (const auto& e1 : neighbour_nr_cells_for_son_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DU-RX-MT-RX-Extend ::= ENUMERATED
const char* du_rx_mt_rx_extend_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported", "supported-and-FDM-required"};
  return convert_enum_idx(names, 3, value, "du_rx_mt_rx_extend_e");
}

// DU-RX-MT-TX-Extend ::= ENUMERATED
const char* du_rx_mt_tx_extend_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported", "supported-and-FDM-required"};
  return convert_enum_idx(names, 3, value, "du_rx_mt_tx_extend_e");
}

// DU-TX-MT-RX-Extend ::= ENUMERATED
const char* du_tx_mt_rx_extend_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported", "supported-and-FDM-required"};
  return convert_enum_idx(names, 3, value, "du_tx_mt_rx_extend_e");
}

// DU-TX-MT-TX-Extend ::= ENUMERATED
const char* du_tx_mt_tx_extend_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported", "supported-and-FDM-required"};
  return convert_enum_idx(names, 3, value, "du_tx_mt_tx_extend_e");
}

// DU-RX-MT-RX ::= ENUMERATED
const char* du_rx_mt_rx_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported"};
  return convert_enum_idx(names, 2, value, "du_rx_mt_rx_e");
}

// DU-RX-MT-TX ::= ENUMERATED
const char* du_rx_mt_tx_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported"};
  return convert_enum_idx(names, 2, value, "du_rx_mt_tx_e");
}

// DU-TX-MT-RX ::= ENUMERATED
const char* du_tx_mt_rx_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported"};
  return convert_enum_idx(names, 2, value, "du_tx_mt_rx_e");
}

// DU-TX-MT-TX ::= ENUMERATED
const char* du_tx_mt_tx_opts::to_string() const
{
  static const char* names[] = {"supported", "not-supported"};
  return convert_enum_idx(names, 2, value, "du_tx_mt_tx_e");
}

// IAB-MT-Cell-List-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t iab_mt_cell_list_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {637, 638, 639, 640};
  return map_enum_number(names, 4, idx, "id");
}
bool iab_mt_cell_list_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {637, 638, 639, 640};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e iab_mt_cell_list_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 637:
      return crit_e::ignore;
    case 638:
      return crit_e::ignore;
    case 639:
      return crit_e::ignore;
    case 640:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
iab_mt_cell_list_item_ext_ies_o::ext_c iab_mt_cell_list_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 637:
      ret.set(ext_c::types::du_rx_mt_rx_extend);
      break;
    case 638:
      ret.set(ext_c::types::du_tx_mt_tx_extend);
      break;
    case 639:
      ret.set(ext_c::types::du_rx_mt_tx_extend);
      break;
    case 640:
      ret.set(ext_c::types::du_tx_mt_rx_extend);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e iab_mt_cell_list_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 637:
      return presence_e::optional;
    case 638:
      return presence_e::optional;
    case 639:
      return presence_e::optional;
    case 640:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void iab_mt_cell_list_item_ext_ies_o::ext_c::destroy_() {}
void iab_mt_cell_list_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
iab_mt_cell_list_item_ext_ies_o::ext_c::ext_c(const iab_mt_cell_list_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::du_rx_mt_rx_extend:
      c.init(other.c.get<du_rx_mt_rx_extend_e>());
      break;
    case types::du_tx_mt_tx_extend:
      c.init(other.c.get<du_tx_mt_tx_extend_e>());
      break;
    case types::du_rx_mt_tx_extend:
      c.init(other.c.get<du_rx_mt_tx_extend_e>());
      break;
    case types::du_tx_mt_rx_extend:
      c.init(other.c.get<du_tx_mt_rx_extend_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_mt_cell_list_item_ext_ies_o::ext_c");
  }
}
iab_mt_cell_list_item_ext_ies_o::ext_c&
iab_mt_cell_list_item_ext_ies_o::ext_c::operator=(const iab_mt_cell_list_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::du_rx_mt_rx_extend:
      c.set(other.c.get<du_rx_mt_rx_extend_e>());
      break;
    case types::du_tx_mt_tx_extend:
      c.set(other.c.get<du_tx_mt_tx_extend_e>());
      break;
    case types::du_rx_mt_tx_extend:
      c.set(other.c.get<du_rx_mt_tx_extend_e>());
      break;
    case types::du_tx_mt_rx_extend:
      c.set(other.c.get<du_tx_mt_rx_extend_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_mt_cell_list_item_ext_ies_o::ext_c");
  }

  return *this;
}
du_rx_mt_rx_extend_e& iab_mt_cell_list_item_ext_ies_o::ext_c::du_rx_mt_rx_extend()
{
  assert_choice_type(types::du_rx_mt_rx_extend, type_, "Extension");
  return c.get<du_rx_mt_rx_extend_e>();
}
du_tx_mt_tx_extend_e& iab_mt_cell_list_item_ext_ies_o::ext_c::du_tx_mt_tx_extend()
{
  assert_choice_type(types::du_tx_mt_tx_extend, type_, "Extension");
  return c.get<du_tx_mt_tx_extend_e>();
}
du_rx_mt_tx_extend_e& iab_mt_cell_list_item_ext_ies_o::ext_c::du_rx_mt_tx_extend()
{
  assert_choice_type(types::du_rx_mt_tx_extend, type_, "Extension");
  return c.get<du_rx_mt_tx_extend_e>();
}
du_tx_mt_rx_extend_e& iab_mt_cell_list_item_ext_ies_o::ext_c::du_tx_mt_rx_extend()
{
  assert_choice_type(types::du_tx_mt_rx_extend, type_, "Extension");
  return c.get<du_tx_mt_rx_extend_e>();
}
const du_rx_mt_rx_extend_e& iab_mt_cell_list_item_ext_ies_o::ext_c::du_rx_mt_rx_extend() const
{
  assert_choice_type(types::du_rx_mt_rx_extend, type_, "Extension");
  return c.get<du_rx_mt_rx_extend_e>();
}
const du_tx_mt_tx_extend_e& iab_mt_cell_list_item_ext_ies_o::ext_c::du_tx_mt_tx_extend() const
{
  assert_choice_type(types::du_tx_mt_tx_extend, type_, "Extension");
  return c.get<du_tx_mt_tx_extend_e>();
}
const du_rx_mt_tx_extend_e& iab_mt_cell_list_item_ext_ies_o::ext_c::du_rx_mt_tx_extend() const
{
  assert_choice_type(types::du_rx_mt_tx_extend, type_, "Extension");
  return c.get<du_rx_mt_tx_extend_e>();
}
const du_tx_mt_rx_extend_e& iab_mt_cell_list_item_ext_ies_o::ext_c::du_tx_mt_rx_extend() const
{
  assert_choice_type(types::du_tx_mt_rx_extend, type_, "Extension");
  return c.get<du_tx_mt_rx_extend_e>();
}
void iab_mt_cell_list_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::du_rx_mt_rx_extend:
      j.write_str("DU-RX-MT-RX-Extend", c.get<du_rx_mt_rx_extend_e>().to_string());
      break;
    case types::du_tx_mt_tx_extend:
      j.write_str("DU-TX-MT-TX-Extend", c.get<du_tx_mt_tx_extend_e>().to_string());
      break;
    case types::du_rx_mt_tx_extend:
      j.write_str("DU-RX-MT-TX-Extend", c.get<du_rx_mt_tx_extend_e>().to_string());
      break;
    case types::du_tx_mt_rx_extend:
      j.write_str("DU-TX-MT-RX-Extend", c.get<du_tx_mt_rx_extend_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "iab_mt_cell_list_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE iab_mt_cell_list_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::du_rx_mt_rx_extend:
      HANDLE_CODE(c.get<du_rx_mt_rx_extend_e>().pack(bref));
      break;
    case types::du_tx_mt_tx_extend:
      HANDLE_CODE(c.get<du_tx_mt_tx_extend_e>().pack(bref));
      break;
    case types::du_rx_mt_tx_extend:
      HANDLE_CODE(c.get<du_rx_mt_tx_extend_e>().pack(bref));
      break;
    case types::du_tx_mt_rx_extend:
      HANDLE_CODE(c.get<du_tx_mt_rx_extend_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_mt_cell_list_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_mt_cell_list_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::du_rx_mt_rx_extend:
      HANDLE_CODE(c.get<du_rx_mt_rx_extend_e>().unpack(bref));
      break;
    case types::du_tx_mt_tx_extend:
      HANDLE_CODE(c.get<du_tx_mt_tx_extend_e>().unpack(bref));
      break;
    case types::du_rx_mt_tx_extend:
      HANDLE_CODE(c.get<du_rx_mt_tx_extend_e>().unpack(bref));
      break;
    case types::du_tx_mt_rx_extend:
      HANDLE_CODE(c.get<du_tx_mt_rx_extend_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_mt_cell_list_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE iab_mt_cell_list_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += du_rx_mt_rx_extend_present ? 1 : 0;
  nof_ies += du_tx_mt_tx_extend_present ? 1 : 0;
  nof_ies += du_rx_mt_tx_extend_present ? 1 : 0;
  nof_ies += du_tx_mt_rx_extend_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (du_rx_mt_rx_extend_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)637, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(du_rx_mt_rx_extend.pack(bref));
  }
  if (du_tx_mt_tx_extend_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)638, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(du_tx_mt_tx_extend.pack(bref));
  }
  if (du_rx_mt_tx_extend_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)639, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(du_rx_mt_tx_extend.pack(bref));
  }
  if (du_tx_mt_rx_extend_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)640, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(du_tx_mt_rx_extend.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_mt_cell_list_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 637: {
        du_rx_mt_rx_extend_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(du_rx_mt_rx_extend.unpack(bref));
        break;
      }
      case 638: {
        du_tx_mt_tx_extend_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(du_tx_mt_tx_extend.unpack(bref));
        break;
      }
      case 639: {
        du_rx_mt_tx_extend_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(du_rx_mt_tx_extend.unpack(bref));
        break;
      }
      case 640: {
        du_tx_mt_rx_extend_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(du_tx_mt_rx_extend.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void iab_mt_cell_list_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (du_rx_mt_rx_extend_present) {
    j.write_int("id", 637);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", du_rx_mt_rx_extend.to_string());
  }
  if (du_tx_mt_tx_extend_present) {
    j.write_int("id", 638);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", du_tx_mt_tx_extend.to_string());
  }
  if (du_rx_mt_tx_extend_present) {
    j.write_int("id", 639);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", du_rx_mt_tx_extend.to_string());
  }
  if (du_tx_mt_rx_extend_present) {
    j.write_int("id", 640);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", du_tx_mt_rx_extend.to_string());
  }
  j.end_obj();
}

// IAB-MT-Cell-List-Item ::= SEQUENCE
SRSASN_CODE iab_mt_cell_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cell_id.pack(bref));
  HANDLE_CODE(du_rx_mt_rx.pack(bref));
  HANDLE_CODE(du_tx_mt_tx.pack(bref));
  HANDLE_CODE(du_rx_mt_tx.pack(bref));
  HANDLE_CODE(du_tx_mt_rx.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_mt_cell_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cell_id.unpack(bref));
  HANDLE_CODE(du_rx_mt_rx.unpack(bref));
  HANDLE_CODE(du_tx_mt_tx.unpack(bref));
  HANDLE_CODE(du_rx_mt_tx.unpack(bref));
  HANDLE_CODE(du_tx_mt_rx.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_mt_cell_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nRCellIdentity", nr_cell_id.to_string());
  j.write_str("dU-RX-MT-RX", du_rx_mt_rx.to_string());
  j.write_str("dU-TX-MT-TX", du_tx_mt_tx.to_string());
  j.write_str("dU-RX-MT-TX", du_rx_mt_tx.to_string());
  j.write_str("dU-TX-MT-RX", du_tx_mt_rx.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MultiplexingInfo ::= SEQUENCE
SRSASN_CODE mux_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, iab_mt_cell_list, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mux_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(iab_mt_cell_list, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mux_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("iAB-MT-Cell-List");
  for (const auto& e1 : iab_mt_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Child-Node-Cells-List-Item ::= SEQUENCE
SRSASN_CODE child_node_cells_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(iab_du_cell_res_cfg_mode_info_present, 1));
  HANDLE_CODE(bref.pack(iab_stc_info_present, 1));
  HANDLE_CODE(bref.pack(rach_cfg_common.size() > 0, 1));
  HANDLE_CODE(bref.pack(rach_cfg_common_iab.size() > 0, 1));
  HANDLE_CODE(bref.pack(csi_rs_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(sr_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(pdcch_cfg_sib1.size() > 0, 1));
  HANDLE_CODE(bref.pack(scs_common.size() > 0, 1));
  HANDLE_CODE(bref.pack(mux_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (iab_du_cell_res_cfg_mode_info_present) {
    HANDLE_CODE(iab_du_cell_res_cfg_mode_info.pack(bref));
  }
  if (iab_stc_info_present) {
    HANDLE_CODE(iab_stc_info.pack(bref));
  }
  if (rach_cfg_common.size() > 0) {
    HANDLE_CODE(rach_cfg_common.pack(bref));
  }
  if (rach_cfg_common_iab.size() > 0) {
    HANDLE_CODE(rach_cfg_common_iab.pack(bref));
  }
  if (csi_rs_cfg.size() > 0) {
    HANDLE_CODE(csi_rs_cfg.pack(bref));
  }
  if (sr_cfg.size() > 0) {
    HANDLE_CODE(sr_cfg.pack(bref));
  }
  if (pdcch_cfg_sib1.size() > 0) {
    HANDLE_CODE(pdcch_cfg_sib1.pack(bref));
  }
  if (scs_common.size() > 0) {
    HANDLE_CODE(scs_common.pack(bref));
  }
  if (mux_info_present) {
    HANDLE_CODE(mux_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE child_node_cells_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(iab_du_cell_res_cfg_mode_info_present, 1));
  HANDLE_CODE(bref.unpack(iab_stc_info_present, 1));
  bool rach_cfg_common_present;
  HANDLE_CODE(bref.unpack(rach_cfg_common_present, 1));
  bool rach_cfg_common_iab_present;
  HANDLE_CODE(bref.unpack(rach_cfg_common_iab_present, 1));
  bool csi_rs_cfg_present;
  HANDLE_CODE(bref.unpack(csi_rs_cfg_present, 1));
  bool sr_cfg_present;
  HANDLE_CODE(bref.unpack(sr_cfg_present, 1));
  bool pdcch_cfg_sib1_present;
  HANDLE_CODE(bref.unpack(pdcch_cfg_sib1_present, 1));
  bool scs_common_present;
  HANDLE_CODE(bref.unpack(scs_common_present, 1));
  HANDLE_CODE(bref.unpack(mux_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (iab_du_cell_res_cfg_mode_info_present) {
    HANDLE_CODE(iab_du_cell_res_cfg_mode_info.unpack(bref));
  }
  if (iab_stc_info_present) {
    HANDLE_CODE(iab_stc_info.unpack(bref));
  }
  if (rach_cfg_common_present) {
    HANDLE_CODE(rach_cfg_common.unpack(bref));
  }
  if (rach_cfg_common_iab_present) {
    HANDLE_CODE(rach_cfg_common_iab.unpack(bref));
  }
  if (csi_rs_cfg_present) {
    HANDLE_CODE(csi_rs_cfg.unpack(bref));
  }
  if (sr_cfg_present) {
    HANDLE_CODE(sr_cfg.unpack(bref));
  }
  if (pdcch_cfg_sib1_present) {
    HANDLE_CODE(pdcch_cfg_sib1.unpack(bref));
  }
  if (scs_common_present) {
    HANDLE_CODE(scs_common.unpack(bref));
  }
  if (mux_info_present) {
    HANDLE_CODE(mux_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void child_node_cells_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (iab_du_cell_res_cfg_mode_info_present) {
    j.write_fieldname("iAB-DU-Cell-Resource-Configuration-Mode-Info");
    iab_du_cell_res_cfg_mode_info.to_json(j);
  }
  if (iab_stc_info_present) {
    j.write_fieldname("iAB-STC-Info");
    iab_stc_info.to_json(j);
  }
  if (rach_cfg_common.size() > 0) {
    j.write_str("rACH-Config-Common", rach_cfg_common.to_string());
  }
  if (rach_cfg_common_iab.size() > 0) {
    j.write_str("rACH-Config-Common-IAB", rach_cfg_common_iab.to_string());
  }
  if (csi_rs_cfg.size() > 0) {
    j.write_str("cSI-RS-Configuration", csi_rs_cfg.to_string());
  }
  if (sr_cfg.size() > 0) {
    j.write_str("sR-Configuration", sr_cfg.to_string());
  }
  if (pdcch_cfg_sib1.size() > 0) {
    j.write_str("pDCCH-ConfigSIB1", pdcch_cfg_sib1.to_string());
  }
  if (scs_common.size() > 0) {
    j.write_str("sCS-Common", scs_common.to_string());
  }
  if (mux_info_present) {
    j.write_fieldname("multiplexingInfo");
    mux_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Child-Nodes-List-Item ::= SEQUENCE
SRSASN_CODE child_nodes_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(child_node_cells_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, gnb_cu_ue_f1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  HANDLE_CODE(pack_integer(bref, gnb_du_ue_f1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (child_node_cells_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, child_node_cells_list, 1, 1024, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE child_nodes_list_item_s::unpack(cbit_ref& bref)
{
  bool child_node_cells_list_present;
  HANDLE_CODE(bref.unpack(child_node_cells_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(gnb_cu_ue_f1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  HANDLE_CODE(unpack_integer(gnb_du_ue_f1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  if (child_node_cells_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(child_node_cells_list, bref, 1, 1024, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void child_nodes_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("gNB-CU-UE-F1AP-ID", gnb_cu_ue_f1ap_id);
  j.write_int("gNB-DU-UE-F1AP-ID", gnb_du_ue_f1ap_id);
  if (child_node_cells_list.size() > 0) {
    j.start_array("child-Node-Cells-List");
    for (const auto& e1 : child_node_cells_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRP-Beam-Power-Item ::= SEQUENCE
SRSASN_CODE trp_beam_pwr_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(prs_res_set_id_present, 1));
  HANDLE_CODE(bref.pack(relative_pwr_fine_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (prs_res_set_id_present) {
    HANDLE_CODE(pack_integer(bref, prs_res_set_id, (uint8_t)0u, (uint8_t)7u, false, true));
  }
  HANDLE_CODE(pack_integer(bref, prs_res_id, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(pack_integer(bref, relative_pwr, (uint8_t)0u, (uint8_t)30u, false, true));
  if (relative_pwr_fine_present) {
    HANDLE_CODE(pack_integer(bref, relative_pwr_fine, (uint8_t)0u, (uint8_t)9u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_beam_pwr_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(prs_res_set_id_present, 1));
  HANDLE_CODE(bref.unpack(relative_pwr_fine_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (prs_res_set_id_present) {
    HANDLE_CODE(unpack_integer(prs_res_set_id, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  }
  HANDLE_CODE(unpack_integer(prs_res_id, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(unpack_integer(relative_pwr, bref, (uint8_t)0u, (uint8_t)30u, false, true));
  if (relative_pwr_fine_present) {
    HANDLE_CODE(unpack_integer(relative_pwr_fine, bref, (uint8_t)0u, (uint8_t)9u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_beam_pwr_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (prs_res_set_id_present) {
    j.write_int("pRSResourceSetID", prs_res_set_id);
  }
  j.write_int("pRSResourceID", prs_res_id);
  j.write_int("relativePower", relative_pwr);
  if (relative_pwr_fine_present) {
    j.write_int("relativePowerFine", relative_pwr_fine);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRP-ElevationAngleList-Item ::= SEQUENCE
SRSASN_CODE trp_elevation_angle_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(trp_elevation_angle_fine_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, trp_elevation_angle, (uint8_t)0u, (uint8_t)180u, false, true));
  if (trp_elevation_angle_fine_present) {
    HANDLE_CODE(pack_integer(bref, trp_elevation_angle_fine, (uint8_t)0u, (uint8_t)9u, false, true));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, trp_beam_pwr_list, 2, 24, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_elevation_angle_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(trp_elevation_angle_fine_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(trp_elevation_angle, bref, (uint8_t)0u, (uint8_t)180u, false, true));
  if (trp_elevation_angle_fine_present) {
    HANDLE_CODE(unpack_integer(trp_elevation_angle_fine, bref, (uint8_t)0u, (uint8_t)9u, false, true));
  }
  HANDLE_CODE(unpack_dyn_seq_of(trp_beam_pwr_list, bref, 2, 24, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_elevation_angle_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("trp-elevation-angle", trp_elevation_angle);
  if (trp_elevation_angle_fine_present) {
    j.write_int("trp-elevation-angle-fine", trp_elevation_angle_fine);
  }
  j.start_array("trp-beam-power-list");
  for (const auto& e1 : trp_beam_pwr_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRP-BeamAntennaAnglesList-Item ::= SEQUENCE
SRSASN_CODE trp_beam_ant_angles_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(trp_azimuth_angle_fine_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, trp_azimuth_angle, (uint16_t)0u, (uint16_t)359u, false, true));
  if (trp_azimuth_angle_fine_present) {
    HANDLE_CODE(pack_integer(bref, trp_azimuth_angle_fine, (uint8_t)0u, (uint8_t)9u, false, true));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, trp_elevation_angle_list, 1, 1801, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_beam_ant_angles_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(trp_azimuth_angle_fine_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(trp_azimuth_angle, bref, (uint16_t)0u, (uint16_t)359u, false, true));
  if (trp_azimuth_angle_fine_present) {
    HANDLE_CODE(unpack_integer(trp_azimuth_angle_fine, bref, (uint8_t)0u, (uint8_t)9u, false, true));
  }
  HANDLE_CODE(unpack_dyn_seq_of(trp_elevation_angle_list, bref, 1, 1801, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_beam_ant_angles_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("trp-azimuth-angle", trp_azimuth_angle);
  if (trp_azimuth_angle_fine_present) {
    j.write_int("trp-azimuth-angle-fine", trp_azimuth_angle_fine);
  }
  j.start_array("trp-elevation-angle-list");
  for (const auto& e1 : trp_elevation_angle_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRP-BeamAntennaExplicitInformation ::= SEQUENCE
SRSASN_CODE trp_beam_ant_explicit_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(lcs_to_gcs_translation_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, trp_beam_ant_angles, 1, 3600, true));
  if (lcs_to_gcs_translation_present) {
    HANDLE_CODE(lcs_to_gcs_translation.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_beam_ant_explicit_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(lcs_to_gcs_translation_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(trp_beam_ant_angles, bref, 1, 3600, true));
  if (lcs_to_gcs_translation_present) {
    HANDLE_CODE(lcs_to_gcs_translation.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_beam_ant_explicit_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("trp-BeamAntennaAngles");
  for (const auto& e1 : trp_beam_ant_angles) {
    e1.to_json(j);
  }
  j.end_array();
  if (lcs_to_gcs_translation_present) {
    j.write_fieldname("lcs-to-gcs-translation");
    lcs_to_gcs_translation.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Choice-TRP-Beam-Antenna-Info-Item ::= CHOICE
void choice_trp_beam_ant_info_item_c::destroy_()
{
  switch (type_) {
    case types::explicit_type:
      c.destroy<trp_beam_ant_explicit_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void choice_trp_beam_ant_info_item_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ref:
      break;
    case types::explicit_type:
      c.init<trp_beam_ant_explicit_info_s>();
      break;
    case types::no_change:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "choice_trp_beam_ant_info_item_c");
  }
}
choice_trp_beam_ant_info_item_c::choice_trp_beam_ant_info_item_c(const choice_trp_beam_ant_info_item_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ref:
      c.init(other.c.get<uint32_t>());
      break;
    case types::explicit_type:
      c.init(other.c.get<trp_beam_ant_explicit_info_s>());
      break;
    case types::no_change:
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "choice_trp_beam_ant_info_item_c");
  }
}
choice_trp_beam_ant_info_item_c&
choice_trp_beam_ant_info_item_c::operator=(const choice_trp_beam_ant_info_item_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ref:
      c.set(other.c.get<uint32_t>());
      break;
    case types::explicit_type:
      c.set(other.c.get<trp_beam_ant_explicit_info_s>());
      break;
    case types::no_change:
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "choice_trp_beam_ant_info_item_c");
  }

  return *this;
}
uint32_t& choice_trp_beam_ant_info_item_c::set_ref()
{
  set(types::ref);
  return c.get<uint32_t>();
}
trp_beam_ant_explicit_info_s& choice_trp_beam_ant_info_item_c::set_explicit_type()
{
  set(types::explicit_type);
  return c.get<trp_beam_ant_explicit_info_s>();
}
void choice_trp_beam_ant_info_item_c::set_no_change()
{
  set(types::no_change);
}
protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>& choice_trp_beam_ant_info_item_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>>();
}
void choice_trp_beam_ant_info_item_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ref:
      j.write_int("reference", c.get<uint32_t>());
      break;
    case types::explicit_type:
      j.write_fieldname("explicit");
      c.get<trp_beam_ant_explicit_info_s>().to_json(j);
      break;
    case types::no_change:
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "choice_trp_beam_ant_info_item_c");
  }
  j.end_obj();
}
SRSASN_CODE choice_trp_beam_ant_info_item_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ref:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::explicit_type:
      HANDLE_CODE(c.get<trp_beam_ant_explicit_info_s>().pack(bref));
      break;
    case types::no_change:
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "choice_trp_beam_ant_info_item_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE choice_trp_beam_ant_info_item_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ref:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::explicit_type:
      HANDLE_CODE(c.get<trp_beam_ant_explicit_info_s>().unpack(bref));
      break;
    case types::no_change:
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<choice_trp_beam_info_item_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "choice_trp_beam_ant_info_item_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* choice_trp_beam_ant_info_item_c::types_opts::to_string() const
{
  static const char* names[] = {"reference", "explicit", "noChange", "choice-extension"};
  return convert_enum_idx(names, 4, value, "choice_trp_beam_ant_info_item_c::types");
}

// CHOtrigger-InterDU ::= ENUMERATED
const char* ch_otrigger_inter_du_opts::to_string() const
{
  static const char* names[] = {"cho-initiation", "cho-replace"};
  return convert_enum_idx(names, 2, value, "ch_otrigger_inter_du_e");
}

// ConditionalInterDUMobilityInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t conditional_inter_du_mob_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {433};
  return map_enum_number(names, 1, idx, "id");
}
bool conditional_inter_du_mob_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 433 == id;
}
crit_e conditional_inter_du_mob_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 433) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
conditional_inter_du_mob_info_ext_ies_o::ext_c conditional_inter_du_mob_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 433) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e conditional_inter_du_mob_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 433) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void conditional_inter_du_mob_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..100)", c);
  j.end_obj();
}
SRSASN_CODE conditional_inter_du_mob_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)1u, (uint8_t)100u, false, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE conditional_inter_du_mob_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)1u, (uint8_t)100u, false, true));
  return SRSASN_SUCCESS;
}

// ConditionalInterDUMobilityInformation ::= SEQUENCE
SRSASN_CODE conditional_inter_du_mob_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(target_gnb_du_ue_f1ap_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(cho_trigger.pack(bref));
  if (target_gnb_du_ue_f1ap_id_present) {
    HANDLE_CODE(pack_integer(bref, target_gnb_du_ue_f1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE conditional_inter_du_mob_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(target_gnb_du_ue_f1ap_id_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cho_trigger.unpack(bref));
  if (target_gnb_du_ue_f1ap_id_present) {
    HANDLE_CODE(unpack_integer(target_gnb_du_ue_f1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void conditional_inter_du_mob_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cho-trigger", cho_trigger.to_string());
  if (target_gnb_du_ue_f1ap_id_present) {
    j.write_int("targetgNB-DUUEF1APID", target_gnb_du_ue_f1ap_id);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// TargetCellList-Item ::= SEQUENCE
SRSASN_CODE target_cell_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(target_cell.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE target_cell_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(target_cell.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void target_cell_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("target-cell");
  target_cell.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CHOtrigger-IntraDU ::= ENUMERATED
const char* ch_otrigger_intra_du_opts::to_string() const
{
  static const char* names[] = {"cho-initiation", "cho-replace", "cho-cancel"};
  return convert_enum_idx(names, 3, value, "ch_otrigger_intra_du_e");
}

// ConditionalIntraDUMobilityInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t conditional_intra_du_mob_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {433};
  return map_enum_number(names, 1, idx, "id");
}
bool conditional_intra_du_mob_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 433 == id;
}
crit_e conditional_intra_du_mob_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 433) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
conditional_intra_du_mob_info_ext_ies_o::ext_c conditional_intra_du_mob_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 433) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e conditional_intra_du_mob_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 433) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void conditional_intra_du_mob_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..100)", c);
  j.end_obj();
}
SRSASN_CODE conditional_intra_du_mob_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)1u, (uint8_t)100u, false, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE conditional_intra_du_mob_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)1u, (uint8_t)100u, false, true));
  return SRSASN_SUCCESS;
}

// ConditionalIntraDUMobilityInformation ::= SEQUENCE
SRSASN_CODE conditional_intra_du_mob_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(target_cells_tocancel.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(cho_trigger.pack(bref));
  if (target_cells_tocancel.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, target_cells_tocancel, 1, 8, true));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE conditional_intra_du_mob_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool target_cells_tocancel_present;
  HANDLE_CODE(bref.unpack(target_cells_tocancel_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cho_trigger.unpack(bref));
  if (target_cells_tocancel_present) {
    HANDLE_CODE(unpack_dyn_seq_of(target_cells_tocancel, bref, 1, 8, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void conditional_intra_du_mob_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cho-trigger", cho_trigger.to_string());
  if (target_cells_tocancel.size() > 0) {
    j.start_array("targetCellsTocancel");
    for (const auto& e1 : target_cells_tocancel) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// SSBCoverageModification-Item ::= SEQUENCE
SRSASN_CODE ssb_coverage_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_coverage_state, (uint8_t)0u, (uint8_t)15u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_coverage_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(unpack_integer(ssb_coverage_state, bref, (uint8_t)0u, (uint8_t)15u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_coverage_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSBIndex", ssb_idx);
  j.write_int("sSBCoverageState", ssb_coverage_state);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Coverage-Modification-Item ::= SEQUENCE
SRSASN_CODE coverage_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ssb_coverage_mod_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, cell_coverage_state, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ssb_coverage_mod_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ssb_coverage_mod_list, 1, 64, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE coverage_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ssb_coverage_mod_list_present;
  HANDLE_CODE(bref.unpack(ssb_coverage_mod_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(cell_coverage_state, bref, (uint8_t)0u, (uint8_t)63u, true, true));
  if (ssb_coverage_mod_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ssb_coverage_mod_list, bref, 1, 64, true));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void coverage_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  j.write_int("cellCoverageState", cell_coverage_state);
  if (ssb_coverage_mod_list.size() > 0) {
    j.start_array("sSBCoverageModificationList");
    for (const auto& e1 : ssb_coverage_mod_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// Coverage-Modification-Notification ::= SEQUENCE
SRSASN_CODE coverage_mod_notif_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, coverage_mod_list, 1, 512, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE coverage_mod_notif_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(coverage_mod_list, bref, 1, 512, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void coverage_mod_notif_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("coverage-Modification-List");
  for (const auto& e1 : coverage_mod_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DL-PRS ::= SEQUENCE
SRSASN_CODE dl_prs_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(dl_prs_res_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prsid, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pack_integer(bref, dl_prs_res_set_id, (uint8_t)0u, (uint8_t)7u, false, true));
  if (dl_prs_res_id_present) {
    HANDLE_CODE(pack_integer(bref, dl_prs_res_id, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_prs_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(dl_prs_res_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prsid, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(unpack_integer(dl_prs_res_set_id, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  if (dl_prs_res_id_present) {
    HANDLE_CODE(unpack_integer(dl_prs_res_id, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dl_prs_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("prsid", prsid);
  j.write_int("dl-PRSResourceSetID", dl_prs_res_set_id);
  if (dl_prs_res_id_present) {
    j.write_int("dl-PRSResourceID", dl_prs_res_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DL-PRSMutingPattern ::= CHOICE
void dl_prs_muting_pattern_c::destroy_()
{
  switch (type_) {
    case types::two:
      c.destroy<fixed_bitstring<2, false, true>>();
      break;
    case types::four:
      c.destroy<fixed_bitstring<4, false, true>>();
      break;
    case types::six:
      c.destroy<fixed_bitstring<6, false, true>>();
      break;
    case types::eight:
      c.destroy<fixed_bitstring<8, false, true>>();
      break;
    case types::sixteen:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::thirty_two:
      c.destroy<fixed_bitstring<32, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void dl_prs_muting_pattern_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::two:
      c.init<fixed_bitstring<2, false, true>>();
      break;
    case types::four:
      c.init<fixed_bitstring<4, false, true>>();
      break;
    case types::six:
      c.init<fixed_bitstring<6, false, true>>();
      break;
    case types::eight:
      c.init<fixed_bitstring<8, false, true>>();
      break;
    case types::sixteen:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::thirty_two:
      c.init<fixed_bitstring<32, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_muting_pattern_c");
  }
}
dl_prs_muting_pattern_c::dl_prs_muting_pattern_c(const dl_prs_muting_pattern_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::two:
      c.init(other.c.get<fixed_bitstring<2, false, true>>());
      break;
    case types::four:
      c.init(other.c.get<fixed_bitstring<4, false, true>>());
      break;
    case types::six:
      c.init(other.c.get<fixed_bitstring<6, false, true>>());
      break;
    case types::eight:
      c.init(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::sixteen:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::thirty_two:
      c.init(other.c.get<fixed_bitstring<32, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_muting_pattern_c");
  }
}
dl_prs_muting_pattern_c& dl_prs_muting_pattern_c::operator=(const dl_prs_muting_pattern_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::two:
      c.set(other.c.get<fixed_bitstring<2, false, true>>());
      break;
    case types::four:
      c.set(other.c.get<fixed_bitstring<4, false, true>>());
      break;
    case types::six:
      c.set(other.c.get<fixed_bitstring<6, false, true>>());
      break;
    case types::eight:
      c.set(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::sixteen:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::thirty_two:
      c.set(other.c.get<fixed_bitstring<32, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_muting_pattern_c");
  }

  return *this;
}
fixed_bitstring<2, false, true>& dl_prs_muting_pattern_c::set_two()
{
  set(types::two);
  return c.get<fixed_bitstring<2, false, true>>();
}
fixed_bitstring<4, false, true>& dl_prs_muting_pattern_c::set_four()
{
  set(types::four);
  return c.get<fixed_bitstring<4, false, true>>();
}
fixed_bitstring<6, false, true>& dl_prs_muting_pattern_c::set_six()
{
  set(types::six);
  return c.get<fixed_bitstring<6, false, true>>();
}
fixed_bitstring<8, false, true>& dl_prs_muting_pattern_c::set_eight()
{
  set(types::eight);
  return c.get<fixed_bitstring<8, false, true>>();
}
fixed_bitstring<16, false, true>& dl_prs_muting_pattern_c::set_sixteen()
{
  set(types::sixteen);
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<32, false, true>& dl_prs_muting_pattern_c::set_thirty_two()
{
  set(types::thirty_two);
  return c.get<fixed_bitstring<32, false, true>>();
}
protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>& dl_prs_muting_pattern_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>>();
}
void dl_prs_muting_pattern_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::two:
      j.write_str("two", c.get<fixed_bitstring<2, false, true>>().to_string());
      break;
    case types::four:
      j.write_str("four", c.get<fixed_bitstring<4, false, true>>().to_string());
      break;
    case types::six:
      j.write_str("six", c.get<fixed_bitstring<6, false, true>>().to_string());
      break;
    case types::eight:
      j.write_str("eight", c.get<fixed_bitstring<8, false, true>>().to_string());
      break;
    case types::sixteen:
      j.write_str("sixteen", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::thirty_two:
      j.write_str("thirty-two", c.get<fixed_bitstring<32, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_muting_pattern_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_prs_muting_pattern_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::two:
      HANDLE_CODE((c.get<fixed_bitstring<2, false, true>>().pack(bref)));
      break;
    case types::four:
      HANDLE_CODE((c.get<fixed_bitstring<4, false, true>>().pack(bref)));
      break;
    case types::six:
      HANDLE_CODE((c.get<fixed_bitstring<6, false, true>>().pack(bref)));
      break;
    case types::eight:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().pack(bref)));
      break;
    case types::sixteen:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::thirty_two:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_muting_pattern_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_prs_muting_pattern_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::two:
      HANDLE_CODE((c.get<fixed_bitstring<2, false, true>>().unpack(bref)));
      break;
    case types::four:
      HANDLE_CODE((c.get<fixed_bitstring<4, false, true>>().unpack(bref)));
      break;
    case types::six:
      HANDLE_CODE((c.get<fixed_bitstring<6, false, true>>().unpack(bref)));
      break;
    case types::eight:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().unpack(bref)));
      break;
    case types::sixteen:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::thirty_two:
      HANDLE_CODE((c.get<fixed_bitstring<32, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<dl_prs_muting_pattern_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_muting_pattern_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_prs_muting_pattern_c::types_opts::to_string() const
{
  static const char* names[] = {"two", "four", "six", "eight", "sixteen", "thirty-two", "choice-extension"};
  return convert_enum_idx(names, 7, value, "dl_prs_muting_pattern_c::types");
}

// DL-PRSResourceARPLocation ::= CHOICE
void dl_prs_res_arp_location_c::destroy_()
{
  switch (type_) {
    case types::relative_geodetic_location:
      c.destroy<relative_geodetic_location_s>();
      break;
    case types::relative_cartesian_location:
      c.destroy<relative_cartesian_location_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void dl_prs_res_arp_location_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::relative_geodetic_location:
      c.init<relative_geodetic_location_s>();
      break;
    case types::relative_cartesian_location:
      c.init<relative_cartesian_location_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_res_arp_location_c");
  }
}
dl_prs_res_arp_location_c::dl_prs_res_arp_location_c(const dl_prs_res_arp_location_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::relative_geodetic_location:
      c.init(other.c.get<relative_geodetic_location_s>());
      break;
    case types::relative_cartesian_location:
      c.init(other.c.get<relative_cartesian_location_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_res_arp_location_c");
  }
}
dl_prs_res_arp_location_c& dl_prs_res_arp_location_c::operator=(const dl_prs_res_arp_location_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::relative_geodetic_location:
      c.set(other.c.get<relative_geodetic_location_s>());
      break;
    case types::relative_cartesian_location:
      c.set(other.c.get<relative_cartesian_location_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_res_arp_location_c");
  }

  return *this;
}
relative_geodetic_location_s& dl_prs_res_arp_location_c::set_relative_geodetic_location()
{
  set(types::relative_geodetic_location);
  return c.get<relative_geodetic_location_s>();
}
relative_cartesian_location_s& dl_prs_res_arp_location_c::set_relative_cartesian_location()
{
  set(types::relative_cartesian_location);
  return c.get<relative_cartesian_location_s>();
}
protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>& dl_prs_res_arp_location_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>>();
}
void dl_prs_res_arp_location_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::relative_geodetic_location:
      j.write_fieldname("relativeGeodeticLocation");
      c.get<relative_geodetic_location_s>().to_json(j);
      break;
    case types::relative_cartesian_location:
      j.write_fieldname("relativeCartesianLocation");
      c.get<relative_cartesian_location_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-Extension");
      c.get<protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_res_arp_location_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_prs_res_arp_location_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::relative_geodetic_location:
      HANDLE_CODE(c.get<relative_geodetic_location_s>().pack(bref));
      break;
    case types::relative_cartesian_location:
      HANDLE_CODE(c.get<relative_cartesian_location_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_res_arp_location_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_prs_res_arp_location_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::relative_geodetic_location:
      HANDLE_CODE(c.get<relative_geodetic_location_s>().unpack(bref));
      break;
    case types::relative_cartesian_location:
      HANDLE_CODE(c.get<relative_cartesian_location_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<dl_prs_res_arp_location_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_res_arp_location_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_prs_res_arp_location_c::types_opts::to_string() const
{
  static const char* names[] = {"relativeGeodeticLocation", "relativeCartesianLocation", "choice-Extension"};
  return convert_enum_idx(names, 3, value, "dl_prs_res_arp_location_c::types");
}

// DL-PRSResourceSetARPLocation ::= CHOICE
void dl_prs_res_set_arp_location_c::destroy_()
{
  switch (type_) {
    case types::relative_geodetic_location:
      c.destroy<relative_geodetic_location_s>();
      break;
    case types::relative_cartesian_location:
      c.destroy<relative_cartesian_location_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void dl_prs_res_set_arp_location_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::relative_geodetic_location:
      c.init<relative_geodetic_location_s>();
      break;
    case types::relative_cartesian_location:
      c.init<relative_cartesian_location_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_res_set_arp_location_c");
  }
}
dl_prs_res_set_arp_location_c::dl_prs_res_set_arp_location_c(const dl_prs_res_set_arp_location_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::relative_geodetic_location:
      c.init(other.c.get<relative_geodetic_location_s>());
      break;
    case types::relative_cartesian_location:
      c.init(other.c.get<relative_cartesian_location_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_res_set_arp_location_c");
  }
}
dl_prs_res_set_arp_location_c& dl_prs_res_set_arp_location_c::operator=(const dl_prs_res_set_arp_location_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::relative_geodetic_location:
      c.set(other.c.get<relative_geodetic_location_s>());
      break;
    case types::relative_cartesian_location:
      c.set(other.c.get<relative_cartesian_location_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_res_set_arp_location_c");
  }

  return *this;
}
relative_geodetic_location_s& dl_prs_res_set_arp_location_c::set_relative_geodetic_location()
{
  set(types::relative_geodetic_location);
  return c.get<relative_geodetic_location_s>();
}
relative_cartesian_location_s& dl_prs_res_set_arp_location_c::set_relative_cartesian_location()
{
  set(types::relative_cartesian_location);
  return c.get<relative_cartesian_location_s>();
}
protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>& dl_prs_res_set_arp_location_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>>();
}
void dl_prs_res_set_arp_location_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::relative_geodetic_location:
      j.write_fieldname("relativeGeodeticLocation");
      c.get<relative_geodetic_location_s>().to_json(j);
      break;
    case types::relative_cartesian_location:
      j.write_fieldname("relativeCartesianLocation");
      c.get<relative_cartesian_location_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-Extension");
      c.get<protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_res_set_arp_location_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_prs_res_set_arp_location_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::relative_geodetic_location:
      HANDLE_CODE(c.get<relative_geodetic_location_s>().pack(bref));
      break;
    case types::relative_cartesian_location:
      HANDLE_CODE(c.get<relative_cartesian_location_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_res_set_arp_location_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_prs_res_set_arp_location_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::relative_geodetic_location:
      HANDLE_CODE(c.get<relative_geodetic_location_s>().unpack(bref));
      break;
    case types::relative_cartesian_location:
      HANDLE_CODE(c.get<relative_cartesian_location_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<dl_prs_res_set_arp_location_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_prs_res_set_arp_location_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* dl_prs_res_set_arp_location_c::types_opts::to_string() const
{
  static const char* names[] = {"relativeGeodeticLocation", "relativeCartesianLocation", "choice-Extension"};
  return convert_enum_idx(names, 3, value, "dl_prs_res_set_arp_location_c::types");
}

// DL-UP-TNL-Address-to-Update-List-Item ::= SEQUENCE
SRSASN_CODE dl_up_tnl_address_to_upd_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(old_ip_adress.pack(bref));
  HANDLE_CODE(new_ip_adress.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_up_tnl_address_to_upd_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(old_ip_adress.unpack(bref));
  HANDLE_CODE(new_ip_adress.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dl_up_tnl_address_to_upd_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("oldIPAdress", old_ip_adress.to_string());
  j.write_str("newIPAdress", new_ip_adress.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DLPRSResourceARP ::= SEQUENCE
SRSASN_CODE dl_prs_res_arp_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_prs_res_id, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(dl_prs_res_arp_location.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_prs_res_arp_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_prs_res_id, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(dl_prs_res_arp_location.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dl_prs_res_arp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dl-PRSResourceID", dl_prs_res_id);
  j.write_fieldname("dL-PRSResourceARPLocation");
  dl_prs_res_arp_location.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DLPRSResourceSetARP ::= SEQUENCE
SRSASN_CODE dl_prs_res_set_arp_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_prs_res_set_id, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(dl_prs_res_set_arp_location.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, listof_dl_prs_res_arp, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_prs_res_set_arp_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_prs_res_set_id, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(dl_prs_res_set_arp_location.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(listof_dl_prs_res_arp, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dl_prs_res_set_arp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dl-PRSResourceSetID", dl_prs_res_set_id);
  j.write_fieldname("dL-PRSResourceSetARPLocation");
  dl_prs_res_set_arp_location.to_json(j);
  j.start_array("listofDL-PRSResourceARP");
  for (const auto& e1 : listof_dl_prs_res_arp) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DLPRSResourceCoordinates ::= SEQUENCE
SRSASN_CODE dl_prs_res_coordinates_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, listof_dl_prs_res_set_arp, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_prs_res_coordinates_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(listof_dl_prs_res_set_arp, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dl_prs_res_coordinates_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("listofDL-PRSResourceSetARP");
  for (const auto& e1 : listof_dl_prs_res_set_arp) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DLPRSResourceID-Item ::= SEQUENCE
SRSASN_CODE dl_prs_res_id_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_prs_res_id, (uint8_t)0u, (uint8_t)63u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_prs_res_id_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_prs_res_id, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dl_prs_res_id_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dl-PRSResourceID", dl_prs_res_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExecuteDuplication ::= ENUMERATED
const char* execute_dupl_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "execute_dupl_e");
}

// RAT-FrequencyPriorityInformation ::= CHOICE
void rat_freq_prio_info_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void rat_freq_prio_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::endc:
      break;
    case types::ngran:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rat_freq_prio_info_c");
  }
}
rat_freq_prio_info_c::rat_freq_prio_info_c(const rat_freq_prio_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::endc:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ngran:
      c.init(other.c.get<uint16_t>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rat_freq_prio_info_c");
  }
}
rat_freq_prio_info_c& rat_freq_prio_info_c::operator=(const rat_freq_prio_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::endc:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ngran:
      c.set(other.c.get<uint16_t>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rat_freq_prio_info_c");
  }

  return *this;
}
uint16_t& rat_freq_prio_info_c::set_endc()
{
  set(types::endc);
  return c.get<uint16_t>();
}
uint16_t& rat_freq_prio_info_c::set_ngran()
{
  set(types::ngran);
  return c.get<uint16_t>();
}
protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>& rat_freq_prio_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>>();
}
void rat_freq_prio_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::endc:
      j.write_int("eNDC", c.get<uint16_t>());
      break;
    case types::ngran:
      j.write_int("nGRAN", c.get<uint16_t>());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "rat_freq_prio_info_c");
  }
  j.end_obj();
}
SRSASN_CODE rat_freq_prio_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::endc:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ngran:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rat_freq_prio_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE rat_freq_prio_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::endc:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ngran:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<rat_freq_prio_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rat_freq_prio_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* rat_freq_prio_info_c::types_opts::to_string() const
{
  static const char* names[] = {"eNDC", "nGRAN", "choice-extension"};
  return convert_enum_idx(names, 3, value, "rat_freq_prio_info_c::types");
}

// RRCDeliveryStatusRequest ::= ENUMERATED
const char* rrc_delivery_status_request_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "rrc_delivery_status_request_e");
}

// UEContextNotRetrievable ::= ENUMERATED
const char* ue_context_not_retrievable_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "ue_context_not_retrievable_e");
}

// DLUPTNLInformation-ToBeSetup-Item ::= SEQUENCE
SRSASN_CODE dl_up_tnl_info_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dl_up_tnl_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_up_tnl_info_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dl_up_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dl_up_tnl_info_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dLUPTNLInformation");
  dl_up_tnl_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRB-Activity ::= ENUMERATED
const char* drb_activity_opts::to_string() const
{
  static const char* names[] = {"active", "not-active"};
  return convert_enum_idx(names, 2, value, "drb_activity_e");
}

// DRB-Activity-Item ::= SEQUENCE
SRSASN_CODE drb_activity_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(drb_activity_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (drb_activity_present) {
    HANDLE_CODE(drb_activity.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_activity_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(drb_activity_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (drb_activity_present) {
    HANDLE_CODE(drb_activity.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drb_activity_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  if (drb_activity_present) {
    j.write_str("dRB-Activity", drb_activity.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TSCAssistanceInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t tsc_assist_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {540};
  return map_enum_number(names, 1, idx, "id");
}
bool tsc_assist_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 540 == id;
}
crit_e tsc_assist_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 540) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
tsc_assist_info_ext_ies_o::ext_c tsc_assist_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 540) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e tsc_assist_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 540) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void tsc_assist_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..1920000,...)", c);
  j.end_obj();
}
SRSASN_CODE tsc_assist_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint32_t)0u, (uint32_t)1920000u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE tsc_assist_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint32_t)0u, (uint32_t)1920000u, true, true));
  return SRSASN_SUCCESS;
}

// TSCAssistanceInformation ::= SEQUENCE
SRSASN_CODE tsc_assist_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(burst_arrival_time.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, periodicity, (uint32_t)0u, (uint32_t)640000u, true, true));
  if (burst_arrival_time.size() > 0) {
    HANDLE_CODE(burst_arrival_time.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tsc_assist_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool burst_arrival_time_present;
  HANDLE_CODE(bref.unpack(burst_arrival_time_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(periodicity, bref, (uint32_t)0u, (uint32_t)640000u, true, true));
  if (burst_arrival_time_present) {
    HANDLE_CODE(burst_arrival_time.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void tsc_assist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("periodicity", periodicity);
  if (burst_arrival_time.size() > 0) {
    j.write_str("burstArrivalTime", burst_arrival_time.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// QoSFlowMappingIndication ::= ENUMERATED
const char* qos_flow_map_ind_opts::to_string() const
{
  static const char* names[] = {"ul", "dl"};
  return convert_enum_idx(names, 2, value, "qos_flow_map_ind_e");
}

// TSCTrafficCharacteristics ::= SEQUENCE
SRSASN_CODE tsc_traffic_characteristics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(tsc_assist_info_dl_present, 1));
  HANDLE_CODE(bref.pack(tsc_assist_info_ul_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (tsc_assist_info_dl_present) {
    HANDLE_CODE(tsc_assist_info_dl.pack(bref));
  }
  if (tsc_assist_info_ul_present) {
    HANDLE_CODE(tsc_assist_info_ul.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tsc_traffic_characteristics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(tsc_assist_info_dl_present, 1));
  HANDLE_CODE(bref.unpack(tsc_assist_info_ul_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (tsc_assist_info_dl_present) {
    HANDLE_CODE(tsc_assist_info_dl.unpack(bref));
  }
  if (tsc_assist_info_ul_present) {
    HANDLE_CODE(tsc_assist_info_ul.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tsc_traffic_characteristics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (tsc_assist_info_dl_present) {
    j.write_fieldname("tSCAssistanceInformationDL");
    tsc_assist_info_dl.to_json(j);
  }
  if (tsc_assist_info_ul_present) {
    j.write_fieldname("tSCAssistanceInformationUL");
    tsc_assist_info_ul.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Flows-Mapped-To-DRB-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t flows_mapped_to_drb_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {183, 364};
  return map_enum_number(names, 2, idx, "id");
}
bool flows_mapped_to_drb_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {183, 364};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e flows_mapped_to_drb_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 183:
      return crit_e::ignore;
    case 364:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
flows_mapped_to_drb_item_ext_ies_o::ext_c flows_mapped_to_drb_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 183:
      ret.set(ext_c::types::qos_flow_map_ind);
      break;
    case 364:
      ret.set(ext_c::types::tsc_traffic_characteristics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e flows_mapped_to_drb_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 183:
      return presence_e::optional;
    case 364:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void flows_mapped_to_drb_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::tsc_traffic_characteristics:
      c.destroy<tsc_traffic_characteristics_s>();
      break;
    default:
      break;
  }
}
void flows_mapped_to_drb_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::qos_flow_map_ind:
      break;
    case types::tsc_traffic_characteristics:
      c.init<tsc_traffic_characteristics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "flows_mapped_to_drb_item_ext_ies_o::ext_c");
  }
}
flows_mapped_to_drb_item_ext_ies_o::ext_c::ext_c(const flows_mapped_to_drb_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::qos_flow_map_ind:
      c.init(other.c.get<qos_flow_map_ind_e>());
      break;
    case types::tsc_traffic_characteristics:
      c.init(other.c.get<tsc_traffic_characteristics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "flows_mapped_to_drb_item_ext_ies_o::ext_c");
  }
}
flows_mapped_to_drb_item_ext_ies_o::ext_c&
flows_mapped_to_drb_item_ext_ies_o::ext_c::operator=(const flows_mapped_to_drb_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::qos_flow_map_ind:
      c.set(other.c.get<qos_flow_map_ind_e>());
      break;
    case types::tsc_traffic_characteristics:
      c.set(other.c.get<tsc_traffic_characteristics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "flows_mapped_to_drb_item_ext_ies_o::ext_c");
  }

  return *this;
}
qos_flow_map_ind_e& flows_mapped_to_drb_item_ext_ies_o::ext_c::qos_flow_map_ind()
{
  assert_choice_type(types::qos_flow_map_ind, type_, "Extension");
  return c.get<qos_flow_map_ind_e>();
}
tsc_traffic_characteristics_s& flows_mapped_to_drb_item_ext_ies_o::ext_c::tsc_traffic_characteristics()
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
const qos_flow_map_ind_e& flows_mapped_to_drb_item_ext_ies_o::ext_c::qos_flow_map_ind() const
{
  assert_choice_type(types::qos_flow_map_ind, type_, "Extension");
  return c.get<qos_flow_map_ind_e>();
}
const tsc_traffic_characteristics_s& flows_mapped_to_drb_item_ext_ies_o::ext_c::tsc_traffic_characteristics() const
{
  assert_choice_type(types::tsc_traffic_characteristics, type_, "Extension");
  return c.get<tsc_traffic_characteristics_s>();
}
void flows_mapped_to_drb_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::qos_flow_map_ind:
      j.write_str("QoSFlowMappingIndication", c.get<qos_flow_map_ind_e>().to_string());
      break;
    case types::tsc_traffic_characteristics:
      j.write_fieldname("TSCTrafficCharacteristics");
      c.get<tsc_traffic_characteristics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "flows_mapped_to_drb_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE flows_mapped_to_drb_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::qos_flow_map_ind:
      HANDLE_CODE(c.get<qos_flow_map_ind_e>().pack(bref));
      break;
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "flows_mapped_to_drb_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE flows_mapped_to_drb_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::qos_flow_map_ind:
      HANDLE_CODE(c.get<qos_flow_map_ind_e>().unpack(bref));
      break;
    case types::tsc_traffic_characteristics:
      HANDLE_CODE(c.get<tsc_traffic_characteristics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "flows_mapped_to_drb_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE flows_mapped_to_drb_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += qos_flow_map_ind_present ? 1 : 0;
  nof_ies += tsc_traffic_characteristics_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (qos_flow_map_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)183, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(qos_flow_map_ind.pack(bref));
  }
  if (tsc_traffic_characteristics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)364, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tsc_traffic_characteristics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE flows_mapped_to_drb_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 183: {
        qos_flow_map_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qos_flow_map_ind.unpack(bref));
        break;
      }
      case 364: {
        tsc_traffic_characteristics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tsc_traffic_characteristics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void flows_mapped_to_drb_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (qos_flow_map_ind_present) {
    j.write_int("id", 183);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", qos_flow_map_ind.to_string());
  }
  if (tsc_traffic_characteristics_present) {
    j.write_int("id", 364);
    j.write_str("criticality", "ignore");
    tsc_traffic_characteristics.to_json(j);
  }
  j.end_obj();
}

// Flows-Mapped-To-DRB-Item ::= SEQUENCE
SRSASN_CODE flows_mapped_to_drb_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qos_flow_id, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(qos_flow_level_qos_params.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE flows_mapped_to_drb_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qos_flow_id, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(qos_flow_level_qos_params.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void flows_mapped_to_drb_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qoSFlowIdentifier", qos_flow_id);
  j.write_fieldname("qoSFlowLevelQoSParameters");
  qos_flow_level_qos_params.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NotificationControl ::= ENUMERATED
const char* notif_ctrl_opts::to_string() const
{
  static const char* names[] = {"active", "not-active"};
  return convert_enum_idx(names, 2, value, "notif_ctrl_e");
}

// DRB-Information ::= SEQUENCE
SRSASN_CODE drb_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(notif_ctrl_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(drb_qos.pack(bref));
  HANDLE_CODE(snssai.pack(bref));
  if (notif_ctrl_present) {
    HANDLE_CODE(notif_ctrl.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, flows_mapped_to_drb_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(notif_ctrl_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(drb_qos.unpack(bref));
  HANDLE_CODE(snssai.unpack(bref));
  if (notif_ctrl_present) {
    HANDLE_CODE(notif_ctrl.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(flows_mapped_to_drb_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drb_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("dRB-QoS");
  drb_qos.to_json(j);
  j.write_fieldname("sNSSAI");
  snssai.to_json(j);
  if (notif_ctrl_present) {
    j.write_str("notificationControl", notif_ctrl.to_string());
  }
  j.start_array("flows-Mapped-To-DRB-List");
  for (const auto& e1 : flows_mapped_to_drb_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRB-Notify-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t drb_notify_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {344};
  return map_enum_number(names, 1, idx, "id");
}
bool drb_notify_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 344 == id;
}
crit_e drb_notify_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 344) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
drb_notify_item_ext_ies_o::ext_c drb_notify_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 344) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drb_notify_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 344) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void drb_notify_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..8,...)", c);
  j.end_obj();
}
SRSASN_CODE drb_notify_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)0u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_notify_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)0u, (uint8_t)8u, true, true));
  return SRSASN_SUCCESS;
}

// Notification-Cause ::= ENUMERATED
const char* notif_cause_opts::to_string() const
{
  static const char* names[] = {"fulfilled", "not-fulfilled"};
  return convert_enum_idx(names, 2, value, "notif_cause_e");
}

// DRB-Notify-Item ::= SEQUENCE
SRSASN_CODE drb_notify_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(notif_cause.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drb_notify_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(notif_cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void drb_notify_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  j.write_str("notification-Cause", notif_cause.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// DRBs-FailedToBeModified-Item ::= SEQUENCE
SRSASN_CODE drbs_failed_to_be_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_failed_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_failed_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBs-FailedToBeSetup-Item ::= SEQUENCE
SRSASN_CODE drbs_failed_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_failed_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_failed_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBs-FailedToBeSetupMod-Item ::= SEQUENCE
SRSASN_CODE drbs_failed_to_be_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_failed_to_be_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_failed_to_be_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Reestablishment-Indication ::= ENUMERATED
const char* reest_ind_opts::to_string() const
{
  static const char* names[] = {"reestablished"};
  return convert_enum_idx(names, 1, value, "reest_ind_e");
}

// RLC-Status ::= SEQUENCE
SRSASN_CODE rlc_status_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(reest_ind.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rlc_status_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(reest_ind.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rlc_status_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("reestablishment-Indication", "reestablished");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBs-Modified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t drbs_modified_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {160, 370, 344};
  return map_enum_number(names, 3, idx, "id");
}
bool drbs_modified_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {160, 370, 344};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_modified_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 160:
      return crit_e::ignore;
    case 370:
      return crit_e::ignore;
    case 344:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_modified_item_ext_ies_o::ext_c drbs_modified_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 160:
      ret.set(ext_c::types::rlc_status);
      break;
    case 370:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 344:
      ret.set(ext_c::types::current_qos_para_set_idx);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_modified_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 160:
      return presence_e::optional;
    case 370:
      return presence_e::optional;
    case 344:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_modified_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::rlc_status:
      c.destroy<rlc_status_s>();
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.destroy<add_pdcp_dupl_tnl_list_l>();
      break;
    default:
      break;
  }
}
void drbs_modified_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::rlc_status:
      c.init<rlc_status_s>();
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.init<add_pdcp_dupl_tnl_list_l>();
      break;
    case types::current_qos_para_set_idx:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_modified_item_ext_ies_o::ext_c");
  }
}
drbs_modified_item_ext_ies_o::ext_c::ext_c(const drbs_modified_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::rlc_status:
      c.init(other.c.get<rlc_status_s>());
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.init(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::current_qos_para_set_idx:
      c.init(other.c.get<uint8_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_modified_item_ext_ies_o::ext_c");
  }
}
drbs_modified_item_ext_ies_o::ext_c&
drbs_modified_item_ext_ies_o::ext_c::operator=(const drbs_modified_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::rlc_status:
      c.set(other.c.get<rlc_status_s>());
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.set(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::current_qos_para_set_idx:
      c.set(other.c.get<uint8_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_modified_item_ext_ies_o::ext_c");
  }

  return *this;
}
rlc_status_s& drbs_modified_item_ext_ies_o::ext_c::rlc_status()
{
  assert_choice_type(types::rlc_status, type_, "Extension");
  return c.get<rlc_status_s>();
}
add_pdcp_dupl_tnl_list_l& drbs_modified_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
uint8_t& drbs_modified_item_ext_ies_o::ext_c::current_qos_para_set_idx()
{
  assert_choice_type(types::current_qos_para_set_idx, type_, "Extension");
  return c.get<uint8_t>();
}
const rlc_status_s& drbs_modified_item_ext_ies_o::ext_c::rlc_status() const
{
  assert_choice_type(types::rlc_status, type_, "Extension");
  return c.get<rlc_status_s>();
}
const add_pdcp_dupl_tnl_list_l& drbs_modified_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const uint8_t& drbs_modified_item_ext_ies_o::ext_c::current_qos_para_set_idx() const
{
  assert_choice_type(types::current_qos_para_set_idx, type_, "Extension");
  return c.get<uint8_t>();
}
void drbs_modified_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::rlc_status:
      j.write_fieldname("RLC-Status");
      c.get<rlc_status_s>().to_json(j);
      break;
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("AdditionalPDCPDuplicationTNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::current_qos_para_set_idx:
      j.write_int("INTEGER (1..8,...)", c.get<uint8_t>());
      break;
    default:
      log_invalid_choice_id(type_, "drbs_modified_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_modified_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::rlc_status:
      HANDLE_CODE(c.get<rlc_status_s>().pack(bref));
      break;
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::current_qos_para_set_idx:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)1u, (uint8_t)8u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_modified_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_modified_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::rlc_status:
      HANDLE_CODE(c.get<rlc_status_s>().unpack(bref));
      break;
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::current_qos_para_set_idx:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)1u, (uint8_t)8u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_modified_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE drbs_modified_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += rlc_status_present ? 1 : 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += current_qos_para_set_idx_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (rlc_status_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)160, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rlc_status.pack(bref));
  }
  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)370, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (current_qos_para_set_idx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)344, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, current_qos_para_set_idx, (uint8_t)1u, (uint8_t)8u, true, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_modified_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 160: {
        rlc_status_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rlc_status.unpack(bref));
        break;
      }
      case 370: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 344: {
        current_qos_para_set_idx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(current_qos_para_set_idx, bref, (uint8_t)1u, (uint8_t)8u, true, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_modified_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (rlc_status_present) {
    j.write_int("id", 160);
    j.write_str("criticality", "ignore");
    rlc_status.to_json(j);
  }
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 370);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (current_qos_para_set_idx_present) {
    j.write_int("id", 344);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", current_qos_para_set_idx);
  }
  j.end_obj();
}

// DRBs-Modified-Item ::= SEQUENCE
SRSASN_CODE drbs_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(lcid_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (lcid_present) {
    HANDLE_CODE(pack_integer(bref, lcid, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, dl_up_tnl_info_to_be_setup_list, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(lcid_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (lcid_present) {
    HANDLE_CODE(unpack_integer(lcid, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  HANDLE_CODE(unpack_dyn_seq_of(dl_up_tnl_info_to_be_setup_list, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  if (lcid_present) {
    j.write_int("lCID", lcid);
  }
  j.start_array("dLUPTNLInformation-ToBeSetup-List");
  for (const auto& e1 : dl_up_tnl_info_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ULUPTNLInformation-ToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t ul_up_tnl_info_to_be_setup_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {280, 598};
  return map_enum_number(names, 2, idx, "id");
}
bool ul_up_tnl_info_to_be_setup_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {280, 598};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_up_tnl_info_to_be_setup_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 280:
      return crit_e::ignore;
    case 598:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c ul_up_tnl_info_to_be_setup_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 280:
      ret.set(ext_c::types::bh_info);
      break;
    case 598:
      ret.set(ext_c::types::drb_map_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_up_tnl_info_to_be_setup_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 280:
      return presence_e::optional;
    case 598:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::bh_info:
      c.destroy<bh_info_s>();
      break;
    case types::drb_map_info:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    default:
      break;
  }
}
void ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::bh_info:
      c.init<bh_info_s>();
      break;
    case types::drb_map_info:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c");
  }
}
ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c::ext_c(const ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::bh_info:
      c.init(other.c.get<bh_info_s>());
      break;
    case types::drb_map_info:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c");
  }
}
ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c& ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c::operator=(
    const ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::bh_info:
      c.set(other.c.get<bh_info_s>());
      break;
    case types::drb_map_info:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c");
  }

  return *this;
}
bh_info_s& ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c::bh_info()
{
  assert_choice_type(types::bh_info, type_, "Extension");
  return c.get<bh_info_s>();
}
fixed_bitstring<16, false, true>& ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c::drb_map_info()
{
  assert_choice_type(types::drb_map_info, type_, "Extension");
  return c.get<fixed_bitstring<16, false, true>>();
}
const bh_info_s& ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c::bh_info() const
{
  assert_choice_type(types::bh_info, type_, "Extension");
  return c.get<bh_info_s>();
}
const fixed_bitstring<16, false, true>& ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c::drb_map_info() const
{
  assert_choice_type(types::drb_map_info, type_, "Extension");
  return c.get<fixed_bitstring<16, false, true>>();
}
void ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::bh_info:
      j.write_fieldname("BHInfo");
      c.get<bh_info_s>().to_json(j);
      break;
    case types::drb_map_info:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::bh_info:
      HANDLE_CODE(c.get<bh_info_s>().pack(bref));
      break;
    case types::drb_map_info:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::bh_info:
      HANDLE_CODE(c.get<bh_info_s>().unpack(bref));
      break;
    case types::drb_map_info:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ul_up_tnl_info_to_be_setup_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE ul_up_tnl_info_to_be_setup_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += bh_info_present ? 1 : 0;
  nof_ies += drb_map_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (bh_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)280, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(bh_info.pack(bref));
  }
  if (drb_map_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)598, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(drb_map_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_up_tnl_info_to_be_setup_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 280: {
        bh_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(bh_info.unpack(bref));
        break;
      }
      case 598: {
        drb_map_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(drb_map_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ul_up_tnl_info_to_be_setup_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (bh_info_present) {
    j.write_int("id", 280);
    j.write_str("criticality", "ignore");
    bh_info.to_json(j);
  }
  if (drb_map_info_present) {
    j.write_int("id", 598);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", drb_map_info.to_string());
  }
  j.end_obj();
}

// ULUPTNLInformation-ToBeSetup-Item ::= SEQUENCE
SRSASN_CODE ul_up_tnl_info_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_up_tnl_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_up_tnl_info_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_up_tnl_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_up_tnl_info_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uLUPTNLInformation");
  ul_up_tnl_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBs-ModifiedConf-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t drbs_modified_conf_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {370};
  return map_enum_number(names, 1, idx, "id");
}
bool drbs_modified_conf_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 370 == id;
}
crit_e drbs_modified_conf_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 370) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
drbs_modified_conf_item_ext_ies_o::ext_c drbs_modified_conf_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 370) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_modified_conf_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 370) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void drbs_modified_conf_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("AdditionalPDCPDuplicationTNL-List");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE drbs_modified_conf_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 2, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_modified_conf_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 2, true));
  return SRSASN_SUCCESS;
}

// DRBs-ModifiedConf-Item ::= SEQUENCE
SRSASN_CODE drbs_modified_conf_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, ul_up_tnl_info_to_be_setup_list, 1, 2, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_modified_conf_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(ul_up_tnl_info_to_be_setup_list, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void drbs_modified_conf_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  j.start_array("uLUPTNLInformation-ToBeSetup-List");
  for (const auto& e1 : ul_up_tnl_info_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// DRBs-Required-ToBeModified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t drbs_required_to_be_modified_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {160, 370};
  return map_enum_number(names, 2, idx, "id");
}
bool drbs_required_to_be_modified_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {160, 370};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_required_to_be_modified_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 160:
      return crit_e::ignore;
    case 370:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_required_to_be_modified_item_ext_ies_o::ext_c
drbs_required_to_be_modified_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 160:
      ret.set(ext_c::types::rlc_status);
      break;
    case 370:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_required_to_be_modified_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 160:
      return presence_e::optional;
    case 370:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_required_to_be_modified_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::rlc_status:
      c.destroy<rlc_status_s>();
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.destroy<add_pdcp_dupl_tnl_list_l>();
      break;
    default:
      break;
  }
}
void drbs_required_to_be_modified_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::rlc_status:
      c.init<rlc_status_s>();
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.init<add_pdcp_dupl_tnl_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_required_to_be_modified_item_ext_ies_o::ext_c");
  }
}
drbs_required_to_be_modified_item_ext_ies_o::ext_c::ext_c(
    const drbs_required_to_be_modified_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::rlc_status:
      c.init(other.c.get<rlc_status_s>());
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.init(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_required_to_be_modified_item_ext_ies_o::ext_c");
  }
}
drbs_required_to_be_modified_item_ext_ies_o::ext_c& drbs_required_to_be_modified_item_ext_ies_o::ext_c::operator=(
    const drbs_required_to_be_modified_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::rlc_status:
      c.set(other.c.get<rlc_status_s>());
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.set(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_required_to_be_modified_item_ext_ies_o::ext_c");
  }

  return *this;
}
rlc_status_s& drbs_required_to_be_modified_item_ext_ies_o::ext_c::rlc_status()
{
  assert_choice_type(types::rlc_status, type_, "Extension");
  return c.get<rlc_status_s>();
}
add_pdcp_dupl_tnl_list_l& drbs_required_to_be_modified_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const rlc_status_s& drbs_required_to_be_modified_item_ext_ies_o::ext_c::rlc_status() const
{
  assert_choice_type(types::rlc_status, type_, "Extension");
  return c.get<rlc_status_s>();
}
const add_pdcp_dupl_tnl_list_l& drbs_required_to_be_modified_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
void drbs_required_to_be_modified_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::rlc_status:
      j.write_fieldname("RLC-Status");
      c.get<rlc_status_s>().to_json(j);
      break;
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("AdditionalPDCPDuplicationTNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "drbs_required_to_be_modified_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_required_to_be_modified_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::rlc_status:
      HANDLE_CODE(c.get<rlc_status_s>().pack(bref));
      break;
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_required_to_be_modified_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_required_to_be_modified_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::rlc_status:
      HANDLE_CODE(c.get<rlc_status_s>().unpack(bref));
      break;
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_required_to_be_modified_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE drbs_required_to_be_modified_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += rlc_status_present ? 1 : 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (rlc_status_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)160, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rlc_status.pack(bref));
  }
  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)370, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_required_to_be_modified_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 160: {
        rlc_status_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rlc_status.unpack(bref));
        break;
      }
      case 370: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_required_to_be_modified_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (rlc_status_present) {
    j.write_int("id", 160);
    j.write_str("criticality", "ignore");
    rlc_status.to_json(j);
  }
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 370);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// DRBs-Required-ToBeModified-Item ::= SEQUENCE
SRSASN_CODE drbs_required_to_be_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, dl_up_tnl_info_to_be_setup_list, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_required_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(dl_up_tnl_info_to_be_setup_list, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_required_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  j.start_array("dLUPTNLInformation-ToBeSetup-List");
  for (const auto& e1 : dl_up_tnl_info_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBs-Required-ToBeReleased-Item ::= SEQUENCE
SRSASN_CODE drbs_required_to_be_released_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_required_to_be_released_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_required_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBs-Setup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t drbs_setup_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {370, 344};
  return map_enum_number(names, 2, idx, "id");
}
bool drbs_setup_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {370, 344};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_setup_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 370:
      return crit_e::ignore;
    case 344:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_setup_item_ext_ies_o::ext_c drbs_setup_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 370:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 344:
      ret.set(ext_c::types::current_qos_para_set_idx);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_setup_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 370:
      return presence_e::optional;
    case 344:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_setup_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c.destroy<add_pdcp_dupl_tnl_list_l>();
      break;
    default:
      break;
  }
}
void drbs_setup_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c.init<add_pdcp_dupl_tnl_list_l>();
      break;
    case types::current_qos_para_set_idx:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_setup_item_ext_ies_o::ext_c");
  }
}
drbs_setup_item_ext_ies_o::ext_c::ext_c(const drbs_setup_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c.init(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::current_qos_para_set_idx:
      c.init(other.c.get<uint8_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_setup_item_ext_ies_o::ext_c");
  }
}
drbs_setup_item_ext_ies_o::ext_c&
drbs_setup_item_ext_ies_o::ext_c::operator=(const drbs_setup_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c.set(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::current_qos_para_set_idx:
      c.set(other.c.get<uint8_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_setup_item_ext_ies_o::ext_c");
  }

  return *this;
}
add_pdcp_dupl_tnl_list_l& drbs_setup_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
uint8_t& drbs_setup_item_ext_ies_o::ext_c::current_qos_para_set_idx()
{
  assert_choice_type(types::current_qos_para_set_idx, type_, "Extension");
  return c.get<uint8_t>();
}
const add_pdcp_dupl_tnl_list_l& drbs_setup_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const uint8_t& drbs_setup_item_ext_ies_o::ext_c::current_qos_para_set_idx() const
{
  assert_choice_type(types::current_qos_para_set_idx, type_, "Extension");
  return c.get<uint8_t>();
}
void drbs_setup_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("AdditionalPDCPDuplicationTNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::current_qos_para_set_idx:
      j.write_int("INTEGER (1..8,...)", c.get<uint8_t>());
      break;
    default:
      log_invalid_choice_id(type_, "drbs_setup_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_setup_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::current_qos_para_set_idx:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)1u, (uint8_t)8u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_setup_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_setup_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::current_qos_para_set_idx:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)1u, (uint8_t)8u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_setup_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE drbs_setup_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += current_qos_para_set_idx_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)370, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (current_qos_para_set_idx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)344, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, current_qos_para_set_idx, (uint8_t)1u, (uint8_t)8u, true, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_setup_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 370: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 344: {
        current_qos_para_set_idx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(current_qos_para_set_idx, bref, (uint8_t)1u, (uint8_t)8u, true, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_setup_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 370);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (current_qos_para_set_idx_present) {
    j.write_int("id", 344);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", current_qos_para_set_idx);
  }
  j.end_obj();
}

// DRBs-Setup-Item ::= SEQUENCE
SRSASN_CODE drbs_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(lcid_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (lcid_present) {
    HANDLE_CODE(pack_integer(bref, lcid, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, dl_up_tnl_info_to_be_setup_list, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(lcid_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (lcid_present) {
    HANDLE_CODE(unpack_integer(lcid, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  HANDLE_CODE(unpack_dyn_seq_of(dl_up_tnl_info_to_be_setup_list, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  if (lcid_present) {
    j.write_int("lCID", lcid);
  }
  j.start_array("dLUPTNLInformation-ToBeSetup-List");
  for (const auto& e1 : dl_up_tnl_info_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBs-SetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t drbs_setup_mod_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {370, 344};
  return map_enum_number(names, 2, idx, "id");
}
bool drbs_setup_mod_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {370, 344};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_setup_mod_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 370:
      return crit_e::ignore;
    case 344:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_setup_mod_item_ext_ies_o::ext_c drbs_setup_mod_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 370:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 344:
      ret.set(ext_c::types::current_qos_para_set_idx);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_setup_mod_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 370:
      return presence_e::optional;
    case 344:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_setup_mod_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c.destroy<add_pdcp_dupl_tnl_list_l>();
      break;
    default:
      break;
  }
}
void drbs_setup_mod_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c.init<add_pdcp_dupl_tnl_list_l>();
      break;
    case types::current_qos_para_set_idx:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_setup_mod_item_ext_ies_o::ext_c");
  }
}
drbs_setup_mod_item_ext_ies_o::ext_c::ext_c(const drbs_setup_mod_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c.init(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::current_qos_para_set_idx:
      c.init(other.c.get<uint8_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_setup_mod_item_ext_ies_o::ext_c");
  }
}
drbs_setup_mod_item_ext_ies_o::ext_c&
drbs_setup_mod_item_ext_ies_o::ext_c::operator=(const drbs_setup_mod_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c.set(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::current_qos_para_set_idx:
      c.set(other.c.get<uint8_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_setup_mod_item_ext_ies_o::ext_c");
  }

  return *this;
}
add_pdcp_dupl_tnl_list_l& drbs_setup_mod_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
uint8_t& drbs_setup_mod_item_ext_ies_o::ext_c::current_qos_para_set_idx()
{
  assert_choice_type(types::current_qos_para_set_idx, type_, "Extension");
  return c.get<uint8_t>();
}
const add_pdcp_dupl_tnl_list_l& drbs_setup_mod_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const uint8_t& drbs_setup_mod_item_ext_ies_o::ext_c::current_qos_para_set_idx() const
{
  assert_choice_type(types::current_qos_para_set_idx, type_, "Extension");
  return c.get<uint8_t>();
}
void drbs_setup_mod_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("AdditionalPDCPDuplicationTNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::current_qos_para_set_idx:
      j.write_int("INTEGER (1..8,...)", c.get<uint8_t>());
      break;
    default:
      log_invalid_choice_id(type_, "drbs_setup_mod_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_setup_mod_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::current_qos_para_set_idx:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)1u, (uint8_t)8u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_setup_mod_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_setup_mod_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::current_qos_para_set_idx:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)1u, (uint8_t)8u, true, true));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_setup_mod_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE drbs_setup_mod_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += current_qos_para_set_idx_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)370, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (current_qos_para_set_idx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)344, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, current_qos_para_set_idx, (uint8_t)1u, (uint8_t)8u, true, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_setup_mod_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 370: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 344: {
        current_qos_para_set_idx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(current_qos_para_set_idx, bref, (uint8_t)1u, (uint8_t)8u, true, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_setup_mod_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 370);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (current_qos_para_set_idx_present) {
    j.write_int("id", 344);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", current_qos_para_set_idx);
  }
  j.end_obj();
}

// DRBs-SetupMod-Item ::= SEQUENCE
SRSASN_CODE drbs_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(lcid_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (lcid_present) {
    HANDLE_CODE(pack_integer(bref, lcid, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, dl_up_tnl_info_to_be_setup_list, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(lcid_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (lcid_present) {
    HANDLE_CODE(unpack_integer(lcid, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  }
  HANDLE_CODE(unpack_dyn_seq_of(dl_up_tnl_info_to_be_setup_list, bref, 1, 2, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  if (lcid_present) {
    j.write_int("lCID", lcid);
  }
  j.start_array("dLUPTNLInformation-ToBeSetup-List");
  for (const auto& e1 : dl_up_tnl_info_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DuplicationState ::= ENUMERATED
const char* dupl_state_opts::to_string() const
{
  static const char* names[] = {"active", "inactive"};
  return convert_enum_idx(names, 2, value, "dupl_state_e");
}

// RLCDuplicationState-Item ::= SEQUENCE
SRSASN_CODE rlc_dupl_state_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(dupl_state.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rlc_dupl_state_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(dupl_state.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rlc_dupl_state_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("duplicationState", dupl_state.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PrimaryPathIndication ::= ENUMERATED
const char* primary_path_ind_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "primary_path_ind_e");
}

// BearerTypeChange ::= ENUMERATED
const char* bearer_type_change_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "bearer_type_change_e");
}

// CG-SDTindicatorMod ::= ENUMERATED
const char* cg_sd_tind_mod_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "cg_sd_tind_mod_e");
}

// DCBasedDuplicationConfigured ::= ENUMERATED
const char* dc_based_dupl_cfg_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "dc_based_dupl_cfg_e");
}

// DuplicationActivation ::= ENUMERATED
const char* dupl_activation_opts::to_string() const
{
  static const char* names[] = {"active", "inactive"};
  return convert_enum_idx(names, 2, value, "dupl_activation_e");
}

// PDCPSNLength ::= ENUMERATED
const char* pdcp_sn_len_opts::to_string() const
{
  static const char* names[] = {"twelve-bits", "eighteen-bits"};
  return convert_enum_idx(names, 2, value, "pdcp_sn_len_e");
}
uint8_t pdcp_sn_len_opts::to_number() const
{
  if (value == eighteen_bits) {
    return 8;
  }
  invalid_enum_number(value, "pdcp_sn_len_e");
  return 0;
}

// QoSInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
uint32_t qos_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {164};
  return map_enum_number(names, 1, idx, "id");
}
bool qos_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 164 == id;
}
crit_e qos_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 164) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
qos_info_ext_ies_o::value_c qos_info_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 164) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e qos_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 164) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void qos_info_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("DRB-Information");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE qos_info_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_info_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// RLCDuplicationInformation ::= SEQUENCE
SRSASN_CODE rlc_dupl_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(primary_path_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, rlc_dupl_state_list, 1, 3, true));
  if (primary_path_ind_present) {
    HANDLE_CODE(primary_path_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rlc_dupl_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(primary_path_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(rlc_dupl_state_list, bref, 1, 3, true));
  if (primary_path_ind_present) {
    HANDLE_CODE(primary_path_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rlc_dupl_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("rLCDuplicationStateList");
  for (const auto& e1 : rlc_dupl_state_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (primary_path_ind_present) {
    j.write_str("primaryPathIndication", primary_path_ind.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TransmissionStopIndicator ::= ENUMERATED
const char* tx_stop_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "tx_stop_ind_e");
}

// ULUEConfiguration ::= ENUMERATED
const char* ul_ue_cfg_opts::to_string() const
{
  static const char* names[] = {"no-data", "shared", "only"};
  return convert_enum_idx(names, 3, value, "ul_ue_cfg_e");
}

// DRBs-ToBeModified-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t drbs_to_be_modified_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {161, 192, 186, 187, 188, 176, 177, 370, 371, 430, 590};
  return map_enum_number(names, 11, idx, "id");
}
bool drbs_to_be_modified_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {161, 192, 186, 187, 188, 176, 177, 370, 371, 430, 590};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_to_be_modified_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 161:
      return crit_e::ignore;
    case 192:
      return crit_e::ignore;
    case 186:
      return crit_e::ignore;
    case 187:
      return crit_e::ignore;
    case 188:
      return crit_e::reject;
    case 176:
      return crit_e::reject;
    case 177:
      return crit_e::reject;
    case 370:
      return crit_e::ignore;
    case 371:
      return crit_e::ignore;
    case 430:
      return crit_e::ignore;
    case 590:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_to_be_modified_item_ext_ies_o::ext_c drbs_to_be_modified_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 161:
      ret.set(ext_c::types::dl_pdcp_sn_len);
      break;
    case 192:
      ret.set(ext_c::types::ul_pdcp_sn_len);
      break;
    case 186:
      ret.set(ext_c::types::bearer_type_change);
      break;
    case 187:
      ret.set(ext_c::types::rlc_mode);
      break;
    case 188:
      ret.set(ext_c::types::dupl_activation);
      break;
    case 176:
      ret.set(ext_c::types::dc_based_dupl_cfg);
      break;
    case 177:
      ret.set(ext_c::types::dc_based_dupl_activation);
      break;
    case 370:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 371:
      ret.set(ext_c::types::rlc_dupl_info);
      break;
    case 430:
      ret.set(ext_c::types::tx_stop_ind);
      break;
    case 590:
      ret.set(ext_c::types::cg_sd_tind_mod);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_be_modified_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 161:
      return presence_e::optional;
    case 192:
      return presence_e::optional;
    case 186:
      return presence_e::optional;
    case 187:
      return presence_e::optional;
    case 188:
      return presence_e::optional;
    case 176:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 370:
      return presence_e::optional;
    case 371:
      return presence_e::optional;
    case 430:
      return presence_e::optional;
    case 590:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_be_modified_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c.destroy<add_pdcp_dupl_tnl_list_l>();
      break;
    case types::rlc_dupl_info:
      c.destroy<rlc_dupl_info_s>();
      break;
    default:
      break;
  }
}
void drbs_to_be_modified_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::dl_pdcp_sn_len:
      break;
    case types::ul_pdcp_sn_len:
      break;
    case types::bearer_type_change:
      break;
    case types::rlc_mode:
      break;
    case types::dupl_activation:
      break;
    case types::dc_based_dupl_cfg:
      break;
    case types::dc_based_dupl_activation:
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.init<add_pdcp_dupl_tnl_list_l>();
      break;
    case types::rlc_dupl_info:
      c.init<rlc_dupl_info_s>();
      break;
    case types::tx_stop_ind:
      break;
    case types::cg_sd_tind_mod:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_item_ext_ies_o::ext_c");
  }
}
drbs_to_be_modified_item_ext_ies_o::ext_c::ext_c(const drbs_to_be_modified_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::dl_pdcp_sn_len:
      c.init(other.c.get<pdcp_sn_len_e>());
      break;
    case types::ul_pdcp_sn_len:
      c.init(other.c.get<pdcp_sn_len_e>());
      break;
    case types::bearer_type_change:
      c.init(other.c.get<bearer_type_change_e>());
      break;
    case types::rlc_mode:
      c.init(other.c.get<rlc_mode_e>());
      break;
    case types::dupl_activation:
      c.init(other.c.get<dupl_activation_e>());
      break;
    case types::dc_based_dupl_cfg:
      c.init(other.c.get<dc_based_dupl_cfg_e>());
      break;
    case types::dc_based_dupl_activation:
      c.init(other.c.get<dupl_activation_e>());
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.init(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::rlc_dupl_info:
      c.init(other.c.get<rlc_dupl_info_s>());
      break;
    case types::tx_stop_ind:
      c.init(other.c.get<tx_stop_ind_e>());
      break;
    case types::cg_sd_tind_mod:
      c.init(other.c.get<cg_sd_tind_mod_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_item_ext_ies_o::ext_c");
  }
}
drbs_to_be_modified_item_ext_ies_o::ext_c&
drbs_to_be_modified_item_ext_ies_o::ext_c::operator=(const drbs_to_be_modified_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::dl_pdcp_sn_len:
      c.set(other.c.get<pdcp_sn_len_e>());
      break;
    case types::ul_pdcp_sn_len:
      c.set(other.c.get<pdcp_sn_len_e>());
      break;
    case types::bearer_type_change:
      c.set(other.c.get<bearer_type_change_e>());
      break;
    case types::rlc_mode:
      c.set(other.c.get<rlc_mode_e>());
      break;
    case types::dupl_activation:
      c.set(other.c.get<dupl_activation_e>());
      break;
    case types::dc_based_dupl_cfg:
      c.set(other.c.get<dc_based_dupl_cfg_e>());
      break;
    case types::dc_based_dupl_activation:
      c.set(other.c.get<dupl_activation_e>());
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.set(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::rlc_dupl_info:
      c.set(other.c.get<rlc_dupl_info_s>());
      break;
    case types::tx_stop_ind:
      c.set(other.c.get<tx_stop_ind_e>());
      break;
    case types::cg_sd_tind_mod:
      c.set(other.c.get<cg_sd_tind_mod_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_item_ext_ies_o::ext_c");
  }

  return *this;
}
pdcp_sn_len_e& drbs_to_be_modified_item_ext_ies_o::ext_c::dl_pdcp_sn_len()
{
  assert_choice_type(types::dl_pdcp_sn_len, type_, "Extension");
  return c.get<pdcp_sn_len_e>();
}
pdcp_sn_len_e& drbs_to_be_modified_item_ext_ies_o::ext_c::ul_pdcp_sn_len()
{
  assert_choice_type(types::ul_pdcp_sn_len, type_, "Extension");
  return c.get<pdcp_sn_len_e>();
}
bearer_type_change_e& drbs_to_be_modified_item_ext_ies_o::ext_c::bearer_type_change()
{
  assert_choice_type(types::bearer_type_change, type_, "Extension");
  return c.get<bearer_type_change_e>();
}
rlc_mode_e& drbs_to_be_modified_item_ext_ies_o::ext_c::rlc_mode()
{
  assert_choice_type(types::rlc_mode, type_, "Extension");
  return c.get<rlc_mode_e>();
}
dupl_activation_e& drbs_to_be_modified_item_ext_ies_o::ext_c::dupl_activation()
{
  assert_choice_type(types::dupl_activation, type_, "Extension");
  return c.get<dupl_activation_e>();
}
dc_based_dupl_cfg_e& drbs_to_be_modified_item_ext_ies_o::ext_c::dc_based_dupl_cfg()
{
  assert_choice_type(types::dc_based_dupl_cfg, type_, "Extension");
  return c.get<dc_based_dupl_cfg_e>();
}
dupl_activation_e& drbs_to_be_modified_item_ext_ies_o::ext_c::dc_based_dupl_activation()
{
  assert_choice_type(types::dc_based_dupl_activation, type_, "Extension");
  return c.get<dupl_activation_e>();
}
add_pdcp_dupl_tnl_list_l& drbs_to_be_modified_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
rlc_dupl_info_s& drbs_to_be_modified_item_ext_ies_o::ext_c::rlc_dupl_info()
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
tx_stop_ind_e& drbs_to_be_modified_item_ext_ies_o::ext_c::tx_stop_ind()
{
  assert_choice_type(types::tx_stop_ind, type_, "Extension");
  return c.get<tx_stop_ind_e>();
}
cg_sd_tind_mod_e& drbs_to_be_modified_item_ext_ies_o::ext_c::cg_sd_tind_mod()
{
  assert_choice_type(types::cg_sd_tind_mod, type_, "Extension");
  return c.get<cg_sd_tind_mod_e>();
}
const pdcp_sn_len_e& drbs_to_be_modified_item_ext_ies_o::ext_c::dl_pdcp_sn_len() const
{
  assert_choice_type(types::dl_pdcp_sn_len, type_, "Extension");
  return c.get<pdcp_sn_len_e>();
}
const pdcp_sn_len_e& drbs_to_be_modified_item_ext_ies_o::ext_c::ul_pdcp_sn_len() const
{
  assert_choice_type(types::ul_pdcp_sn_len, type_, "Extension");
  return c.get<pdcp_sn_len_e>();
}
const bearer_type_change_e& drbs_to_be_modified_item_ext_ies_o::ext_c::bearer_type_change() const
{
  assert_choice_type(types::bearer_type_change, type_, "Extension");
  return c.get<bearer_type_change_e>();
}
const rlc_mode_e& drbs_to_be_modified_item_ext_ies_o::ext_c::rlc_mode() const
{
  assert_choice_type(types::rlc_mode, type_, "Extension");
  return c.get<rlc_mode_e>();
}
const dupl_activation_e& drbs_to_be_modified_item_ext_ies_o::ext_c::dupl_activation() const
{
  assert_choice_type(types::dupl_activation, type_, "Extension");
  return c.get<dupl_activation_e>();
}
const dc_based_dupl_cfg_e& drbs_to_be_modified_item_ext_ies_o::ext_c::dc_based_dupl_cfg() const
{
  assert_choice_type(types::dc_based_dupl_cfg, type_, "Extension");
  return c.get<dc_based_dupl_cfg_e>();
}
const dupl_activation_e& drbs_to_be_modified_item_ext_ies_o::ext_c::dc_based_dupl_activation() const
{
  assert_choice_type(types::dc_based_dupl_activation, type_, "Extension");
  return c.get<dupl_activation_e>();
}
const add_pdcp_dupl_tnl_list_l& drbs_to_be_modified_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const rlc_dupl_info_s& drbs_to_be_modified_item_ext_ies_o::ext_c::rlc_dupl_info() const
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
const tx_stop_ind_e& drbs_to_be_modified_item_ext_ies_o::ext_c::tx_stop_ind() const
{
  assert_choice_type(types::tx_stop_ind, type_, "Extension");
  return c.get<tx_stop_ind_e>();
}
const cg_sd_tind_mod_e& drbs_to_be_modified_item_ext_ies_o::ext_c::cg_sd_tind_mod() const
{
  assert_choice_type(types::cg_sd_tind_mod, type_, "Extension");
  return c.get<cg_sd_tind_mod_e>();
}
void drbs_to_be_modified_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::dl_pdcp_sn_len:
      j.write_str("PDCPSNLength", c.get<pdcp_sn_len_e>().to_string());
      break;
    case types::ul_pdcp_sn_len:
      j.write_str("PDCPSNLength", c.get<pdcp_sn_len_e>().to_string());
      break;
    case types::bearer_type_change:
      j.write_str("BearerTypeChange", "true");
      break;
    case types::rlc_mode:
      j.write_str("RLCMode", c.get<rlc_mode_e>().to_string());
      break;
    case types::dupl_activation:
      j.write_str("DuplicationActivation", c.get<dupl_activation_e>().to_string());
      break;
    case types::dc_based_dupl_cfg:
      j.write_str("DCBasedDuplicationConfigured", c.get<dc_based_dupl_cfg_e>().to_string());
      break;
    case types::dc_based_dupl_activation:
      j.write_str("DuplicationActivation", c.get<dupl_activation_e>().to_string());
      break;
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("AdditionalPDCPDuplicationTNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::rlc_dupl_info:
      j.write_fieldname("RLCDuplicationInformation");
      c.get<rlc_dupl_info_s>().to_json(j);
      break;
    case types::tx_stop_ind:
      j.write_str("TransmissionStopIndicator", "true");
      break;
    case types::cg_sd_tind_mod:
      j.write_str("CG-SDTindicatorMod", c.get<cg_sd_tind_mod_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_to_be_modified_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::dl_pdcp_sn_len:
      HANDLE_CODE(c.get<pdcp_sn_len_e>().pack(bref));
      break;
    case types::ul_pdcp_sn_len:
      HANDLE_CODE(c.get<pdcp_sn_len_e>().pack(bref));
      break;
    case types::bearer_type_change:
      HANDLE_CODE(c.get<bearer_type_change_e>().pack(bref));
      break;
    case types::rlc_mode:
      HANDLE_CODE(c.get<rlc_mode_e>().pack(bref));
      break;
    case types::dupl_activation:
      HANDLE_CODE(c.get<dupl_activation_e>().pack(bref));
      break;
    case types::dc_based_dupl_cfg:
      HANDLE_CODE(c.get<dc_based_dupl_cfg_e>().pack(bref));
      break;
    case types::dc_based_dupl_activation:
      HANDLE_CODE(c.get<dupl_activation_e>().pack(bref));
      break;
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().pack(bref));
      break;
    case types::tx_stop_ind:
      HANDLE_CODE(c.get<tx_stop_ind_e>().pack(bref));
      break;
    case types::cg_sd_tind_mod:
      HANDLE_CODE(c.get<cg_sd_tind_mod_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::dl_pdcp_sn_len:
      HANDLE_CODE(c.get<pdcp_sn_len_e>().unpack(bref));
      break;
    case types::ul_pdcp_sn_len:
      HANDLE_CODE(c.get<pdcp_sn_len_e>().unpack(bref));
      break;
    case types::bearer_type_change:
      HANDLE_CODE(c.get<bearer_type_change_e>().unpack(bref));
      break;
    case types::rlc_mode:
      HANDLE_CODE(c.get<rlc_mode_e>().unpack(bref));
      break;
    case types::dupl_activation:
      HANDLE_CODE(c.get<dupl_activation_e>().unpack(bref));
      break;
    case types::dc_based_dupl_cfg:
      HANDLE_CODE(c.get<dc_based_dupl_cfg_e>().unpack(bref));
      break;
    case types::dc_based_dupl_activation:
      HANDLE_CODE(c.get<dupl_activation_e>().unpack(bref));
      break;
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().unpack(bref));
      break;
    case types::tx_stop_ind:
      HANDLE_CODE(c.get<tx_stop_ind_e>().unpack(bref));
      break;
    case types::cg_sd_tind_mod:
      HANDLE_CODE(c.get<cg_sd_tind_mod_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_modified_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

template struct asn1::protocol_ie_single_container_s<qos_info_ext_ies_o>;

// QoSInformation ::= CHOICE
void qos_info_c::destroy_()
{
  switch (type_) {
    case types::eutran_qos:
      c.destroy<eutran_qos_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<qos_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void qos_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutran_qos:
      c.init<eutran_qos_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<qos_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_info_c");
  }
}
qos_info_c::qos_info_c(const qos_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutran_qos:
      c.init(other.c.get<eutran_qos_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<qos_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_info_c");
  }
}
qos_info_c& qos_info_c::operator=(const qos_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutran_qos:
      c.set(other.c.get<eutran_qos_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<qos_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "qos_info_c");
  }

  return *this;
}
eutran_qos_s& qos_info_c::set_eutran_qos()
{
  set(types::eutran_qos);
  return c.get<eutran_qos_s>();
}
protocol_ie_single_container_s<qos_info_ext_ies_o>& qos_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<qos_info_ext_ies_o>>();
}
void qos_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutran_qos:
      j.write_fieldname("eUTRANQoS");
      c.get<eutran_qos_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<qos_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "qos_info_c");
  }
  j.end_obj();
}
SRSASN_CODE qos_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutran_qos:
      HANDLE_CODE(c.get<eutran_qos_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<qos_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE qos_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutran_qos:
      HANDLE_CODE(c.get<eutran_qos_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<qos_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "qos_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* qos_info_c::types_opts::to_string() const
{
  static const char* names[] = {"eUTRANQoS", "choice-extension"};
  return convert_enum_idx(names, 2, value, "qos_info_c::types");
}

// ULConfiguration ::= SEQUENCE
SRSASN_CODE ul_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_ue_cfg.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_ue_cfg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("uLUEConfiguration", ul_ue_cfg.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE drbs_to_be_modified_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += dl_pdcp_sn_len_present ? 1 : 0;
  nof_ies += ul_pdcp_sn_len_present ? 1 : 0;
  nof_ies += bearer_type_change_present ? 1 : 0;
  nof_ies += rlc_mode_present ? 1 : 0;
  nof_ies += dupl_activation_present ? 1 : 0;
  nof_ies += dc_based_dupl_cfg_present ? 1 : 0;
  nof_ies += dc_based_dupl_activation_present ? 1 : 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += rlc_dupl_info_present ? 1 : 0;
  nof_ies += tx_stop_ind_present ? 1 : 0;
  nof_ies += cg_sd_tind_mod_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (dl_pdcp_sn_len_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)161, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dl_pdcp_sn_len.pack(bref));
  }
  if (ul_pdcp_sn_len_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)192, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_pdcp_sn_len.pack(bref));
  }
  if (bearer_type_change_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)186, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(bearer_type_change.pack(bref));
  }
  if (rlc_mode_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)187, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rlc_mode.pack(bref));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)188, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dupl_activation.pack(bref));
  }
  if (dc_based_dupl_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)176, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dc_based_dupl_cfg.pack(bref));
  }
  if (dc_based_dupl_activation_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)177, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dc_based_dupl_activation.pack(bref));
  }
  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)370, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (rlc_dupl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)371, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rlc_dupl_info.pack(bref));
  }
  if (tx_stop_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)430, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tx_stop_ind.pack(bref));
  }
  if (cg_sd_tind_mod_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)590, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cg_sd_tind_mod.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 161: {
        dl_pdcp_sn_len_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dl_pdcp_sn_len.unpack(bref));
        break;
      }
      case 192: {
        ul_pdcp_sn_len_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_pdcp_sn_len.unpack(bref));
        break;
      }
      case 186: {
        bearer_type_change_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(bearer_type_change.unpack(bref));
        break;
      }
      case 187: {
        rlc_mode_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rlc_mode.unpack(bref));
        break;
      }
      case 188: {
        dupl_activation_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dupl_activation.unpack(bref));
        break;
      }
      case 176: {
        dc_based_dupl_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dc_based_dupl_cfg.unpack(bref));
        break;
      }
      case 177: {
        dc_based_dupl_activation_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dc_based_dupl_activation.unpack(bref));
        break;
      }
      case 370: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 371: {
        rlc_dupl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rlc_dupl_info.unpack(bref));
        break;
      }
      case 430: {
        tx_stop_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tx_stop_ind.unpack(bref));
        break;
      }
      case 590: {
        cg_sd_tind_mod_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cg_sd_tind_mod.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_modified_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (dl_pdcp_sn_len_present) {
    j.write_int("id", 161);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", dl_pdcp_sn_len.to_string());
  }
  if (ul_pdcp_sn_len_present) {
    j.write_int("id", 192);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", ul_pdcp_sn_len.to_string());
  }
  if (bearer_type_change_present) {
    j.write_int("id", 186);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (rlc_mode_present) {
    j.write_int("id", 187);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", rlc_mode.to_string());
  }
  if (dupl_activation_present) {
    j.write_int("id", 188);
    j.write_str("criticality", "reject");
    j.write_str("Extension", dupl_activation.to_string());
  }
  if (dc_based_dupl_cfg_present) {
    j.write_int("id", 176);
    j.write_str("criticality", "reject");
    j.write_str("Extension", dc_based_dupl_cfg.to_string());
  }
  if (dc_based_dupl_activation_present) {
    j.write_int("id", 177);
    j.write_str("criticality", "reject");
    j.write_str("Extension", dc_based_dupl_activation.to_string());
  }
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 370);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (rlc_dupl_info_present) {
    j.write_int("id", 371);
    j.write_str("criticality", "ignore");
    rlc_dupl_info.to_json(j);
  }
  if (tx_stop_ind_present) {
    j.write_int("id", 430);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (cg_sd_tind_mod_present) {
    j.write_int("id", 590);
    j.write_str("criticality", "reject");
    j.write_str("Extension", cg_sd_tind_mod.to_string());
  }
  j.end_obj();
}

// DRBs-ToBeModified-Item ::= SEQUENCE
SRSASN_CODE drbs_to_be_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qos_info_present, 1));
  HANDLE_CODE(bref.pack(ul_cfg_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (qos_info_present) {
    HANDLE_CODE(qos_info.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, ul_up_tnl_info_to_be_setup_list, 1, 2, true));
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(qos_info_present, 1));
  HANDLE_CODE(bref.unpack(ul_cfg_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (qos_info_present) {
    HANDLE_CODE(qos_info.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(ul_up_tnl_info_to_be_setup_list, bref, 1, 2, true));
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  if (qos_info_present) {
    j.write_fieldname("qoSInformation");
    qos_info.to_json(j);
  }
  j.start_array("uLUPTNLInformation-ToBeSetup-List");
  for (const auto& e1 : ul_up_tnl_info_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ul_cfg_present) {
    j.write_fieldname("uLConfiguration");
    ul_cfg.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBs-ToBeReleased-Item ::= SEQUENCE
SRSASN_CODE drbs_to_be_released_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_released_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DRBs-ToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t drbs_to_be_setup_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {176, 177, 161, 192, 370, 371, 593};
  return map_enum_number(names, 7, idx, "id");
}
bool drbs_to_be_setup_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {176, 177, 161, 192, 370, 371, 593};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_to_be_setup_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 176:
      return crit_e::reject;
    case 177:
      return crit_e::reject;
    case 161:
      return crit_e::ignore;
    case 192:
      return crit_e::ignore;
    case 370:
      return crit_e::ignore;
    case 371:
      return crit_e::ignore;
    case 593:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_to_be_setup_item_ext_ies_o::ext_c drbs_to_be_setup_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 176:
      ret.set(ext_c::types::dc_based_dupl_cfg);
      break;
    case 177:
      ret.set(ext_c::types::dc_based_dupl_activation);
      break;
    case 161:
      ret.set(ext_c::types::dl_pdcp_sn_len);
      break;
    case 192:
      ret.set(ext_c::types::ul_pdcp_sn_len);
      break;
    case 370:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 371:
      ret.set(ext_c::types::rlc_dupl_info);
      break;
    case 593:
      ret.set(ext_c::types::sdt_rlc_bearer_cfg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_be_setup_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 176:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 161:
      return presence_e::mandatory;
    case 192:
      return presence_e::optional;
    case 370:
      return presence_e::optional;
    case 371:
      return presence_e::optional;
    case 593:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_be_setup_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c.destroy<add_pdcp_dupl_tnl_list_l>();
      break;
    case types::rlc_dupl_info:
      c.destroy<rlc_dupl_info_s>();
      break;
    case types::sdt_rlc_bearer_cfg:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void drbs_to_be_setup_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::dc_based_dupl_cfg:
      break;
    case types::dc_based_dupl_activation:
      break;
    case types::dl_pdcp_sn_len:
      break;
    case types::ul_pdcp_sn_len:
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.init<add_pdcp_dupl_tnl_list_l>();
      break;
    case types::rlc_dupl_info:
      c.init<rlc_dupl_info_s>();
      break;
    case types::sdt_rlc_bearer_cfg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_item_ext_ies_o::ext_c");
  }
}
drbs_to_be_setup_item_ext_ies_o::ext_c::ext_c(const drbs_to_be_setup_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::dc_based_dupl_cfg:
      c.init(other.c.get<dc_based_dupl_cfg_e>());
      break;
    case types::dc_based_dupl_activation:
      c.init(other.c.get<dupl_activation_e>());
      break;
    case types::dl_pdcp_sn_len:
      c.init(other.c.get<pdcp_sn_len_e>());
      break;
    case types::ul_pdcp_sn_len:
      c.init(other.c.get<pdcp_sn_len_e>());
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.init(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::rlc_dupl_info:
      c.init(other.c.get<rlc_dupl_info_s>());
      break;
    case types::sdt_rlc_bearer_cfg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_item_ext_ies_o::ext_c");
  }
}
drbs_to_be_setup_item_ext_ies_o::ext_c&
drbs_to_be_setup_item_ext_ies_o::ext_c::operator=(const drbs_to_be_setup_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::dc_based_dupl_cfg:
      c.set(other.c.get<dc_based_dupl_cfg_e>());
      break;
    case types::dc_based_dupl_activation:
      c.set(other.c.get<dupl_activation_e>());
      break;
    case types::dl_pdcp_sn_len:
      c.set(other.c.get<pdcp_sn_len_e>());
      break;
    case types::ul_pdcp_sn_len:
      c.set(other.c.get<pdcp_sn_len_e>());
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.set(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::rlc_dupl_info:
      c.set(other.c.get<rlc_dupl_info_s>());
      break;
    case types::sdt_rlc_bearer_cfg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_item_ext_ies_o::ext_c");
  }

  return *this;
}
dc_based_dupl_cfg_e& drbs_to_be_setup_item_ext_ies_o::ext_c::dc_based_dupl_cfg()
{
  assert_choice_type(types::dc_based_dupl_cfg, type_, "Extension");
  return c.get<dc_based_dupl_cfg_e>();
}
dupl_activation_e& drbs_to_be_setup_item_ext_ies_o::ext_c::dc_based_dupl_activation()
{
  assert_choice_type(types::dc_based_dupl_activation, type_, "Extension");
  return c.get<dupl_activation_e>();
}
pdcp_sn_len_e& drbs_to_be_setup_item_ext_ies_o::ext_c::dl_pdcp_sn_len()
{
  assert_choice_type(types::dl_pdcp_sn_len, type_, "Extension");
  return c.get<pdcp_sn_len_e>();
}
pdcp_sn_len_e& drbs_to_be_setup_item_ext_ies_o::ext_c::ul_pdcp_sn_len()
{
  assert_choice_type(types::ul_pdcp_sn_len, type_, "Extension");
  return c.get<pdcp_sn_len_e>();
}
add_pdcp_dupl_tnl_list_l& drbs_to_be_setup_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
rlc_dupl_info_s& drbs_to_be_setup_item_ext_ies_o::ext_c::rlc_dupl_info()
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
unbounded_octstring<true>& drbs_to_be_setup_item_ext_ies_o::ext_c::sdt_rlc_bearer_cfg()
{
  assert_choice_type(types::sdt_rlc_bearer_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const dc_based_dupl_cfg_e& drbs_to_be_setup_item_ext_ies_o::ext_c::dc_based_dupl_cfg() const
{
  assert_choice_type(types::dc_based_dupl_cfg, type_, "Extension");
  return c.get<dc_based_dupl_cfg_e>();
}
const dupl_activation_e& drbs_to_be_setup_item_ext_ies_o::ext_c::dc_based_dupl_activation() const
{
  assert_choice_type(types::dc_based_dupl_activation, type_, "Extension");
  return c.get<dupl_activation_e>();
}
const pdcp_sn_len_e& drbs_to_be_setup_item_ext_ies_o::ext_c::dl_pdcp_sn_len() const
{
  assert_choice_type(types::dl_pdcp_sn_len, type_, "Extension");
  return c.get<pdcp_sn_len_e>();
}
const pdcp_sn_len_e& drbs_to_be_setup_item_ext_ies_o::ext_c::ul_pdcp_sn_len() const
{
  assert_choice_type(types::ul_pdcp_sn_len, type_, "Extension");
  return c.get<pdcp_sn_len_e>();
}
const add_pdcp_dupl_tnl_list_l& drbs_to_be_setup_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const rlc_dupl_info_s& drbs_to_be_setup_item_ext_ies_o::ext_c::rlc_dupl_info() const
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
const unbounded_octstring<true>& drbs_to_be_setup_item_ext_ies_o::ext_c::sdt_rlc_bearer_cfg() const
{
  assert_choice_type(types::sdt_rlc_bearer_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
void drbs_to_be_setup_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::dc_based_dupl_cfg:
      j.write_str("DCBasedDuplicationConfigured", c.get<dc_based_dupl_cfg_e>().to_string());
      break;
    case types::dc_based_dupl_activation:
      j.write_str("DuplicationActivation", c.get<dupl_activation_e>().to_string());
      break;
    case types::dl_pdcp_sn_len:
      j.write_str("PDCPSNLength", c.get<pdcp_sn_len_e>().to_string());
      break;
    case types::ul_pdcp_sn_len:
      j.write_str("PDCPSNLength", c.get<pdcp_sn_len_e>().to_string());
      break;
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("AdditionalPDCPDuplicationTNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::rlc_dupl_info:
      j.write_fieldname("RLCDuplicationInformation");
      c.get<rlc_dupl_info_s>().to_json(j);
      break;
    case types::sdt_rlc_bearer_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_to_be_setup_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::dc_based_dupl_cfg:
      HANDLE_CODE(c.get<dc_based_dupl_cfg_e>().pack(bref));
      break;
    case types::dc_based_dupl_activation:
      HANDLE_CODE(c.get<dupl_activation_e>().pack(bref));
      break;
    case types::dl_pdcp_sn_len:
      HANDLE_CODE(c.get<pdcp_sn_len_e>().pack(bref));
      break;
    case types::ul_pdcp_sn_len:
      HANDLE_CODE(c.get<pdcp_sn_len_e>().pack(bref));
      break;
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().pack(bref));
      break;
    case types::sdt_rlc_bearer_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::dc_based_dupl_cfg:
      HANDLE_CODE(c.get<dc_based_dupl_cfg_e>().unpack(bref));
      break;
    case types::dc_based_dupl_activation:
      HANDLE_CODE(c.get<dupl_activation_e>().unpack(bref));
      break;
    case types::dl_pdcp_sn_len:
      HANDLE_CODE(c.get<pdcp_sn_len_e>().unpack(bref));
      break;
    case types::ul_pdcp_sn_len:
      HANDLE_CODE(c.get<pdcp_sn_len_e>().unpack(bref));
      break;
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().unpack(bref));
      break;
    case types::sdt_rlc_bearer_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE drbs_to_be_setup_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += dc_based_dupl_cfg_present ? 1 : 0;
  nof_ies += dc_based_dupl_activation_present ? 1 : 0;
  nof_ies += ul_pdcp_sn_len_present ? 1 : 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += rlc_dupl_info_present ? 1 : 0;
  nof_ies += sdt_rlc_bearer_cfg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (dc_based_dupl_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)176, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dc_based_dupl_cfg.pack(bref));
  }
  if (dc_based_dupl_activation_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)177, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dc_based_dupl_activation.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)161, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dl_pdcp_sn_len.pack(bref));
  }
  if (ul_pdcp_sn_len_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)192, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_pdcp_sn_len.pack(bref));
  }
  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)370, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (rlc_dupl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)371, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rlc_dupl_info.pack(bref));
  }
  if (sdt_rlc_bearer_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)593, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sdt_rlc_bearer_cfg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 176: {
        dc_based_dupl_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dc_based_dupl_cfg.unpack(bref));
        break;
      }
      case 177: {
        dc_based_dupl_activation_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dc_based_dupl_activation.unpack(bref));
        break;
      }
      case 161: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dl_pdcp_sn_len.unpack(bref));
        break;
      }
      case 192: {
        ul_pdcp_sn_len_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_pdcp_sn_len.unpack(bref));
        break;
      }
      case 370: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 371: {
        rlc_dupl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rlc_dupl_info.unpack(bref));
        break;
      }
      case 593: {
        sdt_rlc_bearer_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sdt_rlc_bearer_cfg.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void drbs_to_be_setup_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (dc_based_dupl_cfg_present) {
    j.write_int("id", 176);
    j.write_str("criticality", "reject");
    j.write_str("Extension", dc_based_dupl_cfg.to_string());
  }
  if (dc_based_dupl_activation_present) {
    j.write_int("id", 177);
    j.write_str("criticality", "reject");
    j.write_str("Extension", dc_based_dupl_activation.to_string());
  }
  j.write_int("id", 161);
  j.write_str("criticality", "ignore");
  j.write_str("Extension", dl_pdcp_sn_len.to_string());
  if (ul_pdcp_sn_len_present) {
    j.write_int("id", 192);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", ul_pdcp_sn_len.to_string());
  }
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 370);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (rlc_dupl_info_present) {
    j.write_int("id", 371);
    j.write_str("criticality", "ignore");
    rlc_dupl_info.to_json(j);
  }
  if (sdt_rlc_bearer_cfg_present) {
    j.write_int("id", 593);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sdt_rlc_bearer_cfg.to_string());
  }
  j.end_obj();
}

// DRBs-ToBeSetup-Item ::= SEQUENCE
SRSASN_CODE drbs_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ul_cfg_present, 1));
  HANDLE_CODE(bref.pack(dupl_activation_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(qos_info.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, ul_up_tnl_info_to_be_setup_list, 1, 2, true));
  HANDLE_CODE(rlc_mode.pack(bref));
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.pack(bref));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ul_cfg_present, 1));
  HANDLE_CODE(bref.unpack(dupl_activation_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(qos_info.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(ul_up_tnl_info_to_be_setup_list, bref, 1, 2, true));
  HANDLE_CODE(rlc_mode.unpack(bref));
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.unpack(bref));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  j.write_fieldname("qoSInformation");
  qos_info.to_json(j);
  j.start_array("uLUPTNLInformation-ToBeSetup-List");
  for (const auto& e1 : ul_up_tnl_info_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_str("rLCMode", rlc_mode.to_string());
  if (ul_cfg_present) {
    j.write_fieldname("uLConfiguration");
    ul_cfg.to_json(j);
  }
  if (dupl_activation_present) {
    j.write_str("duplicationActivation", dupl_activation.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CG-SDTindicatorSetup ::= ENUMERATED
const char* cg_sd_tind_setup_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "cg_sd_tind_setup_e");
}

// DRBs-ToBeSetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t drbs_to_be_setup_mod_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {176, 177, 161, 192, 370, 371, 589};
  return map_enum_number(names, 7, idx, "id");
}
bool drbs_to_be_setup_mod_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {176, 177, 161, 192, 370, 371, 589};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e drbs_to_be_setup_mod_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 176:
      return crit_e::reject;
    case 177:
      return crit_e::reject;
    case 161:
      return crit_e::ignore;
    case 192:
      return crit_e::ignore;
    case 370:
      return crit_e::ignore;
    case 371:
      return crit_e::ignore;
    case 589:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
drbs_to_be_setup_mod_item_ext_ies_o::ext_c drbs_to_be_setup_mod_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 176:
      ret.set(ext_c::types::dc_based_dupl_cfg);
      break;
    case 177:
      ret.set(ext_c::types::dc_based_dupl_activation);
      break;
    case 161:
      ret.set(ext_c::types::dl_pdcp_sn_len);
      break;
    case 192:
      ret.set(ext_c::types::ul_pdcp_sn_len);
      break;
    case 370:
      ret.set(ext_c::types::add_pdcp_dupl_tnl_list);
      break;
    case 371:
      ret.set(ext_c::types::rlc_dupl_info);
      break;
    case 589:
      ret.set(ext_c::types::cg_sd_tind_setup);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e drbs_to_be_setup_mod_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 176:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 161:
      return presence_e::optional;
    case 192:
      return presence_e::optional;
    case 370:
      return presence_e::optional;
    case 371:
      return presence_e::optional;
    case 589:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void drbs_to_be_setup_mod_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::add_pdcp_dupl_tnl_list:
      c.destroy<add_pdcp_dupl_tnl_list_l>();
      break;
    case types::rlc_dupl_info:
      c.destroy<rlc_dupl_info_s>();
      break;
    default:
      break;
  }
}
void drbs_to_be_setup_mod_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::dc_based_dupl_cfg:
      break;
    case types::dc_based_dupl_activation:
      break;
    case types::dl_pdcp_sn_len:
      break;
    case types::ul_pdcp_sn_len:
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.init<add_pdcp_dupl_tnl_list_l>();
      break;
    case types::rlc_dupl_info:
      c.init<rlc_dupl_info_s>();
      break;
    case types::cg_sd_tind_setup:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_mod_item_ext_ies_o::ext_c");
  }
}
drbs_to_be_setup_mod_item_ext_ies_o::ext_c::ext_c(const drbs_to_be_setup_mod_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::dc_based_dupl_cfg:
      c.init(other.c.get<dc_based_dupl_cfg_e>());
      break;
    case types::dc_based_dupl_activation:
      c.init(other.c.get<dupl_activation_e>());
      break;
    case types::dl_pdcp_sn_len:
      c.init(other.c.get<pdcp_sn_len_e>());
      break;
    case types::ul_pdcp_sn_len:
      c.init(other.c.get<pdcp_sn_len_e>());
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.init(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::rlc_dupl_info:
      c.init(other.c.get<rlc_dupl_info_s>());
      break;
    case types::cg_sd_tind_setup:
      c.init(other.c.get<cg_sd_tind_setup_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_mod_item_ext_ies_o::ext_c");
  }
}
drbs_to_be_setup_mod_item_ext_ies_o::ext_c&
drbs_to_be_setup_mod_item_ext_ies_o::ext_c::operator=(const drbs_to_be_setup_mod_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::dc_based_dupl_cfg:
      c.set(other.c.get<dc_based_dupl_cfg_e>());
      break;
    case types::dc_based_dupl_activation:
      c.set(other.c.get<dupl_activation_e>());
      break;
    case types::dl_pdcp_sn_len:
      c.set(other.c.get<pdcp_sn_len_e>());
      break;
    case types::ul_pdcp_sn_len:
      c.set(other.c.get<pdcp_sn_len_e>());
      break;
    case types::add_pdcp_dupl_tnl_list:
      c.set(other.c.get<add_pdcp_dupl_tnl_list_l>());
      break;
    case types::rlc_dupl_info:
      c.set(other.c.get<rlc_dupl_info_s>());
      break;
    case types::cg_sd_tind_setup:
      c.set(other.c.get<cg_sd_tind_setup_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_mod_item_ext_ies_o::ext_c");
  }

  return *this;
}
dc_based_dupl_cfg_e& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::dc_based_dupl_cfg()
{
  assert_choice_type(types::dc_based_dupl_cfg, type_, "Extension");
  return c.get<dc_based_dupl_cfg_e>();
}
dupl_activation_e& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::dc_based_dupl_activation()
{
  assert_choice_type(types::dc_based_dupl_activation, type_, "Extension");
  return c.get<dupl_activation_e>();
}
pdcp_sn_len_e& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::dl_pdcp_sn_len()
{
  assert_choice_type(types::dl_pdcp_sn_len, type_, "Extension");
  return c.get<pdcp_sn_len_e>();
}
pdcp_sn_len_e& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::ul_pdcp_sn_len()
{
  assert_choice_type(types::ul_pdcp_sn_len, type_, "Extension");
  return c.get<pdcp_sn_len_e>();
}
add_pdcp_dupl_tnl_list_l& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list()
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
rlc_dupl_info_s& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::rlc_dupl_info()
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
cg_sd_tind_setup_e& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::cg_sd_tind_setup()
{
  assert_choice_type(types::cg_sd_tind_setup, type_, "Extension");
  return c.get<cg_sd_tind_setup_e>();
}
const dc_based_dupl_cfg_e& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::dc_based_dupl_cfg() const
{
  assert_choice_type(types::dc_based_dupl_cfg, type_, "Extension");
  return c.get<dc_based_dupl_cfg_e>();
}
const dupl_activation_e& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::dc_based_dupl_activation() const
{
  assert_choice_type(types::dc_based_dupl_activation, type_, "Extension");
  return c.get<dupl_activation_e>();
}
const pdcp_sn_len_e& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::dl_pdcp_sn_len() const
{
  assert_choice_type(types::dl_pdcp_sn_len, type_, "Extension");
  return c.get<pdcp_sn_len_e>();
}
const pdcp_sn_len_e& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::ul_pdcp_sn_len() const
{
  assert_choice_type(types::ul_pdcp_sn_len, type_, "Extension");
  return c.get<pdcp_sn_len_e>();
}
const add_pdcp_dupl_tnl_list_l& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::add_pdcp_dupl_tnl_list() const
{
  assert_choice_type(types::add_pdcp_dupl_tnl_list, type_, "Extension");
  return c.get<add_pdcp_dupl_tnl_list_l>();
}
const rlc_dupl_info_s& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::rlc_dupl_info() const
{
  assert_choice_type(types::rlc_dupl_info, type_, "Extension");
  return c.get<rlc_dupl_info_s>();
}
const cg_sd_tind_setup_e& drbs_to_be_setup_mod_item_ext_ies_o::ext_c::cg_sd_tind_setup() const
{
  assert_choice_type(types::cg_sd_tind_setup, type_, "Extension");
  return c.get<cg_sd_tind_setup_e>();
}
void drbs_to_be_setup_mod_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::dc_based_dupl_cfg:
      j.write_str("DCBasedDuplicationConfigured", c.get<dc_based_dupl_cfg_e>().to_string());
      break;
    case types::dc_based_dupl_activation:
      j.write_str("DuplicationActivation", c.get<dupl_activation_e>().to_string());
      break;
    case types::dl_pdcp_sn_len:
      j.write_str("PDCPSNLength", c.get<pdcp_sn_len_e>().to_string());
      break;
    case types::ul_pdcp_sn_len:
      j.write_str("PDCPSNLength", c.get<pdcp_sn_len_e>().to_string());
      break;
    case types::add_pdcp_dupl_tnl_list:
      j.start_array("AdditionalPDCPDuplicationTNL-List");
      for (const auto& e1 : c.get<add_pdcp_dupl_tnl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::rlc_dupl_info:
      j.write_fieldname("RLCDuplicationInformation");
      c.get<rlc_dupl_info_s>().to_json(j);
      break;
    case types::cg_sd_tind_setup:
      j.write_str("CG-SDTindicatorSetup", "true");
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_mod_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE drbs_to_be_setup_mod_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::dc_based_dupl_cfg:
      HANDLE_CODE(c.get<dc_based_dupl_cfg_e>().pack(bref));
      break;
    case types::dc_based_dupl_activation:
      HANDLE_CODE(c.get<dupl_activation_e>().pack(bref));
      break;
    case types::dl_pdcp_sn_len:
      HANDLE_CODE(c.get<pdcp_sn_len_e>().pack(bref));
      break;
    case types::ul_pdcp_sn_len:
      HANDLE_CODE(c.get<pdcp_sn_len_e>().pack(bref));
      break;
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_pdcp_dupl_tnl_list_l>(), 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().pack(bref));
      break;
    case types::cg_sd_tind_setup:
      HANDLE_CODE(c.get<cg_sd_tind_setup_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_mod_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_mod_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::dc_based_dupl_cfg:
      HANDLE_CODE(c.get<dc_based_dupl_cfg_e>().unpack(bref));
      break;
    case types::dc_based_dupl_activation:
      HANDLE_CODE(c.get<dupl_activation_e>().unpack(bref));
      break;
    case types::dl_pdcp_sn_len:
      HANDLE_CODE(c.get<pdcp_sn_len_e>().unpack(bref));
      break;
    case types::ul_pdcp_sn_len:
      HANDLE_CODE(c.get<pdcp_sn_len_e>().unpack(bref));
      break;
    case types::add_pdcp_dupl_tnl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_pdcp_dupl_tnl_list_l>(), bref, 1, 2, true));
      break;
    case types::rlc_dupl_info:
      HANDLE_CODE(c.get<rlc_dupl_info_s>().unpack(bref));
      break;
    case types::cg_sd_tind_setup:
      HANDLE_CODE(c.get<cg_sd_tind_setup_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "drbs_to_be_setup_mod_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE drbs_to_be_setup_mod_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += dc_based_dupl_cfg_present ? 1 : 0;
  nof_ies += dc_based_dupl_activation_present ? 1 : 0;
  nof_ies += dl_pdcp_sn_len_present ? 1 : 0;
  nof_ies += ul_pdcp_sn_len_present ? 1 : 0;
  nof_ies += add_pdcp_dupl_tnl_list_present ? 1 : 0;
  nof_ies += rlc_dupl_info_present ? 1 : 0;
  nof_ies += cg_sd_tind_setup_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (dc_based_dupl_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)176, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dc_based_dupl_cfg.pack(bref));
  }
  if (dc_based_dupl_activation_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)177, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dc_based_dupl_activation.pack(bref));
  }
  if (dl_pdcp_sn_len_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)161, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dl_pdcp_sn_len.pack(bref));
  }
  if (ul_pdcp_sn_len_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)192, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_pdcp_sn_len.pack(bref));
  }
  if (add_pdcp_dupl_tnl_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)370, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_pdcp_dupl_tnl_list, 1, 2, true));
  }
  if (rlc_dupl_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)371, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rlc_dupl_info.pack(bref));
  }
  if (cg_sd_tind_setup_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)589, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cg_sd_tind_setup.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_mod_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 176: {
        dc_based_dupl_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dc_based_dupl_cfg.unpack(bref));
        break;
      }
      case 177: {
        dc_based_dupl_activation_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dc_based_dupl_activation.unpack(bref));
        break;
      }
      case 161: {
        dl_pdcp_sn_len_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dl_pdcp_sn_len.unpack(bref));
        break;
      }
      case 192: {
        ul_pdcp_sn_len_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_pdcp_sn_len.unpack(bref));
        break;
      }
      case 370: {
        add_pdcp_dupl_tnl_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_pdcp_dupl_tnl_list, bref, 1, 2, true));
        break;
      }
      case 371: {
        rlc_dupl_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rlc_dupl_info.unpack(bref));
        break;
      }
      case 589: {
        cg_sd_tind_setup_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cg_sd_tind_setup.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_setup_mod_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (dc_based_dupl_cfg_present) {
    j.write_int("id", 176);
    j.write_str("criticality", "reject");
    j.write_str("Extension", dc_based_dupl_cfg.to_string());
  }
  if (dc_based_dupl_activation_present) {
    j.write_int("id", 177);
    j.write_str("criticality", "reject");
    j.write_str("Extension", dc_based_dupl_activation.to_string());
  }
  if (dl_pdcp_sn_len_present) {
    j.write_int("id", 161);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", dl_pdcp_sn_len.to_string());
  }
  if (ul_pdcp_sn_len_present) {
    j.write_int("id", 192);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", ul_pdcp_sn_len.to_string());
  }
  if (add_pdcp_dupl_tnl_list_present) {
    j.write_int("id", 370);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : add_pdcp_dupl_tnl_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (rlc_dupl_info_present) {
    j.write_int("id", 371);
    j.write_str("criticality", "ignore");
    rlc_dupl_info.to_json(j);
  }
  if (cg_sd_tind_setup_present) {
    j.write_int("id", 589);
    j.write_str("criticality", "reject");
    j.write_str("Extension", "true");
  }
  j.end_obj();
}

// DRBs-ToBeSetupMod-Item ::= SEQUENCE
SRSASN_CODE drbs_to_be_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ul_cfg_present, 1));
  HANDLE_CODE(bref.pack(dupl_activation_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, drb_id, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(qos_info.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, ul_up_tnl_info_to_be_setup_list, 1, 2, true));
  HANDLE_CODE(rlc_mode.pack(bref));
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.pack(bref));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drbs_to_be_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ul_cfg_present, 1));
  HANDLE_CODE(bref.unpack(dupl_activation_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(drb_id, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  HANDLE_CODE(qos_info.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(ul_up_tnl_info_to_be_setup_list, bref, 1, 2, true));
  HANDLE_CODE(rlc_mode.unpack(bref));
  if (ul_cfg_present) {
    HANDLE_CODE(ul_cfg.unpack(bref));
  }
  if (dupl_activation_present) {
    HANDLE_CODE(dupl_activation.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drbs_to_be_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dRBID", drb_id);
  j.write_fieldname("qoSInformation");
  qos_info.to_json(j);
  j.start_array("uLUPTNLInformation-ToBeSetup-List");
  for (const auto& e1 : ul_up_tnl_info_to_be_setup_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_str("rLCMode", rlc_mode.to_string());
  if (ul_cfg_present) {
    j.write_fieldname("uLConfiguration");
    ul_cfg.to_json(j);
  }
  if (dupl_activation_present) {
    j.write_str("duplicationActivation", dupl_activation.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LongDRXCycleLength ::= ENUMERATED
const char* long_drx_cycle_len_opts::to_string() const
{
  static const char* names[] = {"ms10",   "ms20",   "ms32",   "ms40",   "ms60",   "ms64",   "ms70",
                                "ms80",   "ms128",  "ms160",  "ms256",  "ms320",  "ms512",  "ms640",
                                "ms1024", "ms1280", "ms2048", "ms2560", "ms5120", "ms10240"};
  return convert_enum_idx(names, 20, value, "long_drx_cycle_len_e");
}
uint16_t long_drx_cycle_len_opts::to_number() const
{
  static const uint16_t numbers[] = {10,  20,  32,  40,  60,   64,   70,   80,   128,  160,
                                     256, 320, 512, 640, 1024, 1280, 2048, 2560, 5120, 10240};
  return map_enum_number(numbers, 20, value, "long_drx_cycle_len_e");
}

// ShortDRXCycleLength ::= ENUMERATED
const char* short_drx_cycle_len_opts::to_string() const
{
  static const char* names[] = {"ms2",  "ms3",   "ms4",   "ms5",   "ms6",   "ms7",   "ms8",  "ms10",
                                "ms14", "ms16",  "ms20",  "ms30",  "ms32",  "ms35",  "ms40", "ms64",
                                "ms80", "ms128", "ms160", "ms256", "ms320", "ms512", "ms640"};
  return convert_enum_idx(names, 23, value, "short_drx_cycle_len_e");
}
uint16_t short_drx_cycle_len_opts::to_number() const
{
  static const uint16_t numbers[] = {2,  3,  4,  5,  6,  7,   8,   10,  14,  16,  20, 30,
                                     32, 35, 40, 64, 80, 128, 160, 256, 320, 512, 640};
  return map_enum_number(numbers, 23, value, "short_drx_cycle_len_e");
}

// DRXCycle ::= SEQUENCE
SRSASN_CODE drx_cycle_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(short_drx_cycle_len_present, 1));
  HANDLE_CODE(bref.pack(short_drx_cycle_timer_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(long_drx_cycle_len.pack(bref));
  if (short_drx_cycle_len_present) {
    HANDLE_CODE(short_drx_cycle_len.pack(bref));
  }
  if (short_drx_cycle_timer_present) {
    HANDLE_CODE(pack_integer(bref, short_drx_cycle_timer, (uint8_t)1u, (uint8_t)16u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE drx_cycle_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(short_drx_cycle_len_present, 1));
  HANDLE_CODE(bref.unpack(short_drx_cycle_timer_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(long_drx_cycle_len.unpack(bref));
  if (short_drx_cycle_len_present) {
    HANDLE_CODE(short_drx_cycle_len.unpack(bref));
  }
  if (short_drx_cycle_timer_present) {
    HANDLE_CODE(unpack_integer(short_drx_cycle_timer, bref, (uint8_t)1u, (uint8_t)16u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void drx_cycle_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("longDRXCycleLength", long_drx_cycle_len.to_string());
  if (short_drx_cycle_len_present) {
    j.write_str("shortDRXCycleLength", short_drx_cycle_len.to_string());
  }
  if (short_drx_cycle_timer_present) {
    j.write_int("shortDRXCycleTimer", short_drx_cycle_timer);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DUCURIMInformation ::= SEQUENCE
SRSASN_CODE du_cu_rim_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(victim_gnb_set_id.pack(bref));
  HANDLE_CODE(rimrs_detection_status.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, aggressor_cell_list, 1, 512, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE du_cu_rim_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(victim_gnb_set_id.unpack(bref));
  HANDLE_CODE(rimrs_detection_status.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(aggressor_cell_list, bref, 1, 512, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void du_cu_rim_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("victimgNBSetID", victim_gnb_set_id.to_string());
  j.write_str("rIMRSDetectionStatus", rimrs_detection_status.to_string());
  j.start_array("aggressorCellList");
  for (const auto& e1 : aggressor_cell_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DUCURadioInformationType ::= CHOICE
void du_cu_radio_info_type_c::destroy_()
{
  switch (type_) {
    case types::rim:
      c.destroy<du_cu_rim_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void du_cu_radio_info_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::rim:
      c.init<du_cu_rim_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "du_cu_radio_info_type_c");
  }
}
du_cu_radio_info_type_c::du_cu_radio_info_type_c(const du_cu_radio_info_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::rim:
      c.init(other.c.get<du_cu_rim_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "du_cu_radio_info_type_c");
  }
}
du_cu_radio_info_type_c& du_cu_radio_info_type_c::operator=(const du_cu_radio_info_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::rim:
      c.set(other.c.get<du_cu_rim_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "du_cu_radio_info_type_c");
  }

  return *this;
}
du_cu_rim_info_s& du_cu_radio_info_type_c::set_rim()
{
  set(types::rim);
  return c.get<du_cu_rim_info_s>();
}
protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>& du_cu_radio_info_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>>();
}
void du_cu_radio_info_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::rim:
      j.write_fieldname("rIM");
      c.get<du_cu_rim_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "du_cu_radio_info_type_c");
  }
  j.end_obj();
}
SRSASN_CODE du_cu_radio_info_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::rim:
      HANDLE_CODE(c.get<du_cu_rim_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "du_cu_radio_info_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE du_cu_radio_info_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::rim:
      HANDLE_CODE(c.get<du_cu_rim_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<du_cu_radio_info_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "du_cu_radio_info_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* du_cu_radio_info_type_c::types_opts::to_string() const
{
  static const char* names[] = {"rIM", "choice-extension"};
  return convert_enum_idx(names, 2, value, "du_cu_radio_info_type_c::types");
}

// InterFrequencyConfig-NoGap ::= ENUMERATED
const char* interfreq_cfg_no_gap_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "interfreq_cfg_no_gap_e");
}

// TwoPHRModeMCG ::= ENUMERATED
const char* two_phr_mode_mcg_opts::to_string() const
{
  static const char* names[] = {"enabled"};
  return convert_enum_idx(names, 1, value, "two_phr_mode_mcg_e");
}

// TwoPHRModeSCG ::= ENUMERATED
const char* two_phr_mode_scg_opts::to_string() const
{
  static const char* names[] = {"enabled"};
  return convert_enum_idx(names, 1, value, "two_phr_mode_scg_e");
}

// DUtoCURRCInformation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t du_to_cu_rrc_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {191, 193, 194, 208, 209, 210, 212, 235, 236, 237, 238,
                                   341, 342, 211, 587, 621, 645, 651, 677, 692, 693};
  return map_enum_number(names, 21, idx, "id");
}
bool du_to_cu_rrc_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {191, 193, 194, 208, 209, 210, 212, 235, 236, 237, 238,
                                   341, 342, 211, 587, 621, 645, 651, 677, 692, 693};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e du_to_cu_rrc_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 191:
      return crit_e::ignore;
    case 193:
      return crit_e::ignore;
    case 194:
      return crit_e::ignore;
    case 208:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 210:
      return crit_e::ignore;
    case 212:
      return crit_e::ignore;
    case 235:
      return crit_e::ignore;
    case 236:
      return crit_e::ignore;
    case 237:
      return crit_e::ignore;
    case 238:
      return crit_e::ignore;
    case 341:
      return crit_e::ignore;
    case 342:
      return crit_e::ignore;
    case 211:
      return crit_e::ignore;
    case 587:
      return crit_e::ignore;
    case 621:
      return crit_e::ignore;
    case 645:
      return crit_e::ignore;
    case 651:
      return crit_e::ignore;
    case 677:
      return crit_e::ignore;
    case 692:
      return crit_e::ignore;
    case 693:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
du_to_cu_rrc_info_ext_ies_o::ext_c du_to_cu_rrc_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 191:
      ret.set(ext_c::types::drx_long_cycle_start_offset);
      break;
    case 193:
      ret.set(ext_c::types::sel_band_combination_idx);
      break;
    case 194:
      ret.set(ext_c::types::sel_feature_set_entry_idx);
      break;
    case 208:
      ret.set(ext_c::types::ph_info_scg);
      break;
    case 209:
      ret.set(ext_c::types::requested_band_combination_idx);
      break;
    case 210:
      ret.set(ext_c::types::requested_feature_set_entry_idx);
      break;
    case 212:
      ret.set(ext_c::types::drx_cfg);
      break;
    case 235:
      ret.set(ext_c::types::pdcch_blind_detection_scg);
      break;
    case 236:
      ret.set(ext_c::types::requested_pdcch_blind_detection_scg);
      break;
    case 237:
      ret.set(ext_c::types::ph_info_mcg);
      break;
    case 238:
      ret.set(ext_c::types::meas_gap_sharing_cfg);
      break;
    case 341:
      ret.set(ext_c::types::sl_phy_mac_rlc_cfg);
      break;
    case 342:
      ret.set(ext_c::types::sl_cfg_ded_eutra_info);
      break;
    case 211:
      ret.set(ext_c::types::requested_p_max_fr2);
      break;
    case 587:
      ret.set(ext_c::types::sdt_mac_phy_cg_cfg);
      break;
    case 621:
      ret.set(ext_c::types::mu_si_m_gap_cfg);
      break;
    case 645:
      ret.set(ext_c::types::sl_rlc_ch_to_add_mod_list);
      break;
    case 651:
      ret.set(ext_c::types::interfreq_cfg_no_gap);
      break;
    case 677:
      ret.set(ext_c::types::ul_gap_fr2_cfg);
      break;
    case 692:
      ret.set(ext_c::types::two_phr_mode_mcg);
      break;
    case 693:
      ret.set(ext_c::types::two_phr_mode_scg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e du_to_cu_rrc_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 191:
      return presence_e::optional;
    case 193:
      return presence_e::optional;
    case 194:
      return presence_e::optional;
    case 208:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 210:
      return presence_e::optional;
    case 212:
      return presence_e::optional;
    case 235:
      return presence_e::optional;
    case 236:
      return presence_e::optional;
    case 237:
      return presence_e::optional;
    case 238:
      return presence_e::optional;
    case 341:
      return presence_e::optional;
    case 342:
      return presence_e::optional;
    case 211:
      return presence_e::optional;
    case 587:
      return presence_e::optional;
    case 621:
      return presence_e::optional;
    case 645:
      return presence_e::optional;
    case 651:
      return presence_e::optional;
    case 677:
      return presence_e::optional;
    case 692:
      return presence_e::optional;
    case 693:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void du_to_cu_rrc_info_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::sel_band_combination_idx:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::sel_feature_set_entry_idx:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ph_info_scg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::requested_band_combination_idx:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::requested_feature_set_entry_idx:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::drx_cfg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::pdcch_blind_detection_scg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::requested_pdcch_blind_detection_scg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ph_info_mcg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::meas_gap_sharing_cfg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::sl_phy_mac_rlc_cfg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::sl_cfg_ded_eutra_info:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::requested_p_max_fr2:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::sdt_mac_phy_cg_cfg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::mu_si_m_gap_cfg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::sl_rlc_ch_to_add_mod_list:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ul_gap_fr2_cfg:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void du_to_cu_rrc_info_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::drx_long_cycle_start_offset:
      break;
    case types::sel_band_combination_idx:
      c.init<unbounded_octstring<true>>();
      break;
    case types::sel_feature_set_entry_idx:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ph_info_scg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::requested_band_combination_idx:
      c.init<unbounded_octstring<true>>();
      break;
    case types::requested_feature_set_entry_idx:
      c.init<unbounded_octstring<true>>();
      break;
    case types::drx_cfg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::pdcch_blind_detection_scg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::requested_pdcch_blind_detection_scg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ph_info_mcg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::meas_gap_sharing_cfg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::sl_phy_mac_rlc_cfg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::sl_cfg_ded_eutra_info:
      c.init<unbounded_octstring<true>>();
      break;
    case types::requested_p_max_fr2:
      c.init<unbounded_octstring<true>>();
      break;
    case types::sdt_mac_phy_cg_cfg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::mu_si_m_gap_cfg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::sl_rlc_ch_to_add_mod_list:
      c.init<unbounded_octstring<true>>();
      break;
    case types::interfreq_cfg_no_gap:
      break;
    case types::ul_gap_fr2_cfg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::two_phr_mode_mcg:
      break;
    case types::two_phr_mode_scg:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "du_to_cu_rrc_info_ext_ies_o::ext_c");
  }
}
du_to_cu_rrc_info_ext_ies_o::ext_c::ext_c(const du_to_cu_rrc_info_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::drx_long_cycle_start_offset:
      c.init(other.c.get<uint16_t>());
      break;
    case types::sel_band_combination_idx:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sel_feature_set_entry_idx:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ph_info_scg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::requested_band_combination_idx:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::requested_feature_set_entry_idx:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::drx_cfg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdcch_blind_detection_scg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::requested_pdcch_blind_detection_scg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ph_info_mcg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::meas_gap_sharing_cfg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sl_phy_mac_rlc_cfg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sl_cfg_ded_eutra_info:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::requested_p_max_fr2:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sdt_mac_phy_cg_cfg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mu_si_m_gap_cfg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sl_rlc_ch_to_add_mod_list:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::interfreq_cfg_no_gap:
      c.init(other.c.get<interfreq_cfg_no_gap_e>());
      break;
    case types::ul_gap_fr2_cfg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::two_phr_mode_mcg:
      c.init(other.c.get<two_phr_mode_mcg_e>());
      break;
    case types::two_phr_mode_scg:
      c.init(other.c.get<two_phr_mode_scg_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "du_to_cu_rrc_info_ext_ies_o::ext_c");
  }
}
du_to_cu_rrc_info_ext_ies_o::ext_c&
du_to_cu_rrc_info_ext_ies_o::ext_c::operator=(const du_to_cu_rrc_info_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::drx_long_cycle_start_offset:
      c.set(other.c.get<uint16_t>());
      break;
    case types::sel_band_combination_idx:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sel_feature_set_entry_idx:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ph_info_scg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::requested_band_combination_idx:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::requested_feature_set_entry_idx:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::drx_cfg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdcch_blind_detection_scg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::requested_pdcch_blind_detection_scg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ph_info_mcg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::meas_gap_sharing_cfg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sl_phy_mac_rlc_cfg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sl_cfg_ded_eutra_info:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::requested_p_max_fr2:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sdt_mac_phy_cg_cfg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mu_si_m_gap_cfg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sl_rlc_ch_to_add_mod_list:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::interfreq_cfg_no_gap:
      c.set(other.c.get<interfreq_cfg_no_gap_e>());
      break;
    case types::ul_gap_fr2_cfg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::two_phr_mode_mcg:
      c.set(other.c.get<two_phr_mode_mcg_e>());
      break;
    case types::two_phr_mode_scg:
      c.set(other.c.get<two_phr_mode_scg_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "du_to_cu_rrc_info_ext_ies_o::ext_c");
  }

  return *this;
}
uint16_t& du_to_cu_rrc_info_ext_ies_o::ext_c::drx_long_cycle_start_offset()
{
  assert_choice_type(types::drx_long_cycle_start_offset, type_, "Extension");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::sel_band_combination_idx()
{
  assert_choice_type(types::sel_band_combination_idx, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::sel_feature_set_entry_idx()
{
  assert_choice_type(types::sel_feature_set_entry_idx, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::ph_info_scg()
{
  assert_choice_type(types::ph_info_scg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::requested_band_combination_idx()
{
  assert_choice_type(types::requested_band_combination_idx, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::requested_feature_set_entry_idx()
{
  assert_choice_type(types::requested_feature_set_entry_idx, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::drx_cfg()
{
  assert_choice_type(types::drx_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::pdcch_blind_detection_scg()
{
  assert_choice_type(types::pdcch_blind_detection_scg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::requested_pdcch_blind_detection_scg()
{
  assert_choice_type(types::requested_pdcch_blind_detection_scg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::ph_info_mcg()
{
  assert_choice_type(types::ph_info_mcg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::meas_gap_sharing_cfg()
{
  assert_choice_type(types::meas_gap_sharing_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::sl_phy_mac_rlc_cfg()
{
  assert_choice_type(types::sl_phy_mac_rlc_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::sl_cfg_ded_eutra_info()
{
  assert_choice_type(types::sl_cfg_ded_eutra_info, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::requested_p_max_fr2()
{
  assert_choice_type(types::requested_p_max_fr2, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::sdt_mac_phy_cg_cfg()
{
  assert_choice_type(types::sdt_mac_phy_cg_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::mu_si_m_gap_cfg()
{
  assert_choice_type(types::mu_si_m_gap_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::sl_rlc_ch_to_add_mod_list()
{
  assert_choice_type(types::sl_rlc_ch_to_add_mod_list, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
interfreq_cfg_no_gap_e& du_to_cu_rrc_info_ext_ies_o::ext_c::interfreq_cfg_no_gap()
{
  assert_choice_type(types::interfreq_cfg_no_gap, type_, "Extension");
  return c.get<interfreq_cfg_no_gap_e>();
}
unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::ul_gap_fr2_cfg()
{
  assert_choice_type(types::ul_gap_fr2_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
two_phr_mode_mcg_e& du_to_cu_rrc_info_ext_ies_o::ext_c::two_phr_mode_mcg()
{
  assert_choice_type(types::two_phr_mode_mcg, type_, "Extension");
  return c.get<two_phr_mode_mcg_e>();
}
two_phr_mode_scg_e& du_to_cu_rrc_info_ext_ies_o::ext_c::two_phr_mode_scg()
{
  assert_choice_type(types::two_phr_mode_scg, type_, "Extension");
  return c.get<two_phr_mode_scg_e>();
}
const uint16_t& du_to_cu_rrc_info_ext_ies_o::ext_c::drx_long_cycle_start_offset() const
{
  assert_choice_type(types::drx_long_cycle_start_offset, type_, "Extension");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::sel_band_combination_idx() const
{
  assert_choice_type(types::sel_band_combination_idx, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::sel_feature_set_entry_idx() const
{
  assert_choice_type(types::sel_feature_set_entry_idx, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::ph_info_scg() const
{
  assert_choice_type(types::ph_info_scg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::requested_band_combination_idx() const
{
  assert_choice_type(types::requested_band_combination_idx, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::requested_feature_set_entry_idx() const
{
  assert_choice_type(types::requested_feature_set_entry_idx, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::drx_cfg() const
{
  assert_choice_type(types::drx_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::pdcch_blind_detection_scg() const
{
  assert_choice_type(types::pdcch_blind_detection_scg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::requested_pdcch_blind_detection_scg() const
{
  assert_choice_type(types::requested_pdcch_blind_detection_scg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::ph_info_mcg() const
{
  assert_choice_type(types::ph_info_mcg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::meas_gap_sharing_cfg() const
{
  assert_choice_type(types::meas_gap_sharing_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::sl_phy_mac_rlc_cfg() const
{
  assert_choice_type(types::sl_phy_mac_rlc_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::sl_cfg_ded_eutra_info() const
{
  assert_choice_type(types::sl_cfg_ded_eutra_info, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::requested_p_max_fr2() const
{
  assert_choice_type(types::requested_p_max_fr2, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::sdt_mac_phy_cg_cfg() const
{
  assert_choice_type(types::sdt_mac_phy_cg_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::mu_si_m_gap_cfg() const
{
  assert_choice_type(types::mu_si_m_gap_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::sl_rlc_ch_to_add_mod_list() const
{
  assert_choice_type(types::sl_rlc_ch_to_add_mod_list, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const interfreq_cfg_no_gap_e& du_to_cu_rrc_info_ext_ies_o::ext_c::interfreq_cfg_no_gap() const
{
  assert_choice_type(types::interfreq_cfg_no_gap, type_, "Extension");
  return c.get<interfreq_cfg_no_gap_e>();
}
const unbounded_octstring<true>& du_to_cu_rrc_info_ext_ies_o::ext_c::ul_gap_fr2_cfg() const
{
  assert_choice_type(types::ul_gap_fr2_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const two_phr_mode_mcg_e& du_to_cu_rrc_info_ext_ies_o::ext_c::two_phr_mode_mcg() const
{
  assert_choice_type(types::two_phr_mode_mcg, type_, "Extension");
  return c.get<two_phr_mode_mcg_e>();
}
const two_phr_mode_scg_e& du_to_cu_rrc_info_ext_ies_o::ext_c::two_phr_mode_scg() const
{
  assert_choice_type(types::two_phr_mode_scg, type_, "Extension");
  return c.get<two_phr_mode_scg_e>();
}
void du_to_cu_rrc_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::drx_long_cycle_start_offset:
      j.write_int("INTEGER (0..10239)", c.get<uint16_t>());
      break;
    case types::sel_band_combination_idx:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::sel_feature_set_entry_idx:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ph_info_scg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::requested_band_combination_idx:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::requested_feature_set_entry_idx:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::drx_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdcch_blind_detection_scg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::requested_pdcch_blind_detection_scg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ph_info_mcg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::meas_gap_sharing_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::sl_phy_mac_rlc_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::sl_cfg_ded_eutra_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::requested_p_max_fr2:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::sdt_mac_phy_cg_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::mu_si_m_gap_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::sl_rlc_ch_to_add_mod_list:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::interfreq_cfg_no_gap:
      j.write_str("InterFrequencyConfig-NoGap", "true");
      break;
    case types::ul_gap_fr2_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::two_phr_mode_mcg:
      j.write_str("TwoPHRModeMCG", "enabled");
      break;
    case types::two_phr_mode_scg:
      j.write_str("TwoPHRModeSCG", "enabled");
      break;
    default:
      log_invalid_choice_id(type_, "du_to_cu_rrc_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE du_to_cu_rrc_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::drx_long_cycle_start_offset:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)10239u, false, true));
      break;
    case types::sel_band_combination_idx:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::sel_feature_set_entry_idx:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ph_info_scg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::requested_band_combination_idx:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::requested_feature_set_entry_idx:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::drx_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdcch_blind_detection_scg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::requested_pdcch_blind_detection_scg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ph_info_mcg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::meas_gap_sharing_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::sl_phy_mac_rlc_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::sl_cfg_ded_eutra_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::requested_p_max_fr2:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::sdt_mac_phy_cg_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::mu_si_m_gap_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::sl_rlc_ch_to_add_mod_list:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::interfreq_cfg_no_gap:
      HANDLE_CODE(c.get<interfreq_cfg_no_gap_e>().pack(bref));
      break;
    case types::ul_gap_fr2_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::two_phr_mode_mcg:
      HANDLE_CODE(c.get<two_phr_mode_mcg_e>().pack(bref));
      break;
    case types::two_phr_mode_scg:
      HANDLE_CODE(c.get<two_phr_mode_scg_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "du_to_cu_rrc_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE du_to_cu_rrc_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::drx_long_cycle_start_offset:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)10239u, false, true));
      break;
    case types::sel_band_combination_idx:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::sel_feature_set_entry_idx:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ph_info_scg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::requested_band_combination_idx:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::requested_feature_set_entry_idx:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::drx_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdcch_blind_detection_scg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::requested_pdcch_blind_detection_scg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ph_info_mcg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::meas_gap_sharing_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::sl_phy_mac_rlc_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::sl_cfg_ded_eutra_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::requested_p_max_fr2:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::sdt_mac_phy_cg_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::mu_si_m_gap_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::sl_rlc_ch_to_add_mod_list:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::interfreq_cfg_no_gap:
      HANDLE_CODE(c.get<interfreq_cfg_no_gap_e>().unpack(bref));
      break;
    case types::ul_gap_fr2_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::two_phr_mode_mcg:
      HANDLE_CODE(c.get<two_phr_mode_mcg_e>().unpack(bref));
      break;
    case types::two_phr_mode_scg:
      HANDLE_CODE(c.get<two_phr_mode_scg_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "du_to_cu_rrc_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE du_to_cu_rrc_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += drx_long_cycle_start_offset_present ? 1 : 0;
  nof_ies += sel_band_combination_idx_present ? 1 : 0;
  nof_ies += sel_feature_set_entry_idx_present ? 1 : 0;
  nof_ies += ph_info_scg_present ? 1 : 0;
  nof_ies += requested_band_combination_idx_present ? 1 : 0;
  nof_ies += requested_feature_set_entry_idx_present ? 1 : 0;
  nof_ies += drx_cfg_present ? 1 : 0;
  nof_ies += pdcch_blind_detection_scg_present ? 1 : 0;
  nof_ies += requested_pdcch_blind_detection_scg_present ? 1 : 0;
  nof_ies += ph_info_mcg_present ? 1 : 0;
  nof_ies += meas_gap_sharing_cfg_present ? 1 : 0;
  nof_ies += sl_phy_mac_rlc_cfg_present ? 1 : 0;
  nof_ies += sl_cfg_ded_eutra_info_present ? 1 : 0;
  nof_ies += requested_p_max_fr2_present ? 1 : 0;
  nof_ies += sdt_mac_phy_cg_cfg_present ? 1 : 0;
  nof_ies += mu_si_m_gap_cfg_present ? 1 : 0;
  nof_ies += sl_rlc_ch_to_add_mod_list_present ? 1 : 0;
  nof_ies += interfreq_cfg_no_gap_present ? 1 : 0;
  nof_ies += ul_gap_fr2_cfg_present ? 1 : 0;
  nof_ies += two_phr_mode_mcg_present ? 1 : 0;
  nof_ies += two_phr_mode_scg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (drx_long_cycle_start_offset_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)191, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, drx_long_cycle_start_offset, (uint16_t)0u, (uint16_t)10239u, false, true));
  }
  if (sel_band_combination_idx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)193, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sel_band_combination_idx.pack(bref));
  }
  if (sel_feature_set_entry_idx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)194, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sel_feature_set_entry_idx.pack(bref));
  }
  if (ph_info_scg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)208, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ph_info_scg.pack(bref));
  }
  if (requested_band_combination_idx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(requested_band_combination_idx.pack(bref));
  }
  if (requested_feature_set_entry_idx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)210, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(requested_feature_set_entry_idx.pack(bref));
  }
  if (drx_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)212, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(drx_cfg.pack(bref));
  }
  if (pdcch_blind_detection_scg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)235, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pdcch_blind_detection_scg.pack(bref));
  }
  if (requested_pdcch_blind_detection_scg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)236, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(requested_pdcch_blind_detection_scg.pack(bref));
  }
  if (ph_info_mcg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)237, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ph_info_mcg.pack(bref));
  }
  if (meas_gap_sharing_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)238, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(meas_gap_sharing_cfg.pack(bref));
  }
  if (sl_phy_mac_rlc_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)341, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sl_phy_mac_rlc_cfg.pack(bref));
  }
  if (sl_cfg_ded_eutra_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)342, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sl_cfg_ded_eutra_info.pack(bref));
  }
  if (requested_p_max_fr2_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)211, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(requested_p_max_fr2.pack(bref));
  }
  if (sdt_mac_phy_cg_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)587, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sdt_mac_phy_cg_cfg.pack(bref));
  }
  if (mu_si_m_gap_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)621, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mu_si_m_gap_cfg.pack(bref));
  }
  if (sl_rlc_ch_to_add_mod_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)645, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sl_rlc_ch_to_add_mod_list.pack(bref));
  }
  if (interfreq_cfg_no_gap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)651, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(interfreq_cfg_no_gap.pack(bref));
  }
  if (ul_gap_fr2_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)677, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_gap_fr2_cfg.pack(bref));
  }
  if (two_phr_mode_mcg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)692, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(two_phr_mode_mcg.pack(bref));
  }
  if (two_phr_mode_scg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)693, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(two_phr_mode_scg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE du_to_cu_rrc_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 191: {
        drx_long_cycle_start_offset_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(drx_long_cycle_start_offset, bref, (uint16_t)0u, (uint16_t)10239u, false, true));
        break;
      }
      case 193: {
        sel_band_combination_idx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sel_band_combination_idx.unpack(bref));
        break;
      }
      case 194: {
        sel_feature_set_entry_idx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sel_feature_set_entry_idx.unpack(bref));
        break;
      }
      case 208: {
        ph_info_scg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ph_info_scg.unpack(bref));
        break;
      }
      case 209: {
        requested_band_combination_idx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(requested_band_combination_idx.unpack(bref));
        break;
      }
      case 210: {
        requested_feature_set_entry_idx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(requested_feature_set_entry_idx.unpack(bref));
        break;
      }
      case 212: {
        drx_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(drx_cfg.unpack(bref));
        break;
      }
      case 235: {
        pdcch_blind_detection_scg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pdcch_blind_detection_scg.unpack(bref));
        break;
      }
      case 236: {
        requested_pdcch_blind_detection_scg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(requested_pdcch_blind_detection_scg.unpack(bref));
        break;
      }
      case 237: {
        ph_info_mcg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ph_info_mcg.unpack(bref));
        break;
      }
      case 238: {
        meas_gap_sharing_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(meas_gap_sharing_cfg.unpack(bref));
        break;
      }
      case 341: {
        sl_phy_mac_rlc_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sl_phy_mac_rlc_cfg.unpack(bref));
        break;
      }
      case 342: {
        sl_cfg_ded_eutra_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sl_cfg_ded_eutra_info.unpack(bref));
        break;
      }
      case 211: {
        requested_p_max_fr2_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(requested_p_max_fr2.unpack(bref));
        break;
      }
      case 587: {
        sdt_mac_phy_cg_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sdt_mac_phy_cg_cfg.unpack(bref));
        break;
      }
      case 621: {
        mu_si_m_gap_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mu_si_m_gap_cfg.unpack(bref));
        break;
      }
      case 645: {
        sl_rlc_ch_to_add_mod_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sl_rlc_ch_to_add_mod_list.unpack(bref));
        break;
      }
      case 651: {
        interfreq_cfg_no_gap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(interfreq_cfg_no_gap.unpack(bref));
        break;
      }
      case 677: {
        ul_gap_fr2_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_gap_fr2_cfg.unpack(bref));
        break;
      }
      case 692: {
        two_phr_mode_mcg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(two_phr_mode_mcg.unpack(bref));
        break;
      }
      case 693: {
        two_phr_mode_scg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(two_phr_mode_scg.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void du_to_cu_rrc_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (drx_long_cycle_start_offset_present) {
    j.write_int("id", 191);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", drx_long_cycle_start_offset);
  }
  if (sel_band_combination_idx_present) {
    j.write_int("id", 193);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sel_band_combination_idx.to_string());
  }
  if (sel_feature_set_entry_idx_present) {
    j.write_int("id", 194);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sel_feature_set_entry_idx.to_string());
  }
  if (ph_info_scg_present) {
    j.write_int("id", 208);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", ph_info_scg.to_string());
  }
  if (requested_band_combination_idx_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", requested_band_combination_idx.to_string());
  }
  if (requested_feature_set_entry_idx_present) {
    j.write_int("id", 210);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", requested_feature_set_entry_idx.to_string());
  }
  if (drx_cfg_present) {
    j.write_int("id", 212);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", drx_cfg.to_string());
  }
  if (pdcch_blind_detection_scg_present) {
    j.write_int("id", 235);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", pdcch_blind_detection_scg.to_string());
  }
  if (requested_pdcch_blind_detection_scg_present) {
    j.write_int("id", 236);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", requested_pdcch_blind_detection_scg.to_string());
  }
  if (ph_info_mcg_present) {
    j.write_int("id", 237);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", ph_info_mcg.to_string());
  }
  if (meas_gap_sharing_cfg_present) {
    j.write_int("id", 238);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", meas_gap_sharing_cfg.to_string());
  }
  if (sl_phy_mac_rlc_cfg_present) {
    j.write_int("id", 341);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sl_phy_mac_rlc_cfg.to_string());
  }
  if (sl_cfg_ded_eutra_info_present) {
    j.write_int("id", 342);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sl_cfg_ded_eutra_info.to_string());
  }
  if (requested_p_max_fr2_present) {
    j.write_int("id", 211);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", requested_p_max_fr2.to_string());
  }
  if (sdt_mac_phy_cg_cfg_present) {
    j.write_int("id", 587);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sdt_mac_phy_cg_cfg.to_string());
  }
  if (mu_si_m_gap_cfg_present) {
    j.write_int("id", 621);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", mu_si_m_gap_cfg.to_string());
  }
  if (sl_rlc_ch_to_add_mod_list_present) {
    j.write_int("id", 645);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sl_rlc_ch_to_add_mod_list.to_string());
  }
  if (interfreq_cfg_no_gap_present) {
    j.write_int("id", 651);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (ul_gap_fr2_cfg_present) {
    j.write_int("id", 677);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", ul_gap_fr2_cfg.to_string());
  }
  if (two_phr_mode_mcg_present) {
    j.write_int("id", 692);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "enabled");
  }
  if (two_phr_mode_scg_present) {
    j.write_int("id", 693);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "enabled");
  }
  j.end_obj();
}

// DUtoCURRCInformation ::= SEQUENCE
SRSASN_CODE du_to_cu_rrc_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(meas_gap_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(requested_p_max_fr1.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(cell_group_cfg.pack(bref));
  if (meas_gap_cfg.size() > 0) {
    HANDLE_CODE(meas_gap_cfg.pack(bref));
  }
  if (requested_p_max_fr1.size() > 0) {
    HANDLE_CODE(requested_p_max_fr1.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE du_to_cu_rrc_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool meas_gap_cfg_present;
  HANDLE_CODE(bref.unpack(meas_gap_cfg_present, 1));
  bool requested_p_max_fr1_present;
  HANDLE_CODE(bref.unpack(requested_p_max_fr1_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(cell_group_cfg.unpack(bref));
  if (meas_gap_cfg_present) {
    HANDLE_CODE(meas_gap_cfg.unpack(bref));
  }
  if (requested_p_max_fr1_present) {
    HANDLE_CODE(requested_p_max_fr1.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void du_to_cu_rrc_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("cellGroupConfig", cell_group_cfg.to_string());
  if (meas_gap_cfg.size() > 0) {
    j.write_str("measGapConfig", meas_gap_cfg.to_string());
  }
  if (requested_p_max_fr1.size() > 0) {
    j.write_str("requestedP-MaxFR1", requested_p_max_fr1.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Dedicated-SIDelivery-NeededUE-Item ::= SEQUENCE
SRSASN_CODE ded_si_delivery_needed_ue_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, gnb_cu_ue_f1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ded_si_delivery_needed_ue_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(gnb_cu_ue_f1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ded_si_delivery_needed_ue_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("gNB-CU-UE-F1AP-ID", gnb_cu_ue_f1ap_id);
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// DynamicPQIDescriptor ::= SEQUENCE
SRSASN_CODE dyn_pq_id_escriptor_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(res_type_present, 1));
  HANDLE_CODE(bref.pack(averaging_win_present, 1));
  HANDLE_CODE(bref.pack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (res_type_present) {
    HANDLE_CODE(res_type.pack(bref));
  }
  HANDLE_CODE(pack_integer(bref, qos_prio_level, (uint8_t)1u, (uint8_t)8u, true, true));
  HANDLE_CODE(pack_integer(bref, packet_delay_budget, (uint16_t)0u, (uint16_t)1023u, true, true));
  HANDLE_CODE(packet_error_rate.pack(bref));
  if (averaging_win_present) {
    HANDLE_CODE(pack_integer(bref, averaging_win, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(pack_integer(bref, max_data_burst_volume, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dyn_pq_id_escriptor_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(res_type_present, 1));
  HANDLE_CODE(bref.unpack(averaging_win_present, 1));
  HANDLE_CODE(bref.unpack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (res_type_present) {
    HANDLE_CODE(res_type.unpack(bref));
  }
  HANDLE_CODE(unpack_integer(qos_prio_level, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  HANDLE_CODE(unpack_integer(packet_delay_budget, bref, (uint16_t)0u, (uint16_t)1023u, true, true));
  HANDLE_CODE(packet_error_rate.unpack(bref));
  if (averaging_win_present) {
    HANDLE_CODE(unpack_integer(averaging_win, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(unpack_integer(max_data_burst_volume, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void dyn_pq_id_escriptor_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (res_type_present) {
    j.write_str("resourceType", res_type.to_string());
  }
  j.write_int("qoSPriorityLevel", qos_prio_level);
  j.write_int("packetDelayBudget", packet_delay_budget);
  j.write_fieldname("packetErrorRate");
  packet_error_rate.to_json(j);
  if (averaging_win_present) {
    j.write_int("averagingWindow", averaging_win);
  }
  if (max_data_burst_volume_present) {
    j.write_int("maxDataBurstVolume", max_data_burst_volume);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* dyn_pq_id_escriptor_s::res_type_opts::to_string() const
{
  static const char* names[] = {"gbr", "non-gbr", "delay-critical-grb"};
  return convert_enum_idx(names, 3, value, "dyn_pq_id_escriptor_s::res_type_e_");
}

// E-CID-MeasuredResults-Value-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
uint32_t e_c_id_measured_results_value_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {584};
  return map_enum_number(names, 1, idx, "id");
}
bool e_c_id_measured_results_value_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 584 == id;
}
crit_e e_c_id_measured_results_value_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 584) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
e_c_id_measured_results_value_ext_ies_o::value_c e_c_id_measured_results_value_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 584) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e e_c_id_measured_results_value_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 584) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void e_c_id_measured_results_value_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..7690)", c);
  j.end_obj();
}
SRSASN_CODE e_c_id_measured_results_value_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint16_t)0u, (uint16_t)7690u, false, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE e_c_id_measured_results_value_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint16_t)0u, (uint16_t)7690u, false, true));
  return SRSASN_SUCCESS;
}

template struct asn1::protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>;

// E-CID-MeasuredResults-Value ::= CHOICE
void e_c_id_measured_results_value_c::destroy_()
{
  switch (type_) {
    case types::value_angleof_arrival_nr:
      c.destroy<ul_ao_a_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void e_c_id_measured_results_value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::value_angleof_arrival_nr:
      c.init<ul_ao_a_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "e_c_id_measured_results_value_c");
  }
}
e_c_id_measured_results_value_c::e_c_id_measured_results_value_c(const e_c_id_measured_results_value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::value_angleof_arrival_nr:
      c.init(other.c.get<ul_ao_a_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "e_c_id_measured_results_value_c");
  }
}
e_c_id_measured_results_value_c&
e_c_id_measured_results_value_c::operator=(const e_c_id_measured_results_value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::value_angleof_arrival_nr:
      c.set(other.c.get<ul_ao_a_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "e_c_id_measured_results_value_c");
  }

  return *this;
}
ul_ao_a_s& e_c_id_measured_results_value_c::set_value_angleof_arrival_nr()
{
  set(types::value_angleof_arrival_nr);
  return c.get<ul_ao_a_s>();
}
protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>&
e_c_id_measured_results_value_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>>();
}
void e_c_id_measured_results_value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::value_angleof_arrival_nr:
      j.write_fieldname("valueAngleofArrivalNR");
      c.get<ul_ao_a_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "e_c_id_measured_results_value_c");
  }
  j.end_obj();
}
SRSASN_CODE e_c_id_measured_results_value_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::value_angleof_arrival_nr:
      HANDLE_CODE(c.get<ul_ao_a_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "e_c_id_measured_results_value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE e_c_id_measured_results_value_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::value_angleof_arrival_nr:
      HANDLE_CODE(c.get<ul_ao_a_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<e_c_id_measured_results_value_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "e_c_id_measured_results_value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* e_c_id_measured_results_value_c::types_opts::to_string() const
{
  static const char* names[] = {"valueAngleofArrivalNR", "choice-extension"};
  return convert_enum_idx(names, 2, value, "e_c_id_measured_results_value_c::types");
}

// E-CID-MeasuredResults-Item ::= SEQUENCE
SRSASN_CODE e_c_id_measured_results_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(e_c_id_measured_results_value.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE e_c_id_measured_results_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(e_c_id_measured_results_value.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void e_c_id_measured_results_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("e-CID-MeasuredResults-Value");
  e_c_id_measured_results_value.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-CID-MeasurementQuantitiesValue ::= ENUMERATED
const char* e_c_id_meas_quantities_value_opts::to_string() const
{
  static const char* names[] = {"default", "angleOfArrivalNR", "timingAdvanceNR"};
  return convert_enum_idx(names, 3, value, "e_c_id_meas_quantities_value_e");
}

// E-CID-MeasurementQuantities-Item ::= SEQUENCE
SRSASN_CODE e_c_id_meas_quantities_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(e_c_id_meas_quantities_value.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE e_c_id_meas_quantities_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(e_c_id_meas_quantities_value.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void e_c_id_meas_quantities_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("e-CIDmeasurementQuantitiesValue", e_c_id_meas_quantities_value.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-CID-MeasurementQuantities-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
uint32_t e_c_id_meas_quantities_item_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {415};
  return map_enum_number(names, 1, idx, "id");
}
bool e_c_id_meas_quantities_item_ies_o::is_id_valid(const uint32_t& id)
{
  return 415 == id;
}
crit_e e_c_id_meas_quantities_item_ies_o::get_crit(const uint32_t& id)
{
  if (id == 415) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
e_c_id_meas_quantities_item_ies_o::value_c e_c_id_meas_quantities_item_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 415) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e e_c_id_meas_quantities_item_ies_o::get_presence(const uint32_t& id)
{
  if (id == 415) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void e_c_id_meas_quantities_item_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("E-CID-MeasurementQuantities-Item");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE e_c_id_meas_quantities_item_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE e_c_id_meas_quantities_item_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

template struct asn1::protocol_ie_single_container_s<e_c_id_meas_quantities_item_ies_o>;

// NGRANHighAccuracyAccessPointPosition ::= SEQUENCE
SRSASN_CODE ngran_high_accuracy_access_point_position_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, latitude, (int64_t)-2147483648, (int64_t)2147483647, false, true));
  HANDLE_CODE(pack_integer(bref, longitude, (int64_t)-2147483648, (int64_t)2147483647, false, true));
  HANDLE_CODE(pack_integer(bref, altitude, (int32_t)-64000, (int32_t)1280000, false, true));
  HANDLE_CODE(pack_integer(bref, uncertainty_semi_major, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pack_integer(bref, uncertainty_semi_minor, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pack_integer(bref, orientation_of_major_axis, (uint8_t)0u, (uint8_t)179u, false, true));
  HANDLE_CODE(pack_integer(bref, horizontal_confidence, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(pack_integer(bref, uncertainty_altitude, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(pack_integer(bref, vertical_confidence, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ngran_high_accuracy_access_point_position_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(latitude, bref, (int64_t)-2147483648, (int64_t)2147483647, false, true));
  HANDLE_CODE(unpack_integer(longitude, bref, (int64_t)-2147483648, (int64_t)2147483647, false, true));
  HANDLE_CODE(unpack_integer(altitude, bref, (int32_t)-64000, (int32_t)1280000, false, true));
  HANDLE_CODE(unpack_integer(uncertainty_semi_major, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(unpack_integer(uncertainty_semi_minor, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(unpack_integer(orientation_of_major_axis, bref, (uint8_t)0u, (uint8_t)179u, false, true));
  HANDLE_CODE(unpack_integer(horizontal_confidence, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(unpack_integer(uncertainty_altitude, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(unpack_integer(vertical_confidence, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ngran_high_accuracy_access_point_position_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("latitude", latitude);
  j.write_int("longitude", longitude);
  j.write_int("altitude", altitude);
  j.write_int("uncertaintySemi-major", uncertainty_semi_major);
  j.write_int("uncertaintySemi-minor", uncertainty_semi_minor);
  j.write_int("orientationOfMajorAxis", orientation_of_major_axis);
  j.write_int("horizontalConfidence", horizontal_confidence);
  j.write_int("uncertaintyAltitude", uncertainty_altitude);
  j.write_int("verticalConfidence", vertical_confidence);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ReferencePoint ::= CHOICE
void ref_point_c::destroy_()
{
  switch (type_) {
    case types::ref_point_coordinate:
      c.destroy<access_point_position_s>();
      break;
    case types::ref_point_coordinate_ha:
      c.destroy<ngran_high_accuracy_access_point_position_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ref_point_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ref_point_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::coordinate_id:
      break;
    case types::ref_point_coordinate:
      c.init<access_point_position_s>();
      break;
    case types::ref_point_coordinate_ha:
      c.init<ngran_high_accuracy_access_point_position_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ref_point_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ref_point_c");
  }
}
ref_point_c::ref_point_c(const ref_point_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::coordinate_id:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ref_point_coordinate:
      c.init(other.c.get<access_point_position_s>());
      break;
    case types::ref_point_coordinate_ha:
      c.init(other.c.get<ngran_high_accuracy_access_point_position_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ref_point_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ref_point_c");
  }
}
ref_point_c& ref_point_c::operator=(const ref_point_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::coordinate_id:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ref_point_coordinate:
      c.set(other.c.get<access_point_position_s>());
      break;
    case types::ref_point_coordinate_ha:
      c.set(other.c.get<ngran_high_accuracy_access_point_position_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ref_point_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ref_point_c");
  }

  return *this;
}
uint16_t& ref_point_c::set_coordinate_id()
{
  set(types::coordinate_id);
  return c.get<uint16_t>();
}
access_point_position_s& ref_point_c::set_ref_point_coordinate()
{
  set(types::ref_point_coordinate);
  return c.get<access_point_position_s>();
}
ngran_high_accuracy_access_point_position_s& ref_point_c::set_ref_point_coordinate_ha()
{
  set(types::ref_point_coordinate_ha);
  return c.get<ngran_high_accuracy_access_point_position_s>();
}
protocol_ie_single_container_s<ref_point_ext_ies_o>& ref_point_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ref_point_ext_ies_o>>();
}
void ref_point_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::coordinate_id:
      j.write_int("coordinateID", c.get<uint16_t>());
      break;
    case types::ref_point_coordinate:
      j.write_fieldname("referencePointCoordinate");
      c.get<access_point_position_s>().to_json(j);
      break;
    case types::ref_point_coordinate_ha:
      j.write_fieldname("referencePointCoordinateHA");
      c.get<ngran_high_accuracy_access_point_position_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-Extension");
      c.get<protocol_ie_single_container_s<ref_point_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ref_point_c");
  }
  j.end_obj();
}
SRSASN_CODE ref_point_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::coordinate_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)511u, true, true));
      break;
    case types::ref_point_coordinate:
      HANDLE_CODE(c.get<access_point_position_s>().pack(bref));
      break;
    case types::ref_point_coordinate_ha:
      HANDLE_CODE(c.get<ngran_high_accuracy_access_point_position_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ref_point_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ref_point_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ref_point_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::coordinate_id:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)511u, true, true));
      break;
    case types::ref_point_coordinate:
      HANDLE_CODE(c.get<access_point_position_s>().unpack(bref));
      break;
    case types::ref_point_coordinate_ha:
      HANDLE_CODE(c.get<ngran_high_accuracy_access_point_position_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ref_point_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ref_point_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ref_point_c::types_opts::to_string() const
{
  static const char* names[] = {
      "coordinateID", "referencePointCoordinate", "referencePointCoordinateHA", "choice-Extension"};
  return convert_enum_idx(names, 4, value, "ref_point_c::types");
}

// TRPPositionDirectAccuracy ::= CHOICE
void trp_position_direct_accuracy_c::destroy_()
{
  switch (type_) {
    case types::trp_position:
      c.destroy<access_point_position_s>();
      break;
    case types::trph_aposition:
      c.destroy<ngran_high_accuracy_access_point_position_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void trp_position_direct_accuracy_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::trp_position:
      c.init<access_point_position_s>();
      break;
    case types::trph_aposition:
      c.init<ngran_high_accuracy_access_point_position_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_position_direct_accuracy_c");
  }
}
trp_position_direct_accuracy_c::trp_position_direct_accuracy_c(const trp_position_direct_accuracy_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::trp_position:
      c.init(other.c.get<access_point_position_s>());
      break;
    case types::trph_aposition:
      c.init(other.c.get<ngran_high_accuracy_access_point_position_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_position_direct_accuracy_c");
  }
}
trp_position_direct_accuracy_c& trp_position_direct_accuracy_c::operator=(const trp_position_direct_accuracy_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::trp_position:
      c.set(other.c.get<access_point_position_s>());
      break;
    case types::trph_aposition:
      c.set(other.c.get<ngran_high_accuracy_access_point_position_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_position_direct_accuracy_c");
  }

  return *this;
}
access_point_position_s& trp_position_direct_accuracy_c::set_trp_position()
{
  set(types::trp_position);
  return c.get<access_point_position_s>();
}
ngran_high_accuracy_access_point_position_s& trp_position_direct_accuracy_c::set_trph_aposition()
{
  set(types::trph_aposition);
  return c.get<ngran_high_accuracy_access_point_position_s>();
}
protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>& trp_position_direct_accuracy_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>>();
}
void trp_position_direct_accuracy_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::trp_position:
      j.write_fieldname("tRPPosition");
      c.get<access_point_position_s>().to_json(j);
      break;
    case types::trph_aposition:
      j.write_fieldname("tRPHAposition");
      c.get<ngran_high_accuracy_access_point_position_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trp_position_direct_accuracy_c");
  }
  j.end_obj();
}
SRSASN_CODE trp_position_direct_accuracy_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::trp_position:
      HANDLE_CODE(c.get<access_point_position_s>().pack(bref));
      break;
    case types::trph_aposition:
      HANDLE_CODE(c.get<ngran_high_accuracy_access_point_position_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_position_direct_accuracy_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_position_direct_accuracy_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::trp_position:
      HANDLE_CODE(c.get<access_point_position_s>().unpack(bref));
      break;
    case types::trph_aposition:
      HANDLE_CODE(c.get<ngran_high_accuracy_access_point_position_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<trp_position_direct_accuracy_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_position_direct_accuracy_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trp_position_direct_accuracy_c::types_opts::to_string() const
{
  static const char* names[] = {"tRPPosition", "tRPHAposition", "choice-extension"};
  return convert_enum_idx(names, 3, value, "trp_position_direct_accuracy_c::types");
}

// TRPReferencePointType ::= CHOICE
void trp_ref_point_type_c::destroy_()
{
  switch (type_) {
    case types::trp_position_relative_geodetic:
      c.destroy<relative_geodetic_location_s>();
      break;
    case types::trp_position_relative_cartesian:
      c.destroy<relative_cartesian_location_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void trp_ref_point_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::trp_position_relative_geodetic:
      c.init<relative_geodetic_location_s>();
      break;
    case types::trp_position_relative_cartesian:
      c.init<relative_cartesian_location_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_ref_point_type_c");
  }
}
trp_ref_point_type_c::trp_ref_point_type_c(const trp_ref_point_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::trp_position_relative_geodetic:
      c.init(other.c.get<relative_geodetic_location_s>());
      break;
    case types::trp_position_relative_cartesian:
      c.init(other.c.get<relative_cartesian_location_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_ref_point_type_c");
  }
}
trp_ref_point_type_c& trp_ref_point_type_c::operator=(const trp_ref_point_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::trp_position_relative_geodetic:
      c.set(other.c.get<relative_geodetic_location_s>());
      break;
    case types::trp_position_relative_cartesian:
      c.set(other.c.get<relative_cartesian_location_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_ref_point_type_c");
  }

  return *this;
}
relative_geodetic_location_s& trp_ref_point_type_c::set_trp_position_relative_geodetic()
{
  set(types::trp_position_relative_geodetic);
  return c.get<relative_geodetic_location_s>();
}
relative_cartesian_location_s& trp_ref_point_type_c::set_trp_position_relative_cartesian()
{
  set(types::trp_position_relative_cartesian);
  return c.get<relative_cartesian_location_s>();
}
protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>& trp_ref_point_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>>();
}
void trp_ref_point_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::trp_position_relative_geodetic:
      j.write_fieldname("tRPPositionRelativeGeodetic");
      c.get<relative_geodetic_location_s>().to_json(j);
      break;
    case types::trp_position_relative_cartesian:
      j.write_fieldname("tRPPositionRelativeCartesian");
      c.get<relative_cartesian_location_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trp_ref_point_type_c");
  }
  j.end_obj();
}
SRSASN_CODE trp_ref_point_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::trp_position_relative_geodetic:
      HANDLE_CODE(c.get<relative_geodetic_location_s>().pack(bref));
      break;
    case types::trp_position_relative_cartesian:
      HANDLE_CODE(c.get<relative_cartesian_location_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_ref_point_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_ref_point_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::trp_position_relative_geodetic:
      HANDLE_CODE(c.get<relative_geodetic_location_s>().unpack(bref));
      break;
    case types::trp_position_relative_cartesian:
      HANDLE_CODE(c.get<relative_cartesian_location_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<trp_ref_point_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_ref_point_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trp_ref_point_type_c::types_opts::to_string() const
{
  static const char* names[] = {"tRPPositionRelativeGeodetic", "tRPPositionRelativeCartesian", "choice-extension"};
  return convert_enum_idx(names, 3, value, "trp_ref_point_type_c::types");
}

// TRPPositionDirect ::= SEQUENCE
SRSASN_CODE trp_position_direct_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(accuracy.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_position_direct_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(accuracy.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_position_direct_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("accuracy");
  accuracy.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRPPositionReferenced ::= SEQUENCE
SRSASN_CODE trp_position_refd_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ref_point.pack(bref));
  HANDLE_CODE(ref_point_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_position_refd_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ref_point.unpack(bref));
  HANDLE_CODE(ref_point_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_position_refd_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("referencePoint");
  ref_point.to_json(j);
  j.write_fieldname("referencePointType");
  ref_point_type.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GeographicalCoordinates-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t geographical_coordinates_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {556};
  return map_enum_number(names, 1, idx, "id");
}
bool geographical_coordinates_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 556 == id;
}
crit_e geographical_coordinates_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 556) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
geographical_coordinates_ext_ies_o::ext_c geographical_coordinates_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 556) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e geographical_coordinates_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 556) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void geographical_coordinates_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("ARPLocationInformation");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE geographical_coordinates_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 16, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE geographical_coordinates_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 16, true));
  return SRSASN_SUCCESS;
}

// TRPPositionDefinitionType ::= CHOICE
void trp_position_definition_type_c::destroy_()
{
  switch (type_) {
    case types::direct:
      c.destroy<trp_position_direct_s>();
      break;
    case types::refd:
      c.destroy<trp_position_refd_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void trp_position_definition_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::direct:
      c.init<trp_position_direct_s>();
      break;
    case types::refd:
      c.init<trp_position_refd_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_position_definition_type_c");
  }
}
trp_position_definition_type_c::trp_position_definition_type_c(const trp_position_definition_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::direct:
      c.init(other.c.get<trp_position_direct_s>());
      break;
    case types::refd:
      c.init(other.c.get<trp_position_refd_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_position_definition_type_c");
  }
}
trp_position_definition_type_c& trp_position_definition_type_c::operator=(const trp_position_definition_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::direct:
      c.set(other.c.get<trp_position_direct_s>());
      break;
    case types::refd:
      c.set(other.c.get<trp_position_refd_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_position_definition_type_c");
  }

  return *this;
}
trp_position_direct_s& trp_position_definition_type_c::set_direct()
{
  set(types::direct);
  return c.get<trp_position_direct_s>();
}
trp_position_refd_s& trp_position_definition_type_c::set_refd()
{
  set(types::refd);
  return c.get<trp_position_refd_s>();
}
protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>& trp_position_definition_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>>();
}
void trp_position_definition_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::direct:
      j.write_fieldname("direct");
      c.get<trp_position_direct_s>().to_json(j);
      break;
    case types::refd:
      j.write_fieldname("referenced");
      c.get<trp_position_refd_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trp_position_definition_type_c");
  }
  j.end_obj();
}
SRSASN_CODE trp_position_definition_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::direct:
      HANDLE_CODE(c.get<trp_position_direct_s>().pack(bref));
      break;
    case types::refd:
      HANDLE_CODE(c.get<trp_position_refd_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_position_definition_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_position_definition_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::direct:
      HANDLE_CODE(c.get<trp_position_direct_s>().unpack(bref));
      break;
    case types::refd:
      HANDLE_CODE(c.get<trp_position_refd_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<trp_position_definition_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_position_definition_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trp_position_definition_type_c::types_opts::to_string() const
{
  static const char* names[] = {"direct", "referenced", "choice-extension"};
  return convert_enum_idx(names, 3, value, "trp_position_definition_type_c::types");
}

// GeographicalCoordinates ::= SEQUENCE
SRSASN_CODE geographical_coordinates_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(dl_prs_res_coordinates_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(trp_position_definition_type.pack(bref));
  if (dl_prs_res_coordinates_present) {
    HANDLE_CODE(dl_prs_res_coordinates.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE geographical_coordinates_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(dl_prs_res_coordinates_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(trp_position_definition_type.unpack(bref));
  if (dl_prs_res_coordinates_present) {
    HANDLE_CODE(dl_prs_res_coordinates.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void geographical_coordinates_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tRPPositionDefinitionType");
  trp_position_definition_type.to_json(j);
  if (dl_prs_res_coordinates_present) {
    j.write_fieldname("dLPRSResourceCoordinates");
    dl_prs_res_coordinates.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// E-CID-MeasurementResult ::= SEQUENCE
SRSASN_CODE e_c_id_meas_result_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(geographical_coordinates_present, 1));
  HANDLE_CODE(bref.pack(measured_results_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (geographical_coordinates_present) {
    HANDLE_CODE(geographical_coordinates.pack(bref));
  }
  if (measured_results_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, measured_results_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE e_c_id_meas_result_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(geographical_coordinates_present, 1));
  bool measured_results_list_present;
  HANDLE_CODE(bref.unpack(measured_results_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (geographical_coordinates_present) {
    HANDLE_CODE(geographical_coordinates.unpack(bref));
  }
  if (measured_results_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(measured_results_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void e_c_id_meas_result_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (geographical_coordinates_present) {
    j.write_fieldname("geographicalCoordinates");
    geographical_coordinates.to_json(j);
  }
  if (measured_results_list.size() > 0) {
    j.start_array("measuredResults-List");
    for (const auto& e1 : measured_results_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// E-CID-ReportCharacteristics ::= ENUMERATED
const char* e_c_id_report_characteristics_opts::to_string() const
{
  static const char* names[] = {"onDemand", "periodic"};
  return convert_enum_idx(names, 2, value, "e_c_id_report_characteristics_e");
}

// MeasurementPeriodicity ::= ENUMERATED
const char* meas_periodicity_opts::to_string() const
{
  static const char* names[] = {"ms120",
                                "ms240",
                                "ms480",
                                "ms640",
                                "ms1024",
                                "ms2048",
                                "ms5120",
                                "ms10240",
                                "min1",
                                "min6",
                                "min12",
                                "min30",
                                "ms20480",
                                "ms40960",
                                "extended"};
  return convert_enum_idx(names, 15, value, "meas_periodicity_e");
}
uint16_t meas_periodicity_opts::to_number() const
{
  static const uint16_t numbers[] = {120, 240, 480, 640, 1024, 2048, 5120, 10240, 1, 6, 12, 30, 20480, 40960};
  return map_enum_number(numbers, 14, value, "meas_periodicity_e");
}

// PosMeasurementPeriodicityNR-AoA ::= ENUMERATED
const char* pos_meas_periodicity_nr_ao_a_opts::to_string() const
{
  static const char* names[] = {"ms160",
                                "ms320",
                                "ms640",
                                "ms1280",
                                "ms2560",
                                "ms5120",
                                "ms10240",
                                "ms20480",
                                "ms40960",
                                "ms61440",
                                "ms81920",
                                "ms368640",
                                "ms737280",
                                "ms1843200"};
  return convert_enum_idx(names, 14, value, "pos_meas_periodicity_nr_ao_a_e");
}
uint32_t pos_meas_periodicity_nr_ao_a_opts::to_number() const
{
  static const uint32_t numbers[] = {
      160, 320, 640, 1280, 2560, 5120, 10240, 20480, 40960, 61440, 81920, 368640, 737280, 1843200};
  return map_enum_number(numbers, 14, value, "pos_meas_periodicity_nr_ao_a_e");
}

// EUTRA-Transmission-Bandwidth ::= ENUMERATED
const char* eutra_tx_bw_opts::to_string() const
{
  static const char* names[] = {"bw6", "bw15", "bw25", "bw50", "bw75", "bw100"};
  return convert_enum_idx(names, 6, value, "eutra_tx_bw_e");
}
uint8_t eutra_tx_bw_opts::to_number() const
{
  static const uint8_t numbers[] = {6, 15, 25, 50, 75, 100};
  return map_enum_number(numbers, 6, value, "eutra_tx_bw_e");
}

// EUTRA-Coex-FDD-Info ::= SEQUENCE
SRSASN_CODE eutra_coex_fdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ul_earfcn_present, 1));
  HANDLE_CODE(bref.pack(ul_tx_bw_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (ul_earfcn_present) {
    HANDLE_CODE(pack_integer(bref, ul_earfcn, (uint32_t)0u, (uint32_t)262143u, false, true));
  }
  HANDLE_CODE(pack_integer(bref, dl_earfcn, (uint32_t)0u, (uint32_t)262143u, false, true));
  if (ul_tx_bw_present) {
    HANDLE_CODE(ul_tx_bw.pack(bref));
  }
  HANDLE_CODE(dl_tx_bw.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_coex_fdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ul_earfcn_present, 1));
  HANDLE_CODE(bref.unpack(ul_tx_bw_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (ul_earfcn_present) {
    HANDLE_CODE(unpack_integer(ul_earfcn, bref, (uint32_t)0u, (uint32_t)262143u, false, true));
  }
  HANDLE_CODE(unpack_integer(dl_earfcn, bref, (uint32_t)0u, (uint32_t)262143u, false, true));
  if (ul_tx_bw_present) {
    HANDLE_CODE(ul_tx_bw.unpack(bref));
  }
  HANDLE_CODE(dl_tx_bw.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutra_coex_fdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (ul_earfcn_present) {
    j.write_int("uL-EARFCN", ul_earfcn);
  }
  j.write_int("dL-EARFCN", dl_earfcn);
  if (ul_tx_bw_present) {
    j.write_str("uL-Transmission-Bandwidth", ul_tx_bw.to_string());
  }
  j.write_str("dL-Transmission-Bandwidth", dl_tx_bw.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRA-CyclicPrefixDL ::= ENUMERATED
const char* eutra_cp_dl_opts::to_string() const
{
  static const char* names[] = {"normal", "extended"};
  return convert_enum_idx(names, 2, value, "eutra_cp_dl_e");
}

// EUTRA-CyclicPrefixUL ::= ENUMERATED
const char* eutra_cp_ul_opts::to_string() const
{
  static const char* names[] = {"normal", "extended"};
  return convert_enum_idx(names, 2, value, "eutra_cp_ul_e");
}

// EUTRA-SpecialSubframePatterns ::= ENUMERATED
const char* eutra_special_sf_patterns_opts::to_string() const
{
  static const char* names[] = {
      "ssp0", "ssp1", "ssp2", "ssp3", "ssp4", "ssp5", "ssp6", "ssp7", "ssp8", "ssp9", "ssp10"};
  return convert_enum_idx(names, 11, value, "eutra_special_sf_patterns_e");
}
uint8_t eutra_special_sf_patterns_opts::to_number() const
{
  static const uint8_t numbers[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  return map_enum_number(numbers, 11, value, "eutra_special_sf_patterns_e");
}

// EUTRA-SpecialSubframe-Info ::= SEQUENCE
SRSASN_CODE eutra_special_sf_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(special_sf_patterns.pack(bref));
  HANDLE_CODE(cp_dl.pack(bref));
  HANDLE_CODE(cp_ul.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_special_sf_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(special_sf_patterns.unpack(bref));
  HANDLE_CODE(cp_dl.unpack(bref));
  HANDLE_CODE(cp_ul.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutra_special_sf_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("specialSubframePatterns", special_sf_patterns.to_string());
  j.write_str("cyclicPrefixDL", cp_dl.to_string());
  j.write_str("cyclicPrefixUL", cp_ul.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRA-SubframeAssignment ::= ENUMERATED
const char* eutra_sf_assign_opts::to_string() const
{
  static const char* names[] = {"sa0", "sa1", "sa2", "sa3", "sa4", "sa5", "sa6"};
  return convert_enum_idx(names, 7, value, "eutra_sf_assign_e");
}
uint8_t eutra_sf_assign_opts::to_number() const
{
  static const uint8_t numbers[] = {0, 1, 2, 3, 4, 5, 6};
  return map_enum_number(numbers, 7, value, "eutra_sf_assign_e");
}

// EUTRA-Coex-TDD-Info ::= SEQUENCE
SRSASN_CODE eutra_coex_tdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, earfcn, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(tx_bw.pack(bref));
  HANDLE_CODE(sf_assign.pack(bref));
  HANDLE_CODE(special_sf_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_coex_tdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(earfcn, bref, (uint32_t)0u, (uint32_t)262143u, false, true));
  HANDLE_CODE(tx_bw.unpack(bref));
  HANDLE_CODE(sf_assign.unpack(bref));
  HANDLE_CODE(special_sf_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutra_coex_tdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("eARFCN", earfcn);
  j.write_str("transmission-Bandwidth", tx_bw.to_string());
  j.write_str("subframeAssignment", sf_assign.to_string());
  j.write_fieldname("specialSubframe-Info");
  special_sf_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRA-Coex-Mode-Info ::= CHOICE
void eutra_coex_mode_info_c::destroy_()
{
  switch (type_) {
    case types::fdd:
      c.destroy<eutra_coex_fdd_info_s>();
      break;
    case types::tdd:
      c.destroy<eutra_coex_tdd_info_s>();
      break;
    default:
      break;
  }
}
void eutra_coex_mode_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::fdd:
      c.init<eutra_coex_fdd_info_s>();
      break;
    case types::tdd:
      c.init<eutra_coex_tdd_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "eutra_coex_mode_info_c");
  }
}
eutra_coex_mode_info_c::eutra_coex_mode_info_c(const eutra_coex_mode_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::fdd:
      c.init(other.c.get<eutra_coex_fdd_info_s>());
      break;
    case types::tdd:
      c.init(other.c.get<eutra_coex_tdd_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "eutra_coex_mode_info_c");
  }
}
eutra_coex_mode_info_c& eutra_coex_mode_info_c::operator=(const eutra_coex_mode_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::fdd:
      c.set(other.c.get<eutra_coex_fdd_info_s>());
      break;
    case types::tdd:
      c.set(other.c.get<eutra_coex_tdd_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "eutra_coex_mode_info_c");
  }

  return *this;
}
eutra_coex_fdd_info_s& eutra_coex_mode_info_c::set_fdd()
{
  set(types::fdd);
  return c.get<eutra_coex_fdd_info_s>();
}
eutra_coex_tdd_info_s& eutra_coex_mode_info_c::set_tdd()
{
  set(types::tdd);
  return c.get<eutra_coex_tdd_info_s>();
}
void eutra_coex_mode_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::fdd:
      j.write_fieldname("fDD");
      c.get<eutra_coex_fdd_info_s>().to_json(j);
      break;
    case types::tdd:
      j.write_fieldname("tDD");
      c.get<eutra_coex_tdd_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "eutra_coex_mode_info_c");
  }
  j.end_obj();
}
SRSASN_CODE eutra_coex_mode_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<eutra_coex_fdd_info_s>().pack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<eutra_coex_tdd_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "eutra_coex_mode_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_coex_mode_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<eutra_coex_fdd_info_s>().unpack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<eutra_coex_tdd_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "eutra_coex_mode_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* eutra_coex_mode_info_c::types_opts::to_string() const
{
  static const char* names[] = {"fDD", "tDD"};
  return convert_enum_idx(names, 2, value, "eutra_coex_mode_info_c::types");
}

// EUTRA-FDD-Info ::= SEQUENCE
SRSASN_CODE eutra_fdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ul_offset_to_point_a, (uint16_t)0u, (uint16_t)2199u, true, true));
  HANDLE_CODE(pack_integer(bref, dl_offset_to_point_a, (uint16_t)0u, (uint16_t)2199u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_fdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ul_offset_to_point_a, bref, (uint16_t)0u, (uint16_t)2199u, true, true));
  HANDLE_CODE(unpack_integer(dl_offset_to_point_a, bref, (uint16_t)0u, (uint16_t)2199u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutra_fdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uL-offsetToPointA", ul_offset_to_point_a);
  j.write_int("dL-offsetToPointA", dl_offset_to_point_a);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRA-TDD-Info ::= SEQUENCE
SRSASN_CODE eutra_tdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, offset_to_point_a, (uint16_t)0u, (uint16_t)2199u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_tdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(offset_to_point_a, bref, (uint16_t)0u, (uint16_t)2199u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutra_tdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("offsetToPointA", offset_to_point_a);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRA-Mode-Info ::= CHOICE
void eutra_mode_info_c::destroy_()
{
  switch (type_) {
    case types::eutra_fdd:
      c.destroy<eutra_fdd_info_s>();
      break;
    case types::eutra_tdd:
      c.destroy<eutra_tdd_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void eutra_mode_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::eutra_fdd:
      c.init<eutra_fdd_info_s>();
      break;
    case types::eutra_tdd:
      c.init<eutra_tdd_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "eutra_mode_info_c");
  }
}
eutra_mode_info_c::eutra_mode_info_c(const eutra_mode_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::eutra_fdd:
      c.init(other.c.get<eutra_fdd_info_s>());
      break;
    case types::eutra_tdd:
      c.init(other.c.get<eutra_tdd_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "eutra_mode_info_c");
  }
}
eutra_mode_info_c& eutra_mode_info_c::operator=(const eutra_mode_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::eutra_fdd:
      c.set(other.c.get<eutra_fdd_info_s>());
      break;
    case types::eutra_tdd:
      c.set(other.c.get<eutra_tdd_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "eutra_mode_info_c");
  }

  return *this;
}
eutra_fdd_info_s& eutra_mode_info_c::set_eutra_fdd()
{
  set(types::eutra_fdd);
  return c.get<eutra_fdd_info_s>();
}
eutra_tdd_info_s& eutra_mode_info_c::set_eutra_tdd()
{
  set(types::eutra_tdd);
  return c.get<eutra_tdd_info_s>();
}
protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>& eutra_mode_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>>();
}
void eutra_mode_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::eutra_fdd:
      j.write_fieldname("eUTRAFDD");
      c.get<eutra_fdd_info_s>().to_json(j);
      break;
    case types::eutra_tdd:
      j.write_fieldname("eUTRATDD");
      c.get<eutra_tdd_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "eutra_mode_info_c");
  }
  j.end_obj();
}
SRSASN_CODE eutra_mode_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::eutra_fdd:
      HANDLE_CODE(c.get<eutra_fdd_info_s>().pack(bref));
      break;
    case types::eutra_tdd:
      HANDLE_CODE(c.get<eutra_tdd_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "eutra_mode_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_mode_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::eutra_fdd:
      HANDLE_CODE(c.get<eutra_fdd_info_s>().unpack(bref));
      break;
    case types::eutra_tdd:
      HANDLE_CODE(c.get<eutra_tdd_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<eutra_mode_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "eutra_mode_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* eutra_mode_info_c::types_opts::to_string() const
{
  static const char* names[] = {"eUTRAFDD", "eUTRATDD", "choice-extension"};
  return convert_enum_idx(names, 3, value, "eutra_mode_info_c::types");
}

// EUTRA-PRACH-Configuration ::= SEQUENCE
SRSASN_CODE eutra_prach_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(prach_cfg_idx_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, root_seq_idx, (uint16_t)0u, (uint16_t)837u, false, true));
  HANDLE_CODE(pack_integer(bref, zero_correlation_idx, (uint8_t)0u, (uint8_t)15u, false, true));
  HANDLE_CODE(bref.pack(high_speed_flag, 1));
  HANDLE_CODE(pack_integer(bref, prach_freq_offset, (uint8_t)0u, (uint8_t)94u, false, true));
  if (prach_cfg_idx_present) {
    HANDLE_CODE(pack_integer(bref, prach_cfg_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_prach_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(prach_cfg_idx_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(root_seq_idx, bref, (uint16_t)0u, (uint16_t)837u, false, true));
  HANDLE_CODE(unpack_integer(zero_correlation_idx, bref, (uint8_t)0u, (uint8_t)15u, false, true));
  HANDLE_CODE(bref.unpack(high_speed_flag, 1));
  HANDLE_CODE(unpack_integer(prach_freq_offset, bref, (uint8_t)0u, (uint8_t)94u, false, true));
  if (prach_cfg_idx_present) {
    HANDLE_CODE(unpack_integer(prach_cfg_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutra_prach_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("rootSequenceIndex", root_seq_idx);
  j.write_int("zeroCorrelationIndex", zero_correlation_idx);
  j.write_bool("highSpeedFlag", high_speed_flag);
  j.write_int("prach-FreqOffset", prach_freq_offset);
  if (prach_cfg_idx_present) {
    j.write_int("prach-ConfigIndex", prach_cfg_idx);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Served-EUTRA-Cells-Information ::= SEQUENCE
SRSASN_CODE served_eutra_cells_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_mode_info.pack(bref));
  HANDLE_CODE(protected_eutra_res_ind.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_eutra_cells_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_mode_info.unpack(bref));
  HANDLE_CODE(protected_eutra_res_ind.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_eutra_cells_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-Mode-Info");
  eutra_mode_info.to_json(j);
  j.write_str("protectedEUTRAResourceIndication", protected_eutra_res_ind.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// EUTRACells-List-item ::= SEQUENCE
SRSASN_CODE eutra_cells_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cell_id.pack(bref));
  HANDLE_CODE(served_eutra_cells_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE eutra_cells_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_cell_id.unpack(bref));
  HANDLE_CODE(served_eutra_cells_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void eutra_cells_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("eUTRA-Cell-ID", eutra_cell_id.to_string());
  j.write_fieldname("served-EUTRA-Cells-Information");
  served_eutra_cells_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Extended-GNB-CU-Name ::= SEQUENCE
SRSASN_CODE extended_gnb_cu_name_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(gnb_cu_name_visible_string_present, 1));
  HANDLE_CODE(bref.pack(gnb_cu_name_utf8_string_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (gnb_cu_name_visible_string_present) {
    HANDLE_CODE(gnb_cu_name_visible_string.pack(bref));
  }
  if (gnb_cu_name_utf8_string_present) {
    HANDLE_CODE(gnb_cu_name_utf8_string.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_gnb_cu_name_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(gnb_cu_name_visible_string_present, 1));
  HANDLE_CODE(bref.unpack(gnb_cu_name_utf8_string_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (gnb_cu_name_visible_string_present) {
    HANDLE_CODE(gnb_cu_name_visible_string.unpack(bref));
  }
  if (gnb_cu_name_utf8_string_present) {
    HANDLE_CODE(gnb_cu_name_utf8_string.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void extended_gnb_cu_name_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (gnb_cu_name_visible_string_present) {
    j.write_str("gNB-CU-NameVisibleString", gnb_cu_name_visible_string.to_string());
  }
  if (gnb_cu_name_utf8_string_present) {
    j.write_str("gNB-CU-NameUTF8String", gnb_cu_name_utf8_string.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Extended-GNB-DU-Name ::= SEQUENCE
SRSASN_CODE extended_gnb_du_name_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(gnb_du_name_visible_string_present, 1));
  HANDLE_CODE(bref.pack(gnb_du_name_utf8_string_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (gnb_du_name_visible_string_present) {
    HANDLE_CODE(gnb_du_name_visible_string.pack(bref));
  }
  if (gnb_du_name_utf8_string_present) {
    HANDLE_CODE(gnb_du_name_utf8_string.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_gnb_du_name_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(gnb_du_name_visible_string_present, 1));
  HANDLE_CODE(bref.unpack(gnb_du_name_utf8_string_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (gnb_du_name_visible_string_present) {
    HANDLE_CODE(gnb_du_name_visible_string.unpack(bref));
  }
  if (gnb_du_name_utf8_string_present) {
    HANDLE_CODE(gnb_du_name_utf8_string.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void extended_gnb_du_name_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (gnb_du_name_visible_string_present) {
    j.write_str("gNB-DU-NameVisibleString", gnb_du_name_visible_string.to_string());
  }
  if (gnb_du_name_utf8_string_present) {
    j.write_str("gNB-DU-NameUTF8String", gnb_du_name_utf8_string.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ExtendedAdditionalPathList-Item ::= SEQUENCE
SRSASN_CODE extended_add_path_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(path_quality_present, 1));
  HANDLE_CODE(bref.pack(multiple_ul_ao_a_present, 1));
  HANDLE_CODE(bref.pack(path_pwr_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(relative_time_of_path.pack(bref));
  if (path_quality_present) {
    HANDLE_CODE(path_quality.pack(bref));
  }
  if (multiple_ul_ao_a_present) {
    HANDLE_CODE(multiple_ul_ao_a.pack(bref));
  }
  if (path_pwr_present) {
    HANDLE_CODE(path_pwr.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_add_path_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(path_quality_present, 1));
  HANDLE_CODE(bref.unpack(multiple_ul_ao_a_present, 1));
  HANDLE_CODE(bref.unpack(path_pwr_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(relative_time_of_path.unpack(bref));
  if (path_quality_present) {
    HANDLE_CODE(path_quality.unpack(bref));
  }
  if (multiple_ul_ao_a_present) {
    HANDLE_CODE(multiple_ul_ao_a.unpack(bref));
  }
  if (path_pwr_present) {
    HANDLE_CODE(path_pwr.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void extended_add_path_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("relativeTimeOfPath");
  relative_time_of_path.to_json(j);
  if (path_quality_present) {
    j.write_fieldname("pathQuality");
    path_quality.to_json(j);
  }
  if (multiple_ul_ao_a_present) {
    j.write_fieldname("multipleULAoA");
    multiple_ul_ao_a.to_json(j);
  }
  if (path_pwr_present) {
    j.write_fieldname("pathPower");
    path_pwr.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SliceSupportItem ::= SEQUENCE
SRSASN_CODE slice_support_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(snssai.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slice_support_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(snssai.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slice_support_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sNSSAI");
  snssai.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NSAGSupportItem ::= SEQUENCE
SRSASN_CODE nsag_support_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, nsag_id, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, nsag_slice_support, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nsag_support_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(nsag_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(nsag_slice_support, bref, 1, 65535, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nsag_support_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nSAG-ID", nsag_id);
  j.start_array("nSAGSliceSupport");
  for (const auto& e1 : nsag_slice_support) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NPNSupportInfo ::= CHOICE
void npn_support_info_c::destroy_()
{
  switch (type_) {
    case types::sn_pn_info:
      c.destroy<fixed_bitstring<44, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<npn_support_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void npn_support_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::sn_pn_info:
      c.init<fixed_bitstring<44, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<npn_support_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_info_c");
  }
}
npn_support_info_c::npn_support_info_c(const npn_support_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::sn_pn_info:
      c.init(other.c.get<fixed_bitstring<44, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<npn_support_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_info_c");
  }
}
npn_support_info_c& npn_support_info_c::operator=(const npn_support_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::sn_pn_info:
      c.set(other.c.get<fixed_bitstring<44, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<npn_support_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_info_c");
  }

  return *this;
}
fixed_bitstring<44, false, true>& npn_support_info_c::set_sn_pn_info()
{
  set(types::sn_pn_info);
  return c.get<fixed_bitstring<44, false, true>>();
}
protocol_ie_single_container_s<npn_support_info_ext_ies_o>& npn_support_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<npn_support_info_ext_ies_o>>();
}
void npn_support_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::sn_pn_info:
      j.write_str("sNPN-Information", c.get<fixed_bitstring<44, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<npn_support_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_info_c");
  }
  j.end_obj();
}
SRSASN_CODE npn_support_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::sn_pn_info:
      HANDLE_CODE((c.get<fixed_bitstring<44, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_support_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE npn_support_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::sn_pn_info:
      HANDLE_CODE((c.get<fixed_bitstring<44, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<npn_support_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "npn_support_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* npn_support_info_c::types_opts::to_string() const
{
  static const char* names[] = {"sNPN-Information", "choice-extension"};
  return convert_enum_idx(names, 2, value, "npn_support_info_c::types");
}

// ExtendedServedPLMNs-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t extended_served_plmns_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {384, 390, 644};
  return map_enum_number(names, 3, idx, "id");
}
bool extended_served_plmns_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {384, 390, 644};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e extended_served_plmns_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 384:
      return crit_e::reject;
    case 390:
      return crit_e::reject;
    case 644:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
extended_served_plmns_item_ext_ies_o::ext_c extended_served_plmns_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 384:
      ret.set(ext_c::types::npn_support_info);
      break;
    case 390:
      ret.set(ext_c::types::extended_tai_slice_support_list);
      break;
    case 644:
      ret.set(ext_c::types::tai_nsag_support_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e extended_served_plmns_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 384:
      return presence_e::optional;
    case 390:
      return presence_e::optional;
    case 644:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void extended_served_plmns_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::npn_support_info:
      c.destroy<npn_support_info_c>();
      break;
    case types::extended_tai_slice_support_list:
      c.destroy<extended_slice_support_list_l>();
      break;
    case types::tai_nsag_support_list:
      c.destroy<nsag_support_list_l>();
      break;
    default:
      break;
  }
}
void extended_served_plmns_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::npn_support_info:
      c.init<npn_support_info_c>();
      break;
    case types::extended_tai_slice_support_list:
      c.init<extended_slice_support_list_l>();
      break;
    case types::tai_nsag_support_list:
      c.init<nsag_support_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "extended_served_plmns_item_ext_ies_o::ext_c");
  }
}
extended_served_plmns_item_ext_ies_o::ext_c::ext_c(const extended_served_plmns_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::npn_support_info:
      c.init(other.c.get<npn_support_info_c>());
      break;
    case types::extended_tai_slice_support_list:
      c.init(other.c.get<extended_slice_support_list_l>());
      break;
    case types::tai_nsag_support_list:
      c.init(other.c.get<nsag_support_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "extended_served_plmns_item_ext_ies_o::ext_c");
  }
}
extended_served_plmns_item_ext_ies_o::ext_c&
extended_served_plmns_item_ext_ies_o::ext_c::operator=(const extended_served_plmns_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::npn_support_info:
      c.set(other.c.get<npn_support_info_c>());
      break;
    case types::extended_tai_slice_support_list:
      c.set(other.c.get<extended_slice_support_list_l>());
      break;
    case types::tai_nsag_support_list:
      c.set(other.c.get<nsag_support_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "extended_served_plmns_item_ext_ies_o::ext_c");
  }

  return *this;
}
npn_support_info_c& extended_served_plmns_item_ext_ies_o::ext_c::npn_support_info()
{
  assert_choice_type(types::npn_support_info, type_, "Extension");
  return c.get<npn_support_info_c>();
}
extended_slice_support_list_l& extended_served_plmns_item_ext_ies_o::ext_c::extended_tai_slice_support_list()
{
  assert_choice_type(types::extended_tai_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
nsag_support_list_l& extended_served_plmns_item_ext_ies_o::ext_c::tai_nsag_support_list()
{
  assert_choice_type(types::tai_nsag_support_list, type_, "Extension");
  return c.get<nsag_support_list_l>();
}
const npn_support_info_c& extended_served_plmns_item_ext_ies_o::ext_c::npn_support_info() const
{
  assert_choice_type(types::npn_support_info, type_, "Extension");
  return c.get<npn_support_info_c>();
}
const extended_slice_support_list_l&
extended_served_plmns_item_ext_ies_o::ext_c::extended_tai_slice_support_list() const
{
  assert_choice_type(types::extended_tai_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
const nsag_support_list_l& extended_served_plmns_item_ext_ies_o::ext_c::tai_nsag_support_list() const
{
  assert_choice_type(types::tai_nsag_support_list, type_, "Extension");
  return c.get<nsag_support_list_l>();
}
void extended_served_plmns_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::npn_support_info:
      j.write_fieldname("NPNSupportInfo");
      c.get<npn_support_info_c>().to_json(j);
      break;
    case types::extended_tai_slice_support_list:
      j.start_array("ExtendedSliceSupportList");
      for (const auto& e1 : c.get<extended_slice_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_nsag_support_list:
      j.start_array("NSAGSupportList");
      for (const auto& e1 : c.get<nsag_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "extended_served_plmns_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE extended_served_plmns_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_support_info:
      HANDLE_CODE(c.get<npn_support_info_c>().pack(bref));
      break;
    case types::extended_tai_slice_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<extended_slice_support_list_l>(), 1, 65535, true));
      break;
    case types::tai_nsag_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nsag_support_list_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "extended_served_plmns_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_served_plmns_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::npn_support_info:
      HANDLE_CODE(c.get<npn_support_info_c>().unpack(bref));
      break;
    case types::extended_tai_slice_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<extended_slice_support_list_l>(), bref, 1, 65535, true));
      break;
    case types::tai_nsag_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nsag_support_list_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "extended_served_plmns_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE extended_served_plmns_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += npn_support_info_present ? 1 : 0;
  nof_ies += extended_tai_slice_support_list_present ? 1 : 0;
  nof_ies += tai_nsag_support_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (npn_support_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)384, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_support_info.pack(bref));
  }
  if (extended_tai_slice_support_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)390, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, extended_tai_slice_support_list, 1, 65535, true));
  }
  if (tai_nsag_support_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)644, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, tai_nsag_support_list, 1, 256, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_served_plmns_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 384: {
        npn_support_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_support_info.unpack(bref));
        break;
      }
      case 390: {
        extended_tai_slice_support_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(extended_tai_slice_support_list, bref, 1, 65535, true));
        break;
      }
      case 644: {
        tai_nsag_support_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(tai_nsag_support_list, bref, 1, 256, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void extended_served_plmns_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (npn_support_info_present) {
    j.write_int("id", 384);
    j.write_str("criticality", "reject");
    npn_support_info.to_json(j);
  }
  if (extended_tai_slice_support_list_present) {
    j.write_int("id", 390);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : extended_tai_slice_support_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (tai_nsag_support_list_present) {
    j.write_int("id", 644);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : tai_nsag_support_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// ExtendedServedPLMNs-Item ::= SEQUENCE
SRSASN_CODE extended_served_plmns_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(tai_slice_support_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  if (tai_slice_support_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, tai_slice_support_list, 1, 1024, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE extended_served_plmns_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool tai_slice_support_list_present;
  HANDLE_CODE(bref.unpack(tai_slice_support_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  if (tai_slice_support_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(tai_slice_support_list, bref, 1, 1024, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void extended_served_plmns_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  if (tai_slice_support_list.size() > 0) {
    j.start_array("tAISliceSupportList");
    for (const auto& e1 : tai_slice_support_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NumDLULSymbols-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t num_dl_ul_symbols_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {535};
  return map_enum_number(names, 1, idx, "id");
}
bool num_dl_ul_symbols_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 535 == id;
}
crit_e num_dl_ul_symbols_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 535) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
num_dl_ul_symbols_ext_ies_o::ext_c num_dl_ul_symbols_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 535) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e num_dl_ul_symbols_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 535) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void num_dl_ul_symbols_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("Permutation", c.to_string());
  j.end_obj();
}
SRSASN_CODE num_dl_ul_symbols_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE num_dl_ul_symbols_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// PRSAngleItem-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t prs_angle_item_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {439};
  return map_enum_number(names, 1, idx, "id");
}
bool prs_angle_item_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 439 == id;
}
crit_e prs_angle_item_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 439) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
prs_angle_item_item_ext_ies_o::ext_c prs_angle_item_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 439) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e prs_angle_item_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 439) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void prs_angle_item_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..63)", c);
  j.end_obj();
}
SRSASN_CODE prs_angle_item_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)0u, (uint8_t)63u, false, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_angle_item_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  return SRSASN_SUCCESS;
}

// PRSResource-QCLSourcePRS ::= SEQUENCE
SRSASN_CODE prs_res_qcl_source_prs_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(qcl_source_prs_res_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, qcl_source_prs_res_set_id, (uint8_t)0u, (uint8_t)7u, false, true));
  if (qcl_source_prs_res_id_present) {
    HANDLE_CODE(pack_integer(bref, qcl_source_prs_res_id, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_res_qcl_source_prs_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(qcl_source_prs_res_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(qcl_source_prs_res_set_id, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  if (qcl_source_prs_res_id_present) {
    HANDLE_CODE(unpack_integer(qcl_source_prs_res_id, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_res_qcl_source_prs_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("qCLSourcePRSResourceSetID", qcl_source_prs_res_set_id);
  if (qcl_source_prs_res_id_present) {
    j.write_int("qCLSourcePRSResourceID", qcl_source_prs_res_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PRSResource-QCLSourceSSB ::= SEQUENCE
SRSASN_CODE prs_res_qcl_source_ssb_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ssb_idx_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pci_nr, (uint16_t)0u, (uint16_t)1007u, false, true));
  if (ssb_idx_present) {
    HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_res_qcl_source_ssb_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ssb_idx_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pci_nr, bref, (uint16_t)0u, (uint16_t)1007u, false, true));
  if (ssb_idx_present) {
    HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_res_qcl_source_ssb_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pCI-NR", pci_nr);
  if (ssb_idx_present) {
    j.write_int("sSB-Index", ssb_idx);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NumDLULSymbols ::= SEQUENCE
SRSASN_CODE num_dl_ul_symbols_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, num_dl_symbols, (uint8_t)0u, (uint8_t)13u, true, true));
  HANDLE_CODE(pack_integer(bref, num_ul_symbols, (uint8_t)0u, (uint8_t)13u, true, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE num_dl_ul_symbols_s::unpack(cbit_ref& bref)
{
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(num_dl_symbols, bref, (uint8_t)0u, (uint8_t)13u, true, true));
  HANDLE_CODE(unpack_integer(num_ul_symbols, bref, (uint8_t)0u, (uint8_t)13u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void num_dl_ul_symbols_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("numDLSymbols", num_dl_symbols);
  j.write_int("numULSymbols", num_ul_symbols);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PRSAngleItem ::= SEQUENCE
SRSASN_CODE prs_angle_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, nr_prs_azimuth, (uint16_t)0u, (uint16_t)359u, false, true));
  HANDLE_CODE(pack_integer(bref, nr_prs_azimuth_fine, (uint8_t)0u, (uint8_t)9u, false, true));
  HANDLE_CODE(pack_integer(bref, nr_prs_elevation, (uint8_t)0u, (uint8_t)180u, false, true));
  HANDLE_CODE(pack_integer(bref, nr_prs_elevation_fine, (uint8_t)0u, (uint8_t)9u, false, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_angle_item_s::unpack(cbit_ref& bref)
{
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(nr_prs_azimuth, bref, (uint16_t)0u, (uint16_t)359u, false, true));
  HANDLE_CODE(unpack_integer(nr_prs_azimuth_fine, bref, (uint8_t)0u, (uint8_t)9u, false, true));
  HANDLE_CODE(unpack_integer(nr_prs_elevation, bref, (uint8_t)0u, (uint8_t)180u, false, true));
  HANDLE_CODE(unpack_integer(nr_prs_elevation_fine, bref, (uint8_t)0u, (uint8_t)9u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void prs_angle_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nR-PRS-Azimuth", nr_prs_azimuth);
  j.write_int("nR-PRS-Azimuth-fine", nr_prs_azimuth_fine);
  j.write_int("nR-PRS-Elevation", nr_prs_elevation);
  j.write_int("nR-PRS-Elevation-fine", nr_prs_elevation_fine);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PRSResource-QCLInfo ::= CHOICE
void prs_res_qcl_info_c::destroy_()
{
  switch (type_) {
    case types::qcl_source_ssb:
      c.destroy<prs_res_qcl_source_ssb_s>();
      break;
    case types::qcl_source_prs:
      c.destroy<prs_res_qcl_source_prs_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void prs_res_qcl_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::qcl_source_ssb:
      c.init<prs_res_qcl_source_ssb_s>();
      break;
    case types::qcl_source_prs:
      c.init<prs_res_qcl_source_prs_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "prs_res_qcl_info_c");
  }
}
prs_res_qcl_info_c::prs_res_qcl_info_c(const prs_res_qcl_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::qcl_source_ssb:
      c.init(other.c.get<prs_res_qcl_source_ssb_s>());
      break;
    case types::qcl_source_prs:
      c.init(other.c.get<prs_res_qcl_source_prs_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "prs_res_qcl_info_c");
  }
}
prs_res_qcl_info_c& prs_res_qcl_info_c::operator=(const prs_res_qcl_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::qcl_source_ssb:
      c.set(other.c.get<prs_res_qcl_source_ssb_s>());
      break;
    case types::qcl_source_prs:
      c.set(other.c.get<prs_res_qcl_source_prs_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "prs_res_qcl_info_c");
  }

  return *this;
}
prs_res_qcl_source_ssb_s& prs_res_qcl_info_c::set_qcl_source_ssb()
{
  set(types::qcl_source_ssb);
  return c.get<prs_res_qcl_source_ssb_s>();
}
prs_res_qcl_source_prs_s& prs_res_qcl_info_c::set_qcl_source_prs()
{
  set(types::qcl_source_prs);
  return c.get<prs_res_qcl_source_prs_s>();
}
protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>& prs_res_qcl_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>>();
}
void prs_res_qcl_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::qcl_source_ssb:
      j.write_fieldname("qCLSourceSSB");
      c.get<prs_res_qcl_source_ssb_s>().to_json(j);
      break;
    case types::qcl_source_prs:
      j.write_fieldname("qCLSourcePRS");
      c.get<prs_res_qcl_source_prs_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "prs_res_qcl_info_c");
  }
  j.end_obj();
}
SRSASN_CODE prs_res_qcl_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::qcl_source_ssb:
      HANDLE_CODE(c.get<prs_res_qcl_source_ssb_s>().pack(bref));
      break;
    case types::qcl_source_prs:
      HANDLE_CODE(c.get<prs_res_qcl_source_prs_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "prs_res_qcl_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_res_qcl_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::qcl_source_ssb:
      HANDLE_CODE(c.get<prs_res_qcl_source_ssb_s>().unpack(bref));
      break;
    case types::qcl_source_prs:
      HANDLE_CODE(c.get<prs_res_qcl_source_prs_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<prs_res_qcl_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "prs_res_qcl_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* prs_res_qcl_info_c::types_opts::to_string() const
{
  static const char* names[] = {"qCLSourceSSB", "qCLSourcePRS", "choice-extension"};
  return convert_enum_idx(names, 3, value, "prs_res_qcl_info_c::types");
}

// PRSMutingOption1 ::= SEQUENCE
SRSASN_CODE prs_muting_option1_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(muting_pattern.pack(bref));
  HANDLE_CODE(muting_bit_repeat_factor.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_muting_option1_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(muting_pattern.unpack(bref));
  HANDLE_CODE(muting_bit_repeat_factor.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_muting_option1_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mutingPattern");
  muting_pattern.to_json(j);
  j.write_str("mutingBitRepetitionFactor", muting_bit_repeat_factor.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* prs_muting_option1_s::muting_bit_repeat_factor_opts::to_string() const
{
  static const char* names[] = {"rf1", "rf2", "rf4", "rf8"};
  return convert_enum_idx(names, 4, value, "prs_muting_option1_s::muting_bit_repeat_factor_e_");
}
uint8_t prs_muting_option1_s::muting_bit_repeat_factor_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 4, 8};
  return map_enum_number(numbers, 4, value, "prs_muting_option1_s::muting_bit_repeat_factor_e_");
}

// PRSMutingOption2 ::= SEQUENCE
SRSASN_CODE prs_muting_option2_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(muting_pattern.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_muting_option2_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(muting_pattern.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_muting_option2_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mutingPattern");
  muting_pattern.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PRSResource-Item ::= SEQUENCE
SRSASN_CODE prs_res_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(qcl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prs_res_id, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(pack_integer(bref, seq_id, (uint16_t)0u, (uint16_t)4095u, false, true));
  HANDLE_CODE(pack_integer(bref, re_offset, (uint8_t)0u, (uint8_t)11u, true, true));
  HANDLE_CODE(pack_integer(bref, res_slot_offset, (uint16_t)0u, (uint16_t)511u, false, true));
  HANDLE_CODE(pack_integer(bref, res_symbol_offset, (uint8_t)0u, (uint8_t)12u, false, true));
  if (qcl_info_present) {
    HANDLE_CODE(qcl_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_res_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(qcl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prs_res_id, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  HANDLE_CODE(unpack_integer(seq_id, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  HANDLE_CODE(unpack_integer(re_offset, bref, (uint8_t)0u, (uint8_t)11u, true, true));
  HANDLE_CODE(unpack_integer(res_slot_offset, bref, (uint16_t)0u, (uint16_t)511u, false, true));
  HANDLE_CODE(unpack_integer(res_symbol_offset, bref, (uint8_t)0u, (uint8_t)12u, false, true));
  if (qcl_info_present) {
    HANDLE_CODE(qcl_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_res_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pRSResourceID", prs_res_id);
  j.write_int("sequenceID", seq_id);
  j.write_int("rEOffset", re_offset);
  j.write_int("resourceSlotOffset", res_slot_offset);
  j.write_int("resourceSymbolOffset", res_symbol_offset);
  if (qcl_info_present) {
    j.write_fieldname("qCLInfo");
    qcl_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RxTxTimingErrorMargin ::= ENUMERATED
const char* rx_tx_timing_error_margin_opts::to_string() const
{
  static const char* names[] = {"tc0dot5",
                                "tc1",
                                "tc2",
                                "tc4",
                                "tc8",
                                "tc12",
                                "tc16",
                                "tc20",
                                "tc24",
                                "tc32",
                                "tc40",
                                "tc48",
                                "tc64",
                                "tc80",
                                "tc96",
                                "tc128"};
  return convert_enum_idx(names, 16, value, "rx_tx_timing_error_margin_e");
}
float rx_tx_timing_error_margin_opts::to_number() const
{
  static const float numbers[] = {
      0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 16.0, 20.0, 24.0, 32.0, 40.0, 48.0, 64.0, 80.0, 96.0, 128.0};
  return map_enum_number(numbers, 16, value, "rx_tx_timing_error_margin_e");
}
const char* rx_tx_timing_error_margin_opts::to_number_string() const
{
  static const char* number_strs[] = {
      "0.5", "1", "2", "4", "8", "12", "16", "20", "24", "32", "40", "48", "64", "80", "96", "128"};
  return convert_enum_idx(number_strs, 16, value, "rx_tx_timing_error_margin_e");
}

// SymbolAllocInSlot ::= CHOICE
void symbol_alloc_in_slot_c::destroy_()
{
  switch (type_) {
    case types::both_dl_and_ul:
      c.destroy<num_dl_ul_symbols_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void symbol_alloc_in_slot_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::all_dl:
      break;
    case types::all_ul:
      break;
    case types::both_dl_and_ul:
      c.init<num_dl_ul_symbols_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "symbol_alloc_in_slot_c");
  }
}
symbol_alloc_in_slot_c::symbol_alloc_in_slot_c(const symbol_alloc_in_slot_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::all_dl:
      break;
    case types::all_ul:
      break;
    case types::both_dl_and_ul:
      c.init(other.c.get<num_dl_ul_symbols_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "symbol_alloc_in_slot_c");
  }
}
symbol_alloc_in_slot_c& symbol_alloc_in_slot_c::operator=(const symbol_alloc_in_slot_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::all_dl:
      break;
    case types::all_ul:
      break;
    case types::both_dl_and_ul:
      c.set(other.c.get<num_dl_ul_symbols_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "symbol_alloc_in_slot_c");
  }

  return *this;
}
void symbol_alloc_in_slot_c::set_all_dl()
{
  set(types::all_dl);
}
void symbol_alloc_in_slot_c::set_all_ul()
{
  set(types::all_ul);
}
num_dl_ul_symbols_s& symbol_alloc_in_slot_c::set_both_dl_and_ul()
{
  set(types::both_dl_and_ul);
  return c.get<num_dl_ul_symbols_s>();
}
protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>& symbol_alloc_in_slot_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>();
}
void symbol_alloc_in_slot_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::all_dl:
      break;
    case types::all_ul:
      break;
    case types::both_dl_and_ul:
      j.write_fieldname("both-DL-and-UL");
      c.get<num_dl_ul_symbols_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "symbol_alloc_in_slot_c");
  }
  j.end_obj();
}
SRSASN_CODE symbol_alloc_in_slot_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::all_dl:
      break;
    case types::all_ul:
      break;
    case types::both_dl_and_ul:
      HANDLE_CODE(c.get<num_dl_ul_symbols_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "symbol_alloc_in_slot_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE symbol_alloc_in_slot_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::all_dl:
      break;
    case types::all_ul:
      break;
    case types::both_dl_and_ul:
      HANDLE_CODE(c.get<num_dl_ul_symbols_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<symbol_alloc_in_slot_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "symbol_alloc_in_slot_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* symbol_alloc_in_slot_c::types_opts::to_string() const
{
  static const char* names[] = {"all-DL", "all-UL", "both-DL-and-UL", "choice-extension"};
  return convert_enum_idx(names, 4, value, "symbol_alloc_in_slot_c::types");
}

// TimingErrorMargin ::= ENUMERATED
const char* timing_error_margin_opts::to_string() const
{
  static const char* names[] = {"m0Tc",
                                "m2Tc",
                                "m4Tc",
                                "m6Tc",
                                "m8Tc",
                                "m12Tc",
                                "m16Tc",
                                "m20Tc",
                                "m24Tc",
                                "m32Tc",
                                "m40Tc",
                                "m48Tc",
                                "m56Tc",
                                "m64Tc",
                                "m72Tc",
                                "m80Tc"};
  return convert_enum_idx(names, 16, value, "timing_error_margin_e");
}
uint8_t timing_error_margin_opts::to_number() const
{
  static const uint8_t numbers[] = {0, 2, 4, 6, 8, 12, 16, 20, 24, 32, 40, 48, 56, 64, 72, 80};
  return map_enum_number(numbers, 16, value, "timing_error_margin_e");
}

// LCStoGCSTranslation ::= SEQUENCE
SRSASN_CODE lc_sto_gcs_translation_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(alpha_fine_present, 1));
  HANDLE_CODE(bref.pack(beta_fine_present, 1));
  HANDLE_CODE(bref.pack(gamma_fine_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, alpha, (uint16_t)0u, (uint16_t)359u, false, true));
  if (alpha_fine_present) {
    HANDLE_CODE(pack_integer(bref, alpha_fine, (uint8_t)0u, (uint8_t)9u, false, true));
  }
  HANDLE_CODE(pack_integer(bref, beta, (uint16_t)0u, (uint16_t)359u, false, true));
  if (beta_fine_present) {
    HANDLE_CODE(pack_integer(bref, beta_fine, (uint8_t)0u, (uint8_t)9u, false, true));
  }
  HANDLE_CODE(pack_integer(bref, gamma, (uint16_t)0u, (uint16_t)359u, false, true));
  if (gamma_fine_present) {
    HANDLE_CODE(pack_integer(bref, gamma_fine, (uint8_t)0u, (uint8_t)9u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE lc_sto_gcs_translation_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(alpha_fine_present, 1));
  HANDLE_CODE(bref.unpack(beta_fine_present, 1));
  HANDLE_CODE(bref.unpack(gamma_fine_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(alpha, bref, (uint16_t)0u, (uint16_t)359u, false, true));
  if (alpha_fine_present) {
    HANDLE_CODE(unpack_integer(alpha_fine, bref, (uint8_t)0u, (uint8_t)9u, false, true));
  }
  HANDLE_CODE(unpack_integer(beta, bref, (uint16_t)0u, (uint16_t)359u, false, true));
  if (beta_fine_present) {
    HANDLE_CODE(unpack_integer(beta_fine, bref, (uint8_t)0u, (uint8_t)9u, false, true));
  }
  HANDLE_CODE(unpack_integer(gamma, bref, (uint16_t)0u, (uint16_t)359u, false, true));
  if (gamma_fine_present) {
    HANDLE_CODE(unpack_integer(gamma_fine, bref, (uint8_t)0u, (uint8_t)9u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void lc_sto_gcs_translation_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("alpha", alpha);
  if (alpha_fine_present) {
    j.write_int("alpha-fine", alpha_fine);
  }
  j.write_int("beta", beta);
  if (beta_fine_present) {
    j.write_int("beta-fine", beta_fine);
  }
  j.write_int("gamma", gamma);
  if (gamma_fine_present) {
    j.write_int("gamma-fine", gamma_fine);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NR-PRSBeamInformationItem ::= SEQUENCE
SRSASN_CODE nr_prs_beam_info_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prs_res_set_id, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, prs_angle_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_prs_beam_info_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prs_res_set_id, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(unpack_dyn_seq_of(prs_angle_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_prs_beam_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pRSResourceSetID", prs_res_set_id);
  j.start_array("pRSAngleList");
  for (const auto& e1 : prs_angle_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PRSMuting ::= SEQUENCE
SRSASN_CODE prs_muting_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(prs_muting_option1_present, 1));
  HANDLE_CODE(bref.pack(prs_muting_option2_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (prs_muting_option1_present) {
    HANDLE_CODE(prs_muting_option1.pack(bref));
  }
  if (prs_muting_option2_present) {
    HANDLE_CODE(prs_muting_option2.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_muting_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(prs_muting_option1_present, 1));
  HANDLE_CODE(bref.unpack(prs_muting_option2_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (prs_muting_option1_present) {
    HANDLE_CODE(prs_muting_option1.unpack(bref));
  }
  if (prs_muting_option2_present) {
    HANDLE_CODE(prs_muting_option2.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_muting_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (prs_muting_option1_present) {
    j.write_fieldname("pRSMutingOption1");
    prs_muting_option1.to_json(j);
  }
  if (prs_muting_option2_present) {
    j.write_fieldname("pRSMutingOption2");
    prs_muting_option2.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SSB-TF-Configuration ::= SEQUENCE
SRSASN_CODE ssb_tf_cfg_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ssb_position_in_burst_present, 1));
  HANDLE_CODE(bref.pack(sfn_initisation_time_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ssb_freq, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(ssb_subcarrier_spacing.pack(bref));
  HANDLE_CODE(pack_integer(bref, ssb_tx_pwr, (int8_t)-60, (int8_t)50, false, true));
  HANDLE_CODE(ssb_periodicity.pack(bref));
  HANDLE_CODE(pack_integer(bref, ssb_half_frame_offset, (uint8_t)0u, (uint8_t)1u, false, true));
  HANDLE_CODE(pack_integer(bref, ssb_sfn_offset, (uint8_t)0u, (uint8_t)15u, false, true));
  if (ssb_position_in_burst_present) {
    HANDLE_CODE(ssb_position_in_burst.pack(bref));
  }
  if (sfn_initisation_time_present) {
    HANDLE_CODE(sfn_initisation_time.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_tf_cfg_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ssb_position_in_burst_present, 1));
  HANDLE_CODE(bref.unpack(sfn_initisation_time_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(ssb_freq, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(ssb_subcarrier_spacing.unpack(bref));
  HANDLE_CODE(unpack_integer(ssb_tx_pwr, bref, (int8_t)-60, (int8_t)50, false, true));
  HANDLE_CODE(ssb_periodicity.unpack(bref));
  HANDLE_CODE(unpack_integer(ssb_half_frame_offset, bref, (uint8_t)0u, (uint8_t)1u, false, true));
  HANDLE_CODE(unpack_integer(ssb_sfn_offset, bref, (uint8_t)0u, (uint8_t)15u, false, true));
  if (ssb_position_in_burst_present) {
    HANDLE_CODE(ssb_position_in_burst.unpack(bref));
  }
  if (sfn_initisation_time_present) {
    HANDLE_CODE(sfn_initisation_time.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_tf_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sSB-frequency", ssb_freq);
  j.write_str("sSB-subcarrier-spacing", ssb_subcarrier_spacing.to_string());
  j.write_int("sSB-Transmit-power", ssb_tx_pwr);
  j.write_str("sSB-periodicity", ssb_periodicity.to_string());
  j.write_int("sSB-half-frame-offset", ssb_half_frame_offset);
  j.write_int("sSB-SFN-offset", ssb_sfn_offset);
  if (ssb_position_in_burst_present) {
    j.write_fieldname("sSB-position-in-burst");
    ssb_position_in_burst.to_json(j);
  }
  if (sfn_initisation_time_present) {
    j.write_str("sFNInitialisationTime", sfn_initisation_time.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* ssb_tf_cfg_s::ssb_subcarrier_spacing_opts::to_string() const
{
  static const char* names[] = {"kHz15", "kHz30", "kHz60", "kHz120", "kHz240"};
  return convert_enum_idx(names, 5, value, "ssb_tf_cfg_s::ssb_subcarrier_spacing_e_");
}
uint8_t ssb_tf_cfg_s::ssb_subcarrier_spacing_opts::to_number() const
{
  static const uint8_t numbers[] = {15, 30, 60, 120, 240};
  return map_enum_number(numbers, 5, value, "ssb_tf_cfg_s::ssb_subcarrier_spacing_e_");
}

const char* ssb_tf_cfg_s::ssb_periodicity_opts::to_string() const
{
  static const char* names[] = {"ms5", "ms10", "ms20", "ms40", "ms80", "ms160"};
  return convert_enum_idx(names, 6, value, "ssb_tf_cfg_s::ssb_periodicity_e_");
}
uint8_t ssb_tf_cfg_s::ssb_periodicity_opts::to_number() const
{
  static const uint8_t numbers[] = {5, 10, 20, 40, 80, 160};
  return map_enum_number(numbers, 6, value, "ssb_tf_cfg_s::ssb_periodicity_e_");
}

// Slot-Configuration-Item ::= SEQUENCE
SRSASN_CODE slot_cfg_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, slot_idx, (uint16_t)0u, (uint16_t)5119u, true, true));
  HANDLE_CODE(symbol_alloc_in_slot.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE slot_cfg_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(slot_idx, bref, (uint16_t)0u, (uint16_t)5119u, true, true));
  HANDLE_CODE(symbol_alloc_in_slot.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void slot_cfg_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("slotIndex", slot_idx);
  j.write_fieldname("symbolAllocInSlot");
  symbol_alloc_in_slot.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRP-Rx-TEGInformation ::= SEQUENCE
SRSASN_CODE trp_rx_teg_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, trp_rx_teg_id, (uint8_t)0u, (uint8_t)31u, false, true));
  HANDLE_CODE(trp_rx_timing_error_margin.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_rx_teg_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(trp_rx_teg_id, bref, (uint8_t)0u, (uint8_t)31u, false, true));
  HANDLE_CODE(trp_rx_timing_error_margin.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_rx_teg_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("tRP-Rx-TEGID", trp_rx_teg_id);
  j.write_str("tRP-Rx-TimingErrorMargin", trp_rx_timing_error_margin.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRP-RxTx-TEGInformation ::= SEQUENCE
SRSASN_CODE trp_rx_tx_teg_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, trp_rx_tx_teg_id, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(trp_rx_tx_timing_error_margin.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_rx_tx_teg_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(trp_rx_tx_teg_id, bref, (uint16_t)0u, (uint16_t)255u, false, true));
  HANDLE_CODE(trp_rx_tx_timing_error_margin.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_rx_tx_teg_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("tRP-RxTx-TEGID", trp_rx_tx_teg_id);
  j.write_str("tRP-RxTx-TimingErrorMargin", trp_rx_tx_timing_error_margin.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRP-Tx-TEGInformation ::= SEQUENCE
SRSASN_CODE trp_tx_teg_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, trp_tx_teg_id, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(trp_tx_timing_error_margin.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_tx_teg_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(trp_tx_teg_id, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(trp_tx_timing_error_margin.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_tx_teg_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("tRP-Tx-TEGID", trp_tx_teg_id);
  j.write_str("tRP-Tx-TimingErrorMargin", trp_tx_timing_error_margin.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PRSResourceSet-Item ::= SEQUENCE
SRSASN_CODE prs_res_set_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(prs_muting_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prs_res_set_id, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(subcarrier_spacing.pack(bref));
  HANDLE_CODE(pack_integer(bref, pr_sbw, (uint8_t)1u, (uint8_t)63u, false, true));
  HANDLE_CODE(pack_integer(bref, start_prb, (uint16_t)0u, (uint16_t)2176u, false, true));
  HANDLE_CODE(pack_integer(bref, point_a, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(comb_size.pack(bref));
  HANDLE_CODE(cp_type.pack(bref));
  HANDLE_CODE(res_set_periodicity.pack(bref));
  HANDLE_CODE(pack_integer(bref, res_set_slot_offset, (uint32_t)0u, (uint32_t)81919u, true, true));
  HANDLE_CODE(res_repeat_factor.pack(bref));
  HANDLE_CODE(res_time_gap.pack(bref));
  HANDLE_CODE(res_numof_symbols.pack(bref));
  if (prs_muting_present) {
    HANDLE_CODE(prs_muting.pack(bref));
  }
  HANDLE_CODE(pack_integer(bref, prs_res_tx_pwr, (int8_t)-60, (int8_t)50, false, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, prs_res_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_res_set_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(prs_muting_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prs_res_set_id, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(subcarrier_spacing.unpack(bref));
  HANDLE_CODE(unpack_integer(pr_sbw, bref, (uint8_t)1u, (uint8_t)63u, false, true));
  HANDLE_CODE(unpack_integer(start_prb, bref, (uint16_t)0u, (uint16_t)2176u, false, true));
  HANDLE_CODE(unpack_integer(point_a, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(comb_size.unpack(bref));
  HANDLE_CODE(cp_type.unpack(bref));
  HANDLE_CODE(res_set_periodicity.unpack(bref));
  HANDLE_CODE(unpack_integer(res_set_slot_offset, bref, (uint32_t)0u, (uint32_t)81919u, true, true));
  HANDLE_CODE(res_repeat_factor.unpack(bref));
  HANDLE_CODE(res_time_gap.unpack(bref));
  HANDLE_CODE(res_numof_symbols.unpack(bref));
  if (prs_muting_present) {
    HANDLE_CODE(prs_muting.unpack(bref));
  }
  HANDLE_CODE(unpack_integer(prs_res_tx_pwr, bref, (int8_t)-60, (int8_t)50, false, true));
  HANDLE_CODE(unpack_dyn_seq_of(prs_res_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_res_set_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pRSResourceSetID", prs_res_set_id);
  j.write_str("subcarrierSpacing", subcarrier_spacing.to_string());
  j.write_int("pRSbandwidth", pr_sbw);
  j.write_int("startPRB", start_prb);
  j.write_int("pointA", point_a);
  j.write_str("combSize", comb_size.to_string());
  j.write_str("cPType", cp_type.to_string());
  j.write_str("resourceSetPeriodicity", res_set_periodicity.to_string());
  j.write_int("resourceSetSlotOffset", res_set_slot_offset);
  j.write_str("resourceRepetitionFactor", res_repeat_factor.to_string());
  j.write_str("resourceTimeGap", res_time_gap.to_string());
  j.write_str("resourceNumberofSymbols", res_numof_symbols.to_string());
  if (prs_muting_present) {
    j.write_fieldname("pRSMuting");
    prs_muting.to_json(j);
  }
  j.write_int("pRSResourceTransmitPower", prs_res_tx_pwr);
  j.start_array("pRSResource-List");
  for (const auto& e1 : prs_res_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* prs_res_set_item_s::subcarrier_spacing_opts::to_string() const
{
  static const char* names[] = {"kHz15", "kHz30", "kHz60", "kHz120"};
  return convert_enum_idx(names, 4, value, "prs_res_set_item_s::subcarrier_spacing_e_");
}
uint8_t prs_res_set_item_s::subcarrier_spacing_opts::to_number() const
{
  static const uint8_t numbers[] = {15, 30, 60, 120};
  return map_enum_number(numbers, 4, value, "prs_res_set_item_s::subcarrier_spacing_e_");
}

const char* prs_res_set_item_s::comb_size_opts::to_string() const
{
  static const char* names[] = {"n2", "n4", "n6", "n12"};
  return convert_enum_idx(names, 4, value, "prs_res_set_item_s::comb_size_e_");
}
uint8_t prs_res_set_item_s::comb_size_opts::to_number() const
{
  static const uint8_t numbers[] = {2, 4, 6, 12};
  return map_enum_number(numbers, 4, value, "prs_res_set_item_s::comb_size_e_");
}

const char* prs_res_set_item_s::cp_type_opts::to_string() const
{
  static const char* names[] = {"normal", "extended"};
  return convert_enum_idx(names, 2, value, "prs_res_set_item_s::cp_type_e_");
}

const char* prs_res_set_item_s::res_set_periodicity_opts::to_string() const
{
  static const char* names[] = {"n4",    "n5",    "n8",     "n10",    "n16",    "n20",   "n32",
                                "n40",   "n64",   "n80",    "n160",   "n320",   "n640",  "n1280",
                                "n2560", "n5120", "n10240", "n20480", "n40960", "n81920"};
  return convert_enum_idx(names, 20, value, "prs_res_set_item_s::res_set_periodicity_e_");
}
uint32_t prs_res_set_item_s::res_set_periodicity_opts::to_number() const
{
  static const uint32_t numbers[] = {4,   5,   8,   10,   16,   20,   32,    40,    64,    80,
                                     160, 320, 640, 1280, 2560, 5120, 10240, 20480, 40960, 81920};
  return map_enum_number(numbers, 20, value, "prs_res_set_item_s::res_set_periodicity_e_");
}

const char* prs_res_set_item_s::res_repeat_factor_opts::to_string() const
{
  static const char* names[] = {"rf1", "rf2", "rf4", "rf6", "rf8", "rf16", "rf32"};
  return convert_enum_idx(names, 7, value, "prs_res_set_item_s::res_repeat_factor_e_");
}
uint8_t prs_res_set_item_s::res_repeat_factor_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 4, 6, 8, 16, 32};
  return map_enum_number(numbers, 7, value, "prs_res_set_item_s::res_repeat_factor_e_");
}

const char* prs_res_set_item_s::res_time_gap_opts::to_string() const
{
  static const char* names[] = {"tg1", "tg2", "tg4", "tg8", "tg16", "tg32"};
  return convert_enum_idx(names, 6, value, "prs_res_set_item_s::res_time_gap_e_");
}
uint8_t prs_res_set_item_s::res_time_gap_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 4, 8, 16, 32};
  return map_enum_number(numbers, 6, value, "prs_res_set_item_s::res_time_gap_e_");
}

const char* prs_res_set_item_s::res_numof_symbols_opts::to_string() const
{
  static const char* names[] = {"n2", "n4", "n6", "n12"};
  return convert_enum_idx(names, 4, value, "prs_res_set_item_s::res_numof_symbols_e_");
}
uint8_t prs_res_set_item_s::res_numof_symbols_opts::to_number() const
{
  static const uint8_t numbers[] = {2, 4, 6, 12};
  return map_enum_number(numbers, 4, value, "prs_res_set_item_s::res_numof_symbols_e_");
}

// RxTEG ::= SEQUENCE
SRSASN_CODE rx_teg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(trp_rx_teg_info.pack(bref));
  HANDLE_CODE(trp_tx_teg_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rx_teg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(trp_rx_teg_info.unpack(bref));
  HANDLE_CODE(trp_tx_teg_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rx_teg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tRP-Rx-TEGInformation");
  trp_rx_teg_info.to_json(j);
  j.write_fieldname("tRP-Tx-TEGInformation");
  trp_tx_teg_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RxTxTEG ::= SEQUENCE
SRSASN_CODE rx_tx_teg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(trp_tx_teg_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(trp_rx_tx_teg_info.pack(bref));
  if (trp_tx_teg_info_present) {
    HANDLE_CODE(trp_tx_teg_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rx_tx_teg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(trp_tx_teg_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(trp_rx_tx_teg_info.unpack(bref));
  if (trp_tx_teg_info_present) {
    HANDLE_CODE(trp_tx_teg_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rx_tx_teg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tRP-RxTx-TEGInformation");
  trp_rx_tx_teg_info.to_json(j);
  if (trp_tx_teg_info_present) {
    j.write_fieldname("tRP-Tx-TEGInformation");
    trp_tx_teg_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SSBInformationItem ::= SEQUENCE
SRSASN_CODE ssb_info_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ssb_cfg.pack(bref));
  HANDLE_CODE(pack_integer(bref, pci_nr, (uint16_t)0u, (uint16_t)1007u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_info_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ssb_cfg.unpack(bref));
  HANDLE_CODE(unpack_integer(pci_nr, bref, (uint16_t)0u, (uint16_t)1007u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sSB-Configuration");
  ssb_cfg.to_json(j);
  j.write_int("pCI-NR", pci_nr);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRPTEG-Item ::= SEQUENCE
SRSASN_CODE trpteg_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dl_prs_res_id_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(trp_tx_teg_info.pack(bref));
  HANDLE_CODE(pack_integer(bref, dl_prs_res_set_id, (uint8_t)0u, (uint8_t)7u, false, true));
  if (dl_prs_res_id_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, dl_prs_res_id_list, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trpteg_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool dl_prs_res_id_list_present;
  HANDLE_CODE(bref.unpack(dl_prs_res_id_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(trp_tx_teg_info.unpack(bref));
  HANDLE_CODE(unpack_integer(dl_prs_res_set_id, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  if (dl_prs_res_id_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(dl_prs_res_id_list, bref, 1, 64, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trpteg_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tRP-Tx-TEGInformation");
  trp_tx_teg_info.to_json(j);
  j.write_int("dl-PRSResourceSetID", dl_prs_res_set_id);
  if (dl_prs_res_id_list.size() > 0) {
    j.start_array("dl-PRSResourceID-List");
    for (const auto& e1 : dl_prs_res_id_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IntendedTDD-DL-ULConfig ::= SEQUENCE
SRSASN_CODE intended_tdd_dl_ul_cfg_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_scs.pack(bref));
  HANDLE_CODE(nr_cp.pack(bref));
  HANDLE_CODE(nr_dl_ul_tx_periodicity.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, slot_cfg_list, 1, 5120, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE intended_tdd_dl_ul_cfg_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_scs.unpack(bref));
  HANDLE_CODE(nr_cp.unpack(bref));
  HANDLE_CODE(nr_dl_ul_tx_periodicity.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(slot_cfg_list, bref, 1, 5120, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void intended_tdd_dl_ul_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nRSCS", nr_scs.to_string());
  j.write_str("nRCP", nr_cp.to_string());
  j.write_str("nRDLULTxPeriodicity", nr_dl_ul_tx_periodicity.to_string());
  j.start_array("slot-Configuration-List");
  for (const auto& e1 : slot_cfg_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* intended_tdd_dl_ul_cfg_s::nr_scs_opts::to_string() const
{
  static const char* names[] = {"scs15", "scs30", "scs60", "scs120", "scs480", "scs960"};
  return convert_enum_idx(names, 6, value, "intended_tdd_dl_ul_cfg_s::nr_scs_e_");
}
uint16_t intended_tdd_dl_ul_cfg_s::nr_scs_opts::to_number() const
{
  static const uint16_t numbers[] = {15, 30, 60, 120, 480, 960};
  return map_enum_number(numbers, 6, value, "intended_tdd_dl_ul_cfg_s::nr_scs_e_");
}

const char* intended_tdd_dl_ul_cfg_s::nr_cp_opts::to_string() const
{
  static const char* names[] = {"normal", "extended"};
  return convert_enum_idx(names, 2, value, "intended_tdd_dl_ul_cfg_s::nr_cp_e_");
}

const char* intended_tdd_dl_ul_cfg_s::nr_dl_ul_tx_periodicity_opts::to_string() const
{
  static const char* names[] = {"ms0p5",
                                "ms0p625",
                                "ms1",
                                "ms1p25",
                                "ms2",
                                "ms2p5",
                                "ms3",
                                "ms4",
                                "ms5",
                                "ms10",
                                "ms20",
                                "ms40",
                                "ms60",
                                "ms80",
                                "ms100",
                                "ms120",
                                "ms140",
                                "ms160"};
  return convert_enum_idx(names, 18, value, "intended_tdd_dl_ul_cfg_s::nr_dl_ul_tx_periodicity_e_");
}

// NR-PRSBeamInformation ::= SEQUENCE
SRSASN_CODE nr_prs_beam_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(lc_sto_gcs_translation_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, nr_prs_beam_info_list, 1, 2, true));
  if (lc_sto_gcs_translation_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, lc_sto_gcs_translation_list, 1, 3, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_prs_beam_info_s::unpack(cbit_ref& bref)
{
  bool lc_sto_gcs_translation_list_present;
  HANDLE_CODE(bref.unpack(lc_sto_gcs_translation_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(nr_prs_beam_info_list, bref, 1, 2, true));
  if (lc_sto_gcs_translation_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(lc_sto_gcs_translation_list, bref, 1, 3, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_prs_beam_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("nR-PRSBeamInformationList");
  for (const auto& e1 : nr_prs_beam_info_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (lc_sto_gcs_translation_list.size() > 0) {
    j.start_array("lCStoGCSTranslationList");
    for (const auto& e1 : lc_sto_gcs_translation_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NR-U-Channel-Info-Item ::= SEQUENCE
SRSASN_CODE nr_u_ch_info_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, nr_u_ch_id, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(pack_integer(bref, nr_arfcn, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(bw.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_u_ch_info_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(nr_u_ch_id, bref, (uint8_t)1u, (uint8_t)16u, true, true));
  HANDLE_CODE(unpack_integer(nr_arfcn, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(bw.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_u_ch_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("nr-U-channel-ID", nr_u_ch_id);
  j.write_int("nR-ARFCN", nr_arfcn);
  j.write_str("bandwidth", bw.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* nr_u_ch_info_item_s::bw_opts::to_string() const
{
  static const char* names[] = {"mHz-10", "mHz-20", "mHz-40", "mHz-60", "mHz-80"};
  return convert_enum_idx(names, 5, value, "nr_u_ch_info_item_s::bw_e_");
}
int8_t nr_u_ch_info_item_s::bw_opts::to_number() const
{
  static const int8_t numbers[] = {-10, -20, -40, -60, -80};
  return map_enum_number(numbers, 5, value, "nr_u_ch_info_item_s::bw_e_");
}

// OnDemandPRS-Info ::= SEQUENCE
SRSASN_CODE on_demand_prs_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(allowed_res_set_periodicity_values_present, 1));
  HANDLE_CODE(bref.pack(allowed_prs_bw_values_present, 1));
  HANDLE_CODE(bref.pack(allowed_res_repeat_factor_values_present, 1));
  HANDLE_CODE(bref.pack(allowed_res_nof_symbols_values_present, 1));
  HANDLE_CODE(bref.pack(allowed_comb_size_values_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(on_demand_prs_request_allowed.pack(bref));
  if (allowed_res_set_periodicity_values_present) {
    HANDLE_CODE(allowed_res_set_periodicity_values.pack(bref));
  }
  if (allowed_prs_bw_values_present) {
    HANDLE_CODE(allowed_prs_bw_values.pack(bref));
  }
  if (allowed_res_repeat_factor_values_present) {
    HANDLE_CODE(allowed_res_repeat_factor_values.pack(bref));
  }
  if (allowed_res_nof_symbols_values_present) {
    HANDLE_CODE(allowed_res_nof_symbols_values.pack(bref));
  }
  if (allowed_comb_size_values_present) {
    HANDLE_CODE(allowed_comb_size_values.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE on_demand_prs_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(allowed_res_set_periodicity_values_present, 1));
  HANDLE_CODE(bref.unpack(allowed_prs_bw_values_present, 1));
  HANDLE_CODE(bref.unpack(allowed_res_repeat_factor_values_present, 1));
  HANDLE_CODE(bref.unpack(allowed_res_nof_symbols_values_present, 1));
  HANDLE_CODE(bref.unpack(allowed_comb_size_values_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(on_demand_prs_request_allowed.unpack(bref));
  if (allowed_res_set_periodicity_values_present) {
    HANDLE_CODE(allowed_res_set_periodicity_values.unpack(bref));
  }
  if (allowed_prs_bw_values_present) {
    HANDLE_CODE(allowed_prs_bw_values.unpack(bref));
  }
  if (allowed_res_repeat_factor_values_present) {
    HANDLE_CODE(allowed_res_repeat_factor_values.unpack(bref));
  }
  if (allowed_res_nof_symbols_values_present) {
    HANDLE_CODE(allowed_res_nof_symbols_values.unpack(bref));
  }
  if (allowed_comb_size_values_present) {
    HANDLE_CODE(allowed_comb_size_values.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void on_demand_prs_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("onDemandPRSRequestAllowed", on_demand_prs_request_allowed.to_string());
  if (allowed_res_set_periodicity_values_present) {
    j.write_str("allowedResourceSetPeriodicityValues", allowed_res_set_periodicity_values.to_string());
  }
  if (allowed_prs_bw_values_present) {
    j.write_str("allowedPRSBandwidthValues", allowed_prs_bw_values.to_string());
  }
  if (allowed_res_repeat_factor_values_present) {
    j.write_str("allowedResourceRepetitionFactorValues", allowed_res_repeat_factor_values.to_string());
  }
  if (allowed_res_nof_symbols_values_present) {
    j.write_str("allowedResourceNumberOfSymbolsValues", allowed_res_nof_symbols_values.to_string());
  }
  if (allowed_comb_size_values_present) {
    j.write_str("allowedCombSizeValues", allowed_comb_size_values.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PosSRSInfo ::= SEQUENCE
SRSASN_CODE pos_srs_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_integer(bref, pos_srs_res_id, (uint8_t)0u, (uint8_t)63u, false, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_srs_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_integer(pos_srs_res_id, bref, (uint8_t)0u, (uint8_t)63u, false, true));

  return SRSASN_SUCCESS;
}
void pos_srs_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("posSRSResourceID", pos_srs_res_id);
  j.end_obj();
}

// ReferenceSignal ::= CHOICE
void ref_sig_c::destroy_()
{
  switch (type_) {
    case types::ssb:
      c.destroy<ssb_s>();
      break;
    case types::dl_prs:
      c.destroy<dl_prs_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ref_sig_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ref_sig_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nzp_csi_rs:
      break;
    case types::ssb:
      c.init<ssb_s>();
      break;
    case types::srs:
      break;
    case types::positioning_srs:
      break;
    case types::dl_prs:
      c.init<dl_prs_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ref_sig_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ref_sig_c");
  }
}
ref_sig_c::ref_sig_c(const ref_sig_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nzp_csi_rs:
      c.init(other.c.get<uint8_t>());
      break;
    case types::ssb:
      c.init(other.c.get<ssb_s>());
      break;
    case types::srs:
      c.init(other.c.get<uint8_t>());
      break;
    case types::positioning_srs:
      c.init(other.c.get<uint8_t>());
      break;
    case types::dl_prs:
      c.init(other.c.get<dl_prs_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ref_sig_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ref_sig_c");
  }
}
ref_sig_c& ref_sig_c::operator=(const ref_sig_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nzp_csi_rs:
      c.set(other.c.get<uint8_t>());
      break;
    case types::ssb:
      c.set(other.c.get<ssb_s>());
      break;
    case types::srs:
      c.set(other.c.get<uint8_t>());
      break;
    case types::positioning_srs:
      c.set(other.c.get<uint8_t>());
      break;
    case types::dl_prs:
      c.set(other.c.get<dl_prs_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ref_sig_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ref_sig_c");
  }

  return *this;
}
uint8_t& ref_sig_c::set_nzp_csi_rs()
{
  set(types::nzp_csi_rs);
  return c.get<uint8_t>();
}
ssb_s& ref_sig_c::set_ssb()
{
  set(types::ssb);
  return c.get<ssb_s>();
}
uint8_t& ref_sig_c::set_srs()
{
  set(types::srs);
  return c.get<uint8_t>();
}
uint8_t& ref_sig_c::set_positioning_srs()
{
  set(types::positioning_srs);
  return c.get<uint8_t>();
}
dl_prs_s& ref_sig_c::set_dl_prs()
{
  set(types::dl_prs);
  return c.get<dl_prs_s>();
}
protocol_ie_single_container_s<ref_sig_ext_ies_o>& ref_sig_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ref_sig_ext_ies_o>>();
}
void ref_sig_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nzp_csi_rs:
      j.write_int("nZP-CSI-RS", c.get<uint8_t>());
      break;
    case types::ssb:
      j.write_fieldname("sSB");
      c.get<ssb_s>().to_json(j);
      break;
    case types::srs:
      j.write_int("sRS", c.get<uint8_t>());
      break;
    case types::positioning_srs:
      j.write_int("positioningSRS", c.get<uint8_t>());
      break;
    case types::dl_prs:
      j.write_fieldname("dL-PRS");
      c.get<dl_prs_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ref_sig_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ref_sig_c");
  }
  j.end_obj();
}
SRSASN_CODE ref_sig_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::nzp_csi_rs:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)191u, false, true));
      break;
    case types::ssb:
      HANDLE_CODE(c.get<ssb_s>().pack(bref));
      break;
    case types::srs:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)63u, false, true));
      break;
    case types::positioning_srs:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)63u, false, true));
      break;
    case types::dl_prs:
      HANDLE_CODE(c.get<dl_prs_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ref_sig_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ref_sig_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ref_sig_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::nzp_csi_rs:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)191u, false, true));
      break;
    case types::ssb:
      HANDLE_CODE(c.get<ssb_s>().unpack(bref));
      break;
    case types::srs:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)63u, false, true));
      break;
    case types::positioning_srs:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)63u, false, true));
      break;
    case types::dl_prs:
      HANDLE_CODE(c.get<dl_prs_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ref_sig_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ref_sig_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ref_sig_c::types_opts::to_string() const
{
  static const char* names[] = {"nZP-CSI-RS", "sSB", "sRS", "positioningSRS", "dL-PRS", "choice-extension"};
  return convert_enum_idx(names, 6, value, "ref_sig_c::types");
}

// SRSInfo ::= SEQUENCE
SRSASN_CODE srs_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_integer(bref, srs_res, (uint8_t)0u, (uint8_t)63u, false, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE srs_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_integer(srs_res, bref, (uint8_t)0u, (uint8_t)63u, false, true));

  return SRSASN_SUCCESS;
}
void srs_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRSResource", srs_res);
  j.end_obj();
}

// SRSPortIndex ::= ENUMERATED
const char* srs_port_idx_opts::to_string() const
{
  static const char* names[] = {"id1000", "id1001", "id1002", "id1003"};
  return convert_enum_idx(names, 4, value, "srs_port_idx_e");
}
uint16_t srs_port_idx_opts::to_number() const
{
  static const uint16_t numbers[] = {1000, 1001, 1002, 1003};
  return map_enum_number(numbers, 4, value, "srs_port_idx_e");
}

// TRPBeamAntennaInformation ::= SEQUENCE
SRSASN_CODE trp_beam_ant_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(choice_trp_beam_ant_info_item.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_beam_ant_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(choice_trp_beam_ant_info_item.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_beam_ant_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("choice-TRP-Beam-Antenna-Info-Item");
  choice_trp_beam_ant_info_item.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRPTEGInformation ::= CHOICE
void trpteg_info_c::destroy_()
{
  switch (type_) {
    case types::rx_tx_teg:
      c.destroy<rx_tx_teg_s>();
      break;
    case types::rx_teg:
      c.destroy<rx_teg_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<trpteg_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void trpteg_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::rx_tx_teg:
      c.init<rx_tx_teg_s>();
      break;
    case types::rx_teg:
      c.init<rx_teg_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<trpteg_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trpteg_info_c");
  }
}
trpteg_info_c::trpteg_info_c(const trpteg_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::rx_tx_teg:
      c.init(other.c.get<rx_tx_teg_s>());
      break;
    case types::rx_teg:
      c.init(other.c.get<rx_teg_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<trpteg_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trpteg_info_c");
  }
}
trpteg_info_c& trpteg_info_c::operator=(const trpteg_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::rx_tx_teg:
      c.set(other.c.get<rx_tx_teg_s>());
      break;
    case types::rx_teg:
      c.set(other.c.get<rx_teg_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<trpteg_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trpteg_info_c");
  }

  return *this;
}
rx_tx_teg_s& trpteg_info_c::set_rx_tx_teg()
{
  set(types::rx_tx_teg);
  return c.get<rx_tx_teg_s>();
}
rx_teg_s& trpteg_info_c::set_rx_teg()
{
  set(types::rx_teg);
  return c.get<rx_teg_s>();
}
protocol_ie_single_container_s<trpteg_info_ext_ies_o>& trpteg_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<trpteg_info_ext_ies_o>>();
}
void trpteg_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::rx_tx_teg:
      j.write_fieldname("rxTx-TEG");
      c.get<rx_tx_teg_s>().to_json(j);
      break;
    case types::rx_teg:
      j.write_fieldname("rx-TEG");
      c.get<rx_teg_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<trpteg_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trpteg_info_c");
  }
  j.end_obj();
}
SRSASN_CODE trpteg_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::rx_tx_teg:
      HANDLE_CODE(c.get<rx_tx_teg_s>().pack(bref));
      break;
    case types::rx_teg:
      HANDLE_CODE(c.get<rx_teg_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<trpteg_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trpteg_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trpteg_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::rx_tx_teg:
      HANDLE_CODE(c.get<rx_tx_teg_s>().unpack(bref));
      break;
    case types::rx_teg:
      HANDLE_CODE(c.get<rx_teg_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<trpteg_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trpteg_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trpteg_info_c::types_opts::to_string() const
{
  static const char* names[] = {"rxTx-TEG", "rx-TEG", "choice-extension"};
  return convert_enum_idx(names, 3, value, "trpteg_info_c::types");
}

// TRPType ::= ENUMERATED
const char* trp_type_opts::to_string() const
{
  static const char* names[] = {"prsOnlyTP", "srsOnlyRP", "tp", "rp", "trp"};
  return convert_enum_idx(names, 5, value, "trp_type_e");
}

// FDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t fdd_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {355, 389};
  return map_enum_number(names, 2, idx, "id");
}
bool fdd_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {355, 389};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e fdd_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 355:
      return crit_e::ignore;
    case 389:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
fdd_info_ext_ies_o::ext_c fdd_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 355:
      ret.set(ext_c::types::ul_carrier_list);
      break;
    case 389:
      ret.set(ext_c::types::dl_carrier_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e fdd_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 355:
      return presence_e::optional;
    case 389:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void fdd_info_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::ul_carrier_list:
      c.destroy<nr_carrier_list_l>();
      break;
    case types::dl_carrier_list:
      c.destroy<nr_carrier_list_l>();
      break;
    default:
      break;
  }
}
void fdd_info_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ul_carrier_list:
      c.init<nr_carrier_list_l>();
      break;
    case types::dl_carrier_list:
      c.init<nr_carrier_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "fdd_info_ext_ies_o::ext_c");
  }
}
fdd_info_ext_ies_o::ext_c::ext_c(const fdd_info_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ul_carrier_list:
      c.init(other.c.get<nr_carrier_list_l>());
      break;
    case types::dl_carrier_list:
      c.init(other.c.get<nr_carrier_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "fdd_info_ext_ies_o::ext_c");
  }
}
fdd_info_ext_ies_o::ext_c& fdd_info_ext_ies_o::ext_c::operator=(const fdd_info_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ul_carrier_list:
      c.set(other.c.get<nr_carrier_list_l>());
      break;
    case types::dl_carrier_list:
      c.set(other.c.get<nr_carrier_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "fdd_info_ext_ies_o::ext_c");
  }

  return *this;
}
nr_carrier_list_l& fdd_info_ext_ies_o::ext_c::ul_carrier_list()
{
  assert_choice_type(types::ul_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
nr_carrier_list_l& fdd_info_ext_ies_o::ext_c::dl_carrier_list()
{
  assert_choice_type(types::dl_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
const nr_carrier_list_l& fdd_info_ext_ies_o::ext_c::ul_carrier_list() const
{
  assert_choice_type(types::ul_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
const nr_carrier_list_l& fdd_info_ext_ies_o::ext_c::dl_carrier_list() const
{
  assert_choice_type(types::dl_carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
void fdd_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ul_carrier_list:
      j.start_array("NRCarrierList");
      for (const auto& e1 : c.get<nr_carrier_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::dl_carrier_list:
      j.start_array("NRCarrierList");
      for (const auto& e1 : c.get<nr_carrier_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "fdd_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE fdd_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ul_carrier_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_carrier_list_l>(), 1, 5, true));
      break;
    case types::dl_carrier_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_carrier_list_l>(), 1, 5, true));
      break;
    default:
      log_invalid_choice_id(type_, "fdd_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE fdd_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ul_carrier_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_carrier_list_l>(), bref, 1, 5, true));
      break;
    case types::dl_carrier_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_carrier_list_l>(), bref, 1, 5, true));
      break;
    default:
      log_invalid_choice_id(type_, "fdd_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// GNB-RxTxTimeDiff-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t gnb_rx_tx_time_diff_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {561, 567};
  return map_enum_number(names, 2, idx, "id");
}
bool gnb_rx_tx_time_diff_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {561, 567};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e gnb_rx_tx_time_diff_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 561:
      return crit_e::ignore;
    case 567:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
gnb_rx_tx_time_diff_ext_ies_o::ext_c gnb_rx_tx_time_diff_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 561:
      ret.set(ext_c::types::extended_add_path_list);
      break;
    case 567:
      ret.set(ext_c::types::trpteg_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e gnb_rx_tx_time_diff_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 561:
      return presence_e::optional;
    case 567:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void gnb_rx_tx_time_diff_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::extended_add_path_list:
      c.destroy<extended_add_path_list_l>();
      break;
    case types::trpteg_info:
      c.destroy<trpteg_info_c>();
      break;
    default:
      break;
  }
}
void gnb_rx_tx_time_diff_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::extended_add_path_list:
      c.init<extended_add_path_list_l>();
      break;
    case types::trpteg_info:
      c.init<trpteg_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rx_tx_time_diff_ext_ies_o::ext_c");
  }
}
gnb_rx_tx_time_diff_ext_ies_o::ext_c::ext_c(const gnb_rx_tx_time_diff_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::extended_add_path_list:
      c.init(other.c.get<extended_add_path_list_l>());
      break;
    case types::trpteg_info:
      c.init(other.c.get<trpteg_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rx_tx_time_diff_ext_ies_o::ext_c");
  }
}
gnb_rx_tx_time_diff_ext_ies_o::ext_c&
gnb_rx_tx_time_diff_ext_ies_o::ext_c::operator=(const gnb_rx_tx_time_diff_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::extended_add_path_list:
      c.set(other.c.get<extended_add_path_list_l>());
      break;
    case types::trpteg_info:
      c.set(other.c.get<trpteg_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rx_tx_time_diff_ext_ies_o::ext_c");
  }

  return *this;
}
extended_add_path_list_l& gnb_rx_tx_time_diff_ext_ies_o::ext_c::extended_add_path_list()
{
  assert_choice_type(types::extended_add_path_list, type_, "Extension");
  return c.get<extended_add_path_list_l>();
}
trpteg_info_c& gnb_rx_tx_time_diff_ext_ies_o::ext_c::trpteg_info()
{
  assert_choice_type(types::trpteg_info, type_, "Extension");
  return c.get<trpteg_info_c>();
}
const extended_add_path_list_l& gnb_rx_tx_time_diff_ext_ies_o::ext_c::extended_add_path_list() const
{
  assert_choice_type(types::extended_add_path_list, type_, "Extension");
  return c.get<extended_add_path_list_l>();
}
const trpteg_info_c& gnb_rx_tx_time_diff_ext_ies_o::ext_c::trpteg_info() const
{
  assert_choice_type(types::trpteg_info, type_, "Extension");
  return c.get<trpteg_info_c>();
}
void gnb_rx_tx_time_diff_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::extended_add_path_list:
      j.start_array("ExtendedAdditionalPathList");
      for (const auto& e1 : c.get<extended_add_path_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::trpteg_info:
      j.write_fieldname("TRPTEGInformation");
      c.get<trpteg_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rx_tx_time_diff_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE gnb_rx_tx_time_diff_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_add_path_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<extended_add_path_list_l>(), 1, 8, true));
      break;
    case types::trpteg_info:
      HANDLE_CODE(c.get<trpteg_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rx_tx_time_diff_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_rx_tx_time_diff_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_add_path_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<extended_add_path_list_l>(), bref, 1, 8, true));
      break;
    case types::trpteg_info:
      HANDLE_CODE(c.get<trpteg_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rx_tx_time_diff_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// GNBRxTxTimeDiffMeas ::= CHOICE
void gnb_rx_tx_time_diff_meas_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void gnb_rx_tx_time_diff_meas_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::k0:
      break;
    case types::k1:
      break;
    case types::k2:
      break;
    case types::k3:
      break;
    case types::k4:
      break;
    case types::k5:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rx_tx_time_diff_meas_c");
  }
}
gnb_rx_tx_time_diff_meas_c::gnb_rx_tx_time_diff_meas_c(const gnb_rx_tx_time_diff_meas_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::k0:
      c.init(other.c.get<uint32_t>());
      break;
    case types::k1:
      c.init(other.c.get<uint32_t>());
      break;
    case types::k2:
      c.init(other.c.get<uint32_t>());
      break;
    case types::k3:
      c.init(other.c.get<uint32_t>());
      break;
    case types::k4:
      c.init(other.c.get<uint32_t>());
      break;
    case types::k5:
      c.init(other.c.get<uint16_t>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rx_tx_time_diff_meas_c");
  }
}
gnb_rx_tx_time_diff_meas_c& gnb_rx_tx_time_diff_meas_c::operator=(const gnb_rx_tx_time_diff_meas_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::k0:
      c.set(other.c.get<uint32_t>());
      break;
    case types::k1:
      c.set(other.c.get<uint32_t>());
      break;
    case types::k2:
      c.set(other.c.get<uint32_t>());
      break;
    case types::k3:
      c.set(other.c.get<uint32_t>());
      break;
    case types::k4:
      c.set(other.c.get<uint32_t>());
      break;
    case types::k5:
      c.set(other.c.get<uint16_t>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rx_tx_time_diff_meas_c");
  }

  return *this;
}
uint32_t& gnb_rx_tx_time_diff_meas_c::set_k0()
{
  set(types::k0);
  return c.get<uint32_t>();
}
uint32_t& gnb_rx_tx_time_diff_meas_c::set_k1()
{
  set(types::k1);
  return c.get<uint32_t>();
}
uint32_t& gnb_rx_tx_time_diff_meas_c::set_k2()
{
  set(types::k2);
  return c.get<uint32_t>();
}
uint32_t& gnb_rx_tx_time_diff_meas_c::set_k3()
{
  set(types::k3);
  return c.get<uint32_t>();
}
uint32_t& gnb_rx_tx_time_diff_meas_c::set_k4()
{
  set(types::k4);
  return c.get<uint32_t>();
}
uint16_t& gnb_rx_tx_time_diff_meas_c::set_k5()
{
  set(types::k5);
  return c.get<uint16_t>();
}
protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>& gnb_rx_tx_time_diff_meas_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>>();
}
void gnb_rx_tx_time_diff_meas_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::k0:
      j.write_int("k0", c.get<uint32_t>());
      break;
    case types::k1:
      j.write_int("k1", c.get<uint32_t>());
      break;
    case types::k2:
      j.write_int("k2", c.get<uint32_t>());
      break;
    case types::k3:
      j.write_int("k3", c.get<uint32_t>());
      break;
    case types::k4:
      j.write_int("k4", c.get<uint32_t>());
      break;
    case types::k5:
      j.write_int("k5", c.get<uint16_t>());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rx_tx_time_diff_meas_c");
  }
  j.end_obj();
}
SRSASN_CODE gnb_rx_tx_time_diff_meas_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::k0:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)1970049u, false, true));
      break;
    case types::k1:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)985025u, false, true));
      break;
    case types::k2:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)492513u, false, true));
      break;
    case types::k3:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)246257u, false, true));
      break;
    case types::k4:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)123129u, false, true));
      break;
    case types::k5:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)61565u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rx_tx_time_diff_meas_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_rx_tx_time_diff_meas_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::k0:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)1970049u, false, true));
      break;
    case types::k1:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)985025u, false, true));
      break;
    case types::k2:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)492513u, false, true));
      break;
    case types::k3:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)246257u, false, true));
      break;
    case types::k4:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)123129u, false, true));
      break;
    case types::k5:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)61565u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<gnb_rx_tx_time_diff_meas_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_rx_tx_time_diff_meas_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* gnb_rx_tx_time_diff_meas_c::types_opts::to_string() const
{
  static const char* names[] = {"k0", "k1", "k2", "k3", "k4", "k5", "choice-extension"};
  return convert_enum_idx(names, 7, value, "gnb_rx_tx_time_diff_meas_c::types");
}
uint8_t gnb_rx_tx_time_diff_meas_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0, 1, 2, 3, 4, 5};
  return map_enum_number(numbers, 6, value, "gnb_rx_tx_time_diff_meas_c::types");
}

// LoS-NLoSIndicatorHard ::= ENUMERATED
const char* lo_s_n_lo_si_ndicator_hard_opts::to_string() const
{
  static const char* names[] = {"nLoS", "loS"};
  return convert_enum_idx(names, 2, value, "lo_s_n_lo_si_ndicator_hard_e");
}

// NonDynamicPQIDescriptor ::= SEQUENCE
SRSASN_CODE non_dyn_pq_id_escriptor_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(qos_prio_level_present, 1));
  HANDLE_CODE(bref.pack(averaging_win_present, 1));
  HANDLE_CODE(bref.pack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, five_qi, (uint16_t)0u, (uint16_t)255u, true, true));
  if (qos_prio_level_present) {
    HANDLE_CODE(pack_integer(bref, qos_prio_level, (uint8_t)1u, (uint8_t)8u, true, true));
  }
  if (averaging_win_present) {
    HANDLE_CODE(pack_integer(bref, averaging_win, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(pack_integer(bref, max_data_burst_volume, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE non_dyn_pq_id_escriptor_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(qos_prio_level_present, 1));
  HANDLE_CODE(bref.unpack(averaging_win_present, 1));
  HANDLE_CODE(bref.unpack(max_data_burst_volume_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(five_qi, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  if (qos_prio_level_present) {
    HANDLE_CODE(unpack_integer(qos_prio_level, bref, (uint8_t)1u, (uint8_t)8u, true, true));
  }
  if (averaging_win_present) {
    HANDLE_CODE(unpack_integer(averaging_win, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (max_data_burst_volume_present) {
    HANDLE_CODE(unpack_integer(max_data_burst_volume, bref, (uint16_t)0u, (uint16_t)4095u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void non_dyn_pq_id_escriptor_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("fiveQI", five_qi);
  if (qos_prio_level_present) {
    j.write_int("qoSPriorityLevel", qos_prio_level);
  }
  if (averaging_win_present) {
    j.write_int("averagingWindow", averaging_win);
  }
  if (max_data_burst_volume_present) {
    j.write_int("maxDataBurstVolume", max_data_burst_volume);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PRSConfiguration ::= SEQUENCE
SRSASN_CODE prs_cfg_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, prs_res_set_list, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_cfg_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(prs_res_set_list, bref, 1, 8, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("pRSResourceSet-List");
  for (const auto& e1 : prs_res_set_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PRSTransmissionOffIndicationPerResource-Item ::= SEQUENCE
SRSASN_CODE prs_tx_off_ind_per_res_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prs_res_id, (uint8_t)0u, (uint8_t)63u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_tx_off_ind_per_res_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prs_res_id, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_tx_off_ind_per_res_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pRSResourceID", prs_res_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RequestedDLPRSResource-Item ::= SEQUENCE
SRSASN_CODE requested_dl_prs_res_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(qcl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (qcl_info_present) {
    HANDLE_CODE(qcl_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE requested_dl_prs_res_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(qcl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (qcl_info_present) {
    HANDLE_CODE(qcl_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void requested_dl_prs_res_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (qcl_info_present) {
    j.write_fieldname("qCLInfo");
    qcl_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRSResourceTypeChoice ::= CHOICE
void srs_res_type_choice_c::destroy_()
{
  switch (type_) {
    case types::srs_res_info:
      c.destroy<srs_info_s>();
      break;
    case types::pos_srs_res_info:
      c.destroy<pos_srs_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void srs_res_type_choice_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::srs_res_info:
      c.init<srs_info_s>();
      break;
    case types::pos_srs_res_info:
      c.init<pos_srs_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "srs_res_type_choice_c");
  }
}
srs_res_type_choice_c::srs_res_type_choice_c(const srs_res_type_choice_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::srs_res_info:
      c.init(other.c.get<srs_info_s>());
      break;
    case types::pos_srs_res_info:
      c.init(other.c.get<pos_srs_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "srs_res_type_choice_c");
  }
}
srs_res_type_choice_c& srs_res_type_choice_c::operator=(const srs_res_type_choice_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::srs_res_info:
      c.set(other.c.get<srs_info_s>());
      break;
    case types::pos_srs_res_info:
      c.set(other.c.get<pos_srs_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "srs_res_type_choice_c");
  }

  return *this;
}
srs_info_s& srs_res_type_choice_c::set_srs_res_info()
{
  set(types::srs_res_info);
  return c.get<srs_info_s>();
}
pos_srs_info_s& srs_res_type_choice_c::set_pos_srs_res_info()
{
  set(types::pos_srs_res_info);
  return c.get<pos_srs_info_s>();
}
protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>& srs_res_type_choice_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>>();
}
void srs_res_type_choice_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::srs_res_info:
      j.write_fieldname("sRSResourceInfo");
      c.get<srs_info_s>().to_json(j);
      break;
    case types::pos_srs_res_info:
      j.write_fieldname("posSRSResourceInfo");
      c.get<pos_srs_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "srs_res_type_choice_c");
  }
  j.end_obj();
}
SRSASN_CODE srs_res_type_choice_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::srs_res_info:
      HANDLE_CODE(c.get<srs_info_s>().pack(bref));
      break;
    case types::pos_srs_res_info:
      HANDLE_CODE(c.get<pos_srs_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "srs_res_type_choice_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE srs_res_type_choice_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::srs_res_info:
      HANDLE_CODE(c.get<srs_info_s>().unpack(bref));
      break;
    case types::pos_srs_res_info:
      HANDLE_CODE(c.get<pos_srs_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<srs_res_type_choice_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "srs_res_type_choice_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* srs_res_type_choice_c::types_opts::to_string() const
{
  static const char* names[] = {"sRSResourceInfo", "posSRSResourceInfo", "choice-extension"};
  return convert_enum_idx(names, 3, value, "srs_res_type_choice_c::types");
}

// SRSResourcetype-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t srs_restype_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {663};
  return map_enum_number(names, 1, idx, "id");
}
bool srs_restype_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 663 == id;
}
crit_e srs_restype_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 663) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
srs_restype_ext_ies_o::ext_c srs_restype_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 663) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e srs_restype_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 663) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void srs_restype_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("SRSPortIndex", c.to_string());
  j.end_obj();
}
SRSASN_CODE srs_restype_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE srs_restype_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// SSBInformation ::= SEQUENCE
SRSASN_CODE ssb_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ssb_info_list, 1, 255, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ssb_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ssb_info_list, bref, 1, 255, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ssb_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("sSBInformationList");
  for (const auto& e1 : ssb_info_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ServedPLMNs-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t served_plmns_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {131, 384, 390, 644};
  return map_enum_number(names, 4, idx, "id");
}
bool served_plmns_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {131, 384, 390, 644};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e served_plmns_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 131:
      return crit_e::ignore;
    case 384:
      return crit_e::reject;
    case 390:
      return crit_e::reject;
    case 644:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
served_plmns_item_ext_ies_o::ext_c served_plmns_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 131:
      ret.set(ext_c::types::tai_slice_support_list);
      break;
    case 384:
      ret.set(ext_c::types::npn_support_info);
      break;
    case 390:
      ret.set(ext_c::types::extended_tai_slice_support_list);
      break;
    case 644:
      ret.set(ext_c::types::tai_nsag_support_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e served_plmns_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 131:
      return presence_e::optional;
    case 384:
      return presence_e::optional;
    case 390:
      return presence_e::optional;
    case 644:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void served_plmns_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::tai_slice_support_list:
      c.destroy<slice_support_list_l>();
      break;
    case types::npn_support_info:
      c.destroy<npn_support_info_c>();
      break;
    case types::extended_tai_slice_support_list:
      c.destroy<extended_slice_support_list_l>();
      break;
    case types::tai_nsag_support_list:
      c.destroy<nsag_support_list_l>();
      break;
    default:
      break;
  }
}
void served_plmns_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::tai_slice_support_list:
      c.init<slice_support_list_l>();
      break;
    case types::npn_support_info:
      c.init<npn_support_info_c>();
      break;
    case types::extended_tai_slice_support_list:
      c.init<extended_slice_support_list_l>();
      break;
    case types::tai_nsag_support_list:
      c.init<nsag_support_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "served_plmns_item_ext_ies_o::ext_c");
  }
}
served_plmns_item_ext_ies_o::ext_c::ext_c(const served_plmns_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::tai_slice_support_list:
      c.init(other.c.get<slice_support_list_l>());
      break;
    case types::npn_support_info:
      c.init(other.c.get<npn_support_info_c>());
      break;
    case types::extended_tai_slice_support_list:
      c.init(other.c.get<extended_slice_support_list_l>());
      break;
    case types::tai_nsag_support_list:
      c.init(other.c.get<nsag_support_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "served_plmns_item_ext_ies_o::ext_c");
  }
}
served_plmns_item_ext_ies_o::ext_c&
served_plmns_item_ext_ies_o::ext_c::operator=(const served_plmns_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::tai_slice_support_list:
      c.set(other.c.get<slice_support_list_l>());
      break;
    case types::npn_support_info:
      c.set(other.c.get<npn_support_info_c>());
      break;
    case types::extended_tai_slice_support_list:
      c.set(other.c.get<extended_slice_support_list_l>());
      break;
    case types::tai_nsag_support_list:
      c.set(other.c.get<nsag_support_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "served_plmns_item_ext_ies_o::ext_c");
  }

  return *this;
}
slice_support_list_l& served_plmns_item_ext_ies_o::ext_c::tai_slice_support_list()
{
  assert_choice_type(types::tai_slice_support_list, type_, "Extension");
  return c.get<slice_support_list_l>();
}
npn_support_info_c& served_plmns_item_ext_ies_o::ext_c::npn_support_info()
{
  assert_choice_type(types::npn_support_info, type_, "Extension");
  return c.get<npn_support_info_c>();
}
extended_slice_support_list_l& served_plmns_item_ext_ies_o::ext_c::extended_tai_slice_support_list()
{
  assert_choice_type(types::extended_tai_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
nsag_support_list_l& served_plmns_item_ext_ies_o::ext_c::tai_nsag_support_list()
{
  assert_choice_type(types::tai_nsag_support_list, type_, "Extension");
  return c.get<nsag_support_list_l>();
}
const slice_support_list_l& served_plmns_item_ext_ies_o::ext_c::tai_slice_support_list() const
{
  assert_choice_type(types::tai_slice_support_list, type_, "Extension");
  return c.get<slice_support_list_l>();
}
const npn_support_info_c& served_plmns_item_ext_ies_o::ext_c::npn_support_info() const
{
  assert_choice_type(types::npn_support_info, type_, "Extension");
  return c.get<npn_support_info_c>();
}
const extended_slice_support_list_l& served_plmns_item_ext_ies_o::ext_c::extended_tai_slice_support_list() const
{
  assert_choice_type(types::extended_tai_slice_support_list, type_, "Extension");
  return c.get<extended_slice_support_list_l>();
}
const nsag_support_list_l& served_plmns_item_ext_ies_o::ext_c::tai_nsag_support_list() const
{
  assert_choice_type(types::tai_nsag_support_list, type_, "Extension");
  return c.get<nsag_support_list_l>();
}
void served_plmns_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::tai_slice_support_list:
      j.start_array("SliceSupportList");
      for (const auto& e1 : c.get<slice_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::npn_support_info:
      j.write_fieldname("NPNSupportInfo");
      c.get<npn_support_info_c>().to_json(j);
      break;
    case types::extended_tai_slice_support_list:
      j.start_array("ExtendedSliceSupportList");
      for (const auto& e1 : c.get<extended_slice_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::tai_nsag_support_list:
      j.start_array("NSAGSupportList");
      for (const auto& e1 : c.get<nsag_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "served_plmns_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE served_plmns_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tai_slice_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<slice_support_list_l>(), 1, 1024, true));
      break;
    case types::npn_support_info:
      HANDLE_CODE(c.get<npn_support_info_c>().pack(bref));
      break;
    case types::extended_tai_slice_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<extended_slice_support_list_l>(), 1, 65535, true));
      break;
    case types::tai_nsag_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nsag_support_list_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "served_plmns_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE served_plmns_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::tai_slice_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<slice_support_list_l>(), bref, 1, 1024, true));
      break;
    case types::npn_support_info:
      HANDLE_CODE(c.get<npn_support_info_c>().unpack(bref));
      break;
    case types::extended_tai_slice_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<extended_slice_support_list_l>(), bref, 1, 65535, true));
      break;
    case types::tai_nsag_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nsag_support_list_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "served_plmns_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// SpatialDirectionInformation ::= SEQUENCE
SRSASN_CODE spatial_direction_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_prs_beam_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE spatial_direction_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_prs_beam_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void spatial_direction_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nR-PRSBeamInformation");
  nr_prs_beam_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SpatialRelationPerSRSResourceItem ::= SEQUENCE
SRSASN_CODE spatial_relation_per_srs_res_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ref_sig.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE spatial_relation_per_srs_res_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ref_sig.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void spatial_relation_per_srs_res_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("referenceSignal");
  ref_sig.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TDD-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t tdd_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {256, 361, 354};
  return map_enum_number(names, 3, idx, "id");
}
bool tdd_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {256, 361, 354};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e tdd_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 256:
      return crit_e::ignore;
    case 361:
      return crit_e::ignore;
    case 354:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
tdd_info_ext_ies_o::ext_c tdd_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 256:
      ret.set(ext_c::types::intended_tdd_dl_ul_cfg);
      break;
    case 361:
      ret.set(ext_c::types::tdd_ul_dl_cfg_common_nr);
      break;
    case 354:
      ret.set(ext_c::types::carrier_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e tdd_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 256:
      return presence_e::optional;
    case 361:
      return presence_e::optional;
    case 354:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void tdd_info_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::intended_tdd_dl_ul_cfg:
      c.destroy<intended_tdd_dl_ul_cfg_s>();
      break;
    case types::tdd_ul_dl_cfg_common_nr:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::carrier_list:
      c.destroy<nr_carrier_list_l>();
      break;
    default:
      break;
  }
}
void tdd_info_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::intended_tdd_dl_ul_cfg:
      c.init<intended_tdd_dl_ul_cfg_s>();
      break;
    case types::tdd_ul_dl_cfg_common_nr:
      c.init<unbounded_octstring<true>>();
      break;
    case types::carrier_list:
      c.init<nr_carrier_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tdd_info_ext_ies_o::ext_c");
  }
}
tdd_info_ext_ies_o::ext_c::ext_c(const tdd_info_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::intended_tdd_dl_ul_cfg:
      c.init(other.c.get<intended_tdd_dl_ul_cfg_s>());
      break;
    case types::tdd_ul_dl_cfg_common_nr:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::carrier_list:
      c.init(other.c.get<nr_carrier_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tdd_info_ext_ies_o::ext_c");
  }
}
tdd_info_ext_ies_o::ext_c& tdd_info_ext_ies_o::ext_c::operator=(const tdd_info_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::intended_tdd_dl_ul_cfg:
      c.set(other.c.get<intended_tdd_dl_ul_cfg_s>());
      break;
    case types::tdd_ul_dl_cfg_common_nr:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::carrier_list:
      c.set(other.c.get<nr_carrier_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "tdd_info_ext_ies_o::ext_c");
  }

  return *this;
}
intended_tdd_dl_ul_cfg_s& tdd_info_ext_ies_o::ext_c::intended_tdd_dl_ul_cfg()
{
  assert_choice_type(types::intended_tdd_dl_ul_cfg, type_, "Extension");
  return c.get<intended_tdd_dl_ul_cfg_s>();
}
unbounded_octstring<true>& tdd_info_ext_ies_o::ext_c::tdd_ul_dl_cfg_common_nr()
{
  assert_choice_type(types::tdd_ul_dl_cfg_common_nr, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
nr_carrier_list_l& tdd_info_ext_ies_o::ext_c::carrier_list()
{
  assert_choice_type(types::carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
const intended_tdd_dl_ul_cfg_s& tdd_info_ext_ies_o::ext_c::intended_tdd_dl_ul_cfg() const
{
  assert_choice_type(types::intended_tdd_dl_ul_cfg, type_, "Extension");
  return c.get<intended_tdd_dl_ul_cfg_s>();
}
const unbounded_octstring<true>& tdd_info_ext_ies_o::ext_c::tdd_ul_dl_cfg_common_nr() const
{
  assert_choice_type(types::tdd_ul_dl_cfg_common_nr, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const nr_carrier_list_l& tdd_info_ext_ies_o::ext_c::carrier_list() const
{
  assert_choice_type(types::carrier_list, type_, "Extension");
  return c.get<nr_carrier_list_l>();
}
void tdd_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::intended_tdd_dl_ul_cfg:
      j.write_fieldname("IntendedTDD-DL-ULConfig");
      c.get<intended_tdd_dl_ul_cfg_s>().to_json(j);
      break;
    case types::tdd_ul_dl_cfg_common_nr:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::carrier_list:
      j.start_array("NRCarrierList");
      for (const auto& e1 : c.get<nr_carrier_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "tdd_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE tdd_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::intended_tdd_dl_ul_cfg:
      HANDLE_CODE(c.get<intended_tdd_dl_ul_cfg_s>().pack(bref));
      break;
    case types::tdd_ul_dl_cfg_common_nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::carrier_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<nr_carrier_list_l>(), 1, 5, true));
      break;
    default:
      log_invalid_choice_id(type_, "tdd_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE tdd_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::intended_tdd_dl_ul_cfg:
      HANDLE_CODE(c.get<intended_tdd_dl_ul_cfg_s>().unpack(bref));
      break;
    case types::tdd_ul_dl_cfg_common_nr:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::carrier_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<nr_carrier_list_l>(), bref, 1, 5, true));
      break;
    default:
      log_invalid_choice_id(type_, "tdd_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// TRPInformationTypeResponseItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
uint32_t trp_info_type_resp_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {434, 551, 566, 577};
  return map_enum_number(names, 4, idx, "id");
}
bool trp_info_type_resp_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {434, 551, 566, 577};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trp_info_type_resp_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 434:
      return crit_e::reject;
    case 551:
      return crit_e::reject;
    case 566:
      return crit_e::reject;
    case 577:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trp_info_type_resp_item_ext_ies_o::value_c trp_info_type_resp_item_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 434:
      ret.set(value_c::types::trp_type);
      break;
    case 551:
      ret.set(value_c::types::on_demand_prs);
      break;
    case 566:
      ret.set(value_c::types::trp_tx_teg_assoc);
      break;
    case 577:
      ret.set(value_c::types::trp_beam_ant_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trp_info_type_resp_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 434:
      return presence_e::mandatory;
    case 551:
      return presence_e::mandatory;
    case 566:
      return presence_e::optional;
    case 577:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void trp_info_type_resp_item_ext_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::on_demand_prs:
      c.destroy<on_demand_prs_info_s>();
      break;
    case types::trp_tx_teg_assoc:
      c.destroy<trp_tx_teg_assoc_l>();
      break;
    case types::trp_beam_ant_info:
      c.destroy<trp_beam_ant_info_s>();
      break;
    default:
      break;
  }
}
void trp_info_type_resp_item_ext_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::trp_type:
      break;
    case types::on_demand_prs:
      c.init<on_demand_prs_info_s>();
      break;
    case types::trp_tx_teg_assoc:
      c.init<trp_tx_teg_assoc_l>();
      break;
    case types::trp_beam_ant_info:
      c.init<trp_beam_ant_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_info_type_resp_item_ext_ies_o::value_c");
  }
}
trp_info_type_resp_item_ext_ies_o::value_c::value_c(const trp_info_type_resp_item_ext_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::trp_type:
      c.init(other.c.get<trp_type_e>());
      break;
    case types::on_demand_prs:
      c.init(other.c.get<on_demand_prs_info_s>());
      break;
    case types::trp_tx_teg_assoc:
      c.init(other.c.get<trp_tx_teg_assoc_l>());
      break;
    case types::trp_beam_ant_info:
      c.init(other.c.get<trp_beam_ant_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_info_type_resp_item_ext_ies_o::value_c");
  }
}
trp_info_type_resp_item_ext_ies_o::value_c&
trp_info_type_resp_item_ext_ies_o::value_c::operator=(const trp_info_type_resp_item_ext_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::trp_type:
      c.set(other.c.get<trp_type_e>());
      break;
    case types::on_demand_prs:
      c.set(other.c.get<on_demand_prs_info_s>());
      break;
    case types::trp_tx_teg_assoc:
      c.set(other.c.get<trp_tx_teg_assoc_l>());
      break;
    case types::trp_beam_ant_info:
      c.set(other.c.get<trp_beam_ant_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_info_type_resp_item_ext_ies_o::value_c");
  }

  return *this;
}
trp_type_e& trp_info_type_resp_item_ext_ies_o::value_c::trp_type()
{
  assert_choice_type(types::trp_type, type_, "Value");
  return c.get<trp_type_e>();
}
on_demand_prs_info_s& trp_info_type_resp_item_ext_ies_o::value_c::on_demand_prs()
{
  assert_choice_type(types::on_demand_prs, type_, "Value");
  return c.get<on_demand_prs_info_s>();
}
trp_tx_teg_assoc_l& trp_info_type_resp_item_ext_ies_o::value_c::trp_tx_teg_assoc()
{
  assert_choice_type(types::trp_tx_teg_assoc, type_, "Value");
  return c.get<trp_tx_teg_assoc_l>();
}
trp_beam_ant_info_s& trp_info_type_resp_item_ext_ies_o::value_c::trp_beam_ant_info()
{
  assert_choice_type(types::trp_beam_ant_info, type_, "Value");
  return c.get<trp_beam_ant_info_s>();
}
const trp_type_e& trp_info_type_resp_item_ext_ies_o::value_c::trp_type() const
{
  assert_choice_type(types::trp_type, type_, "Value");
  return c.get<trp_type_e>();
}
const on_demand_prs_info_s& trp_info_type_resp_item_ext_ies_o::value_c::on_demand_prs() const
{
  assert_choice_type(types::on_demand_prs, type_, "Value");
  return c.get<on_demand_prs_info_s>();
}
const trp_tx_teg_assoc_l& trp_info_type_resp_item_ext_ies_o::value_c::trp_tx_teg_assoc() const
{
  assert_choice_type(types::trp_tx_teg_assoc, type_, "Value");
  return c.get<trp_tx_teg_assoc_l>();
}
const trp_beam_ant_info_s& trp_info_type_resp_item_ext_ies_o::value_c::trp_beam_ant_info() const
{
  assert_choice_type(types::trp_beam_ant_info, type_, "Value");
  return c.get<trp_beam_ant_info_s>();
}
void trp_info_type_resp_item_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::trp_type:
      j.write_str("TRPType", c.get<trp_type_e>().to_string());
      break;
    case types::on_demand_prs:
      j.write_fieldname("OnDemandPRS-Info");
      c.get<on_demand_prs_info_s>().to_json(j);
      break;
    case types::trp_tx_teg_assoc:
      j.start_array("TRPTxTEGAssociation");
      for (const auto& e1 : c.get<trp_tx_teg_assoc_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::trp_beam_ant_info:
      j.write_fieldname("TRPBeamAntennaInformation");
      c.get<trp_beam_ant_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trp_info_type_resp_item_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE trp_info_type_resp_item_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::trp_type:
      HANDLE_CODE(c.get<trp_type_e>().pack(bref));
      break;
    case types::on_demand_prs:
      HANDLE_CODE(c.get<on_demand_prs_info_s>().pack(bref));
      break;
    case types::trp_tx_teg_assoc:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<trp_tx_teg_assoc_l>(), 1, 8, true));
      break;
    case types::trp_beam_ant_info:
      HANDLE_CODE(c.get<trp_beam_ant_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_info_type_resp_item_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_info_type_resp_item_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::trp_type:
      HANDLE_CODE(c.get<trp_type_e>().unpack(bref));
      break;
    case types::on_demand_prs:
      HANDLE_CODE(c.get<on_demand_prs_info_s>().unpack(bref));
      break;
    case types::trp_tx_teg_assoc:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<trp_tx_teg_assoc_l>(), bref, 1, 8, true));
      break;
    case types::trp_beam_ant_info:
      HANDLE_CODE(c.get<trp_beam_ant_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_info_type_resp_item_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// TimeStampSlotIndex-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
uint32_t time_stamp_slot_idx_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {661, 662};
  return map_enum_number(names, 2, idx, "id");
}
bool time_stamp_slot_idx_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {661, 662};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e time_stamp_slot_idx_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 661:
      return crit_e::reject;
    case 662:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
time_stamp_slot_idx_ext_ies_o::value_c time_stamp_slot_idx_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 661:
      ret.set(value_c::types::scs_480);
      break;
    case 662:
      ret.set(value_c::types::scs_960);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e time_stamp_slot_idx_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 661:
      return presence_e::mandatory;
    case 662:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void time_stamp_slot_idx_ext_ies_o::value_c::destroy_() {}
void time_stamp_slot_idx_ext_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
time_stamp_slot_idx_ext_ies_o::value_c::value_c(const time_stamp_slot_idx_ext_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::scs_480:
      c.init(other.c.get<uint16_t>());
      break;
    case types::scs_960:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "time_stamp_slot_idx_ext_ies_o::value_c");
  }
}
time_stamp_slot_idx_ext_ies_o::value_c&
time_stamp_slot_idx_ext_ies_o::value_c::operator=(const time_stamp_slot_idx_ext_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::scs_480:
      c.set(other.c.get<uint16_t>());
      break;
    case types::scs_960:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "time_stamp_slot_idx_ext_ies_o::value_c");
  }

  return *this;
}
uint16_t& time_stamp_slot_idx_ext_ies_o::value_c::scs_480()
{
  assert_choice_type(types::scs_480, type_, "Value");
  return c.get<uint16_t>();
}
uint16_t& time_stamp_slot_idx_ext_ies_o::value_c::scs_960()
{
  assert_choice_type(types::scs_960, type_, "Value");
  return c.get<uint16_t>();
}
const uint16_t& time_stamp_slot_idx_ext_ies_o::value_c::scs_480() const
{
  assert_choice_type(types::scs_480, type_, "Value");
  return c.get<uint16_t>();
}
const uint16_t& time_stamp_slot_idx_ext_ies_o::value_c::scs_960() const
{
  assert_choice_type(types::scs_960, type_, "Value");
  return c.get<uint16_t>();
}
void time_stamp_slot_idx_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::scs_480:
      j.write_int("INTEGER (0..319)", c.get<uint16_t>());
      break;
    case types::scs_960:
      j.write_int("INTEGER (0..639)", c.get<uint16_t>());
      break;
    default:
      log_invalid_choice_id(type_, "time_stamp_slot_idx_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE time_stamp_slot_idx_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::scs_480:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)319u, false, true));
      break;
    case types::scs_960:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)639u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "time_stamp_slot_idx_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE time_stamp_slot_idx_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::scs_480:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)319u, false, true));
      break;
    case types::scs_960:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)639u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "time_stamp_slot_idx_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UACAction ::= ENUMERATED
const char* uac_action_opts::to_string() const
{
  static const char* names[] = {"reject-non-emergency-mo-dt",
                                "reject-rrc-cr-signalling",
                                "permit-emergency-sessions-and-mobile-terminated-services-only",
                                "permit-high-priority-sessions-and-mobile-terminated-services-only"};
  return convert_enum_idx(names, 4, value, "uac_action_e");
}

// UACOperatorDefined ::= SEQUENCE
SRSASN_CODE uac_operator_defined_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, access_category, (uint8_t)32u, (uint8_t)63u, true, true));
  HANDLE_CODE(access_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE uac_operator_defined_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(access_category, bref, (uint8_t)32u, (uint8_t)63u, true, true));
  HANDLE_CODE(access_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void uac_operator_defined_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("accessCategory", access_category);
  j.write_str("accessIdentity", access_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UL-RTOA-Measurement-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t ul_rtoa_meas_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {561, 568};
  return map_enum_number(names, 2, idx, "id");
}
bool ul_rtoa_meas_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {561, 568};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_rtoa_meas_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 561:
      return crit_e::ignore;
    case 568:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_rtoa_meas_ext_ies_o::ext_c ul_rtoa_meas_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 561:
      ret.set(ext_c::types::extended_add_path_list);
      break;
    case 568:
      ret.set(ext_c::types::trp_rx_teg_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_rtoa_meas_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 561:
      return presence_e::optional;
    case 568:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void ul_rtoa_meas_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::extended_add_path_list:
      c.destroy<extended_add_path_list_l>();
      break;
    case types::trp_rx_teg_info:
      c.destroy<trp_rx_teg_info_s>();
      break;
    default:
      break;
  }
}
void ul_rtoa_meas_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::extended_add_path_list:
      c.init<extended_add_path_list_l>();
      break;
    case types::trp_rx_teg_info:
      c.init<trp_rx_teg_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_rtoa_meas_ext_ies_o::ext_c");
  }
}
ul_rtoa_meas_ext_ies_o::ext_c::ext_c(const ul_rtoa_meas_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::extended_add_path_list:
      c.init(other.c.get<extended_add_path_list_l>());
      break;
    case types::trp_rx_teg_info:
      c.init(other.c.get<trp_rx_teg_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_rtoa_meas_ext_ies_o::ext_c");
  }
}
ul_rtoa_meas_ext_ies_o::ext_c& ul_rtoa_meas_ext_ies_o::ext_c::operator=(const ul_rtoa_meas_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::extended_add_path_list:
      c.set(other.c.get<extended_add_path_list_l>());
      break;
    case types::trp_rx_teg_info:
      c.set(other.c.get<trp_rx_teg_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_rtoa_meas_ext_ies_o::ext_c");
  }

  return *this;
}
extended_add_path_list_l& ul_rtoa_meas_ext_ies_o::ext_c::extended_add_path_list()
{
  assert_choice_type(types::extended_add_path_list, type_, "Extension");
  return c.get<extended_add_path_list_l>();
}
trp_rx_teg_info_s& ul_rtoa_meas_ext_ies_o::ext_c::trp_rx_teg_info()
{
  assert_choice_type(types::trp_rx_teg_info, type_, "Extension");
  return c.get<trp_rx_teg_info_s>();
}
const extended_add_path_list_l& ul_rtoa_meas_ext_ies_o::ext_c::extended_add_path_list() const
{
  assert_choice_type(types::extended_add_path_list, type_, "Extension");
  return c.get<extended_add_path_list_l>();
}
const trp_rx_teg_info_s& ul_rtoa_meas_ext_ies_o::ext_c::trp_rx_teg_info() const
{
  assert_choice_type(types::trp_rx_teg_info, type_, "Extension");
  return c.get<trp_rx_teg_info_s>();
}
void ul_rtoa_meas_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::extended_add_path_list:
      j.start_array("ExtendedAdditionalPathList");
      for (const auto& e1 : c.get<extended_add_path_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::trp_rx_teg_info:
      j.write_fieldname("TRP-Rx-TEGInformation");
      c.get<trp_rx_teg_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_rtoa_meas_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_rtoa_meas_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_add_path_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<extended_add_path_list_l>(), 1, 8, true));
      break;
    case types::trp_rx_teg_info:
      HANDLE_CODE(c.get<trp_rx_teg_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_rtoa_meas_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_rtoa_meas_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::extended_add_path_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<extended_add_path_list_l>(), bref, 1, 8, true));
      break;
    case types::trp_rx_teg_info:
      HANDLE_CODE(c.get<trp_rx_teg_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_rtoa_meas_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UL-RTOA-MeasurementItem ::= CHOICE
void ul_rtoa_meas_item_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ul_rtoa_meas_item_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::k0:
      break;
    case types::k1:
      break;
    case types::k2:
      break;
    case types::k3:
      break;
    case types::k4:
      break;
    case types::k5:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_rtoa_meas_item_c");
  }
}
ul_rtoa_meas_item_c::ul_rtoa_meas_item_c(const ul_rtoa_meas_item_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::k0:
      c.init(other.c.get<uint32_t>());
      break;
    case types::k1:
      c.init(other.c.get<uint32_t>());
      break;
    case types::k2:
      c.init(other.c.get<uint32_t>());
      break;
    case types::k3:
      c.init(other.c.get<uint32_t>());
      break;
    case types::k4:
      c.init(other.c.get<uint32_t>());
      break;
    case types::k5:
      c.init(other.c.get<uint16_t>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_rtoa_meas_item_c");
  }
}
ul_rtoa_meas_item_c& ul_rtoa_meas_item_c::operator=(const ul_rtoa_meas_item_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::k0:
      c.set(other.c.get<uint32_t>());
      break;
    case types::k1:
      c.set(other.c.get<uint32_t>());
      break;
    case types::k2:
      c.set(other.c.get<uint32_t>());
      break;
    case types::k3:
      c.set(other.c.get<uint32_t>());
      break;
    case types::k4:
      c.set(other.c.get<uint32_t>());
      break;
    case types::k5:
      c.set(other.c.get<uint16_t>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_rtoa_meas_item_c");
  }

  return *this;
}
uint32_t& ul_rtoa_meas_item_c::set_k0()
{
  set(types::k0);
  return c.get<uint32_t>();
}
uint32_t& ul_rtoa_meas_item_c::set_k1()
{
  set(types::k1);
  return c.get<uint32_t>();
}
uint32_t& ul_rtoa_meas_item_c::set_k2()
{
  set(types::k2);
  return c.get<uint32_t>();
}
uint32_t& ul_rtoa_meas_item_c::set_k3()
{
  set(types::k3);
  return c.get<uint32_t>();
}
uint32_t& ul_rtoa_meas_item_c::set_k4()
{
  set(types::k4);
  return c.get<uint32_t>();
}
uint16_t& ul_rtoa_meas_item_c::set_k5()
{
  set(types::k5);
  return c.get<uint16_t>();
}
protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>& ul_rtoa_meas_item_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>>();
}
void ul_rtoa_meas_item_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::k0:
      j.write_int("k0", c.get<uint32_t>());
      break;
    case types::k1:
      j.write_int("k1", c.get<uint32_t>());
      break;
    case types::k2:
      j.write_int("k2", c.get<uint32_t>());
      break;
    case types::k3:
      j.write_int("k3", c.get<uint32_t>());
      break;
    case types::k4:
      j.write_int("k4", c.get<uint32_t>());
      break;
    case types::k5:
      j.write_int("k5", c.get<uint16_t>());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_rtoa_meas_item_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_rtoa_meas_item_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::k0:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)1970049u, false, true));
      break;
    case types::k1:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)985025u, false, true));
      break;
    case types::k2:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)492513u, false, true));
      break;
    case types::k3:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)246257u, false, true));
      break;
    case types::k4:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)123129u, false, true));
      break;
    case types::k5:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)61565u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_rtoa_meas_item_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_rtoa_meas_item_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::k0:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)1970049u, false, true));
      break;
    case types::k1:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)985025u, false, true));
      break;
    case types::k2:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)492513u, false, true));
      break;
    case types::k3:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)246257u, false, true));
      break;
    case types::k4:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)123129u, false, true));
      break;
    case types::k5:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)61565u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ul_rtoa_meas_item_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_rtoa_meas_item_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ul_rtoa_meas_item_c::types_opts::to_string() const
{
  static const char* names[] = {"k0", "k1", "k2", "k3", "k4", "k5", "choice-extension"};
  return convert_enum_idx(names, 7, value, "ul_rtoa_meas_item_c::types");
}
uint8_t ul_rtoa_meas_item_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {0, 1, 2, 3, 4, 5};
  return map_enum_number(numbers, 6, value, "ul_rtoa_meas_item_c::types");
}

// Cell-Direction ::= ENUMERATED
const char* cell_direction_opts::to_string() const
{
  static const char* names[] = {"dl-only", "ul-only"};
  return convert_enum_idx(names, 2, value, "cell_direction_e");
}

SRSASN_CODE fdd_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ul_carrier_list_present ? 1 : 0;
  nof_ies += dl_carrier_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (ul_carrier_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)355, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ul_carrier_list, 1, 5, true));
  }
  if (dl_carrier_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)389, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, dl_carrier_list, 1, 5, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE fdd_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 355: {
        ul_carrier_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ul_carrier_list, bref, 1, 5, true));
        break;
      }
      case 389: {
        dl_carrier_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(dl_carrier_list, bref, 1, 5, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void fdd_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ul_carrier_list_present) {
    j.write_int("id", 355);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : ul_carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dl_carrier_list_present) {
    j.write_int("id", 389);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : dl_carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// FDD-Info ::= SEQUENCE
SRSASN_CODE fdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_nr_freq_info.pack(bref));
  HANDLE_CODE(dl_nr_freq_info.pack(bref));
  HANDLE_CODE(ul_tx_bw.pack(bref));
  HANDLE_CODE(dl_tx_bw.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE fdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_nr_freq_info.unpack(bref));
  HANDLE_CODE(dl_nr_freq_info.unpack(bref));
  HANDLE_CODE(ul_tx_bw.unpack(bref));
  HANDLE_CODE(dl_tx_bw.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void fdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uL-NRFreqInfo");
  ul_nr_freq_info.to_json(j);
  j.write_fieldname("dL-NRFreqInfo");
  dl_nr_freq_info.to_json(j);
  j.write_fieldname("uL-Transmission-Bandwidth");
  ul_tx_bw.to_json(j);
  j.write_fieldname("dL-Transmission-Bandwidth");
  dl_tx_bw.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FlowsMappedToSLDRB-Item ::= SEQUENCE
SRSASN_CODE flows_mapped_to_sl_drb_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pc5_qos_flow_id, (uint16_t)1u, (uint16_t)2048u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE flows_mapped_to_sl_drb_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pc5_qos_flow_id, bref, (uint16_t)1u, (uint16_t)2048u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void flows_mapped_to_sl_drb_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pc5QoSFlowIdentifier", pc5_qos_flow_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE gnb_rx_tx_time_diff_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += extended_add_path_list_present ? 1 : 0;
  nof_ies += trpteg_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (extended_add_path_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)561, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, extended_add_path_list, 1, 8, true));
  }
  if (trpteg_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)567, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trpteg_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_rx_tx_time_diff_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 561: {
        extended_add_path_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(extended_add_path_list, bref, 1, 8, true));
        break;
      }
      case 567: {
        trpteg_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trpteg_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void gnb_rx_tx_time_diff_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (extended_add_path_list_present) {
    j.write_int("id", 561);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : extended_add_path_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (trpteg_info_present) {
    j.write_int("id", 567);
    j.write_str("criticality", "ignore");
    trpteg_info.to_json(j);
  }
  j.end_obj();
}

// GNB-RxTxTimeDiff ::= SEQUENCE
SRSASN_CODE gnb_rx_tx_time_diff_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(add_path_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rx_tx_time_diff.pack(bref));
  if (add_path_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, add_path_list, 1, 2, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_rx_tx_time_diff_s::unpack(cbit_ref& bref)
{
  bool add_path_list_present;
  HANDLE_CODE(bref.unpack(add_path_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rx_tx_time_diff.unpack(bref));
  if (add_path_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(add_path_list, bref, 1, 2, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gnb_rx_tx_time_diff_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("rxTxTimeDiff");
  rx_tx_time_diff.to_json(j);
  if (add_path_list.size() > 0) {
    j.start_array("additionalPath-List");
    for (const auto& e1 : add_path_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-Info-IAB-DU ::= SEQUENCE
SRSASN_CODE iab_info_iab_du_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(mux_info_present, 1));
  HANDLE_CODE(bref.pack(iab_stc_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (mux_info_present) {
    HANDLE_CODE(mux_info.pack(bref));
  }
  if (iab_stc_info_present) {
    HANDLE_CODE(iab_stc_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_info_iab_du_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(mux_info_present, 1));
  HANDLE_CODE(bref.unpack(iab_stc_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (mux_info_present) {
    HANDLE_CODE(mux_info.unpack(bref));
  }
  if (iab_stc_info_present) {
    HANDLE_CODE(iab_stc_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_info_iab_du_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (mux_info_present) {
    j.write_fieldname("multiplexingInfo");
    mux_info.to_json(j);
  }
  if (iab_stc_info_present) {
    j.write_fieldname("iAB-STC-Info");
    iab_stc_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LoS-NLoSInformation ::= CHOICE
void lo_s_n_lo_si_nformation_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void lo_s_n_lo_si_nformation_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::lo_s_n_lo_si_ndicator_soft:
      break;
    case types::lo_s_n_lo_si_ndicator_hard:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "lo_s_n_lo_si_nformation_c");
  }
}
lo_s_n_lo_si_nformation_c::lo_s_n_lo_si_nformation_c(const lo_s_n_lo_si_nformation_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::lo_s_n_lo_si_ndicator_soft:
      c.init(other.c.get<uint8_t>());
      break;
    case types::lo_s_n_lo_si_ndicator_hard:
      c.init(other.c.get<lo_s_n_lo_si_ndicator_hard_e>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "lo_s_n_lo_si_nformation_c");
  }
}
lo_s_n_lo_si_nformation_c& lo_s_n_lo_si_nformation_c::operator=(const lo_s_n_lo_si_nformation_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::lo_s_n_lo_si_ndicator_soft:
      c.set(other.c.get<uint8_t>());
      break;
    case types::lo_s_n_lo_si_ndicator_hard:
      c.set(other.c.get<lo_s_n_lo_si_ndicator_hard_e>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "lo_s_n_lo_si_nformation_c");
  }

  return *this;
}
uint8_t& lo_s_n_lo_si_nformation_c::set_lo_s_n_lo_si_ndicator_soft()
{
  set(types::lo_s_n_lo_si_ndicator_soft);
  return c.get<uint8_t>();
}
lo_s_n_lo_si_ndicator_hard_e& lo_s_n_lo_si_nformation_c::set_lo_s_n_lo_si_ndicator_hard()
{
  set(types::lo_s_n_lo_si_ndicator_hard);
  return c.get<lo_s_n_lo_si_ndicator_hard_e>();
}
protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>& lo_s_n_lo_si_nformation_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>>();
}
void lo_s_n_lo_si_nformation_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::lo_s_n_lo_si_ndicator_soft:
      j.write_int("loS-NLoSIndicatorSoft", c.get<uint8_t>());
      break;
    case types::lo_s_n_lo_si_ndicator_hard:
      j.write_str("loS-NLoSIndicatorHard", c.get<lo_s_n_lo_si_ndicator_hard_e>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-Extension");
      c.get<protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "lo_s_n_lo_si_nformation_c");
  }
  j.end_obj();
}
SRSASN_CODE lo_s_n_lo_si_nformation_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::lo_s_n_lo_si_ndicator_soft:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)10u, false, true));
      break;
    case types::lo_s_n_lo_si_ndicator_hard:
      HANDLE_CODE(c.get<lo_s_n_lo_si_ndicator_hard_e>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "lo_s_n_lo_si_nformation_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE lo_s_n_lo_si_nformation_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::lo_s_n_lo_si_ndicator_soft:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)10u, false, true));
      break;
    case types::lo_s_n_lo_si_ndicator_hard:
      HANDLE_CODE(c.get<lo_s_n_lo_si_ndicator_hard_e>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<lo_s_n_lo_si_nformation_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "lo_s_n_lo_si_nformation_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* lo_s_n_lo_si_nformation_c::types_opts::to_string() const
{
  static const char* names[] = {"loS-NLoSIndicatorSoft", "loS-NLoSIndicatorHard", "choice-Extension"};
  return convert_enum_idx(names, 3, value, "lo_s_n_lo_si_nformation_c::types");
}

// M5ReportAmount ::= ENUMERATED
const char* m5_report_amount_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m5_report_amount_e");
}
int8_t m5_report_amount_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m5_report_amount_e");
}

// M6ReportAmount ::= ENUMERATED
const char* m6_report_amount_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m6_report_amount_e");
}
int8_t m6_report_amount_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m6_report_amount_e");
}

// M7ReportAmount ::= ENUMERATED
const char* m7_report_amount_opts::to_string() const
{
  static const char* names[] = {"r1", "r2", "r4", "r8", "r16", "r32", "r64", "infinity"};
  return convert_enum_idx(names, 8, value, "m7_report_amount_e");
}
int8_t m7_report_amount_opts::to_number() const
{
  static const int8_t numbers[] = {1, 2, 4, 8, 16, 32, 64, -1};
  return map_enum_number(numbers, 8, value, "m7_report_amount_e");
}

// MeasuredResultsValue-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
uint32_t measured_results_value_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {554, 558, 559};
  return map_enum_number(names, 3, idx, "id");
}
bool measured_results_value_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {554, 558, 559};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e measured_results_value_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 554:
      return crit_e::reject;
    case 558:
      return crit_e::reject;
    case 559:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
measured_results_value_ext_ies_o::value_c measured_results_value_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 554:
      ret.set(value_c::types::zo_a_info);
      break;
    case 558:
      ret.set(value_c::types::multiple_ul_ao_a);
      break;
    case 559:
      ret.set(value_c::types::ul_srs_rsrp_p);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e measured_results_value_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 554:
      return presence_e::mandatory;
    case 558:
      return presence_e::mandatory;
    case 559:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void measured_results_value_ext_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::zo_a_info:
      c.destroy<zo_a_info_s>();
      break;
    case types::multiple_ul_ao_a:
      c.destroy<multiple_ul_ao_a_s>();
      break;
    case types::ul_srs_rsrp_p:
      c.destroy<ul_srs_rsrp_p_s>();
      break;
    default:
      break;
  }
}
void measured_results_value_ext_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::zo_a_info:
      c.init<zo_a_info_s>();
      break;
    case types::multiple_ul_ao_a:
      c.init<multiple_ul_ao_a_s>();
      break;
    case types::ul_srs_rsrp_p:
      c.init<ul_srs_rsrp_p_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "measured_results_value_ext_ies_o::value_c");
  }
}
measured_results_value_ext_ies_o::value_c::value_c(const measured_results_value_ext_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::zo_a_info:
      c.init(other.c.get<zo_a_info_s>());
      break;
    case types::multiple_ul_ao_a:
      c.init(other.c.get<multiple_ul_ao_a_s>());
      break;
    case types::ul_srs_rsrp_p:
      c.init(other.c.get<ul_srs_rsrp_p_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "measured_results_value_ext_ies_o::value_c");
  }
}
measured_results_value_ext_ies_o::value_c&
measured_results_value_ext_ies_o::value_c::operator=(const measured_results_value_ext_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::zo_a_info:
      c.set(other.c.get<zo_a_info_s>());
      break;
    case types::multiple_ul_ao_a:
      c.set(other.c.get<multiple_ul_ao_a_s>());
      break;
    case types::ul_srs_rsrp_p:
      c.set(other.c.get<ul_srs_rsrp_p_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "measured_results_value_ext_ies_o::value_c");
  }

  return *this;
}
zo_a_info_s& measured_results_value_ext_ies_o::value_c::zo_a_info()
{
  assert_choice_type(types::zo_a_info, type_, "Value");
  return c.get<zo_a_info_s>();
}
multiple_ul_ao_a_s& measured_results_value_ext_ies_o::value_c::multiple_ul_ao_a()
{
  assert_choice_type(types::multiple_ul_ao_a, type_, "Value");
  return c.get<multiple_ul_ao_a_s>();
}
ul_srs_rsrp_p_s& measured_results_value_ext_ies_o::value_c::ul_srs_rsrp_p()
{
  assert_choice_type(types::ul_srs_rsrp_p, type_, "Value");
  return c.get<ul_srs_rsrp_p_s>();
}
const zo_a_info_s& measured_results_value_ext_ies_o::value_c::zo_a_info() const
{
  assert_choice_type(types::zo_a_info, type_, "Value");
  return c.get<zo_a_info_s>();
}
const multiple_ul_ao_a_s& measured_results_value_ext_ies_o::value_c::multiple_ul_ao_a() const
{
  assert_choice_type(types::multiple_ul_ao_a, type_, "Value");
  return c.get<multiple_ul_ao_a_s>();
}
const ul_srs_rsrp_p_s& measured_results_value_ext_ies_o::value_c::ul_srs_rsrp_p() const
{
  assert_choice_type(types::ul_srs_rsrp_p, type_, "Value");
  return c.get<ul_srs_rsrp_p_s>();
}
void measured_results_value_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::zo_a_info:
      j.write_fieldname("ZoAInformation");
      c.get<zo_a_info_s>().to_json(j);
      break;
    case types::multiple_ul_ao_a:
      j.write_fieldname("MultipleULAoA");
      c.get<multiple_ul_ao_a_s>().to_json(j);
      break;
    case types::ul_srs_rsrp_p:
      j.write_fieldname("UL-SRS-RSRPP");
      c.get<ul_srs_rsrp_p_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "measured_results_value_ext_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE measured_results_value_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::zo_a_info:
      HANDLE_CODE(c.get<zo_a_info_s>().pack(bref));
      break;
    case types::multiple_ul_ao_a:
      HANDLE_CODE(c.get<multiple_ul_ao_a_s>().pack(bref));
      break;
    case types::ul_srs_rsrp_p:
      HANDLE_CODE(c.get<ul_srs_rsrp_p_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "measured_results_value_ext_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE measured_results_value_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::zo_a_info:
      HANDLE_CODE(c.get<zo_a_info_s>().unpack(bref));
      break;
    case types::multiple_ul_ao_a:
      HANDLE_CODE(c.get<multiple_ul_ao_a_s>().unpack(bref));
      break;
    case types::ul_srs_rsrp_p:
      HANDLE_CODE(c.get<ul_srs_rsrp_p_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "measured_results_value_ext_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NR-Mode-Info-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
uint32_t nr_mode_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {445};
  return map_enum_number(names, 1, idx, "id");
}
bool nr_mode_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 445 == id;
}
crit_e nr_mode_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 445) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
nr_mode_info_ext_ies_o::value_c nr_mode_info_ext_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 445) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e nr_mode_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 445) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void nr_mode_info_ext_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("NR-U-Channel-Info-List");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE nr_mode_info_ext_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 16, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_mode_info_ext_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 16, true));
  return SRSASN_SUCCESS;
}

// PC5-QoS-Characteristics ::= CHOICE
void pc5_qos_characteristics_c::destroy_()
{
  switch (type_) {
    case types::non_dyn_pqi:
      c.destroy<non_dyn_pq_id_escriptor_s>();
      break;
    case types::dyn_pqi:
      c.destroy<dyn_pq_id_escriptor_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void pc5_qos_characteristics_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::non_dyn_pqi:
      c.init<non_dyn_pq_id_escriptor_s>();
      break;
    case types::dyn_pqi:
      c.init<dyn_pq_id_escriptor_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pc5_qos_characteristics_c");
  }
}
pc5_qos_characteristics_c::pc5_qos_characteristics_c(const pc5_qos_characteristics_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::non_dyn_pqi:
      c.init(other.c.get<non_dyn_pq_id_escriptor_s>());
      break;
    case types::dyn_pqi:
      c.init(other.c.get<dyn_pq_id_escriptor_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pc5_qos_characteristics_c");
  }
}
pc5_qos_characteristics_c& pc5_qos_characteristics_c::operator=(const pc5_qos_characteristics_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::non_dyn_pqi:
      c.set(other.c.get<non_dyn_pq_id_escriptor_s>());
      break;
    case types::dyn_pqi:
      c.set(other.c.get<dyn_pq_id_escriptor_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pc5_qos_characteristics_c");
  }

  return *this;
}
non_dyn_pq_id_escriptor_s& pc5_qos_characteristics_c::set_non_dyn_pqi()
{
  set(types::non_dyn_pqi);
  return c.get<non_dyn_pq_id_escriptor_s>();
}
dyn_pq_id_escriptor_s& pc5_qos_characteristics_c::set_dyn_pqi()
{
  set(types::dyn_pqi);
  return c.get<dyn_pq_id_escriptor_s>();
}
protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>& pc5_qos_characteristics_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>>();
}
void pc5_qos_characteristics_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::non_dyn_pqi:
      j.write_fieldname("non-Dynamic-PQI");
      c.get<non_dyn_pq_id_escriptor_s>().to_json(j);
      break;
    case types::dyn_pqi:
      j.write_fieldname("dynamic-PQI");
      c.get<dyn_pq_id_escriptor_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pc5_qos_characteristics_c");
  }
  j.end_obj();
}
SRSASN_CODE pc5_qos_characteristics_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::non_dyn_pqi:
      HANDLE_CODE(c.get<non_dyn_pq_id_escriptor_s>().pack(bref));
      break;
    case types::dyn_pqi:
      HANDLE_CODE(c.get<dyn_pq_id_escriptor_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pc5_qos_characteristics_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_qos_characteristics_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::non_dyn_pqi:
      HANDLE_CODE(c.get<non_dyn_pq_id_escriptor_s>().unpack(bref));
      break;
    case types::dyn_pqi:
      HANDLE_CODE(c.get<dyn_pq_id_escriptor_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pc5_qos_characteristics_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pc5_qos_characteristics_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pc5_qos_characteristics_c::types_opts::to_string() const
{
  static const char* names[] = {"non-Dynamic-PQI", "dynamic-PQI", "choice-extension"};
  return convert_enum_idx(names, 3, value, "pc5_qos_characteristics_c::types");
}

// PC5FlowBitRates ::= SEQUENCE
SRSASN_CODE pc5_flow_bit_rates_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, guaranteed_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(pack_integer(bref, max_flow_bit_rate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_flow_bit_rates_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(guaranteed_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  HANDLE_CODE(unpack_integer(max_flow_bit_rate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_flow_bit_rates_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("guaranteedFlowBitRate", guaranteed_flow_bit_rate);
  j.write_int("maximumFlowBitRate", max_flow_bit_rate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PRSTransmissionOffPerResource-Item ::= SEQUENCE
SRSASN_CODE prs_tx_off_per_res_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prs_res_set_id, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, prs_tx_off_ind_per_res_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_tx_off_per_res_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prs_res_set_id, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  HANDLE_CODE(unpack_dyn_seq_of(prs_tx_off_ind_per_res_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_tx_off_per_res_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pRSResourceSetID", prs_res_set_id);
  j.start_array("pRSTransmissionOffIndicationPerResourceList");
  for (const auto& e1 : prs_tx_off_ind_per_res_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PRSTransmissionOffPerResourceSet-Item ::= SEQUENCE
SRSASN_CODE prs_tx_off_per_res_set_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, prs_res_set_id, (uint8_t)0u, (uint8_t)7u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_tx_off_per_res_set_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(prs_res_set_id, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_tx_off_per_res_set_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pRSResourceSetID", prs_res_set_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PeriodicitySRS ::= ENUMERATED
const char* periodicity_srs_opts::to_string() const
{
  static const char* names[] = {"ms0p125", "ms0p25", "ms0p5", "ms0p625", "ms1",    "ms1p25", "ms2",    "ms2p5", "ms4",
                                "ms5",     "ms8",    "ms10",  "ms16",    "ms20",   "ms32",   "ms40",   "ms64",  "ms80",
                                "ms160",   "ms320",  "ms640", "ms1280",  "ms2560", "ms5120", "ms10240"};
  return convert_enum_idx(names, 25, value, "periodicity_srs_e");
}

// SFN-Offset ::= SEQUENCE
SRSASN_CODE sfn_offset_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sfn_time_offset.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sfn_offset_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sfn_time_offset.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sfn_offset_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("sFN-Time-Offset", sfn_time_offset.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRSResourcetype ::= SEQUENCE
SRSASN_CODE srs_restype_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(srs_res_type_choice.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srs_restype_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(srs_res_type_choice.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void srs_restype_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sRSResourceTypeChoice");
  srs_res_type_choice.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

SRSASN_CODE served_plmns_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += tai_slice_support_list_present ? 1 : 0;
  nof_ies += npn_support_info_present ? 1 : 0;
  nof_ies += extended_tai_slice_support_list_present ? 1 : 0;
  nof_ies += tai_nsag_support_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (tai_slice_support_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)131, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, tai_slice_support_list, 1, 1024, true));
  }
  if (npn_support_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)384, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_support_info.pack(bref));
  }
  if (extended_tai_slice_support_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)390, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, extended_tai_slice_support_list, 1, 65535, true));
  }
  if (tai_nsag_support_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)644, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, tai_nsag_support_list, 1, 256, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_plmns_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 131: {
        tai_slice_support_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(tai_slice_support_list, bref, 1, 1024, true));
        break;
      }
      case 384: {
        npn_support_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_support_info.unpack(bref));
        break;
      }
      case 390: {
        extended_tai_slice_support_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(extended_tai_slice_support_list, bref, 1, 65535, true));
        break;
      }
      case 644: {
        tai_nsag_support_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(tai_nsag_support_list, bref, 1, 256, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void served_plmns_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (tai_slice_support_list_present) {
    j.write_int("id", 131);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : tai_slice_support_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (npn_support_info_present) {
    j.write_int("id", 384);
    j.write_str("criticality", "reject");
    npn_support_info.to_json(j);
  }
  if (extended_tai_slice_support_list_present) {
    j.write_int("id", 390);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : extended_tai_slice_support_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (tai_nsag_support_list_present) {
    j.write_int("id", 644);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : tai_nsag_support_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// ServedPLMNs-Item ::= SEQUENCE
SRSASN_CODE served_plmns_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_plmns_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_plmns_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMN-Identity", plmn_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SpatialRelationforResourceIDItem ::= SEQUENCE
SRSASN_CODE spatial_relationfor_res_id_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ref_sig.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE spatial_relationfor_res_id_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ref_sig.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void spatial_relationfor_res_id_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("referenceSignal");
  ref_sig.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// StartTimeAndDuration ::= SEQUENCE
SRSASN_CODE start_time_and_dur_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(start_time_present, 1));
  HANDLE_CODE(bref.pack(dur_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (start_time_present) {
    HANDLE_CODE(start_time.pack(bref));
  }
  if (dur_present) {
    HANDLE_CODE(pack_integer(bref, dur, (uint32_t)0u, (uint32_t)90060u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE start_time_and_dur_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(start_time_present, 1));
  HANDLE_CODE(bref.unpack(dur_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (start_time_present) {
    HANDLE_CODE(start_time.unpack(bref));
  }
  if (dur_present) {
    HANDLE_CODE(unpack_integer(dur, bref, (uint32_t)0u, (uint32_t)90060u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void start_time_and_dur_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (start_time_present) {
    j.write_str("startTime", start_time.to_string());
  }
  if (dur_present) {
    j.write_int("duration", dur);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE tdd_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += intended_tdd_dl_ul_cfg_present ? 1 : 0;
  nof_ies += tdd_ul_dl_cfg_common_nr_present ? 1 : 0;
  nof_ies += carrier_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (intended_tdd_dl_ul_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)256, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(intended_tdd_dl_ul_cfg.pack(bref));
  }
  if (tdd_ul_dl_cfg_common_nr_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)361, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tdd_ul_dl_cfg_common_nr.pack(bref));
  }
  if (carrier_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)354, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, carrier_list, 1, 5, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tdd_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 256: {
        intended_tdd_dl_ul_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(intended_tdd_dl_ul_cfg.unpack(bref));
        break;
      }
      case 361: {
        tdd_ul_dl_cfg_common_nr_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tdd_ul_dl_cfg_common_nr.unpack(bref));
        break;
      }
      case 354: {
        carrier_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(carrier_list, bref, 1, 5, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void tdd_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (intended_tdd_dl_ul_cfg_present) {
    j.write_int("id", 256);
    j.write_str("criticality", "ignore");
    intended_tdd_dl_ul_cfg.to_json(j);
  }
  if (tdd_ul_dl_cfg_common_nr_present) {
    j.write_int("id", 361);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", tdd_ul_dl_cfg_common_nr.to_string());
  }
  if (carrier_list_present) {
    j.write_int("id", 354);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// TDD-Info ::= SEQUENCE
SRSASN_CODE tdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_freq_info.pack(bref));
  HANDLE_CODE(tx_bw.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_freq_info.unpack(bref));
  HANDLE_CODE(tx_bw.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRFreqInfo");
  nr_freq_info.to_json(j);
  j.write_fieldname("transmission-Bandwidth");
  tx_bw.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>;

// TRPInformationTypeResponseItem ::= CHOICE
void trp_info_type_resp_item_c::destroy_()
{
  switch (type_) {
    case types::ng_ran_cgi:
      c.destroy<nr_cgi_s>();
      break;
    case types::prs_cfg:
      c.destroy<prs_cfg_s>();
      break;
    case types::ss_binfo:
      c.destroy<ssb_info_s>();
      break;
    case types::sfn_initisation_time:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    case types::spatial_direction_info:
      c.destroy<spatial_direction_info_s>();
      break;
    case types::geographical_coordinates:
      c.destroy<geographical_coordinates_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void trp_info_type_resp_item_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pci_nr:
      break;
    case types::ng_ran_cgi:
      c.init<nr_cgi_s>();
      break;
    case types::nr_arfcn:
      break;
    case types::prs_cfg:
      c.init<prs_cfg_s>();
      break;
    case types::ss_binfo:
      c.init<ssb_info_s>();
      break;
    case types::sfn_initisation_time:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::spatial_direction_info:
      c.init<spatial_direction_info_s>();
      break;
    case types::geographical_coordinates:
      c.init<geographical_coordinates_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_info_type_resp_item_c");
  }
}
trp_info_type_resp_item_c::trp_info_type_resp_item_c(const trp_info_type_resp_item_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pci_nr:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ng_ran_cgi:
      c.init(other.c.get<nr_cgi_s>());
      break;
    case types::nr_arfcn:
      c.init(other.c.get<uint32_t>());
      break;
    case types::prs_cfg:
      c.init(other.c.get<prs_cfg_s>());
      break;
    case types::ss_binfo:
      c.init(other.c.get<ssb_info_s>());
      break;
    case types::sfn_initisation_time:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::spatial_direction_info:
      c.init(other.c.get<spatial_direction_info_s>());
      break;
    case types::geographical_coordinates:
      c.init(other.c.get<geographical_coordinates_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_info_type_resp_item_c");
  }
}
trp_info_type_resp_item_c& trp_info_type_resp_item_c::operator=(const trp_info_type_resp_item_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pci_nr:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ng_ran_cgi:
      c.set(other.c.get<nr_cgi_s>());
      break;
    case types::nr_arfcn:
      c.set(other.c.get<uint32_t>());
      break;
    case types::prs_cfg:
      c.set(other.c.get<prs_cfg_s>());
      break;
    case types::ss_binfo:
      c.set(other.c.get<ssb_info_s>());
      break;
    case types::sfn_initisation_time:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::spatial_direction_info:
      c.set(other.c.get<spatial_direction_info_s>());
      break;
    case types::geographical_coordinates:
      c.set(other.c.get<geographical_coordinates_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_info_type_resp_item_c");
  }

  return *this;
}
uint16_t& trp_info_type_resp_item_c::set_pci_nr()
{
  set(types::pci_nr);
  return c.get<uint16_t>();
}
nr_cgi_s& trp_info_type_resp_item_c::set_ng_ran_cgi()
{
  set(types::ng_ran_cgi);
  return c.get<nr_cgi_s>();
}
uint32_t& trp_info_type_resp_item_c::set_nr_arfcn()
{
  set(types::nr_arfcn);
  return c.get<uint32_t>();
}
prs_cfg_s& trp_info_type_resp_item_c::set_prs_cfg()
{
  set(types::prs_cfg);
  return c.get<prs_cfg_s>();
}
ssb_info_s& trp_info_type_resp_item_c::set_ss_binfo()
{
  set(types::ss_binfo);
  return c.get<ssb_info_s>();
}
fixed_bitstring<64, false, true>& trp_info_type_resp_item_c::set_sfn_initisation_time()
{
  set(types::sfn_initisation_time);
  return c.get<fixed_bitstring<64, false, true>>();
}
spatial_direction_info_s& trp_info_type_resp_item_c::set_spatial_direction_info()
{
  set(types::spatial_direction_info);
  return c.get<spatial_direction_info_s>();
}
geographical_coordinates_s& trp_info_type_resp_item_c::set_geographical_coordinates()
{
  set(types::geographical_coordinates);
  return c.get<geographical_coordinates_s>();
}
protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>& trp_info_type_resp_item_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>>();
}
void trp_info_type_resp_item_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pci_nr:
      j.write_int("pCI-NR", c.get<uint16_t>());
      break;
    case types::ng_ran_cgi:
      j.write_fieldname("nG-RAN-CGI");
      c.get<nr_cgi_s>().to_json(j);
      break;
    case types::nr_arfcn:
      j.write_int("nRARFCN", c.get<uint32_t>());
      break;
    case types::prs_cfg:
      j.write_fieldname("pRSConfiguration");
      c.get<prs_cfg_s>().to_json(j);
      break;
    case types::ss_binfo:
      j.write_fieldname("sSBinformation");
      c.get<ssb_info_s>().to_json(j);
      break;
    case types::sfn_initisation_time:
      j.write_str("sFNInitialisationTime", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::spatial_direction_info:
      j.write_fieldname("spatialDirectionInformation");
      c.get<spatial_direction_info_s>().to_json(j);
      break;
    case types::geographical_coordinates:
      j.write_fieldname("geographicalCoordinates");
      c.get<geographical_coordinates_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trp_info_type_resp_item_c");
  }
  j.end_obj();
}
SRSASN_CODE trp_info_type_resp_item_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::pci_nr:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)1007u, false, true));
      break;
    case types::ng_ran_cgi:
      HANDLE_CODE(c.get<nr_cgi_s>().pack(bref));
      break;
    case types::nr_arfcn:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)3279165u, false, true));
      break;
    case types::prs_cfg:
      HANDLE_CODE(c.get<prs_cfg_s>().pack(bref));
      break;
    case types::ss_binfo:
      HANDLE_CODE(c.get<ssb_info_s>().pack(bref));
      break;
    case types::sfn_initisation_time:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::spatial_direction_info:
      HANDLE_CODE(c.get<spatial_direction_info_s>().pack(bref));
      break;
    case types::geographical_coordinates:
      HANDLE_CODE(c.get<geographical_coordinates_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_info_type_resp_item_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_info_type_resp_item_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::pci_nr:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)1007u, false, true));
      break;
    case types::ng_ran_cgi:
      HANDLE_CODE(c.get<nr_cgi_s>().unpack(bref));
      break;
    case types::nr_arfcn:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
      break;
    case types::prs_cfg:
      HANDLE_CODE(c.get<prs_cfg_s>().unpack(bref));
      break;
    case types::ss_binfo:
      HANDLE_CODE(c.get<ssb_info_s>().unpack(bref));
      break;
    case types::sfn_initisation_time:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::spatial_direction_info:
      HANDLE_CODE(c.get<spatial_direction_info_s>().unpack(bref));
      break;
    case types::geographical_coordinates:
      HANDLE_CODE(c.get<geographical_coordinates_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<trp_info_type_resp_item_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_info_type_resp_item_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* trp_info_type_resp_item_c::types_opts::to_string() const
{
  static const char* names[] = {"pCI-NR",
                                "nG-RAN-CGI",
                                "nRARFCN",
                                "pRSConfiguration",
                                "sSBinformation",
                                "sFNInitialisationTime",
                                "spatialDirectionInformation",
                                "geographicalCoordinates",
                                "choice-extension"};
  return convert_enum_idx(names, 9, value, "trp_info_type_resp_item_c::types");
}

template struct asn1::protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>;

// TimeStampSlotIndex ::= CHOICE
void time_stamp_slot_idx_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void time_stamp_slot_idx_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::scs_15:
      break;
    case types::scs_30:
      break;
    case types::scs_60:
      break;
    case types::scs_120:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "time_stamp_slot_idx_c");
  }
}
time_stamp_slot_idx_c::time_stamp_slot_idx_c(const time_stamp_slot_idx_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::scs_15:
      c.init(other.c.get<uint8_t>());
      break;
    case types::scs_30:
      c.init(other.c.get<uint8_t>());
      break;
    case types::scs_60:
      c.init(other.c.get<uint8_t>());
      break;
    case types::scs_120:
      c.init(other.c.get<uint8_t>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "time_stamp_slot_idx_c");
  }
}
time_stamp_slot_idx_c& time_stamp_slot_idx_c::operator=(const time_stamp_slot_idx_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::scs_15:
      c.set(other.c.get<uint8_t>());
      break;
    case types::scs_30:
      c.set(other.c.get<uint8_t>());
      break;
    case types::scs_60:
      c.set(other.c.get<uint8_t>());
      break;
    case types::scs_120:
      c.set(other.c.get<uint8_t>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "time_stamp_slot_idx_c");
  }

  return *this;
}
uint8_t& time_stamp_slot_idx_c::set_scs_15()
{
  set(types::scs_15);
  return c.get<uint8_t>();
}
uint8_t& time_stamp_slot_idx_c::set_scs_30()
{
  set(types::scs_30);
  return c.get<uint8_t>();
}
uint8_t& time_stamp_slot_idx_c::set_scs_60()
{
  set(types::scs_60);
  return c.get<uint8_t>();
}
uint8_t& time_stamp_slot_idx_c::set_scs_120()
{
  set(types::scs_120);
  return c.get<uint8_t>();
}
protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>& time_stamp_slot_idx_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>>();
}
void time_stamp_slot_idx_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::scs_15:
      j.write_int("sCS-15", c.get<uint8_t>());
      break;
    case types::scs_30:
      j.write_int("sCS-30", c.get<uint8_t>());
      break;
    case types::scs_60:
      j.write_int("sCS-60", c.get<uint8_t>());
      break;
    case types::scs_120:
      j.write_int("sCS-120", c.get<uint8_t>());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "time_stamp_slot_idx_c");
  }
  j.end_obj();
}
SRSASN_CODE time_stamp_slot_idx_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::scs_15:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)9u, false, true));
      break;
    case types::scs_30:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)19u, false, true));
      break;
    case types::scs_60:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)39u, false, true));
      break;
    case types::scs_120:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)79u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "time_stamp_slot_idx_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE time_stamp_slot_idx_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::scs_15:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)9u, false, true));
      break;
    case types::scs_30:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)19u, false, true));
      break;
    case types::scs_60:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)39u, false, true));
      break;
    case types::scs_120:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)79u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<time_stamp_slot_idx_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "time_stamp_slot_idx_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* time_stamp_slot_idx_c::types_opts::to_string() const
{
  static const char* names[] = {"sCS-15", "sCS-30", "sCS-60", "sCS-120", "choice-extension"};
  return convert_enum_idx(names, 5, value, "time_stamp_slot_idx_c::types");
}
int8_t time_stamp_slot_idx_c::types_opts::to_number() const
{
  static const int8_t numbers[] = {-15, -30, -60, -120};
  return map_enum_number(numbers, 4, value, "time_stamp_slot_idx_c::types");
}

// UACCategoryType ::= CHOICE
void uac_category_type_c::destroy_()
{
  switch (type_) {
    case types::uac_operator_defined:
      c.destroy<uac_operator_defined_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<uac_category_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void uac_category_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::uac_standardized:
      break;
    case types::uac_operator_defined:
      c.init<uac_operator_defined_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<uac_category_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "uac_category_type_c");
  }
}
uac_category_type_c::uac_category_type_c(const uac_category_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::uac_standardized:
      c.init(other.c.get<uac_action_e>());
      break;
    case types::uac_operator_defined:
      c.init(other.c.get<uac_operator_defined_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<uac_category_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "uac_category_type_c");
  }
}
uac_category_type_c& uac_category_type_c::operator=(const uac_category_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::uac_standardized:
      c.set(other.c.get<uac_action_e>());
      break;
    case types::uac_operator_defined:
      c.set(other.c.get<uac_operator_defined_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<uac_category_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "uac_category_type_c");
  }

  return *this;
}
uac_action_e& uac_category_type_c::set_uac_standardized()
{
  set(types::uac_standardized);
  return c.get<uac_action_e>();
}
uac_operator_defined_s& uac_category_type_c::set_uac_operator_defined()
{
  set(types::uac_operator_defined);
  return c.get<uac_operator_defined_s>();
}
protocol_ie_single_container_s<uac_category_type_ext_ies_o>& uac_category_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<uac_category_type_ext_ies_o>>();
}
void uac_category_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::uac_standardized:
      j.write_str("uACstandardized", c.get<uac_action_e>().to_string());
      break;
    case types::uac_operator_defined:
      j.write_fieldname("uACOperatorDefined");
      c.get<uac_operator_defined_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<uac_category_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "uac_category_type_c");
  }
  j.end_obj();
}
SRSASN_CODE uac_category_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::uac_standardized:
      HANDLE_CODE(c.get<uac_action_e>().pack(bref));
      break;
    case types::uac_operator_defined:
      HANDLE_CODE(c.get<uac_operator_defined_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<uac_category_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "uac_category_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE uac_category_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::uac_standardized:
      HANDLE_CODE(c.get<uac_action_e>().unpack(bref));
      break;
    case types::uac_operator_defined:
      HANDLE_CODE(c.get<uac_operator_defined_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<uac_category_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "uac_category_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* uac_category_type_c::types_opts::to_string() const
{
  static const char* names[] = {"uACstandardized", "uACOperatorDefined", "choice-extension"};
  return convert_enum_idx(names, 3, value, "uac_category_type_c::types");
}

SRSASN_CODE ul_rtoa_meas_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += extended_add_path_list_present ? 1 : 0;
  nof_ies += trp_rx_teg_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (extended_add_path_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)561, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, extended_add_path_list, 1, 8, true));
  }
  if (trp_rx_teg_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)568, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trp_rx_teg_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_rtoa_meas_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 561: {
        extended_add_path_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(extended_add_path_list, bref, 1, 8, true));
        break;
      }
      case 568: {
        trp_rx_teg_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trp_rx_teg_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ul_rtoa_meas_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (extended_add_path_list_present) {
    j.write_int("id", 561);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : extended_add_path_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (trp_rx_teg_info_present) {
    j.write_int("id", 568);
    j.write_str("criticality", "ignore");
    trp_rx_teg_info.to_json(j);
  }
  j.end_obj();
}

// UL-RTOA-Measurement ::= SEQUENCE
SRSASN_CODE ul_rtoa_meas_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(add_path_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_rtoa_meas_item.pack(bref));
  if (add_path_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, add_path_list, 1, 2, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_rtoa_meas_s::unpack(cbit_ref& bref)
{
  bool add_path_list_present;
  HANDLE_CODE(bref.unpack(add_path_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_rtoa_meas_item.unpack(bref));
  if (add_path_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(add_path_list, bref, 1, 2, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_rtoa_meas_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uL-RTOA-MeasurementItem");
  ul_rtoa_meas_item.to_json(j);
  if (add_path_list.size() > 0) {
    j.start_array("additionalPath-List");
    for (const auto& e1 : add_path_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// VictimgNBSetID ::= SEQUENCE
SRSASN_CODE victim_gnb_set_id_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(victim_gnb_set_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE victim_gnb_set_id_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(victim_gnb_set_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void victim_gnb_set_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("victimgNBSetID", victim_gnb_set_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// AdditionalDuplicationIndication ::= ENUMERATED
const char* add_dupl_ind_opts::to_string() const
{
  static const char* names[] = {"three", "four"};
  return convert_enum_idx(names, 2, value, "add_dupl_ind_e");
}
uint8_t add_dupl_ind_opts::to_number() const
{
  static const uint8_t numbers[] = {3, 4};
  return map_enum_number(numbers, 2, value, "add_dupl_ind_e");
}

// GNB-DU-System-Information-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t gnb_du_sys_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {310, 311, 312, 387, 625, 627, 648};
  return map_enum_number(names, 7, idx, "id");
}
bool gnb_du_sys_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {310, 311, 312, 387, 625, 627, 648};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e gnb_du_sys_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 310:
      return crit_e::ignore;
    case 311:
      return crit_e::ignore;
    case 312:
      return crit_e::ignore;
    case 387:
      return crit_e::ignore;
    case 625:
      return crit_e::ignore;
    case 627:
      return crit_e::ignore;
    case 648:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
gnb_du_sys_info_ext_ies_o::ext_c gnb_du_sys_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 310:
      ret.set(ext_c::types::sib12_msg);
      break;
    case 311:
      ret.set(ext_c::types::sib13_msg);
      break;
    case 312:
      ret.set(ext_c::types::sib14_msg);
      break;
    case 387:
      ret.set(ext_c::types::sib10_msg);
      break;
    case 625:
      ret.set(ext_c::types::sib17_msg);
      break;
    case 627:
      ret.set(ext_c::types::sib20_msg);
      break;
    case 648:
      ret.set(ext_c::types::sib15_msg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e gnb_du_sys_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 310:
      return presence_e::optional;
    case 311:
      return presence_e::optional;
    case 312:
      return presence_e::optional;
    case 387:
      return presence_e::optional;
    case 625:
      return presence_e::optional;
    case 627:
      return presence_e::optional;
    case 648:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void gnb_du_sys_info_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::sib12_msg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::sib13_msg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::sib14_msg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::sib10_msg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::sib17_msg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::sib20_msg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::sib15_msg:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void gnb_du_sys_info_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::sib12_msg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::sib13_msg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::sib14_msg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::sib10_msg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::sib17_msg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::sib20_msg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::sib15_msg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_du_sys_info_ext_ies_o::ext_c");
  }
}
gnb_du_sys_info_ext_ies_o::ext_c::ext_c(const gnb_du_sys_info_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::sib12_msg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sib13_msg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sib14_msg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sib10_msg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sib17_msg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sib20_msg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sib15_msg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_du_sys_info_ext_ies_o::ext_c");
  }
}
gnb_du_sys_info_ext_ies_o::ext_c&
gnb_du_sys_info_ext_ies_o::ext_c::operator=(const gnb_du_sys_info_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::sib12_msg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sib13_msg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sib14_msg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sib10_msg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sib17_msg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sib20_msg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::sib15_msg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "gnb_du_sys_info_ext_ies_o::ext_c");
  }

  return *this;
}
unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib12_msg()
{
  assert_choice_type(types::sib12_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib13_msg()
{
  assert_choice_type(types::sib13_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib14_msg()
{
  assert_choice_type(types::sib14_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib10_msg()
{
  assert_choice_type(types::sib10_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib17_msg()
{
  assert_choice_type(types::sib17_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib20_msg()
{
  assert_choice_type(types::sib20_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib15_msg()
{
  assert_choice_type(types::sib15_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib12_msg() const
{
  assert_choice_type(types::sib12_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib13_msg() const
{
  assert_choice_type(types::sib13_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib14_msg() const
{
  assert_choice_type(types::sib14_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib10_msg() const
{
  assert_choice_type(types::sib10_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib17_msg() const
{
  assert_choice_type(types::sib17_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib20_msg() const
{
  assert_choice_type(types::sib20_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& gnb_du_sys_info_ext_ies_o::ext_c::sib15_msg() const
{
  assert_choice_type(types::sib15_msg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
void gnb_du_sys_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::sib12_msg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::sib13_msg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::sib14_msg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::sib10_msg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::sib17_msg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::sib20_msg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::sib15_msg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "gnb_du_sys_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE gnb_du_sys_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::sib12_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::sib13_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::sib14_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::sib10_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::sib17_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::sib20_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::sib15_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_du_sys_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_du_sys_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::sib12_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::sib13_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::sib14_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::sib10_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::sib17_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::sib20_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::sib15_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "gnb_du_sys_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// GTPTLA-Item ::= SEQUENCE
SRSASN_CODE gtp_tla_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(gtp_transport_layer_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gtp_tla_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(gtp_transport_layer_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gtp_tla_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("gTPTransportLayerAddress", gtp_transport_layer_address.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LastUsedCellIndication ::= ENUMERATED
const char* last_used_cell_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "last_used_cell_ind_e");
}

// M5-Links-to-log ::= ENUMERATED
const char* m5_links_to_log_opts::to_string() const
{
  static const char* names[] = {"uplink", "downlink", "both-uplink-and-downlink"};
  return convert_enum_idx(names, 3, value, "m5_links_to_log_e");
}

// M5Configuration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t m5_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {537};
  return map_enum_number(names, 1, idx, "id");
}
bool m5_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 537 == id;
}
crit_e m5_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 537) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m5_cfg_ext_ies_o::ext_c m5_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 537) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m5_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 537) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m5_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("M5ReportAmount", c.to_string());
  j.end_obj();
}
SRSASN_CODE m5_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m5_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// M5period ::= ENUMERATED
const char* m5period_opts::to_string() const
{
  static const char* names[] = {"ms1024", "ms2048", "ms5120", "ms10240", "min1"};
  return convert_enum_idx(names, 5, value, "m5period_e");
}
uint16_t m5period_opts::to_number() const
{
  static const uint16_t numbers[] = {1024, 2048, 5120, 10240, 1};
  return map_enum_number(numbers, 5, value, "m5period_e");
}

// M6-Links-to-log ::= ENUMERATED
const char* m6_links_to_log_opts::to_string() const
{
  static const char* names[] = {"uplink", "downlink", "both-uplink-and-downlink"};
  return convert_enum_idx(names, 3, value, "m6_links_to_log_e");
}

// M6Configuration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t m6_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {538};
  return map_enum_number(names, 1, idx, "id");
}
bool m6_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 538 == id;
}
crit_e m6_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 538) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m6_cfg_ext_ies_o::ext_c m6_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 538) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m6_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 538) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m6_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("M6ReportAmount", c.to_string());
  j.end_obj();
}
SRSASN_CODE m6_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m6_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// M6report-Interval ::= ENUMERATED
const char* m6report_interv_opts::to_string() const
{
  static const char* names[] = {"ms120",
                                "ms240",
                                "ms640",
                                "ms1024",
                                "ms2048",
                                "ms5120",
                                "ms10240",
                                "ms20480",
                                "ms40960",
                                "min1",
                                "min6",
                                "min12",
                                "min30",
                                "ms480"};
  return convert_enum_idx(names, 14, value, "m6report_interv_e");
}
uint16_t m6report_interv_opts::to_number() const
{
  static const uint16_t numbers[] = {120, 240, 640, 1024, 2048, 5120, 10240, 20480, 40960, 1, 6, 12, 30, 480};
  return map_enum_number(numbers, 14, value, "m6report_interv_e");
}

// M7-Links-to-log ::= ENUMERATED
const char* m7_links_to_log_opts::to_string() const
{
  static const char* names[] = {"downlink"};
  return convert_enum_idx(names, 1, value, "m7_links_to_log_e");
}

// M7Configuration-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t m7_cfg_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {539};
  return map_enum_number(names, 1, idx, "id");
}
bool m7_cfg_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 539 == id;
}
crit_e m7_cfg_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 539) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
m7_cfg_ext_ies_o::ext_c m7_cfg_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 539) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e m7_cfg_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 539) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void m7_cfg_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("M7ReportAmount", c.to_string());
  j.end_obj();
}
SRSASN_CODE m7_cfg_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE m7_cfg_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

template struct asn1::protocol_ie_single_container_s<measured_results_value_ext_ies_o>;

// MeasuredResultsValue ::= CHOICE
void measured_results_value_c::destroy_()
{
  switch (type_) {
    case types::ul_angle_of_arrival:
      c.destroy<ul_ao_a_s>();
      break;
    case types::ul_rtoa:
      c.destroy<ul_rtoa_meas_s>();
      break;
    case types::gnb_rx_tx_time_diff:
      c.destroy<gnb_rx_tx_time_diff_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<measured_results_value_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void measured_results_value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ul_angle_of_arrival:
      c.init<ul_ao_a_s>();
      break;
    case types::ul_srs_rsrp:
      break;
    case types::ul_rtoa:
      c.init<ul_rtoa_meas_s>();
      break;
    case types::gnb_rx_tx_time_diff:
      c.init<gnb_rx_tx_time_diff_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<measured_results_value_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "measured_results_value_c");
  }
}
measured_results_value_c::measured_results_value_c(const measured_results_value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ul_angle_of_arrival:
      c.init(other.c.get<ul_ao_a_s>());
      break;
    case types::ul_srs_rsrp:
      c.init(other.c.get<uint8_t>());
      break;
    case types::ul_rtoa:
      c.init(other.c.get<ul_rtoa_meas_s>());
      break;
    case types::gnb_rx_tx_time_diff:
      c.init(other.c.get<gnb_rx_tx_time_diff_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<measured_results_value_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "measured_results_value_c");
  }
}
measured_results_value_c& measured_results_value_c::operator=(const measured_results_value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ul_angle_of_arrival:
      c.set(other.c.get<ul_ao_a_s>());
      break;
    case types::ul_srs_rsrp:
      c.set(other.c.get<uint8_t>());
      break;
    case types::ul_rtoa:
      c.set(other.c.get<ul_rtoa_meas_s>());
      break;
    case types::gnb_rx_tx_time_diff:
      c.set(other.c.get<gnb_rx_tx_time_diff_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<measured_results_value_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "measured_results_value_c");
  }

  return *this;
}
ul_ao_a_s& measured_results_value_c::set_ul_angle_of_arrival()
{
  set(types::ul_angle_of_arrival);
  return c.get<ul_ao_a_s>();
}
uint8_t& measured_results_value_c::set_ul_srs_rsrp()
{
  set(types::ul_srs_rsrp);
  return c.get<uint8_t>();
}
ul_rtoa_meas_s& measured_results_value_c::set_ul_rtoa()
{
  set(types::ul_rtoa);
  return c.get<ul_rtoa_meas_s>();
}
gnb_rx_tx_time_diff_s& measured_results_value_c::set_gnb_rx_tx_time_diff()
{
  set(types::gnb_rx_tx_time_diff);
  return c.get<gnb_rx_tx_time_diff_s>();
}
protocol_ie_single_container_s<measured_results_value_ext_ies_o>& measured_results_value_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<measured_results_value_ext_ies_o>>();
}
void measured_results_value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ul_angle_of_arrival:
      j.write_fieldname("uL-AngleOfArrival");
      c.get<ul_ao_a_s>().to_json(j);
      break;
    case types::ul_srs_rsrp:
      j.write_int("uL-SRS-RSRP", c.get<uint8_t>());
      break;
    case types::ul_rtoa:
      j.write_fieldname("uL-RTOA");
      c.get<ul_rtoa_meas_s>().to_json(j);
      break;
    case types::gnb_rx_tx_time_diff:
      j.write_fieldname("gNB-RxTxTimeDiff");
      c.get<gnb_rx_tx_time_diff_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<measured_results_value_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "measured_results_value_c");
  }
  j.end_obj();
}
SRSASN_CODE measured_results_value_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ul_angle_of_arrival:
      HANDLE_CODE(c.get<ul_ao_a_s>().pack(bref));
      break;
    case types::ul_srs_rsrp:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)126u, false, true));
      break;
    case types::ul_rtoa:
      HANDLE_CODE(c.get<ul_rtoa_meas_s>().pack(bref));
      break;
    case types::gnb_rx_tx_time_diff:
      HANDLE_CODE(c.get<gnb_rx_tx_time_diff_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<measured_results_value_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "measured_results_value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE measured_results_value_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ul_angle_of_arrival:
      HANDLE_CODE(c.get<ul_ao_a_s>().unpack(bref));
      break;
    case types::ul_srs_rsrp:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)126u, false, true));
      break;
    case types::ul_rtoa:
      HANDLE_CODE(c.get<ul_rtoa_meas_s>().unpack(bref));
      break;
    case types::gnb_rx_tx_time_diff:
      HANDLE_CODE(c.get<gnb_rx_tx_time_diff_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<measured_results_value_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "measured_results_value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* measured_results_value_c::types_opts::to_string() const
{
  static const char* names[] = {"uL-AngleOfArrival", "uL-SRS-RSRP", "uL-RTOA", "gNB-RxTxTimeDiff", "choice-extension"};
  return convert_enum_idx(names, 5, value, "measured_results_value_c::types");
}

// MeasurementBeamInfo ::= SEQUENCE
SRSASN_CODE meas_beam_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(prs_res_id_present, 1));
  HANDLE_CODE(bref.pack(prs_res_set_id_present, 1));
  HANDLE_CODE(bref.pack(ssb_idx_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (prs_res_id_present) {
    HANDLE_CODE(pack_integer(bref, prs_res_id, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (prs_res_set_id_present) {
    HANDLE_CODE(pack_integer(bref, prs_res_set_id, (uint8_t)0u, (uint8_t)7u, false, true));
  }
  if (ssb_idx_present) {
    HANDLE_CODE(pack_integer(bref, ssb_idx, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE meas_beam_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(prs_res_id_present, 1));
  HANDLE_CODE(bref.unpack(prs_res_set_id_present, 1));
  HANDLE_CODE(bref.unpack(ssb_idx_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (prs_res_id_present) {
    HANDLE_CODE(unpack_integer(prs_res_id, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (prs_res_set_id_present) {
    HANDLE_CODE(unpack_integer(prs_res_set_id, bref, (uint8_t)0u, (uint8_t)7u, false, true));
  }
  if (ssb_idx_present) {
    HANDLE_CODE(unpack_integer(ssb_idx, bref, (uint8_t)0u, (uint8_t)63u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void meas_beam_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (prs_res_id_present) {
    j.write_int("pRS-Resource-ID", prs_res_id);
  }
  if (prs_res_set_id_present) {
    j.write_int("pRS-Resource-Set-ID", prs_res_set_id);
  }
  if (ssb_idx_present) {
    j.write_int("sSB-Index", ssb_idx);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

template struct asn1::protocol_ie_single_container_s<nr_mode_info_ext_ies_o>;

// NR-Mode-Info ::= CHOICE
void nr_mode_info_c::destroy_()
{
  switch (type_) {
    case types::fdd:
      c.destroy<fdd_info_s>();
      break;
    case types::tdd:
      c.destroy<tdd_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void nr_mode_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::fdd:
      c.init<fdd_info_s>();
      break;
    case types::tdd:
      c.init<tdd_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_c");
  }
}
nr_mode_info_c::nr_mode_info_c(const nr_mode_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::fdd:
      c.init(other.c.get<fdd_info_s>());
      break;
    case types::tdd:
      c.init(other.c.get<tdd_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_c");
  }
}
nr_mode_info_c& nr_mode_info_c::operator=(const nr_mode_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::fdd:
      c.set(other.c.get<fdd_info_s>());
      break;
    case types::tdd:
      c.set(other.c.get<tdd_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_c");
  }

  return *this;
}
fdd_info_s& nr_mode_info_c::set_fdd()
{
  set(types::fdd);
  return c.get<fdd_info_s>();
}
tdd_info_s& nr_mode_info_c::set_tdd()
{
  set(types::tdd);
  return c.get<tdd_info_s>();
}
protocol_ie_single_container_s<nr_mode_info_ext_ies_o>& nr_mode_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>();
}
void nr_mode_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::fdd:
      j.write_fieldname("fDD");
      c.get<fdd_info_s>().to_json(j);
      break;
    case types::tdd:
      j.write_fieldname("tDD");
      c.get<tdd_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_c");
  }
  j.end_obj();
}
SRSASN_CODE nr_mode_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<fdd_info_s>().pack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<tdd_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_mode_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<fdd_info_s>().unpack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<tdd_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<nr_mode_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nr_mode_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* nr_mode_info_c::types_opts::to_string() const
{
  static const char* names[] = {"fDD", "tDD", "choice-extension"};
  return convert_enum_idx(names, 3, value, "nr_mode_info_c::types");
}

// PC5QoSParameters ::= SEQUENCE
SRSASN_CODE pc5_qos_params_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(pc5_qos_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pc5_qos_characteristics.pack(bref));
  if (pc5_qos_flow_bit_rates_present) {
    HANDLE_CODE(pc5_qos_flow_bit_rates.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_qos_params_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(pc5_qos_flow_bit_rates_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(pc5_qos_characteristics.unpack(bref));
  if (pc5_qos_flow_bit_rates_present) {
    HANDLE_CODE(pc5_qos_flow_bit_rates.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_qos_params_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("pC5-QoS-Characteristics");
  pc5_qos_characteristics.to_json(j);
  if (pc5_qos_flow_bit_rates_present) {
    j.write_fieldname("pC5-QoS-Flow-Bit-Rates");
    pc5_qos_flow_bit_rates.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PEISubgroupingSupportIndication ::= ENUMERATED
const char* pei_subgrouping_support_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "pei_subgrouping_support_ind_e");
}

// PathlossReferenceSignal ::= CHOICE
void pathloss_ref_sig_c::destroy_()
{
  switch (type_) {
    case types::ssb:
      c.destroy<ssb_s>();
      break;
    case types::dl_prs:
      c.destroy<dl_prs_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void pathloss_ref_sig_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ssb:
      c.init<ssb_s>();
      break;
    case types::dl_prs:
      c.init<dl_prs_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pathloss_ref_sig_c");
  }
}
pathloss_ref_sig_c::pathloss_ref_sig_c(const pathloss_ref_sig_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ssb:
      c.init(other.c.get<ssb_s>());
      break;
    case types::dl_prs:
      c.init(other.c.get<dl_prs_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pathloss_ref_sig_c");
  }
}
pathloss_ref_sig_c& pathloss_ref_sig_c::operator=(const pathloss_ref_sig_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ssb:
      c.set(other.c.get<ssb_s>());
      break;
    case types::dl_prs:
      c.set(other.c.get<dl_prs_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pathloss_ref_sig_c");
  }

  return *this;
}
ssb_s& pathloss_ref_sig_c::set_ssb()
{
  set(types::ssb);
  return c.get<ssb_s>();
}
dl_prs_s& pathloss_ref_sig_c::set_dl_prs()
{
  set(types::dl_prs);
  return c.get<dl_prs_s>();
}
protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>& pathloss_ref_sig_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>>();
}
void pathloss_ref_sig_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ssb:
      j.write_fieldname("sSB");
      c.get<ssb_s>().to_json(j);
      break;
    case types::dl_prs:
      j.write_fieldname("dL-PRS");
      c.get<dl_prs_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pathloss_ref_sig_c");
  }
  j.end_obj();
}
SRSASN_CODE pathloss_ref_sig_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ssb:
      HANDLE_CODE(c.get<ssb_s>().pack(bref));
      break;
    case types::dl_prs:
      HANDLE_CODE(c.get<dl_prs_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pathloss_ref_sig_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pathloss_ref_sig_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ssb:
      HANDLE_CODE(c.get<ssb_s>().unpack(bref));
      break;
    case types::dl_prs:
      HANDLE_CODE(c.get<dl_prs_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pathloss_ref_sig_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pathloss_ref_sig_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pathloss_ref_sig_c::types_opts::to_string() const
{
  static const char* names[] = {"sSB", "dL-PRS", "choice-extension"};
  return convert_enum_idx(names, 3, value, "pathloss_ref_sig_c::types");
}

// PeriodicityList-Item ::= SEQUENCE
SRSASN_CODE periodicity_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(periodicity_srs.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE periodicity_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(periodicity_srs.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void periodicity_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("periodicitySRS", periodicity_srs.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PosMeasurementResultItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t pos_meas_result_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {557, 560, 562};
  return map_enum_number(names, 3, idx, "id");
}
bool pos_meas_result_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {557, 560, 562};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pos_meas_result_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 557:
      return crit_e::ignore;
    case 560:
      return crit_e::ignore;
    case 562:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pos_meas_result_item_ext_ies_o::ext_c pos_meas_result_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 557:
      ret.set(ext_c::types::arp_id);
      break;
    case 560:
      ret.set(ext_c::types::srs_restype);
      break;
    case 562:
      ret.set(ext_c::types::lo_s_n_lo_si_nformation);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pos_meas_result_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 557:
      return presence_e::optional;
    case 560:
      return presence_e::optional;
    case 562:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pos_meas_result_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::srs_restype:
      c.destroy<srs_restype_s>();
      break;
    case types::lo_s_n_lo_si_nformation:
      c.destroy<lo_s_n_lo_si_nformation_c>();
      break;
    default:
      break;
  }
}
void pos_meas_result_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::arp_id:
      break;
    case types::srs_restype:
      c.init<srs_restype_s>();
      break;
    case types::lo_s_n_lo_si_nformation:
      c.init<lo_s_n_lo_si_nformation_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pos_meas_result_item_ext_ies_o::ext_c");
  }
}
pos_meas_result_item_ext_ies_o::ext_c::ext_c(const pos_meas_result_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::arp_id:
      c.init(other.c.get<uint8_t>());
      break;
    case types::srs_restype:
      c.init(other.c.get<srs_restype_s>());
      break;
    case types::lo_s_n_lo_si_nformation:
      c.init(other.c.get<lo_s_n_lo_si_nformation_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pos_meas_result_item_ext_ies_o::ext_c");
  }
}
pos_meas_result_item_ext_ies_o::ext_c&
pos_meas_result_item_ext_ies_o::ext_c::operator=(const pos_meas_result_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::arp_id:
      c.set(other.c.get<uint8_t>());
      break;
    case types::srs_restype:
      c.set(other.c.get<srs_restype_s>());
      break;
    case types::lo_s_n_lo_si_nformation:
      c.set(other.c.get<lo_s_n_lo_si_nformation_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pos_meas_result_item_ext_ies_o::ext_c");
  }

  return *this;
}
uint8_t& pos_meas_result_item_ext_ies_o::ext_c::arp_id()
{
  assert_choice_type(types::arp_id, type_, "Extension");
  return c.get<uint8_t>();
}
srs_restype_s& pos_meas_result_item_ext_ies_o::ext_c::srs_restype()
{
  assert_choice_type(types::srs_restype, type_, "Extension");
  return c.get<srs_restype_s>();
}
lo_s_n_lo_si_nformation_c& pos_meas_result_item_ext_ies_o::ext_c::lo_s_n_lo_si_nformation()
{
  assert_choice_type(types::lo_s_n_lo_si_nformation, type_, "Extension");
  return c.get<lo_s_n_lo_si_nformation_c>();
}
const uint8_t& pos_meas_result_item_ext_ies_o::ext_c::arp_id() const
{
  assert_choice_type(types::arp_id, type_, "Extension");
  return c.get<uint8_t>();
}
const srs_restype_s& pos_meas_result_item_ext_ies_o::ext_c::srs_restype() const
{
  assert_choice_type(types::srs_restype, type_, "Extension");
  return c.get<srs_restype_s>();
}
const lo_s_n_lo_si_nformation_c& pos_meas_result_item_ext_ies_o::ext_c::lo_s_n_lo_si_nformation() const
{
  assert_choice_type(types::lo_s_n_lo_si_nformation, type_, "Extension");
  return c.get<lo_s_n_lo_si_nformation_c>();
}
void pos_meas_result_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::arp_id:
      j.write_int("INTEGER (1..16,...)", c.get<uint8_t>());
      break;
    case types::srs_restype:
      j.write_fieldname("SRSResourcetype");
      c.get<srs_restype_s>().to_json(j);
      break;
    case types::lo_s_n_lo_si_nformation:
      j.write_fieldname("LoS-NLoSInformation");
      c.get<lo_s_n_lo_si_nformation_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pos_meas_result_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pos_meas_result_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::arp_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)1u, (uint8_t)16u, true, true));
      break;
    case types::srs_restype:
      HANDLE_CODE(c.get<srs_restype_s>().pack(bref));
      break;
    case types::lo_s_n_lo_si_nformation:
      HANDLE_CODE(c.get<lo_s_n_lo_si_nformation_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pos_meas_result_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_meas_result_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::arp_id:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)1u, (uint8_t)16u, true, true));
      break;
    case types::srs_restype:
      HANDLE_CODE(c.get<srs_restype_s>().unpack(bref));
      break;
    case types::lo_s_n_lo_si_nformation:
      HANDLE_CODE(c.get<lo_s_n_lo_si_nformation_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pos_meas_result_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RequestedDLPRSResourceSet-Item ::= SEQUENCE
SRSASN_CODE requested_dl_prs_res_set_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(comb_size_present, 1));
  HANDLE_CODE(bref.pack(res_set_periodicity_present, 1));
  HANDLE_CODE(bref.pack(res_repeat_factor_present, 1));
  HANDLE_CODE(bref.pack(res_numof_symbols_present, 1));
  HANDLE_CODE(bref.pack(requested_dl_prs_res_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(res_set_start_time_and_dur_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pr_sbw, (uint8_t)1u, (uint8_t)63u, false, true));
  if (comb_size_present) {
    HANDLE_CODE(comb_size.pack(bref));
  }
  if (res_set_periodicity_present) {
    HANDLE_CODE(res_set_periodicity.pack(bref));
  }
  if (res_repeat_factor_present) {
    HANDLE_CODE(res_repeat_factor.pack(bref));
  }
  if (res_numof_symbols_present) {
    HANDLE_CODE(res_numof_symbols.pack(bref));
  }
  if (requested_dl_prs_res_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, requested_dl_prs_res_list, 1, 64, true));
  }
  if (res_set_start_time_and_dur_present) {
    HANDLE_CODE(res_set_start_time_and_dur.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE requested_dl_prs_res_set_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(comb_size_present, 1));
  HANDLE_CODE(bref.unpack(res_set_periodicity_present, 1));
  HANDLE_CODE(bref.unpack(res_repeat_factor_present, 1));
  HANDLE_CODE(bref.unpack(res_numof_symbols_present, 1));
  bool requested_dl_prs_res_list_present;
  HANDLE_CODE(bref.unpack(requested_dl_prs_res_list_present, 1));
  HANDLE_CODE(bref.unpack(res_set_start_time_and_dur_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pr_sbw, bref, (uint8_t)1u, (uint8_t)63u, false, true));
  if (comb_size_present) {
    HANDLE_CODE(comb_size.unpack(bref));
  }
  if (res_set_periodicity_present) {
    HANDLE_CODE(res_set_periodicity.unpack(bref));
  }
  if (res_repeat_factor_present) {
    HANDLE_CODE(res_repeat_factor.unpack(bref));
  }
  if (res_numof_symbols_present) {
    HANDLE_CODE(res_numof_symbols.unpack(bref));
  }
  if (requested_dl_prs_res_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(requested_dl_prs_res_list, bref, 1, 64, true));
  }
  if (res_set_start_time_and_dur_present) {
    HANDLE_CODE(res_set_start_time_and_dur.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void requested_dl_prs_res_set_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pRSbandwidth", pr_sbw);
  if (comb_size_present) {
    j.write_str("combSize", comb_size.to_string());
  }
  if (res_set_periodicity_present) {
    j.write_str("resourceSetPeriodicity", res_set_periodicity.to_string());
  }
  if (res_repeat_factor_present) {
    j.write_str("resourceRepetitionFactor", res_repeat_factor.to_string());
  }
  if (res_numof_symbols_present) {
    j.write_str("resourceNumberofSymbols", res_numof_symbols.to_string());
  }
  if (requested_dl_prs_res_list.size() > 0) {
    j.start_array("requestedDLPRSResource-List");
    for (const auto& e1 : requested_dl_prs_res_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (res_set_start_time_and_dur_present) {
    j.write_fieldname("resourceSetStartTimeAndDuration");
    res_set_start_time_and_dur.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* requested_dl_prs_res_set_item_s::comb_size_opts::to_string() const
{
  static const char* names[] = {"n2", "n4", "n6", "n12"};
  return convert_enum_idx(names, 4, value, "requested_dl_prs_res_set_item_s::comb_size_e_");
}
uint8_t requested_dl_prs_res_set_item_s::comb_size_opts::to_number() const
{
  static const uint8_t numbers[] = {2, 4, 6, 12};
  return map_enum_number(numbers, 4, value, "requested_dl_prs_res_set_item_s::comb_size_e_");
}

const char* requested_dl_prs_res_set_item_s::res_set_periodicity_opts::to_string() const
{
  static const char* names[] = {"n4",    "n5",    "n8",     "n10",    "n16",    "n20",   "n32",
                                "n40",   "n64",   "n80",    "n160",   "n320",   "n640",  "n1280",
                                "n2560", "n5120", "n10240", "n20480", "n40960", "n81920"};
  return convert_enum_idx(names, 20, value, "requested_dl_prs_res_set_item_s::res_set_periodicity_e_");
}
uint32_t requested_dl_prs_res_set_item_s::res_set_periodicity_opts::to_number() const
{
  static const uint32_t numbers[] = {4,   5,   8,   10,   16,   20,   32,    40,    64,    80,
                                     160, 320, 640, 1280, 2560, 5120, 10240, 20480, 40960, 81920};
  return map_enum_number(numbers, 20, value, "requested_dl_prs_res_set_item_s::res_set_periodicity_e_");
}

const char* requested_dl_prs_res_set_item_s::res_repeat_factor_opts::to_string() const
{
  static const char* names[] = {"rf1", "rf2", "rf4", "rf6", "rf8", "rf16", "rf32"};
  return convert_enum_idx(names, 7, value, "requested_dl_prs_res_set_item_s::res_repeat_factor_e_");
}
uint8_t requested_dl_prs_res_set_item_s::res_repeat_factor_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 4, 6, 8, 16, 32};
  return map_enum_number(numbers, 7, value, "requested_dl_prs_res_set_item_s::res_repeat_factor_e_");
}

const char* requested_dl_prs_res_set_item_s::res_numof_symbols_opts::to_string() const
{
  static const char* names[] = {"n2", "n4", "n6", "n12"};
  return convert_enum_idx(names, 4, value, "requested_dl_prs_res_set_item_s::res_numof_symbols_e_");
}
uint8_t requested_dl_prs_res_set_item_s::res_numof_symbols_opts::to_number() const
{
  static const uint8_t numbers[] = {2, 4, 6, 12};
  return map_enum_number(numbers, 4, value, "requested_dl_prs_res_set_item_s::res_numof_symbols_e_");
}

// SCS-SpecificCarrier ::= SEQUENCE
SRSASN_CODE scs_specific_carrier_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, offset_to_carrier, (uint16_t)0u, (uint16_t)2199u, true, true));
  HANDLE_CODE(subcarrier_spacing.pack(bref));
  HANDLE_CODE(pack_integer(bref, carrier_bw, (uint16_t)1u, (uint16_t)275u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE scs_specific_carrier_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(offset_to_carrier, bref, (uint16_t)0u, (uint16_t)2199u, true, true));
  HANDLE_CODE(subcarrier_spacing.unpack(bref));
  HANDLE_CODE(unpack_integer(carrier_bw, bref, (uint16_t)1u, (uint16_t)275u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void scs_specific_carrier_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("offsetToCarrier", offset_to_carrier);
  j.write_str("subcarrierSpacing", subcarrier_spacing.to_string());
  j.write_int("carrierBandwidth", carrier_bw);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* scs_specific_carrier_s::subcarrier_spacing_opts::to_string() const
{
  static const char* names[] = {"kHz15", "kHz30", "kHz60", "kHz120", "kHz480", "kHz960"};
  return convert_enum_idx(names, 6, value, "scs_specific_carrier_s::subcarrier_spacing_e_");
}
uint16_t scs_specific_carrier_s::subcarrier_spacing_opts::to_number() const
{
  static const uint16_t numbers[] = {15, 30, 60, 120, 480, 960};
  return map_enum_number(numbers, 6, value, "scs_specific_carrier_s::subcarrier_spacing_e_");
}

// Served-Cell-Information-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t served_cell_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {139, 196, 201, 223, 232, 425, 251, 252, 290, 357, 358, 429, 383, 478, 579};
  return map_enum_number(names, 15, idx, "id");
}
bool served_cell_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {139, 196, 201, 223, 232, 425, 251, 252, 290, 357, 358, 429, 383, 478, 579};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e served_cell_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 139:
      return crit_e::ignore;
    case 196:
      return crit_e::ignore;
    case 201:
      return crit_e::ignore;
    case 223:
      return crit_e::ignore;
    case 232:
      return crit_e::ignore;
    case 425:
      return crit_e::ignore;
    case 251:
      return crit_e::ignore;
    case 252:
      return crit_e::ignore;
    case 290:
      return crit_e::ignore;
    case 357:
      return crit_e::ignore;
    case 358:
      return crit_e::ignore;
    case 429:
      return crit_e::ignore;
    case 383:
      return crit_e::reject;
    case 478:
      return crit_e::ignore;
    case 579:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
served_cell_info_ext_ies_o::ext_c served_cell_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 139:
      ret.set(ext_c::types::ranac);
      break;
    case 196:
      ret.set(ext_c::types::extended_served_plmns_list);
      break;
    case 201:
      ret.set(ext_c::types::cell_direction);
      break;
    case 223:
      ret.set(ext_c::types::bplmn_id_info_list);
      break;
    case 232:
      ret.set(ext_c::types::cell_type);
      break;
    case 425:
      ret.set(ext_c::types::cfg_tac_ind);
      break;
    case 251:
      ret.set(ext_c::types::aggressor_gnb_set_id);
      break;
    case 252:
      ret.set(ext_c::types::victim_gnb_set_id);
      break;
    case 290:
      ret.set(ext_c::types::iab_info_iab_du);
      break;
    case 357:
      ret.set(ext_c::types::ssb_positions_in_burst);
      break;
    case 358:
      ret.set(ext_c::types::nr_prach_cfg);
      break;
    case 429:
      ret.set(ext_c::types::sfn_offset);
      break;
    case 383:
      ret.set(ext_c::types::npn_broadcast_info);
      break;
    case 478:
      ret.set(ext_c::types::supported_mbs_fsa_id_list);
      break;
    case 579:
      ret.set(ext_c::types::redcap_bcast_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e served_cell_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 139:
      return presence_e::optional;
    case 196:
      return presence_e::optional;
    case 201:
      return presence_e::optional;
    case 223:
      return presence_e::optional;
    case 232:
      return presence_e::optional;
    case 425:
      return presence_e::optional;
    case 251:
      return presence_e::optional;
    case 252:
      return presence_e::optional;
    case 290:
      return presence_e::optional;
    case 357:
      return presence_e::optional;
    case 358:
      return presence_e::optional;
    case 429:
      return presence_e::optional;
    case 383:
      return presence_e::optional;
    case 478:
      return presence_e::optional;
    case 579:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void served_cell_info_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::extended_served_plmns_list:
      c.destroy<extended_served_plmns_list_l>();
      break;
    case types::bplmn_id_info_list:
      c.destroy<bplmn_id_info_list_l>();
      break;
    case types::cell_type:
      c.destroy<cell_type_s>();
      break;
    case types::aggressor_gnb_set_id:
      c.destroy<aggressor_gnb_set_id_s>();
      break;
    case types::victim_gnb_set_id:
      c.destroy<victim_gnb_set_id_s>();
      break;
    case types::iab_info_iab_du:
      c.destroy<iab_info_iab_du_s>();
      break;
    case types::ssb_positions_in_burst:
      c.destroy<ssb_positions_in_burst_c>();
      break;
    case types::nr_prach_cfg:
      c.destroy<nr_prach_cfg_s>();
      break;
    case types::sfn_offset:
      c.destroy<sfn_offset_s>();
      break;
    case types::npn_broadcast_info:
      c.destroy<npn_broadcast_info_c>();
      break;
    case types::supported_mbs_fsa_id_list:
      c.destroy<supported_mbs_fsa_id_list_l>();
      break;
    case types::redcap_bcast_info:
      c.destroy<fixed_bitstring<8, false, true>>();
      break;
    default:
      break;
  }
}
void served_cell_info_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ranac:
      break;
    case types::extended_served_plmns_list:
      c.init<extended_served_plmns_list_l>();
      break;
    case types::cell_direction:
      break;
    case types::bplmn_id_info_list:
      c.init<bplmn_id_info_list_l>();
      break;
    case types::cell_type:
      c.init<cell_type_s>();
      break;
    case types::cfg_tac_ind:
      break;
    case types::aggressor_gnb_set_id:
      c.init<aggressor_gnb_set_id_s>();
      break;
    case types::victim_gnb_set_id:
      c.init<victim_gnb_set_id_s>();
      break;
    case types::iab_info_iab_du:
      c.init<iab_info_iab_du_s>();
      break;
    case types::ssb_positions_in_burst:
      c.init<ssb_positions_in_burst_c>();
      break;
    case types::nr_prach_cfg:
      c.init<nr_prach_cfg_s>();
      break;
    case types::sfn_offset:
      c.init<sfn_offset_s>();
      break;
    case types::npn_broadcast_info:
      c.init<npn_broadcast_info_c>();
      break;
    case types::supported_mbs_fsa_id_list:
      c.init<supported_mbs_fsa_id_list_l>();
      break;
    case types::redcap_bcast_info:
      c.init<fixed_bitstring<8, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_ext_ies_o::ext_c");
  }
}
served_cell_info_ext_ies_o::ext_c::ext_c(const served_cell_info_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ranac:
      c.init(other.c.get<uint16_t>());
      break;
    case types::extended_served_plmns_list:
      c.init(other.c.get<extended_served_plmns_list_l>());
      break;
    case types::cell_direction:
      c.init(other.c.get<cell_direction_e>());
      break;
    case types::bplmn_id_info_list:
      c.init(other.c.get<bplmn_id_info_list_l>());
      break;
    case types::cell_type:
      c.init(other.c.get<cell_type_s>());
      break;
    case types::cfg_tac_ind:
      c.init(other.c.get<cfg_tac_ind_e>());
      break;
    case types::aggressor_gnb_set_id:
      c.init(other.c.get<aggressor_gnb_set_id_s>());
      break;
    case types::victim_gnb_set_id:
      c.init(other.c.get<victim_gnb_set_id_s>());
      break;
    case types::iab_info_iab_du:
      c.init(other.c.get<iab_info_iab_du_s>());
      break;
    case types::ssb_positions_in_burst:
      c.init(other.c.get<ssb_positions_in_burst_c>());
      break;
    case types::nr_prach_cfg:
      c.init(other.c.get<nr_prach_cfg_s>());
      break;
    case types::sfn_offset:
      c.init(other.c.get<sfn_offset_s>());
      break;
    case types::npn_broadcast_info:
      c.init(other.c.get<npn_broadcast_info_c>());
      break;
    case types::supported_mbs_fsa_id_list:
      c.init(other.c.get<supported_mbs_fsa_id_list_l>());
      break;
    case types::redcap_bcast_info:
      c.init(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_ext_ies_o::ext_c");
  }
}
served_cell_info_ext_ies_o::ext_c&
served_cell_info_ext_ies_o::ext_c::operator=(const served_cell_info_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ranac:
      c.set(other.c.get<uint16_t>());
      break;
    case types::extended_served_plmns_list:
      c.set(other.c.get<extended_served_plmns_list_l>());
      break;
    case types::cell_direction:
      c.set(other.c.get<cell_direction_e>());
      break;
    case types::bplmn_id_info_list:
      c.set(other.c.get<bplmn_id_info_list_l>());
      break;
    case types::cell_type:
      c.set(other.c.get<cell_type_s>());
      break;
    case types::cfg_tac_ind:
      c.set(other.c.get<cfg_tac_ind_e>());
      break;
    case types::aggressor_gnb_set_id:
      c.set(other.c.get<aggressor_gnb_set_id_s>());
      break;
    case types::victim_gnb_set_id:
      c.set(other.c.get<victim_gnb_set_id_s>());
      break;
    case types::iab_info_iab_du:
      c.set(other.c.get<iab_info_iab_du_s>());
      break;
    case types::ssb_positions_in_burst:
      c.set(other.c.get<ssb_positions_in_burst_c>());
      break;
    case types::nr_prach_cfg:
      c.set(other.c.get<nr_prach_cfg_s>());
      break;
    case types::sfn_offset:
      c.set(other.c.get<sfn_offset_s>());
      break;
    case types::npn_broadcast_info:
      c.set(other.c.get<npn_broadcast_info_c>());
      break;
    case types::supported_mbs_fsa_id_list:
      c.set(other.c.get<supported_mbs_fsa_id_list_l>());
      break;
    case types::redcap_bcast_info:
      c.set(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_ext_ies_o::ext_c");
  }

  return *this;
}
uint16_t& served_cell_info_ext_ies_o::ext_c::ranac()
{
  assert_choice_type(types::ranac, type_, "Extension");
  return c.get<uint16_t>();
}
extended_served_plmns_list_l& served_cell_info_ext_ies_o::ext_c::extended_served_plmns_list()
{
  assert_choice_type(types::extended_served_plmns_list, type_, "Extension");
  return c.get<extended_served_plmns_list_l>();
}
cell_direction_e& served_cell_info_ext_ies_o::ext_c::cell_direction()
{
  assert_choice_type(types::cell_direction, type_, "Extension");
  return c.get<cell_direction_e>();
}
bplmn_id_info_list_l& served_cell_info_ext_ies_o::ext_c::bplmn_id_info_list()
{
  assert_choice_type(types::bplmn_id_info_list, type_, "Extension");
  return c.get<bplmn_id_info_list_l>();
}
cell_type_s& served_cell_info_ext_ies_o::ext_c::cell_type()
{
  assert_choice_type(types::cell_type, type_, "Extension");
  return c.get<cell_type_s>();
}
cfg_tac_ind_e& served_cell_info_ext_ies_o::ext_c::cfg_tac_ind()
{
  assert_choice_type(types::cfg_tac_ind, type_, "Extension");
  return c.get<cfg_tac_ind_e>();
}
aggressor_gnb_set_id_s& served_cell_info_ext_ies_o::ext_c::aggressor_gnb_set_id()
{
  assert_choice_type(types::aggressor_gnb_set_id, type_, "Extension");
  return c.get<aggressor_gnb_set_id_s>();
}
victim_gnb_set_id_s& served_cell_info_ext_ies_o::ext_c::victim_gnb_set_id()
{
  assert_choice_type(types::victim_gnb_set_id, type_, "Extension");
  return c.get<victim_gnb_set_id_s>();
}
iab_info_iab_du_s& served_cell_info_ext_ies_o::ext_c::iab_info_iab_du()
{
  assert_choice_type(types::iab_info_iab_du, type_, "Extension");
  return c.get<iab_info_iab_du_s>();
}
ssb_positions_in_burst_c& served_cell_info_ext_ies_o::ext_c::ssb_positions_in_burst()
{
  assert_choice_type(types::ssb_positions_in_burst, type_, "Extension");
  return c.get<ssb_positions_in_burst_c>();
}
nr_prach_cfg_s& served_cell_info_ext_ies_o::ext_c::nr_prach_cfg()
{
  assert_choice_type(types::nr_prach_cfg, type_, "Extension");
  return c.get<nr_prach_cfg_s>();
}
sfn_offset_s& served_cell_info_ext_ies_o::ext_c::sfn_offset()
{
  assert_choice_type(types::sfn_offset, type_, "Extension");
  return c.get<sfn_offset_s>();
}
npn_broadcast_info_c& served_cell_info_ext_ies_o::ext_c::npn_broadcast_info()
{
  assert_choice_type(types::npn_broadcast_info, type_, "Extension");
  return c.get<npn_broadcast_info_c>();
}
supported_mbs_fsa_id_list_l& served_cell_info_ext_ies_o::ext_c::supported_mbs_fsa_id_list()
{
  assert_choice_type(types::supported_mbs_fsa_id_list, type_, "Extension");
  return c.get<supported_mbs_fsa_id_list_l>();
}
fixed_bitstring<8, false, true>& served_cell_info_ext_ies_o::ext_c::redcap_bcast_info()
{
  assert_choice_type(types::redcap_bcast_info, type_, "Extension");
  return c.get<fixed_bitstring<8, false, true>>();
}
const uint16_t& served_cell_info_ext_ies_o::ext_c::ranac() const
{
  assert_choice_type(types::ranac, type_, "Extension");
  return c.get<uint16_t>();
}
const extended_served_plmns_list_l& served_cell_info_ext_ies_o::ext_c::extended_served_plmns_list() const
{
  assert_choice_type(types::extended_served_plmns_list, type_, "Extension");
  return c.get<extended_served_plmns_list_l>();
}
const cell_direction_e& served_cell_info_ext_ies_o::ext_c::cell_direction() const
{
  assert_choice_type(types::cell_direction, type_, "Extension");
  return c.get<cell_direction_e>();
}
const bplmn_id_info_list_l& served_cell_info_ext_ies_o::ext_c::bplmn_id_info_list() const
{
  assert_choice_type(types::bplmn_id_info_list, type_, "Extension");
  return c.get<bplmn_id_info_list_l>();
}
const cell_type_s& served_cell_info_ext_ies_o::ext_c::cell_type() const
{
  assert_choice_type(types::cell_type, type_, "Extension");
  return c.get<cell_type_s>();
}
const cfg_tac_ind_e& served_cell_info_ext_ies_o::ext_c::cfg_tac_ind() const
{
  assert_choice_type(types::cfg_tac_ind, type_, "Extension");
  return c.get<cfg_tac_ind_e>();
}
const aggressor_gnb_set_id_s& served_cell_info_ext_ies_o::ext_c::aggressor_gnb_set_id() const
{
  assert_choice_type(types::aggressor_gnb_set_id, type_, "Extension");
  return c.get<aggressor_gnb_set_id_s>();
}
const victim_gnb_set_id_s& served_cell_info_ext_ies_o::ext_c::victim_gnb_set_id() const
{
  assert_choice_type(types::victim_gnb_set_id, type_, "Extension");
  return c.get<victim_gnb_set_id_s>();
}
const iab_info_iab_du_s& served_cell_info_ext_ies_o::ext_c::iab_info_iab_du() const
{
  assert_choice_type(types::iab_info_iab_du, type_, "Extension");
  return c.get<iab_info_iab_du_s>();
}
const ssb_positions_in_burst_c& served_cell_info_ext_ies_o::ext_c::ssb_positions_in_burst() const
{
  assert_choice_type(types::ssb_positions_in_burst, type_, "Extension");
  return c.get<ssb_positions_in_burst_c>();
}
const nr_prach_cfg_s& served_cell_info_ext_ies_o::ext_c::nr_prach_cfg() const
{
  assert_choice_type(types::nr_prach_cfg, type_, "Extension");
  return c.get<nr_prach_cfg_s>();
}
const sfn_offset_s& served_cell_info_ext_ies_o::ext_c::sfn_offset() const
{
  assert_choice_type(types::sfn_offset, type_, "Extension");
  return c.get<sfn_offset_s>();
}
const npn_broadcast_info_c& served_cell_info_ext_ies_o::ext_c::npn_broadcast_info() const
{
  assert_choice_type(types::npn_broadcast_info, type_, "Extension");
  return c.get<npn_broadcast_info_c>();
}
const supported_mbs_fsa_id_list_l& served_cell_info_ext_ies_o::ext_c::supported_mbs_fsa_id_list() const
{
  assert_choice_type(types::supported_mbs_fsa_id_list, type_, "Extension");
  return c.get<supported_mbs_fsa_id_list_l>();
}
const fixed_bitstring<8, false, true>& served_cell_info_ext_ies_o::ext_c::redcap_bcast_info() const
{
  assert_choice_type(types::redcap_bcast_info, type_, "Extension");
  return c.get<fixed_bitstring<8, false, true>>();
}
void served_cell_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ranac:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::extended_served_plmns_list:
      j.start_array("ExtendedServedPLMNs-List");
      for (const auto& e1 : c.get<extended_served_plmns_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cell_direction:
      j.write_str("Cell-Direction", c.get<cell_direction_e>().to_string());
      break;
    case types::bplmn_id_info_list:
      j.start_array("BPLMN-ID-Info-List");
      for (const auto& e1 : c.get<bplmn_id_info_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cell_type:
      j.write_fieldname("CellType");
      c.get<cell_type_s>().to_json(j);
      break;
    case types::cfg_tac_ind:
      j.write_str("ConfiguredTACIndication", "true");
      break;
    case types::aggressor_gnb_set_id:
      j.write_fieldname("AggressorgNBSetID");
      c.get<aggressor_gnb_set_id_s>().to_json(j);
      break;
    case types::victim_gnb_set_id:
      j.write_fieldname("VictimgNBSetID");
      c.get<victim_gnb_set_id_s>().to_json(j);
      break;
    case types::iab_info_iab_du:
      j.write_fieldname("IAB-Info-IAB-DU");
      c.get<iab_info_iab_du_s>().to_json(j);
      break;
    case types::ssb_positions_in_burst:
      j.write_fieldname("SSB-PositionsInBurst");
      c.get<ssb_positions_in_burst_c>().to_json(j);
      break;
    case types::nr_prach_cfg:
      j.write_fieldname("NRPRACHConfig");
      c.get<nr_prach_cfg_s>().to_json(j);
      break;
    case types::sfn_offset:
      j.write_fieldname("SFN-Offset");
      c.get<sfn_offset_s>().to_json(j);
      break;
    case types::npn_broadcast_info:
      j.write_fieldname("NPNBroadcastInformation");
      c.get<npn_broadcast_info_c>().to_json(j);
      break;
    case types::supported_mbs_fsa_id_list:
      j.start_array("Supported-MBS-FSA-ID-List");
      for (const auto& e1 : c.get<supported_mbs_fsa_id_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::redcap_bcast_info:
      j.write_str("BIT STRING", c.get<fixed_bitstring<8, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE served_cell_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ranac:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::extended_served_plmns_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<extended_served_plmns_list_l>(), 1, 6, true));
      break;
    case types::cell_direction:
      HANDLE_CODE(c.get<cell_direction_e>().pack(bref));
      break;
    case types::bplmn_id_info_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<bplmn_id_info_list_l>(), 1, 12, true));
      break;
    case types::cell_type:
      HANDLE_CODE(c.get<cell_type_s>().pack(bref));
      break;
    case types::cfg_tac_ind:
      HANDLE_CODE(c.get<cfg_tac_ind_e>().pack(bref));
      break;
    case types::aggressor_gnb_set_id:
      HANDLE_CODE(c.get<aggressor_gnb_set_id_s>().pack(bref));
      break;
    case types::victim_gnb_set_id:
      HANDLE_CODE(c.get<victim_gnb_set_id_s>().pack(bref));
      break;
    case types::iab_info_iab_du:
      HANDLE_CODE(c.get<iab_info_iab_du_s>().pack(bref));
      break;
    case types::ssb_positions_in_burst:
      HANDLE_CODE(c.get<ssb_positions_in_burst_c>().pack(bref));
      break;
    case types::nr_prach_cfg:
      HANDLE_CODE(c.get<nr_prach_cfg_s>().pack(bref));
      break;
    case types::sfn_offset:
      HANDLE_CODE(c.get<sfn_offset_s>().pack(bref));
      break;
    case types::npn_broadcast_info:
      HANDLE_CODE(c.get<npn_broadcast_info_c>().pack(bref));
      break;
    case types::supported_mbs_fsa_id_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<supported_mbs_fsa_id_list_l>(), 1, 256, true));
      break;
    case types::redcap_bcast_info:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ranac:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::extended_served_plmns_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<extended_served_plmns_list_l>(), bref, 1, 6, true));
      break;
    case types::cell_direction:
      HANDLE_CODE(c.get<cell_direction_e>().unpack(bref));
      break;
    case types::bplmn_id_info_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<bplmn_id_info_list_l>(), bref, 1, 12, true));
      break;
    case types::cell_type:
      HANDLE_CODE(c.get<cell_type_s>().unpack(bref));
      break;
    case types::cfg_tac_ind:
      HANDLE_CODE(c.get<cfg_tac_ind_e>().unpack(bref));
      break;
    case types::aggressor_gnb_set_id:
      HANDLE_CODE(c.get<aggressor_gnb_set_id_s>().unpack(bref));
      break;
    case types::victim_gnb_set_id:
      HANDLE_CODE(c.get<victim_gnb_set_id_s>().unpack(bref));
      break;
    case types::iab_info_iab_du:
      HANDLE_CODE(c.get<iab_info_iab_du_s>().unpack(bref));
      break;
    case types::ssb_positions_in_burst:
      HANDLE_CODE(c.get<ssb_positions_in_burst_c>().unpack(bref));
      break;
    case types::nr_prach_cfg:
      HANDLE_CODE(c.get<nr_prach_cfg_s>().unpack(bref));
      break;
    case types::sfn_offset:
      HANDLE_CODE(c.get<sfn_offset_s>().unpack(bref));
      break;
    case types::npn_broadcast_info:
      HANDLE_CODE(c.get<npn_broadcast_info_c>().unpack(bref));
      break;
    case types::supported_mbs_fsa_id_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<supported_mbs_fsa_id_list_l>(), bref, 1, 256, true));
      break;
    case types::redcap_bcast_info:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "served_cell_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// SpatialRelationPerSRSResource ::= SEQUENCE
SRSASN_CODE spatial_relation_per_srs_res_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, spatial_relation_per_srs_res_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE spatial_relation_per_srs_res_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(spatial_relation_per_srs_res_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void spatial_relation_per_srs_res_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("spatialRelationPerSRSResource-List");
  for (const auto& e1 : spatial_relation_per_srs_res_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TimeStamp ::= SEQUENCE
SRSASN_CODE time_stamp_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(meas_time_present, 1));
  HANDLE_CODE(bref.pack(ie_ext_present, 1));

  HANDLE_CODE(pack_integer(bref, sys_frame_num, (uint16_t)0u, (uint16_t)1023u, false, true));
  HANDLE_CODE(slot_idx.pack(bref));
  if (meas_time_present) {
    HANDLE_CODE(meas_time.pack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE time_stamp_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(meas_time_present, 1));
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  HANDLE_CODE(unpack_integer(sys_frame_num, bref, (uint16_t)0u, (uint16_t)1023u, false, true));
  HANDLE_CODE(slot_idx.unpack(bref));
  if (meas_time_present) {
    HANDLE_CODE(meas_time.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(ie_ext.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void time_stamp_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("systemFrameNumber", sys_frame_num);
  j.write_fieldname("slotIndex");
  slot_idx.to_json(j);
  if (meas_time_present) {
    j.write_str("measurementTime", meas_time.to_string());
  }
  if (ie_ext_present) {
    j.write_fieldname("iE-Extension");
    ie_ext.to_json(j);
  }
  j.end_obj();
}

// UACType-Item ::= SEQUENCE
SRSASN_CODE uac_type_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, uac_reduction_ind, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(uac_category_type.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE uac_type_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(uac_reduction_ind, bref, (uint8_t)0u, (uint8_t)100u, false, true));
  HANDLE_CODE(uac_category_type.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void uac_type_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uACReductionIndication", uac_reduction_ind);
  j.write_fieldname("uACCategoryType");
  uac_category_type.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// CellULConfigured ::= ENUMERATED
const char* cell_ul_cfg_opts::to_string() const
{
  static const char* names[] = {"none", "ul", "sul", "ul-and-sul"};
  return convert_enum_idx(names, 4, value, "cell_ul_cfg_e");
}
uint8_t cell_ul_cfg_opts::to_number() const
{
  static const uint8_t numbers[] = {1};
  return map_enum_number(numbers, 1, value, "cell_ul_cfg_e");
}

// DuplicationIndication ::= ENUMERATED
const char* dupl_ind_opts::to_string() const
{
  static const char* names[] = {"true", "false"};
  return convert_enum_idx(names, 2, value, "dupl_ind_e");
}

// GNB-CU-TNL-Association-To-Remove-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t gnb_cu_tnl_assoc_to_rem_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {229};
  return map_enum_number(names, 1, idx, "id");
}
bool gnb_cu_tnl_assoc_to_rem_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 229 == id;
}
crit_e gnb_cu_tnl_assoc_to_rem_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 229) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
gnb_cu_tnl_assoc_to_rem_item_ext_ies_o::ext_c gnb_cu_tnl_assoc_to_rem_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 229) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e gnb_cu_tnl_assoc_to_rem_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 229) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void gnb_cu_tnl_assoc_to_rem_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("CP-TransportLayerAddress");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE gnb_cu_tnl_assoc_to_rem_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_cu_tnl_assoc_to_rem_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

SRSASN_CODE gnb_du_sys_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += sib12_msg_present ? 1 : 0;
  nof_ies += sib13_msg_present ? 1 : 0;
  nof_ies += sib14_msg_present ? 1 : 0;
  nof_ies += sib10_msg_present ? 1 : 0;
  nof_ies += sib17_msg_present ? 1 : 0;
  nof_ies += sib20_msg_present ? 1 : 0;
  nof_ies += sib15_msg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (sib12_msg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)310, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sib12_msg.pack(bref));
  }
  if (sib13_msg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)311, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sib13_msg.pack(bref));
  }
  if (sib14_msg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)312, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sib14_msg.pack(bref));
  }
  if (sib10_msg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)387, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sib10_msg.pack(bref));
  }
  if (sib17_msg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)625, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sib17_msg.pack(bref));
  }
  if (sib20_msg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)627, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sib20_msg.pack(bref));
  }
  if (sib15_msg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)648, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sib15_msg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_du_sys_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 310: {
        sib12_msg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sib12_msg.unpack(bref));
        break;
      }
      case 311: {
        sib13_msg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sib13_msg.unpack(bref));
        break;
      }
      case 312: {
        sib14_msg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sib14_msg.unpack(bref));
        break;
      }
      case 387: {
        sib10_msg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sib10_msg.unpack(bref));
        break;
      }
      case 625: {
        sib17_msg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sib17_msg.unpack(bref));
        break;
      }
      case 627: {
        sib20_msg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sib20_msg.unpack(bref));
        break;
      }
      case 648: {
        sib15_msg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sib15_msg.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void gnb_du_sys_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (sib12_msg_present) {
    j.write_int("id", 310);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sib12_msg.to_string());
  }
  if (sib13_msg_present) {
    j.write_int("id", 311);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sib13_msg.to_string());
  }
  if (sib14_msg_present) {
    j.write_int("id", 312);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sib14_msg.to_string());
  }
  if (sib10_msg_present) {
    j.write_int("id", 387);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sib10_msg.to_string());
  }
  if (sib17_msg_present) {
    j.write_int("id", 625);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sib17_msg.to_string());
  }
  if (sib20_msg_present) {
    j.write_int("id", 627);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sib20_msg.to_string());
  }
  if (sib15_msg_present) {
    j.write_int("id", 648);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sib15_msg.to_string());
  }
  j.end_obj();
}

// GNB-DU-System-Information ::= SEQUENCE
SRSASN_CODE gnb_du_sys_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mib_msg.pack(bref));
  HANDLE_CODE(sib1_msg.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_du_sys_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mib_msg.unpack(bref));
  HANDLE_CODE(sib1_msg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gnb_du_sys_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mIB-message", mib_msg.to_string());
  j.write_str("sIB1-message", sib1_msg.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-MT-Cell-NA-Resource-Configuration-FDD-Info ::= SEQUENCE
SRSASN_CODE iab_mt_cell_na_res_cfg_fdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ul_freq_info_present, 1));
  HANDLE_CODE(bref.pack(ul_tx_bw_present, 1));
  HANDLE_CODE(bref.pack(ul_nr_carrier_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(dl_freq_info_present, 1));
  HANDLE_CODE(bref.pack(dl_tx_bw_present, 1));
  HANDLE_CODE(bref.pack(dl_nr_carrier_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(gnb_du_cell_na_res_cfg_fdd_ul.pack(bref));
  HANDLE_CODE(gnb_du_cell_na_res_cfg_fdd_dl.pack(bref));
  if (ul_freq_info_present) {
    HANDLE_CODE(ul_freq_info.pack(bref));
  }
  if (ul_tx_bw_present) {
    HANDLE_CODE(ul_tx_bw.pack(bref));
  }
  if (ul_nr_carrier_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ul_nr_carrier_list, 1, 5, true));
  }
  if (dl_freq_info_present) {
    HANDLE_CODE(dl_freq_info.pack(bref));
  }
  if (dl_tx_bw_present) {
    HANDLE_CODE(dl_tx_bw.pack(bref));
  }
  if (dl_nr_carrier_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, dl_nr_carrier_list, 1, 5, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_mt_cell_na_res_cfg_fdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ul_freq_info_present, 1));
  HANDLE_CODE(bref.unpack(ul_tx_bw_present, 1));
  bool ul_nr_carrier_list_present;
  HANDLE_CODE(bref.unpack(ul_nr_carrier_list_present, 1));
  HANDLE_CODE(bref.unpack(dl_freq_info_present, 1));
  HANDLE_CODE(bref.unpack(dl_tx_bw_present, 1));
  bool dl_nr_carrier_list_present;
  HANDLE_CODE(bref.unpack(dl_nr_carrier_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(gnb_du_cell_na_res_cfg_fdd_ul.unpack(bref));
  HANDLE_CODE(gnb_du_cell_na_res_cfg_fdd_dl.unpack(bref));
  if (ul_freq_info_present) {
    HANDLE_CODE(ul_freq_info.unpack(bref));
  }
  if (ul_tx_bw_present) {
    HANDLE_CODE(ul_tx_bw.unpack(bref));
  }
  if (ul_nr_carrier_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ul_nr_carrier_list, bref, 1, 5, true));
  }
  if (dl_freq_info_present) {
    HANDLE_CODE(dl_freq_info.unpack(bref));
  }
  if (dl_tx_bw_present) {
    HANDLE_CODE(dl_tx_bw.unpack(bref));
  }
  if (dl_nr_carrier_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(dl_nr_carrier_list, bref, 1, 5, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_mt_cell_na_res_cfg_fdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("gNB-DU-Cell-NA-Resource-Configuration-FDD-UL");
  gnb_du_cell_na_res_cfg_fdd_ul.to_json(j);
  j.write_fieldname("gNB-DU-Cell-NA-Resource-Configuration-FDD-DL");
  gnb_du_cell_na_res_cfg_fdd_dl.to_json(j);
  if (ul_freq_info_present) {
    j.write_fieldname("uL-FreqInfo");
    ul_freq_info.to_json(j);
  }
  if (ul_tx_bw_present) {
    j.write_fieldname("uL-Transmission-Bandwidth");
    ul_tx_bw.to_json(j);
  }
  if (ul_nr_carrier_list.size() > 0) {
    j.start_array("uL-NR-Carrier-List");
    for (const auto& e1 : ul_nr_carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (dl_freq_info_present) {
    j.write_fieldname("dL-FreqInfo");
    dl_freq_info.to_json(j);
  }
  if (dl_tx_bw_present) {
    j.write_fieldname("dL-Transmission-Bandwidth");
    dl_tx_bw.to_json(j);
  }
  if (dl_nr_carrier_list.size() > 0) {
    j.start_array("dL-NR-Carrier-List");
    for (const auto& e1 : dl_nr_carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-MT-Cell-NA-Resource-Configuration-TDD-Info ::= SEQUENCE
SRSASN_CODE iab_mt_cell_na_res_cfg_tdd_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nr_freq_info_present, 1));
  HANDLE_CODE(bref.pack(tx_bw_present, 1));
  HANDLE_CODE(bref.pack(nr_carrier_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(gnb_du_cell_na_resourc_cfg_tdd.pack(bref));
  if (nr_freq_info_present) {
    HANDLE_CODE(nr_freq_info.pack(bref));
  }
  if (tx_bw_present) {
    HANDLE_CODE(tx_bw.pack(bref));
  }
  if (nr_carrier_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, nr_carrier_list, 1, 5, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_mt_cell_na_res_cfg_tdd_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nr_freq_info_present, 1));
  HANDLE_CODE(bref.unpack(tx_bw_present, 1));
  bool nr_carrier_list_present;
  HANDLE_CODE(bref.unpack(nr_carrier_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(gnb_du_cell_na_resourc_cfg_tdd.unpack(bref));
  if (nr_freq_info_present) {
    HANDLE_CODE(nr_freq_info.unpack(bref));
  }
  if (tx_bw_present) {
    HANDLE_CODE(tx_bw.unpack(bref));
  }
  if (nr_carrier_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(nr_carrier_list, bref, 1, 5, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_mt_cell_na_res_cfg_tdd_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("gNB-DU-Cell-NA-Resourc-Configuration-TDD");
  gnb_du_cell_na_resourc_cfg_tdd.to_json(j);
  if (nr_freq_info_present) {
    j.write_fieldname("nRFreqInfo");
    nr_freq_info.to_json(j);
  }
  if (tx_bw_present) {
    j.write_fieldname("transmission-Bandwidth");
    tx_bw.to_json(j);
  }
  if (nr_carrier_list.size() > 0) {
    j.start_array("nR-Carrier-List");
    for (const auto& e1 : nr_carrier_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IABTNLAddressUsage ::= ENUMERATED
const char* iab_tnl_address_usage_opts::to_string() const
{
  static const char* names[] = {"f1-c", "f1-u", "non-f1"};
  return convert_enum_idx(names, 3, value, "iab_tnl_address_usage_e");
}

// IgnorePRACHConfiguration ::= ENUMERATED
const char* ignore_prach_cfg_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "ignore_prach_cfg_e");
}

// M2Configuration ::= ENUMERATED
const char* m2_cfg_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "m2_cfg_e");
}

// M5Configuration ::= SEQUENCE
SRSASN_CODE m5_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(m5period.pack(bref));
  HANDLE_CODE(m5_links_to_log.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m5_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m5period.unpack(bref));
  HANDLE_CODE(m5_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m5_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m5period", m5period.to_string());
  j.write_str("m5-links-to-log", m5_links_to_log.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// M6Configuration ::= SEQUENCE
SRSASN_CODE m6_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(m6report_interv.pack(bref));
  HANDLE_CODE(m6_links_to_log.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m6_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m6report_interv.unpack(bref));
  HANDLE_CODE(m6_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m6_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("m6report-Interval", m6report_interv.to_string());
  j.write_str("m6-links-to-log", m6_links_to_log.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// M7Configuration ::= SEQUENCE
SRSASN_CODE m7_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, m7period, (uint8_t)1u, (uint8_t)60u, true, true));
  HANDLE_CODE(m7_links_to_log.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE m7_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(m7period, bref, (uint8_t)1u, (uint8_t)60u, true, true));
  HANDLE_CODE(m7_links_to_log.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void m7_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("m7period", m7period);
  j.write_str("m7-links-to-log", "downlink");
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// MBSPTPRetransmissionTunnelRequired ::= ENUMERATED
const char* mbsptp_retx_tunnel_required_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "mbsptp_retx_tunnel_required_e");
}

// MDT-Activation ::= ENUMERATED
const char* mdt_activation_opts::to_string() const
{
  static const char* names[] = {"immediate-MDT-only", "immediate-MDT-and-Trace"};
  return convert_enum_idx(names, 2, value, "mdt_activation_e");
}

// MRB-ProgressInformation ::= CHOICE
void mrb_progress_info_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void mrb_progress_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pdcp_sn12:
      break;
    case types::pdcp_sn18:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }
}
mrb_progress_info_c::mrb_progress_info_c(const mrb_progress_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pdcp_sn12:
      c.init(other.c.get<uint16_t>());
      break;
    case types::pdcp_sn18:
      c.init(other.c.get<uint32_t>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }
}
mrb_progress_info_c& mrb_progress_info_c::operator=(const mrb_progress_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pdcp_sn12:
      c.set(other.c.get<uint16_t>());
      break;
    case types::pdcp_sn18:
      c.set(other.c.get<uint32_t>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }

  return *this;
}
uint16_t& mrb_progress_info_c::set_pdcp_sn12()
{
  set(types::pdcp_sn12);
  return c.get<uint16_t>();
}
uint32_t& mrb_progress_info_c::set_pdcp_sn18()
{
  set(types::pdcp_sn18);
  return c.get<uint32_t>();
}
protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>& mrb_progress_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>();
}
void mrb_progress_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pdcp_sn12:
      j.write_int("pdcp-SN12", c.get<uint16_t>());
      break;
    case types::pdcp_sn18:
      j.write_int("pdcp-SN18", c.get<uint32_t>());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
  }
  j.end_obj();
}
SRSASN_CODE mrb_progress_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::pdcp_sn12:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)4095u, false, true));
      break;
    case types::pdcp_sn18:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)262143u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE mrb_progress_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::pdcp_sn12:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)4095u, false, true));
      break;
    case types::pdcp_sn18:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)262143u, false, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<mrb_progress_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "mrb_progress_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* mrb_progress_info_c::types_opts::to_string() const
{
  static const char* names[] = {"pdcp-SN12", "pdcp-SN18", "choice-extension"};
  return convert_enum_idx(names, 3, value, "mrb_progress_info_c::types");
}
uint8_t mrb_progress_info_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {12, 18};
  return map_enum_number(numbers, 2, value, "mrb_progress_info_c::types");
}

// NonUPTrafficType ::= ENUMERATED
const char* non_up_traffic_type_opts::to_string() const
{
  static const char* names[] = {"ue-associated", "non-ue-associated", "non-f1", "bap-control-pdu"};
  return convert_enum_idx(names, 4, value, "non_up_traffic_type_e");
}
uint8_t non_up_traffic_type_opts::to_number() const
{
  if (value == non_f1) {
    return 1;
  }
  invalid_enum_number(value, "non_up_traffic_type_e");
  return 0;
}

// NumberOfTRPRxTEG ::= ENUMERATED
const char* nof_trp_rx_teg_opts::to_string() const
{
  static const char* names[] = {"two", "three", "four", "six", "eight"};
  return convert_enum_idx(names, 5, value, "nof_trp_rx_teg_e");
}
uint8_t nof_trp_rx_teg_opts::to_number() const
{
  static const uint8_t numbers[] = {2, 3, 4, 6, 8};
  return map_enum_number(numbers, 5, value, "nof_trp_rx_teg_e");
}

// NumberOfTRPRxTxTEG ::= ENUMERATED
const char* nof_trp_rx_tx_teg_opts::to_string() const
{
  static const char* names[] = {"wo", "three", "four", "six", "eight"};
  return convert_enum_idx(names, 5, value, "nof_trp_rx_tx_teg_e");
}
uint8_t nof_trp_rx_tx_teg_opts::to_number() const
{
  switch (value) {
    case three:
      return 3;
    case four:
      return 4;
    case six:
      return 6;
    case eight:
      return 8;
    default:
      invalid_enum_number(value, "nof_trp_rx_tx_teg_e");
  }
  return 0;
}

// PDCMeasuredResults-Value ::= CHOICE
void pdc_measured_results_value_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void pdc_measured_results_value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pdc_tadv_nr:
      break;
    case types::pdc_rx_tx_time_diff:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdc_measured_results_value_c");
  }
}
pdc_measured_results_value_c::pdc_measured_results_value_c(const pdc_measured_results_value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pdc_tadv_nr:
      c.init(other.c.get<uint16_t>());
      break;
    case types::pdc_rx_tx_time_diff:
      c.init(other.c.get<uint16_t>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdc_measured_results_value_c");
  }
}
pdc_measured_results_value_c& pdc_measured_results_value_c::operator=(const pdc_measured_results_value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pdc_tadv_nr:
      c.set(other.c.get<uint16_t>());
      break;
    case types::pdc_rx_tx_time_diff:
      c.set(other.c.get<uint16_t>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdc_measured_results_value_c");
  }

  return *this;
}
uint16_t& pdc_measured_results_value_c::set_pdc_tadv_nr()
{
  set(types::pdc_tadv_nr);
  return c.get<uint16_t>();
}
uint16_t& pdc_measured_results_value_c::set_pdc_rx_tx_time_diff()
{
  set(types::pdc_rx_tx_time_diff);
  return c.get<uint16_t>();
}
protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>& pdc_measured_results_value_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>>();
}
void pdc_measured_results_value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pdc_tadv_nr:
      j.write_int("pDC-TADV-NR", c.get<uint16_t>());
      break;
    case types::pdc_rx_tx_time_diff:
      j.write_int("pDC-RxTxTimeDiff", c.get<uint16_t>());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdc_measured_results_value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdc_measured_results_value_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::pdc_tadv_nr:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)62500u, true, true));
      break;
    case types::pdc_rx_tx_time_diff:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)61565u, true, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdc_measured_results_value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdc_measured_results_value_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::pdc_tadv_nr:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)62500u, true, true));
      break;
    case types::pdc_rx_tx_time_diff:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)61565u, true, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pdc_measured_results_value_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdc_measured_results_value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pdc_measured_results_value_c::types_opts::to_string() const
{
  static const char* names[] = {"pDC-TADV-NR", "pDC-RxTxTimeDiff", "choice-extension"};
  return convert_enum_idx(names, 3, value, "pdc_measured_results_value_c::types");
}

// PDCMeasurementQuantitiesValue ::= ENUMERATED
const char* pdc_meas_quantities_value_opts::to_string() const
{
  static const char* names[] = {"nr-pdc-tadv", "gNB-rx-tx"};
  return convert_enum_idx(names, 2, value, "pdc_meas_quantities_value_e");
}

// PRSTransmissionOffIndication ::= CHOICE
void prs_tx_off_ind_c::destroy_()
{
  switch (type_) {
    case types::prs_tx_off_per_res_set:
      c.destroy<prs_tx_off_per_res_set_l>();
      break;
    case types::prs_tx_off_per_res:
      c.destroy<prs_tx_off_per_res_l>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void prs_tx_off_ind_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::prs_tx_off_per_trp:
      break;
    case types::prs_tx_off_per_res_set:
      c.init<prs_tx_off_per_res_set_l>();
      break;
    case types::prs_tx_off_per_res:
      c.init<prs_tx_off_per_res_l>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "prs_tx_off_ind_c");
  }
}
prs_tx_off_ind_c::prs_tx_off_ind_c(const prs_tx_off_ind_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::prs_tx_off_per_trp:
      break;
    case types::prs_tx_off_per_res_set:
      c.init(other.c.get<prs_tx_off_per_res_set_l>());
      break;
    case types::prs_tx_off_per_res:
      c.init(other.c.get<prs_tx_off_per_res_l>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "prs_tx_off_ind_c");
  }
}
prs_tx_off_ind_c& prs_tx_off_ind_c::operator=(const prs_tx_off_ind_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::prs_tx_off_per_trp:
      break;
    case types::prs_tx_off_per_res_set:
      c.set(other.c.get<prs_tx_off_per_res_set_l>());
      break;
    case types::prs_tx_off_per_res:
      c.set(other.c.get<prs_tx_off_per_res_l>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "prs_tx_off_ind_c");
  }

  return *this;
}
void prs_tx_off_ind_c::set_prs_tx_off_per_trp()
{
  set(types::prs_tx_off_per_trp);
}
prs_tx_off_per_res_set_l& prs_tx_off_ind_c::set_prs_tx_off_per_res_set()
{
  set(types::prs_tx_off_per_res_set);
  return c.get<prs_tx_off_per_res_set_l>();
}
prs_tx_off_per_res_l& prs_tx_off_ind_c::set_prs_tx_off_per_res()
{
  set(types::prs_tx_off_per_res);
  return c.get<prs_tx_off_per_res_l>();
}
protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>& prs_tx_off_ind_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>>();
}
void prs_tx_off_ind_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::prs_tx_off_per_trp:
      break;
    case types::prs_tx_off_per_res_set:
      j.start_array("pRSTransmissionOffPerResourceSet");
      for (const auto& e1 : c.get<prs_tx_off_per_res_set_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::prs_tx_off_per_res:
      j.start_array("pRSTransmissionOffPerResource");
      for (const auto& e1 : c.get<prs_tx_off_per_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "prs_tx_off_ind_c");
  }
  j.end_obj();
}
SRSASN_CODE prs_tx_off_ind_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::prs_tx_off_per_trp:
      break;
    case types::prs_tx_off_per_res_set:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<prs_tx_off_per_res_set_l>(), 1, 8, true));
      break;
    case types::prs_tx_off_per_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<prs_tx_off_per_res_l>(), 1, 8, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "prs_tx_off_ind_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_tx_off_ind_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::prs_tx_off_per_trp:
      break;
    case types::prs_tx_off_per_res_set:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<prs_tx_off_per_res_set_l>(), bref, 1, 8, true));
      break;
    case types::prs_tx_off_per_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<prs_tx_off_per_res_l>(), bref, 1, 8, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<prs_tx_off_ind_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "prs_tx_off_ind_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* prs_tx_off_ind_c::types_opts::to_string() const
{
  static const char* names[] = {"pRSTransmissionOffPerTRP",
                                "pRSTransmissionOffPerResourceSet",
                                "pRSTransmissionOffPerResource",
                                "choice-extension"};
  return convert_enum_idx(names, 4, value, "prs_tx_off_ind_c::types");
}

// PagingCell-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t paging_cell_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {624, 664};
  return map_enum_number(names, 2, idx, "id");
}
bool paging_cell_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {624, 664};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e paging_cell_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 624:
      return crit_e::ignore;
    case 664:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
paging_cell_item_ext_ies_o::ext_c paging_cell_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 624:
      ret.set(ext_c::types::last_used_cell_ind);
      break;
    case 664:
      ret.set(ext_c::types::pei_subgrouping_support_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e paging_cell_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 624:
      return presence_e::optional;
    case 664:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void paging_cell_item_ext_ies_o::ext_c::destroy_() {}
void paging_cell_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
paging_cell_item_ext_ies_o::ext_c::ext_c(const paging_cell_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::last_used_cell_ind:
      c.init(other.c.get<last_used_cell_ind_e>());
      break;
    case types::pei_subgrouping_support_ind:
      c.init(other.c.get<pei_subgrouping_support_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_cell_item_ext_ies_o::ext_c");
  }
}
paging_cell_item_ext_ies_o::ext_c&
paging_cell_item_ext_ies_o::ext_c::operator=(const paging_cell_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::last_used_cell_ind:
      c.set(other.c.get<last_used_cell_ind_e>());
      break;
    case types::pei_subgrouping_support_ind:
      c.set(other.c.get<pei_subgrouping_support_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_cell_item_ext_ies_o::ext_c");
  }

  return *this;
}
last_used_cell_ind_e& paging_cell_item_ext_ies_o::ext_c::last_used_cell_ind()
{
  assert_choice_type(types::last_used_cell_ind, type_, "Extension");
  return c.get<last_used_cell_ind_e>();
}
pei_subgrouping_support_ind_e& paging_cell_item_ext_ies_o::ext_c::pei_subgrouping_support_ind()
{
  assert_choice_type(types::pei_subgrouping_support_ind, type_, "Extension");
  return c.get<pei_subgrouping_support_ind_e>();
}
const last_used_cell_ind_e& paging_cell_item_ext_ies_o::ext_c::last_used_cell_ind() const
{
  assert_choice_type(types::last_used_cell_ind, type_, "Extension");
  return c.get<last_used_cell_ind_e>();
}
const pei_subgrouping_support_ind_e& paging_cell_item_ext_ies_o::ext_c::pei_subgrouping_support_ind() const
{
  assert_choice_type(types::pei_subgrouping_support_ind, type_, "Extension");
  return c.get<pei_subgrouping_support_ind_e>();
}
void paging_cell_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::last_used_cell_ind:
      j.write_str("LastUsedCellIndication", "true");
      break;
    case types::pei_subgrouping_support_ind:
      j.write_str("PEISubgroupingSupportIndication", "true");
      break;
    default:
      log_invalid_choice_id(type_, "paging_cell_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE paging_cell_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::last_used_cell_ind:
      HANDLE_CODE(c.get<last_used_cell_ind_e>().pack(bref));
      break;
    case types::pei_subgrouping_support_ind:
      HANDLE_CODE(c.get<pei_subgrouping_support_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_cell_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_cell_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::last_used_cell_ind:
      HANDLE_CODE(c.get<last_used_cell_ind_e>().unpack(bref));
      break;
    case types::pei_subgrouping_support_ind:
      HANDLE_CODE(c.get<pei_subgrouping_support_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_cell_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PagingDRX ::= ENUMERATED
const char* paging_drx_opts::to_string() const
{
  static const char* names[] = {"v32", "v64", "v128", "v256"};
  return convert_enum_idx(names, 4, value, "paging_drx_e");
}
uint16_t paging_drx_opts::to_number() const
{
  static const uint16_t numbers[] = {32, 64, 128, 256};
  return map_enum_number(numbers, 4, value, "paging_drx_e");
}

// PathlossReferenceInfo ::= SEQUENCE
SRSASN_CODE pathloss_ref_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pathloss_ref_sig.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pathloss_ref_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(pathloss_ref_sig.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pathloss_ref_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("pathlossReferenceSignal");
  pathloss_ref_sig.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE pos_meas_result_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += arp_id_present ? 1 : 0;
  nof_ies += srs_restype_present ? 1 : 0;
  nof_ies += lo_s_n_lo_si_nformation_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (arp_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)557, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, arp_id, (uint8_t)1u, (uint8_t)16u, true, true));
  }
  if (srs_restype_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)560, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(srs_restype.pack(bref));
  }
  if (lo_s_n_lo_si_nformation_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)562, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(lo_s_n_lo_si_nformation.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_meas_result_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 557: {
        arp_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(arp_id, bref, (uint8_t)1u, (uint8_t)16u, true, true));
        break;
      }
      case 560: {
        srs_restype_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srs_restype.unpack(bref));
        break;
      }
      case 562: {
        lo_s_n_lo_si_nformation_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lo_s_n_lo_si_nformation.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pos_meas_result_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (arp_id_present) {
    j.write_int("id", 557);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", arp_id);
  }
  if (srs_restype_present) {
    j.write_int("id", 560);
    j.write_str("criticality", "ignore");
    srs_restype.to_json(j);
  }
  if (lo_s_n_lo_si_nformation_present) {
    j.write_int("id", 562);
    j.write_str("criticality", "ignore");
    lo_s_n_lo_si_nformation.to_json(j);
  }
  j.end_obj();
}

// PosMeasurementResultItem ::= SEQUENCE
SRSASN_CODE pos_meas_result_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(meas_quality_present, 1));
  HANDLE_CODE(bref.pack(meas_beam_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(measured_results_value.pack(bref));
  HANDLE_CODE(time_stamp.pack(bref));
  if (meas_quality_present) {
    HANDLE_CODE(meas_quality.pack(bref));
  }
  if (meas_beam_info_present) {
    HANDLE_CODE(meas_beam_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_meas_result_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(meas_quality_present, 1));
  HANDLE_CODE(bref.unpack(meas_beam_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(measured_results_value.unpack(bref));
  HANDLE_CODE(time_stamp.unpack(bref));
  if (meas_quality_present) {
    HANDLE_CODE(meas_quality.unpack(bref));
  }
  if (meas_beam_info_present) {
    HANDLE_CODE(meas_beam_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pos_meas_result_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("measuredResultsValue");
  measured_results_value.to_json(j);
  j.write_fieldname("timeStamp");
  time_stamp.to_json(j);
  if (meas_quality_present) {
    j.write_fieldname("measurementQuality");
    meas_quality.to_json(j);
  }
  if (meas_beam_info_present) {
    j.write_fieldname("measurementBeamInfo");
    meas_beam_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QoEMetrics ::= SEQUENCE
SRSASN_CODE qo_e_metrics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(app_layer_buffer_level_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(playout_delay_for_media_startup.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (app_layer_buffer_level_list.size() > 0) {
    HANDLE_CODE(app_layer_buffer_level_list.pack(bref));
  }
  if (playout_delay_for_media_startup.size() > 0) {
    HANDLE_CODE(playout_delay_for_media_startup.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qo_e_metrics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool app_layer_buffer_level_list_present;
  HANDLE_CODE(bref.unpack(app_layer_buffer_level_list_present, 1));
  bool playout_delay_for_media_startup_present;
  HANDLE_CODE(bref.unpack(playout_delay_for_media_startup_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (app_layer_buffer_level_list_present) {
    HANDLE_CODE(app_layer_buffer_level_list.unpack(bref));
  }
  if (playout_delay_for_media_startup_present) {
    HANDLE_CODE(playout_delay_for_media_startup.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qo_e_metrics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (app_layer_buffer_level_list.size() > 0) {
    j.write_str("appLayerBufferLevelList", app_layer_buffer_level_list.to_string());
  }
  if (playout_delay_for_media_startup.size() > 0) {
    j.write_str("playoutDelayForMediaStartup", playout_delay_for_media_startup.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SCell-ToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t scell_to_be_setup_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {182};
  return map_enum_number(names, 1, idx, "id");
}
bool scell_to_be_setup_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 182 == id;
}
crit_e scell_to_be_setup_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 182) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
scell_to_be_setup_item_ext_ies_o::ext_c scell_to_be_setup_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 182) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e scell_to_be_setup_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 182) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void scell_to_be_setup_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..64,...)", c);
  j.end_obj();
}
SRSASN_CODE scell_to_be_setup_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)1u, (uint8_t)64u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE scell_to_be_setup_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  return SRSASN_SUCCESS;
}

// SCell-ToBeSetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t scell_to_be_setup_mod_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {182};
  return map_enum_number(names, 1, idx, "id");
}
bool scell_to_be_setup_mod_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 182 == id;
}
crit_e scell_to_be_setup_mod_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 182) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
scell_to_be_setup_mod_item_ext_ies_o::ext_c scell_to_be_setup_mod_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 182) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e scell_to_be_setup_mod_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 182) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void scell_to_be_setup_mod_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..64,...)", c);
  j.end_obj();
}
SRSASN_CODE scell_to_be_setup_mod_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint8_t)1u, (uint8_t)64u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE scell_to_be_setup_mod_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  return SRSASN_SUCCESS;
}

// SDTBearerType ::= CHOICE
void sdt_bearer_type_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void sdt_bearer_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::srb:
      break;
    case types::drb:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sdt_bearer_type_c");
  }
}
sdt_bearer_type_c::sdt_bearer_type_c(const sdt_bearer_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::srb:
      c.init(other.c.get<uint8_t>());
      break;
    case types::drb:
      c.init(other.c.get<uint8_t>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sdt_bearer_type_c");
  }
}
sdt_bearer_type_c& sdt_bearer_type_c::operator=(const sdt_bearer_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::srb:
      c.set(other.c.get<uint8_t>());
      break;
    case types::drb:
      c.set(other.c.get<uint8_t>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sdt_bearer_type_c");
  }

  return *this;
}
uint8_t& sdt_bearer_type_c::set_srb()
{
  set(types::srb);
  return c.get<uint8_t>();
}
uint8_t& sdt_bearer_type_c::set_drb()
{
  set(types::drb);
  return c.get<uint8_t>();
}
protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>& sdt_bearer_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>>();
}
void sdt_bearer_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::srb:
      j.write_int("sRB", c.get<uint8_t>());
      break;
    case types::drb:
      j.write_int("dRB", c.get<uint8_t>());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "sdt_bearer_type_c");
  }
  j.end_obj();
}
SRSASN_CODE sdt_bearer_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::srb:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)0u, (uint8_t)3u, true, true));
      break;
    case types::drb:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)1u, (uint8_t)32u, true, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sdt_bearer_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE sdt_bearer_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::srb:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)0u, (uint8_t)3u, true, true));
      break;
    case types::drb:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)1u, (uint8_t)32u, true, true));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<sdt_bearer_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sdt_bearer_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* sdt_bearer_type_c::types_opts::to_string() const
{
  static const char* names[] = {"sRB", "dRB", "choice-extension"};
  return convert_enum_idx(names, 3, value, "sdt_bearer_type_c::types");
}

// SLDRBInformation ::= SEQUENCE
SRSASN_CODE sl_drb_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(sl_drb_qos.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, flows_mapped_to_sl_drb_list, 1, 2048, true));

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drb_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(sl_drb_qos.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(flows_mapped_to_sl_drb_list, bref, 1, 2048, true));

  return SRSASN_SUCCESS;
}
void sl_drb_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sLDRB-QoS");
  sl_drb_qos.to_json(j);
  j.start_array("flowsMappedToSLDRB-List");
  for (const auto& e1 : flows_mapped_to_sl_drb_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}

// SLDRXConfigurationIndicator ::= ENUMERATED
const char* sldrx_cfg_ind_opts::to_string() const
{
  static const char* names[] = {"release"};
  return convert_enum_idx(names, 1, value, "sldrx_cfg_ind_e");
}

// SLDRXCycleLength ::= ENUMERATED
const char* sldrx_cycle_len_opts::to_string() const
{
  static const char* names[] = {"ms10",   "ms20",   "ms32",   "ms40",   "ms60",   "ms64",   "ms70",
                                "ms80",   "ms128",  "ms160",  "ms256",  "ms320",  "ms512",  "ms640",
                                "ms1024", "ms1280", "ms2048", "ms2560", "ms5120", "ms10240"};
  return convert_enum_idx(names, 20, value, "sldrx_cycle_len_e");
}
uint16_t sldrx_cycle_len_opts::to_number() const
{
  static const uint16_t numbers[] = {10,  20,  32,  40,  60,   64,   70,   80,   128,  160,
                                     256, 320, 512, 640, 1024, 1280, 2048, 2560, 5120, 10240};
  return map_enum_number(numbers, 20, value, "sldrx_cycle_len_e");
}

// SRBs-ToBeSetup-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t srbs_to_be_setup_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {372, 593, 597};
  return map_enum_number(names, 3, idx, "id");
}
bool srbs_to_be_setup_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {372, 593, 597};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e srbs_to_be_setup_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 372:
      return crit_e::ignore;
    case 593:
      return crit_e::ignore;
    case 597:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
srbs_to_be_setup_item_ext_ies_o::ext_c srbs_to_be_setup_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 372:
      ret.set(ext_c::types::add_dupl_ind);
      break;
    case 593:
      ret.set(ext_c::types::sdt_rlc_bearer_cfg);
      break;
    case 597:
      ret.set(ext_c::types::srb_map_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e srbs_to_be_setup_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 372:
      return presence_e::optional;
    case 593:
      return presence_e::optional;
    case 597:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void srbs_to_be_setup_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::sdt_rlc_bearer_cfg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::srb_map_info:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    default:
      break;
  }
}
void srbs_to_be_setup_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::add_dupl_ind:
      break;
    case types::sdt_rlc_bearer_cfg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::srb_map_info:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "srbs_to_be_setup_item_ext_ies_o::ext_c");
  }
}
srbs_to_be_setup_item_ext_ies_o::ext_c::ext_c(const srbs_to_be_setup_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::add_dupl_ind:
      c.init(other.c.get<add_dupl_ind_e>());
      break;
    case types::sdt_rlc_bearer_cfg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::srb_map_info:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "srbs_to_be_setup_item_ext_ies_o::ext_c");
  }
}
srbs_to_be_setup_item_ext_ies_o::ext_c&
srbs_to_be_setup_item_ext_ies_o::ext_c::operator=(const srbs_to_be_setup_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::add_dupl_ind:
      c.set(other.c.get<add_dupl_ind_e>());
      break;
    case types::sdt_rlc_bearer_cfg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::srb_map_info:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "srbs_to_be_setup_item_ext_ies_o::ext_c");
  }

  return *this;
}
add_dupl_ind_e& srbs_to_be_setup_item_ext_ies_o::ext_c::add_dupl_ind()
{
  assert_choice_type(types::add_dupl_ind, type_, "Extension");
  return c.get<add_dupl_ind_e>();
}
unbounded_octstring<true>& srbs_to_be_setup_item_ext_ies_o::ext_c::sdt_rlc_bearer_cfg()
{
  assert_choice_type(types::sdt_rlc_bearer_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
fixed_bitstring<16, false, true>& srbs_to_be_setup_item_ext_ies_o::ext_c::srb_map_info()
{
  assert_choice_type(types::srb_map_info, type_, "Extension");
  return c.get<fixed_bitstring<16, false, true>>();
}
const add_dupl_ind_e& srbs_to_be_setup_item_ext_ies_o::ext_c::add_dupl_ind() const
{
  assert_choice_type(types::add_dupl_ind, type_, "Extension");
  return c.get<add_dupl_ind_e>();
}
const unbounded_octstring<true>& srbs_to_be_setup_item_ext_ies_o::ext_c::sdt_rlc_bearer_cfg() const
{
  assert_choice_type(types::sdt_rlc_bearer_cfg, type_, "Extension");
  return c.get<unbounded_octstring<true>>();
}
const fixed_bitstring<16, false, true>& srbs_to_be_setup_item_ext_ies_o::ext_c::srb_map_info() const
{
  assert_choice_type(types::srb_map_info, type_, "Extension");
  return c.get<fixed_bitstring<16, false, true>>();
}
void srbs_to_be_setup_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_dupl_ind:
      j.write_str("AdditionalDuplicationIndication", c.get<add_dupl_ind_e>().to_string());
      break;
    case types::sdt_rlc_bearer_cfg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::srb_map_info:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "srbs_to_be_setup_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE srbs_to_be_setup_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dupl_ind:
      HANDLE_CODE(c.get<add_dupl_ind_e>().pack(bref));
      break;
    case types::sdt_rlc_bearer_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::srb_map_info:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "srbs_to_be_setup_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE srbs_to_be_setup_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dupl_ind:
      HANDLE_CODE(c.get<add_dupl_ind_e>().unpack(bref));
      break;
    case types::sdt_rlc_bearer_cfg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::srb_map_info:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "srbs_to_be_setup_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// SRBs-ToBeSetupMod-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t srbs_to_be_setup_mod_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {372, 597, 589};
  return map_enum_number(names, 3, idx, "id");
}
bool srbs_to_be_setup_mod_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {372, 597, 589};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e srbs_to_be_setup_mod_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 372:
      return crit_e::ignore;
    case 597:
      return crit_e::ignore;
    case 589:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
srbs_to_be_setup_mod_item_ext_ies_o::ext_c srbs_to_be_setup_mod_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 372:
      ret.set(ext_c::types::add_dupl_ind);
      break;
    case 597:
      ret.set(ext_c::types::srb_map_info);
      break;
    case 589:
      ret.set(ext_c::types::cg_sd_tind_setup);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e srbs_to_be_setup_mod_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 372:
      return presence_e::optional;
    case 597:
      return presence_e::optional;
    case 589:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void srbs_to_be_setup_mod_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::srb_map_info:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    default:
      break;
  }
}
void srbs_to_be_setup_mod_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::add_dupl_ind:
      break;
    case types::srb_map_info:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::cg_sd_tind_setup:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "srbs_to_be_setup_mod_item_ext_ies_o::ext_c");
  }
}
srbs_to_be_setup_mod_item_ext_ies_o::ext_c::ext_c(const srbs_to_be_setup_mod_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::add_dupl_ind:
      c.init(other.c.get<add_dupl_ind_e>());
      break;
    case types::srb_map_info:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::cg_sd_tind_setup:
      c.init(other.c.get<cg_sd_tind_setup_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "srbs_to_be_setup_mod_item_ext_ies_o::ext_c");
  }
}
srbs_to_be_setup_mod_item_ext_ies_o::ext_c&
srbs_to_be_setup_mod_item_ext_ies_o::ext_c::operator=(const srbs_to_be_setup_mod_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::add_dupl_ind:
      c.set(other.c.get<add_dupl_ind_e>());
      break;
    case types::srb_map_info:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::cg_sd_tind_setup:
      c.set(other.c.get<cg_sd_tind_setup_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "srbs_to_be_setup_mod_item_ext_ies_o::ext_c");
  }

  return *this;
}
add_dupl_ind_e& srbs_to_be_setup_mod_item_ext_ies_o::ext_c::add_dupl_ind()
{
  assert_choice_type(types::add_dupl_ind, type_, "Extension");
  return c.get<add_dupl_ind_e>();
}
fixed_bitstring<16, false, true>& srbs_to_be_setup_mod_item_ext_ies_o::ext_c::srb_map_info()
{
  assert_choice_type(types::srb_map_info, type_, "Extension");
  return c.get<fixed_bitstring<16, false, true>>();
}
cg_sd_tind_setup_e& srbs_to_be_setup_mod_item_ext_ies_o::ext_c::cg_sd_tind_setup()
{
  assert_choice_type(types::cg_sd_tind_setup, type_, "Extension");
  return c.get<cg_sd_tind_setup_e>();
}
const add_dupl_ind_e& srbs_to_be_setup_mod_item_ext_ies_o::ext_c::add_dupl_ind() const
{
  assert_choice_type(types::add_dupl_ind, type_, "Extension");
  return c.get<add_dupl_ind_e>();
}
const fixed_bitstring<16, false, true>& srbs_to_be_setup_mod_item_ext_ies_o::ext_c::srb_map_info() const
{
  assert_choice_type(types::srb_map_info, type_, "Extension");
  return c.get<fixed_bitstring<16, false, true>>();
}
const cg_sd_tind_setup_e& srbs_to_be_setup_mod_item_ext_ies_o::ext_c::cg_sd_tind_setup() const
{
  assert_choice_type(types::cg_sd_tind_setup, type_, "Extension");
  return c.get<cg_sd_tind_setup_e>();
}
void srbs_to_be_setup_mod_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::add_dupl_ind:
      j.write_str("AdditionalDuplicationIndication", c.get<add_dupl_ind_e>().to_string());
      break;
    case types::srb_map_info:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::cg_sd_tind_setup:
      j.write_str("CG-SDTindicatorSetup", "true");
      break;
    default:
      log_invalid_choice_id(type_, "srbs_to_be_setup_mod_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE srbs_to_be_setup_mod_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dupl_ind:
      HANDLE_CODE(c.get<add_dupl_ind_e>().pack(bref));
      break;
    case types::srb_map_info:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::cg_sd_tind_setup:
      HANDLE_CODE(c.get<cg_sd_tind_setup_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "srbs_to_be_setup_mod_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE srbs_to_be_setup_mod_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::add_dupl_ind:
      HANDLE_CODE(c.get<add_dupl_ind_e>().unpack(bref));
      break;
    case types::srb_map_info:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::cg_sd_tind_setup:
      HANDLE_CODE(c.get<cg_sd_tind_setup_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "srbs_to_be_setup_mod_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// SRSResourceSetItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t srs_res_set_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {435};
  return map_enum_number(names, 1, idx, "id");
}
bool srs_res_set_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 435 == id;
}
crit_e srs_res_set_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 435) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
srs_res_set_item_ext_ies_o::ext_c srs_res_set_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 435) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e srs_res_set_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 435) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void srs_res_set_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("SpatialRelationPerSRSResource");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE srs_res_set_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE srs_res_set_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

SRSASN_CODE served_cell_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ranac_present ? 1 : 0;
  nof_ies += extended_served_plmns_list_present ? 1 : 0;
  nof_ies += cell_direction_present ? 1 : 0;
  nof_ies += bplmn_id_info_list_present ? 1 : 0;
  nof_ies += cell_type_present ? 1 : 0;
  nof_ies += cfg_tac_ind_present ? 1 : 0;
  nof_ies += aggressor_gnb_set_id_present ? 1 : 0;
  nof_ies += victim_gnb_set_id_present ? 1 : 0;
  nof_ies += iab_info_iab_du_present ? 1 : 0;
  nof_ies += ssb_positions_in_burst_present ? 1 : 0;
  nof_ies += nr_prach_cfg_present ? 1 : 0;
  nof_ies += sfn_offset_present ? 1 : 0;
  nof_ies += npn_broadcast_info_present ? 1 : 0;
  nof_ies += supported_mbs_fsa_id_list_present ? 1 : 0;
  nof_ies += redcap_bcast_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (ranac_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)139, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ranac, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (extended_served_plmns_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)196, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, extended_served_plmns_list, 1, 6, true));
  }
  if (cell_direction_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)201, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cell_direction.pack(bref));
  }
  if (bplmn_id_info_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)223, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, bplmn_id_info_list, 1, 12, true));
  }
  if (cell_type_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)232, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cell_type.pack(bref));
  }
  if (cfg_tac_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)425, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cfg_tac_ind.pack(bref));
  }
  if (aggressor_gnb_set_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)251, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(aggressor_gnb_set_id.pack(bref));
  }
  if (victim_gnb_set_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)252, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(victim_gnb_set_id.pack(bref));
  }
  if (iab_info_iab_du_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)290, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(iab_info_iab_du.pack(bref));
  }
  if (ssb_positions_in_burst_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)357, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ssb_positions_in_burst.pack(bref));
  }
  if (nr_prach_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)358, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_prach_cfg.pack(bref));
  }
  if (sfn_offset_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)429, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sfn_offset.pack(bref));
  }
  if (npn_broadcast_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)383, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_broadcast_info.pack(bref));
  }
  if (supported_mbs_fsa_id_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)478, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, supported_mbs_fsa_id_list, 1, 256, true));
  }
  if (redcap_bcast_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)579, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redcap_bcast_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 139: {
        ranac_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ranac, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 196: {
        extended_served_plmns_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(extended_served_plmns_list, bref, 1, 6, true));
        break;
      }
      case 201: {
        cell_direction_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cell_direction.unpack(bref));
        break;
      }
      case 223: {
        bplmn_id_info_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(bplmn_id_info_list, bref, 1, 12, true));
        break;
      }
      case 232: {
        cell_type_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cell_type.unpack(bref));
        break;
      }
      case 425: {
        cfg_tac_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cfg_tac_ind.unpack(bref));
        break;
      }
      case 251: {
        aggressor_gnb_set_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(aggressor_gnb_set_id.unpack(bref));
        break;
      }
      case 252: {
        victim_gnb_set_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(victim_gnb_set_id.unpack(bref));
        break;
      }
      case 290: {
        iab_info_iab_du_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_info_iab_du.unpack(bref));
        break;
      }
      case 357: {
        ssb_positions_in_burst_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ssb_positions_in_burst.unpack(bref));
        break;
      }
      case 358: {
        nr_prach_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_prach_cfg.unpack(bref));
        break;
      }
      case 429: {
        sfn_offset_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sfn_offset.unpack(bref));
        break;
      }
      case 383: {
        npn_broadcast_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_broadcast_info.unpack(bref));
        break;
      }
      case 478: {
        supported_mbs_fsa_id_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(supported_mbs_fsa_id_list, bref, 1, 256, true));
        break;
      }
      case 579: {
        redcap_bcast_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redcap_bcast_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void served_cell_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ranac_present) {
    j.write_int("id", 139);
    j.write_str("criticality", "ignore");
    j.write_int("Extension", ranac);
  }
  if (extended_served_plmns_list_present) {
    j.write_int("id", 196);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : extended_served_plmns_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (cell_direction_present) {
    j.write_int("id", 201);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", cell_direction.to_string());
  }
  if (bplmn_id_info_list_present) {
    j.write_int("id", 223);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : bplmn_id_info_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (cell_type_present) {
    j.write_int("id", 232);
    j.write_str("criticality", "ignore");
    cell_type.to_json(j);
  }
  if (cfg_tac_ind_present) {
    j.write_int("id", 425);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (aggressor_gnb_set_id_present) {
    j.write_int("id", 251);
    j.write_str("criticality", "ignore");
    aggressor_gnb_set_id.to_json(j);
  }
  if (victim_gnb_set_id_present) {
    j.write_int("id", 252);
    j.write_str("criticality", "ignore");
    victim_gnb_set_id.to_json(j);
  }
  if (iab_info_iab_du_present) {
    j.write_int("id", 290);
    j.write_str("criticality", "ignore");
    iab_info_iab_du.to_json(j);
  }
  if (ssb_positions_in_burst_present) {
    j.write_int("id", 357);
    j.write_str("criticality", "ignore");
    ssb_positions_in_burst.to_json(j);
  }
  if (nr_prach_cfg_present) {
    j.write_int("id", 358);
    j.write_str("criticality", "ignore");
    nr_prach_cfg.to_json(j);
  }
  if (sfn_offset_present) {
    j.write_int("id", 429);
    j.write_str("criticality", "ignore");
    sfn_offset.to_json(j);
  }
  if (npn_broadcast_info_present) {
    j.write_int("id", 383);
    j.write_str("criticality", "reject");
    npn_broadcast_info.to_json(j);
  }
  if (supported_mbs_fsa_id_list_present) {
    j.write_int("id", 478);
    j.write_str("criticality", "ignore");
    j.start_array("Extension");
    for (const auto& e1 : supported_mbs_fsa_id_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (redcap_bcast_info_present) {
    j.write_int("id", 579);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", redcap_bcast_info.to_string());
  }
  j.end_obj();
}

// Served-Cell-Information ::= SEQUENCE
SRSASN_CODE served_cell_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_gs_tac_present, 1));
  HANDLE_CODE(bref.pack(cfg_eps_tac_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nr_pci, (uint16_t)0u, (uint16_t)1007u, false, true));
  if (five_gs_tac_present) {
    HANDLE_CODE(five_gs_tac.pack(bref));
  }
  if (cfg_eps_tac_present) {
    HANDLE_CODE(cfg_eps_tac.pack(bref));
  }
  HANDLE_CODE(pack_dyn_seq_of(bref, served_plmns, 1, 6, true));
  HANDLE_CODE(nr_mode_info.pack(bref));
  HANDLE_CODE(meas_timing_cfg.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cell_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_gs_tac_present, 1));
  HANDLE_CODE(bref.unpack(cfg_eps_tac_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nr_pci, bref, (uint16_t)0u, (uint16_t)1007u, false, true));
  if (five_gs_tac_present) {
    HANDLE_CODE(five_gs_tac.unpack(bref));
  }
  if (cfg_eps_tac_present) {
    HANDLE_CODE(cfg_eps_tac.unpack(bref));
  }
  HANDLE_CODE(unpack_dyn_seq_of(served_plmns, bref, 1, 6, true));
  HANDLE_CODE(nr_mode_info.unpack(bref));
  HANDLE_CODE(meas_timing_cfg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_cell_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  j.write_int("nRPCI", nr_pci);
  if (five_gs_tac_present) {
    j.write_str("fiveGS-TAC", five_gs_tac.to_string());
  }
  if (cfg_eps_tac_present) {
    j.write_str("configured-EPS-TAC", cfg_eps_tac.to_string());
  }
  j.start_array("servedPLMNs");
  for (const auto& e1 : served_plmns) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_fieldname("nR-Mode-Info");
  nr_mode_info.to_json(j);
  j.write_str("measurementTimingConfiguration", meas_timing_cfg.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SpatialRelationInfo ::= SEQUENCE
SRSASN_CODE spatial_relation_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, spatial_relationfor_res_id, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE spatial_relation_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(spatial_relationfor_res_id, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void spatial_relation_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("spatialRelationforResourceID");
  for (const auto& e1 : spatial_relationfor_res_id) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TNLAssociationUsage ::= ENUMERATED
const char* tnl_assoc_usage_opts::to_string() const
{
  static const char* names[] = {"ue", "non-ue", "both"};
  return convert_enum_idx(names, 3, value, "tnl_assoc_usage_e");
}

// TRPInformation ::= SEQUENCE
SRSASN_CODE trp_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, trp_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, trp_info_type_resp_list, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(trp_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(unpack_dyn_seq_of(trp_info_type_resp_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("tRPID", trp_id);
  j.start_array("tRPInformationTypeResponseList");
  for (const auto& e1 : trp_info_type_resp_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UACPLMN-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t uac_plmn_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {385};
  return map_enum_number(names, 1, idx, "id");
}
bool uac_plmn_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 385 == id;
}
crit_e uac_plmn_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 385) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
uac_plmn_item_ext_ies_o::ext_c uac_plmn_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 385) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e uac_plmn_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 385) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void uac_plmn_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("BIT STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE uac_plmn_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE uac_plmn_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// UE-MulticastMRBs-RequiredToBeModified-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t ue_multicast_m_rbs_required_to_be_modified_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {681};
  return map_enum_number(names, 1, idx, "id");
}
bool ue_multicast_m_rbs_required_to_be_modified_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 681 == id;
}
crit_e ue_multicast_m_rbs_required_to_be_modified_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 681) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ue_multicast_m_rbs_required_to_be_modified_item_ext_ies_o::ext_c
ue_multicast_m_rbs_required_to_be_modified_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 681) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_multicast_m_rbs_required_to_be_modified_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 681) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void ue_multicast_m_rbs_required_to_be_modified_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("OCTET STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE ue_multicast_m_rbs_required_to_be_modified_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_multicast_m_rbs_required_to_be_modified_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// UE-MulticastMRBs-ToBeSetup-Item-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t ue_multicast_m_rbs_to_be_setup_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {671};
  return map_enum_number(names, 1, idx, "id");
}
bool ue_multicast_m_rbs_to_be_setup_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 671 == id;
}
crit_e ue_multicast_m_rbs_to_be_setup_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 671) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ue_multicast_m_rbs_to_be_setup_item_ext_ies_o::ext_c
ue_multicast_m_rbs_to_be_setup_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 671) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_multicast_m_rbs_to_be_setup_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 671) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void ue_multicast_m_rbs_to_be_setup_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (1..512,...)", c);
  j.end_obj();
}
SRSASN_CODE ue_multicast_m_rbs_to_be_setup_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint16_t)1u, (uint16_t)512u, true, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_multicast_m_rbs_to_be_setup_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  return SRSASN_SUCCESS;
}

// UE-associatedLogicalF1-ConnectionItem ::= SEQUENCE
SRSASN_CODE ue_associated_lc_f1_conn_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(gnb_cu_ue_f1ap_id_present, 1));
  HANDLE_CODE(bref.pack(gnb_du_ue_f1ap_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (gnb_cu_ue_f1ap_id_present) {
    HANDLE_CODE(pack_integer(bref, gnb_cu_ue_f1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (gnb_du_ue_f1ap_id_present) {
    HANDLE_CODE(pack_integer(bref, gnb_du_ue_f1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_associated_lc_f1_conn_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(gnb_cu_ue_f1ap_id_present, 1));
  HANDLE_CODE(bref.unpack(gnb_du_ue_f1ap_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (gnb_cu_ue_f1ap_id_present) {
    HANDLE_CODE(unpack_integer(gnb_cu_ue_f1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (gnb_du_ue_f1ap_id_present) {
    HANDLE_CODE(unpack_integer(gnb_du_ue_f1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_associated_lc_f1_conn_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (gnb_cu_ue_f1ap_id_present) {
    j.write_int("gNB-CU-UE-F1AP-ID", gnb_cu_ue_f1ap_id);
  }
  if (gnb_du_ue_f1ap_id_present) {
    j.write_int("gNB-DU-UE-F1AP-ID", gnb_du_ue_f1ap_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEIdentityIndexValue ::= CHOICE
void ue_id_idx_value_c::destroy_()
{
  switch (type_) {
    case types::idx_len10:
      c.destroy<fixed_bitstring<10, false, true>>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void ue_id_idx_value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::idx_len10:
      c.init<fixed_bitstring<10, false, true>>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }
}
ue_id_idx_value_c::ue_id_idx_value_c(const ue_id_idx_value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::idx_len10:
      c.init(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }
}
ue_id_idx_value_c& ue_id_idx_value_c::operator=(const ue_id_idx_value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::idx_len10:
      c.set(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }

  return *this;
}
fixed_bitstring<10, false, true>& ue_id_idx_value_c::set_idx_len10()
{
  set(types::idx_len10);
  return c.get<fixed_bitstring<10, false, true>>();
}
protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>& ue_id_idx_value_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>>();
}
void ue_id_idx_value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::idx_len10:
      j.write_str("indexLength10", c.get<fixed_bitstring<10, false, true>>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_id_idx_value_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::idx_len10:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().pack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_id_idx_value_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::idx_len10:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().unpack(bref)));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<ue_id_idx_value_choice_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_id_idx_value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* ue_id_idx_value_c::types_opts::to_string() const
{
  static const char* names[] = {"indexLength10", "choice-extension"};
  return convert_enum_idx(names, 2, value, "ue_id_idx_value_c::types");
}
uint8_t ue_id_idx_value_c::types_opts::to_number() const
{
  static const uint8_t numbers[] = {10};
  return map_enum_number(numbers, 1, value, "ue_id_idx_value_c::types");
}

// GNB-CU-TNL-Association-Failed-To-Setup-Item ::= SEQUENCE
SRSASN_CODE gnb_cu_tnl_assoc_failed_to_setup_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.pack(bref));
  HANDLE_CODE(cause.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_cu_tnl_assoc_failed_to_setup_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.unpack(bref));
  HANDLE_CODE(cause.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gnb_cu_tnl_assoc_failed_to_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationTransportLayerAddress");
  tnl_assoc_transport_layer_address.to_json(j);
  j.write_fieldname("cause");
  cause.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GNB-CU-TNL-Association-Setup-Item ::= SEQUENCE
SRSASN_CODE gnb_cu_tnl_assoc_setup_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_cu_tnl_assoc_setup_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gnb_cu_tnl_assoc_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationTransportLayerAddress");
  tnl_assoc_transport_layer_address.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GNB-CU-TNL-Association-To-Add-Item ::= SEQUENCE
SRSASN_CODE gnb_cu_tnl_assoc_to_add_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.pack(bref));
  HANDLE_CODE(tnl_assoc_usage.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_cu_tnl_assoc_to_add_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.unpack(bref));
  HANDLE_CODE(tnl_assoc_usage.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gnb_cu_tnl_assoc_to_add_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationTransportLayerAddress");
  tnl_assoc_transport_layer_address.to_json(j);
  j.write_str("tNLAssociationUsage", tnl_assoc_usage.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GNB-CU-TNL-Association-To-Remove-Item ::= SEQUENCE
SRSASN_CODE gnb_cu_tnl_assoc_to_rem_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_cu_tnl_assoc_to_rem_item_s::unpack(cbit_ref& bref)
{
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void gnb_cu_tnl_assoc_to_rem_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationTransportLayerAddress");
  tnl_assoc_transport_layer_address.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// GNB-CU-TNL-Association-To-Update-Item ::= SEQUENCE
SRSASN_CODE gnb_cu_tnl_assoc_to_upd_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(tnl_assoc_usage_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.pack(bref));
  if (tnl_assoc_usage_present) {
    HANDLE_CODE(tnl_assoc_usage.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_cu_tnl_assoc_to_upd_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(tnl_assoc_usage_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.unpack(bref));
  if (tnl_assoc_usage_present) {
    HANDLE_CODE(tnl_assoc_usage.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gnb_cu_tnl_assoc_to_upd_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationTransportLayerAddress");
  tnl_assoc_transport_layer_address.to_json(j);
  if (tnl_assoc_usage_present) {
    j.write_str("tNLAssociationUsage", tnl_assoc_usage.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GNB-DU-Served-Cells-Item ::= SEQUENCE
SRSASN_CODE gnb_du_served_cells_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(gnb_du_sys_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(served_cell_info.pack(bref));
  if (gnb_du_sys_info_present) {
    HANDLE_CODE(gnb_du_sys_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_du_served_cells_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(gnb_du_sys_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(served_cell_info.unpack(bref));
  if (gnb_du_sys_info_present) {
    HANDLE_CODE(gnb_du_sys_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gnb_du_served_cells_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("served-Cell-Information");
  served_cell_info.to_json(j);
  if (gnb_du_sys_info_present) {
    j.write_fieldname("gNB-DU-System-Information");
    gnb_du_sys_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// GNB-DU-TNL-Association-To-Remove-Item ::= SEQUENCE
SRSASN_CODE gnb_du_tnl_assoc_to_rem_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(tnl_assoc_transport_layer_address_gnb_cu_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.pack(bref));
  if (tnl_assoc_transport_layer_address_gnb_cu_present) {
    HANDLE_CODE(tnl_assoc_transport_layer_address_gnb_cu.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_du_tnl_assoc_to_rem_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(tnl_assoc_transport_layer_address_gnb_cu_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(tnl_assoc_transport_layer_address.unpack(bref));
  if (tnl_assoc_transport_layer_address_gnb_cu_present) {
    HANDLE_CODE(tnl_assoc_transport_layer_address_gnb_cu.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gnb_du_tnl_assoc_to_rem_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tNLAssociationTransportLayerAddress");
  tnl_assoc_transport_layer_address.to_json(j);
  if (tnl_assoc_transport_layer_address_gnb_cu_present) {
    j.write_fieldname("tNLAssociationTransportLayerAddressgNBCU");
    tnl_assoc_transport_layer_address_gnb_cu.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-Allocated-TNL-Address-Item ::= SEQUENCE
SRSASN_CODE iab_allocated_tnl_address_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(iab_tnl_address_usage_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(iab_tnl_address.pack(bref));
  if (iab_tnl_address_usage_present) {
    HANDLE_CODE(iab_tnl_address_usage.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_allocated_tnl_address_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(iab_tnl_address_usage_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(iab_tnl_address.unpack(bref));
  if (iab_tnl_address_usage_present) {
    HANDLE_CODE(iab_tnl_address_usage.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_allocated_tnl_address_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("iABTNLAddress");
  iab_tnl_address.to_json(j);
  if (iab_tnl_address_usage_present) {
    j.write_str("iABTNLAddressUsage", iab_tnl_address_usage.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-Congestion-Indication-Item ::= SEQUENCE
SRSASN_CODE iab_congestion_ind_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(bh_rlc_ch_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(child_node_id.pack(bref));
  if (bh_rlc_ch_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, bh_rlc_ch_list, 1, 65536, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_congestion_ind_item_s::unpack(cbit_ref& bref)
{
  bool bh_rlc_ch_list_present;
  HANDLE_CODE(bref.unpack(bh_rlc_ch_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(child_node_id.unpack(bref));
  if (bh_rlc_ch_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(bh_rlc_ch_list, bref, 1, 65536, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_congestion_ind_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("childNodeIdentifier", child_node_id.to_string());
  if (bh_rlc_ch_list.size() > 0) {
    j.start_array("bHRLCCHList");
    for (const auto& e1 : bh_rlc_ch_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-MT-Cell-NA-Resource-Configuration-Mode-Info ::= CHOICE
void iab_mt_cell_na_res_cfg_mode_info_c::destroy_()
{
  switch (type_) {
    case types::fdd:
      c.destroy<iab_mt_cell_na_res_cfg_fdd_info_s>();
      break;
    case types::tdd:
      c.destroy<iab_mt_cell_na_res_cfg_tdd_info_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void iab_mt_cell_na_res_cfg_mode_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::fdd:
      c.init<iab_mt_cell_na_res_cfg_fdd_info_s>();
      break;
    case types::tdd:
      c.init<iab_mt_cell_na_res_cfg_tdd_info_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_mt_cell_na_res_cfg_mode_info_c");
  }
}
iab_mt_cell_na_res_cfg_mode_info_c::iab_mt_cell_na_res_cfg_mode_info_c(const iab_mt_cell_na_res_cfg_mode_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::fdd:
      c.init(other.c.get<iab_mt_cell_na_res_cfg_fdd_info_s>());
      break;
    case types::tdd:
      c.init(other.c.get<iab_mt_cell_na_res_cfg_tdd_info_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_mt_cell_na_res_cfg_mode_info_c");
  }
}
iab_mt_cell_na_res_cfg_mode_info_c&
iab_mt_cell_na_res_cfg_mode_info_c::operator=(const iab_mt_cell_na_res_cfg_mode_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::fdd:
      c.set(other.c.get<iab_mt_cell_na_res_cfg_fdd_info_s>());
      break;
    case types::tdd:
      c.set(other.c.get<iab_mt_cell_na_res_cfg_tdd_info_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_mt_cell_na_res_cfg_mode_info_c");
  }

  return *this;
}
iab_mt_cell_na_res_cfg_fdd_info_s& iab_mt_cell_na_res_cfg_mode_info_c::set_fdd()
{
  set(types::fdd);
  return c.get<iab_mt_cell_na_res_cfg_fdd_info_s>();
}
iab_mt_cell_na_res_cfg_tdd_info_s& iab_mt_cell_na_res_cfg_mode_info_c::set_tdd()
{
  set(types::tdd);
  return c.get<iab_mt_cell_na_res_cfg_tdd_info_s>();
}
protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>&
iab_mt_cell_na_res_cfg_mode_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>>();
}
void iab_mt_cell_na_res_cfg_mode_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::fdd:
      j.write_fieldname("fDD");
      c.get<iab_mt_cell_na_res_cfg_fdd_info_s>().to_json(j);
      break;
    case types::tdd:
      j.write_fieldname("tDD");
      c.get<iab_mt_cell_na_res_cfg_tdd_info_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "iab_mt_cell_na_res_cfg_mode_info_c");
  }
  j.end_obj();
}
SRSASN_CODE iab_mt_cell_na_res_cfg_mode_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<iab_mt_cell_na_res_cfg_fdd_info_s>().pack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<iab_mt_cell_na_res_cfg_tdd_info_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_mt_cell_na_res_cfg_mode_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_mt_cell_na_res_cfg_mode_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::fdd:
      HANDLE_CODE(c.get<iab_mt_cell_na_res_cfg_fdd_info_s>().unpack(bref));
      break;
    case types::tdd:
      HANDLE_CODE(c.get<iab_mt_cell_na_res_cfg_tdd_info_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_mt_cell_na_res_cfg_mode_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_mt_cell_na_res_cfg_mode_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* iab_mt_cell_na_res_cfg_mode_info_c::types_opts::to_string() const
{
  static const char* names[] = {"fDD", "tDD", "choice-extension"};
  return convert_enum_idx(names, 3, value, "iab_mt_cell_na_res_cfg_mode_info_c::types");
}

// IAB-TNL-Addresses-To-Remove-Item ::= SEQUENCE
SRSASN_CODE iab_tnl_addresses_to_rem_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(iab_tnl_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_tnl_addresses_to_rem_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(iab_tnl_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_tnl_addresses_to_rem_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("iABTNLAddress");
  iab_tnl_address.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IABTNLAddress-Item ::= SEQUENCE
SRSASN_CODE iab_tnl_address_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(iab_tnl_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_tnl_address_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(iab_tnl_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_tnl_address_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("iABTNLAddress");
  iab_tnl_address.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MC-PagingCell-Item ::= SEQUENCE
SRSASN_CODE mc_paging_cell_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mc_paging_cell_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mc_paging_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MDTConfiguration ::= SEQUENCE
SRSASN_CODE mdt_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(m2_cfg_present, 1));
  HANDLE_CODE(bref.pack(m5_cfg_present, 1));
  HANDLE_CODE(bref.pack(m6_cfg_present, 1));
  HANDLE_CODE(bref.pack(m7_cfg_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.pack(bref));
  HANDLE_CODE(meass_to_activ.pack(bref));
  if (m2_cfg_present) {
    HANDLE_CODE(m2_cfg.pack(bref));
  }
  if (m5_cfg_present) {
    HANDLE_CODE(m5_cfg.pack(bref));
  }
  if (m6_cfg_present) {
    HANDLE_CODE(m6_cfg.pack(bref));
  }
  if (m7_cfg_present) {
    HANDLE_CODE(m7_cfg.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mdt_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(m2_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m5_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m6_cfg_present, 1));
  HANDLE_CODE(bref.unpack(m7_cfg_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mdt_activation.unpack(bref));
  HANDLE_CODE(meass_to_activ.unpack(bref));
  if (m2_cfg_present) {
    HANDLE_CODE(m2_cfg.unpack(bref));
  }
  if (m5_cfg_present) {
    HANDLE_CODE(m5_cfg.unpack(bref));
  }
  if (m6_cfg_present) {
    HANDLE_CODE(m6_cfg.unpack(bref));
  }
  if (m7_cfg_present) {
    HANDLE_CODE(m7_cfg.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mdt_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("mdt-Activation", mdt_activation.to_string());
  j.write_str("measurementsToActivate", meass_to_activ.to_string());
  if (m2_cfg_present) {
    j.write_str("m2Configuration", "true");
  }
  if (m5_cfg_present) {
    j.write_fieldname("m5Configuration");
    m5_cfg.to_json(j);
  }
  if (m6_cfg_present) {
    j.write_fieldname("m6Configuration");
    m6_cfg.to_json(j);
  }
  if (m7_cfg_present) {
    j.write_fieldname("m7Configuration");
    m7_cfg.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastF1UContext-FailedToBeSetup-Item ::= SEQUENCE
SRSASN_CODE multicast_f1_u_context_failed_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_f1_u_context_failed_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_f1_u_context_failed_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastF1UContext-Setup-Item ::= SEQUENCE
SRSASN_CODE multicast_f1_u_context_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mbs_f1u_info_at_cu.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_f1_u_context_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mbs_f1u_info_at_cu.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_f1_u_context_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.write_fieldname("mbs-f1u-info-at-CU");
  mbs_f1u_info_at_cu.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastF1UContext-ToBeSetup-Item ::= SEQUENCE
SRSASN_CODE multicast_f1_u_context_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_progress_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mbs_f1u_info_at_du.pack(bref));
  if (mbs_progress_info_present) {
    HANDLE_CODE(mbs_progress_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_f1_u_context_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_progress_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mbs_f1u_info_at_du.unpack(bref));
  if (mbs_progress_info_present) {
    HANDLE_CODE(mbs_progress_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_f1_u_context_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.write_fieldname("mbs-f1u-info-at-DU");
  mbs_f1u_info_at_du.to_json(j);
  if (mbs_progress_info_present) {
    j.write_fieldname("mbsProgressInformation");
    mbs_progress_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastMRBs-FailedToBeModified-Item ::= SEQUENCE
SRSASN_CODE multicast_m_rbs_failed_to_be_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_m_rbs_failed_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_m_rbs_failed_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastMRBs-FailedToBeSetup-Item ::= SEQUENCE
SRSASN_CODE multicast_m_rbs_failed_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_m_rbs_failed_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_m_rbs_failed_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastMRBs-FailedToBeSetupMod-Item ::= SEQUENCE
SRSASN_CODE multicast_m_rbs_failed_to_be_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_m_rbs_failed_to_be_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_m_rbs_failed_to_be_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastMRBs-Modified-Item ::= SEQUENCE
SRSASN_CODE multicast_m_rbs_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_m_rbs_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_m_rbs_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastMRBs-Setup-Item ::= SEQUENCE
SRSASN_CODE multicast_m_rbs_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_m_rbs_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_m_rbs_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastMRBs-SetupMod-Item ::= SEQUENCE
SRSASN_CODE multicast_m_rbs_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_m_rbs_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_m_rbs_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastMRBs-ToBeModified-Item ::= SEQUENCE
SRSASN_CODE multicast_m_rbs_to_be_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mrb_qos_info_present, 1));
  HANDLE_CODE(bref.pack(mbs_flows_mapped_to_mrb_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(mbs_dl_pdcp_sn_len_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (mrb_qos_info_present) {
    HANDLE_CODE(mrb_qos_info.pack(bref));
  }
  if (mbs_flows_mapped_to_mrb_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, mbs_flows_mapped_to_mrb_list, 1, 64, true));
  }
  if (mbs_dl_pdcp_sn_len_present) {
    HANDLE_CODE(mbs_dl_pdcp_sn_len.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_m_rbs_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mrb_qos_info_present, 1));
  bool mbs_flows_mapped_to_mrb_list_present;
  HANDLE_CODE(bref.unpack(mbs_flows_mapped_to_mrb_list_present, 1));
  HANDLE_CODE(bref.unpack(mbs_dl_pdcp_sn_len_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (mrb_qos_info_present) {
    HANDLE_CODE(mrb_qos_info.unpack(bref));
  }
  if (mbs_flows_mapped_to_mrb_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(mbs_flows_mapped_to_mrb_list, bref, 1, 64, true));
  }
  if (mbs_dl_pdcp_sn_len_present) {
    HANDLE_CODE(mbs_dl_pdcp_sn_len.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_m_rbs_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (mrb_qos_info_present) {
    j.write_fieldname("mRB-QoSInformation");
    mrb_qos_info.to_json(j);
  }
  if (mbs_flows_mapped_to_mrb_list.size() > 0) {
    j.start_array("mBS-Flows-Mapped-To-MRB-List");
    for (const auto& e1 : mbs_flows_mapped_to_mrb_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (mbs_dl_pdcp_sn_len_present) {
    j.write_str("mBS-DL-PDCP-SN-Length", mbs_dl_pdcp_sn_len.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastMRBs-ToBeReleased-Item ::= SEQUENCE
SRSASN_CODE multicast_m_rbs_to_be_released_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_m_rbs_to_be_released_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_m_rbs_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastMRBs-ToBeSetup-Item ::= SEQUENCE
SRSASN_CODE multicast_m_rbs_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mrb_qos_info.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_flows_mapped_to_mrb_list, 1, 64, true));
  HANDLE_CODE(mbs_dl_pdcp_sn_len.pack(bref));
  HANDLE_CODE(ie_exts.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_m_rbs_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mrb_qos_info.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(mbs_flows_mapped_to_mrb_list, bref, 1, 64, true));
  HANDLE_CODE(mbs_dl_pdcp_sn_len.unpack(bref));
  HANDLE_CODE(ie_exts.unpack(bref));

  return SRSASN_SUCCESS;
}
void multicast_m_rbs_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.write_fieldname("mRB-QoSInformation");
  mrb_qos_info.to_json(j);
  j.start_array("mBS-Flows-Mapped-To-MRB-List");
  for (const auto& e1 : mbs_flows_mapped_to_mrb_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_str("mBS-DL-PDCP-SN-Length", mbs_dl_pdcp_sn_len.to_string());
  j.write_fieldname("iE-Extensions");
  ie_exts.to_json(j);
  j.end_obj();
}

// MulticastMRBs-ToBeSetupMod-Item ::= SEQUENCE
SRSASN_CODE multicast_m_rbs_to_be_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mrb_qos_info.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, mbs_flows_mapped_to_mrb_list, 1, 64, true));
  HANDLE_CODE(mbs_dl_pdcp_sn_len.pack(bref));
  HANDLE_CODE(ie_exts.pack(bref));

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_m_rbs_to_be_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(mrb_qos_info.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(mbs_flows_mapped_to_mrb_list, bref, 1, 64, true));
  HANDLE_CODE(mbs_dl_pdcp_sn_len.unpack(bref));
  HANDLE_CODE(ie_exts.unpack(bref));

  return SRSASN_SUCCESS;
}
void multicast_m_rbs_to_be_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  j.write_fieldname("mRB-QoSInformation");
  mrb_qos_info.to_json(j);
  j.start_array("mBS-Flows-Mapped-To-MRB-List");
  for (const auto& e1 : mbs_flows_mapped_to_mrb_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_str("mBS-DL-PDCP-SN-Length", mbs_dl_pdcp_sn_len.to_string());
  j.write_fieldname("iE-Extensions");
  ie_exts.to_json(j);
  j.end_obj();
}

// NR-CGI-List-For-Restart-Item ::= SEQUENCE
SRSASN_CODE nr_cgi_list_for_restart_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_cgi_list_for_restart_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_cgi_list_for_restart_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Neighbour-Cell-Information-Item ::= SEQUENCE
SRSASN_CODE neighbour_cell_info_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(intended_tdd_dl_ul_cfg_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (intended_tdd_dl_ul_cfg_present) {
    HANDLE_CODE(intended_tdd_dl_ul_cfg.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE neighbour_cell_info_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(intended_tdd_dl_ul_cfg_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (intended_tdd_dl_ul_cfg_present) {
    HANDLE_CODE(intended_tdd_dl_ul_cfg.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void neighbour_cell_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (intended_tdd_dl_ul_cfg_present) {
    j.write_fieldname("intendedTDD-DL-ULConfig");
    intended_tdd_dl_ul_cfg.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NotificationInformation ::= SEQUENCE
SRSASN_CODE notif_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(msg_id.pack(bref));
  HANDLE_CODE(serial_num.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE notif_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(msg_id.unpack(bref));
  HANDLE_CODE(serial_num.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void notif_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("message-Identifier", msg_id.to_string());
  j.write_str("serialNumber", serial_num.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5RLCChannelQoSInformation ::= CHOICE
void pc5_rlc_ch_qos_info_c::destroy_()
{
  switch (type_) {
    case types::pc5_rlc_ch_qos:
      c.destroy<qos_flow_level_qos_params_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void pc5_rlc_ch_qos_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pc5_rlc_ch_qos:
      c.init<qos_flow_level_qos_params_s>();
      break;
    case types::pc5_ctrl_plane_traffic_type:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pc5_rlc_ch_qos_info_c");
  }
}
pc5_rlc_ch_qos_info_c::pc5_rlc_ch_qos_info_c(const pc5_rlc_ch_qos_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pc5_rlc_ch_qos:
      c.init(other.c.get<qos_flow_level_qos_params_s>());
      break;
    case types::pc5_ctrl_plane_traffic_type:
      c.init(other.c.get<pc5_ctrl_plane_traffic_type_e_>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pc5_rlc_ch_qos_info_c");
  }
}
pc5_rlc_ch_qos_info_c& pc5_rlc_ch_qos_info_c::operator=(const pc5_rlc_ch_qos_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pc5_rlc_ch_qos:
      c.set(other.c.get<qos_flow_level_qos_params_s>());
      break;
    case types::pc5_ctrl_plane_traffic_type:
      c.set(other.c.get<pc5_ctrl_plane_traffic_type_e_>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pc5_rlc_ch_qos_info_c");
  }

  return *this;
}
qos_flow_level_qos_params_s& pc5_rlc_ch_qos_info_c::set_pc5_rlc_ch_qos()
{
  set(types::pc5_rlc_ch_qos);
  return c.get<qos_flow_level_qos_params_s>();
}
pc5_rlc_ch_qos_info_c::pc5_ctrl_plane_traffic_type_e_& pc5_rlc_ch_qos_info_c::set_pc5_ctrl_plane_traffic_type()
{
  set(types::pc5_ctrl_plane_traffic_type);
  return c.get<pc5_ctrl_plane_traffic_type_e_>();
}
protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>& pc5_rlc_ch_qos_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>>();
}
void pc5_rlc_ch_qos_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pc5_rlc_ch_qos:
      j.write_fieldname("pC5RLCChannelQoS");
      c.get<qos_flow_level_qos_params_s>().to_json(j);
      break;
    case types::pc5_ctrl_plane_traffic_type:
      j.write_str("pC5ControlPlaneTrafficType", c.get<pc5_ctrl_plane_traffic_type_e_>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pc5_rlc_ch_qos_info_c");
  }
  j.end_obj();
}
SRSASN_CODE pc5_rlc_ch_qos_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::pc5_rlc_ch_qos:
      HANDLE_CODE(c.get<qos_flow_level_qos_params_s>().pack(bref));
      break;
    case types::pc5_ctrl_plane_traffic_type:
      HANDLE_CODE(c.get<pc5_ctrl_plane_traffic_type_e_>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pc5_rlc_ch_qos_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_rlc_ch_qos_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::pc5_rlc_ch_qos:
      HANDLE_CODE(c.get<qos_flow_level_qos_params_s>().unpack(bref));
      break;
    case types::pc5_ctrl_plane_traffic_type:
      HANDLE_CODE(c.get<pc5_ctrl_plane_traffic_type_e_>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<pc5_rlc_ch_qos_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pc5_rlc_ch_qos_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* pc5_rlc_ch_qos_info_c::pc5_ctrl_plane_traffic_type_opts::to_string() const
{
  static const char* names[] = {"srb1", "srb2"};
  return convert_enum_idx(names, 2, value, "pc5_rlc_ch_qos_info_c::pc5_ctrl_plane_traffic_type_e_");
}
uint8_t pc5_rlc_ch_qos_info_c::pc5_ctrl_plane_traffic_type_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2};
  return map_enum_number(numbers, 2, value, "pc5_rlc_ch_qos_info_c::pc5_ctrl_plane_traffic_type_e_");
}

const char* pc5_rlc_ch_qos_info_c::types_opts::to_string() const
{
  static const char* names[] = {"pC5RLCChannelQoS", "pC5ControlPlaneTrafficType", "choice-extension"};
  return convert_enum_idx(names, 3, value, "pc5_rlc_ch_qos_info_c::types");
}

// PDCMeasuredResults-Item ::= SEQUENCE
SRSASN_CODE pdc_measured_results_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pdc_measured_results_value.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdc_measured_results_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(pdc_measured_results_value.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdc_measured_results_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("pDCMeasuredResults-Value");
  pdc_measured_results_value.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDCMeasurementQuantities-Item ::= SEQUENCE
SRSASN_CODE pdc_meas_quantities_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pd_cmeas_quantities_value.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdc_meas_quantities_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(pd_cmeas_quantities_value.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdc_meas_quantities_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pDCmeasurementQuantitiesValue", pd_cmeas_quantities_value.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PRSTransmissionOffInformation ::= SEQUENCE
SRSASN_CODE prs_tx_off_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(prs_tx_off_ind.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_tx_off_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(prs_tx_off_ind.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_tx_off_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("pRSTransmissionOffIndication");
  prs_tx_off_ind.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PWS-Failed-NR-CGI-Item ::= SEQUENCE
SRSASN_CODE pws_failed_nr_cgi_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  HANDLE_CODE(pack_integer(bref, nof_broadcasts, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_failed_nr_cgi_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  HANDLE_CODE(unpack_integer(nof_broadcasts, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pws_failed_nr_cgi_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  j.write_int("numberOfBroadcasts", nof_broadcasts);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE paging_cell_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += last_used_cell_ind_present ? 1 : 0;
  nof_ies += pei_subgrouping_support_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (last_used_cell_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)624, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(last_used_cell_ind.pack(bref));
  }
  if (pei_subgrouping_support_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)664, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pei_subgrouping_support_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_cell_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 624: {
        last_used_cell_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(last_used_cell_ind.unpack(bref));
        break;
      }
      case 664: {
        pei_subgrouping_support_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pei_subgrouping_support_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void paging_cell_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (last_used_cell_ind_present) {
    j.write_int("id", 624);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  if (pei_subgrouping_support_ind_present) {
    j.write_int("id", 664);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", "true");
  }
  j.end_obj();
}

// PagingCell-Item ::= SEQUENCE
SRSASN_CODE paging_cell_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_cell_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void paging_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PosMeasurementResultList-ItemExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t pos_meas_result_list_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {111};
  return map_enum_number(names, 1, idx, "id");
}
bool pos_meas_result_list_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 111 == id;
}
crit_e pos_meas_result_list_item_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 111) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pos_meas_result_list_item_ext_ies_o::ext_c pos_meas_result_list_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 111) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pos_meas_result_list_item_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 111) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void pos_meas_result_list_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("NRCGI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pos_meas_result_list_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_meas_result_list_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// PosMeasurementType ::= ENUMERATED
const char* pos_meas_type_opts::to_string() const
{
  static const char* names[] = {"gnb-rx-tx", "ul-srs-rsrp", "ul-aoa", "ul-rtoa", "multiple-ul-aoa", "ul-srs-rsrpp"};
  return convert_enum_idx(names, 6, value, "pos_meas_type_e");
}

// Potential-SpCell-Item ::= SEQUENCE
SRSASN_CODE potential_sp_cell_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(potential_sp_cell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE potential_sp_cell_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(potential_sp_cell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void potential_sp_cell_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("potential-SpCell-ID");
  potential_sp_cell_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Protected-EUTRA-Resources-Item ::= SEQUENCE
SRSASN_CODE protected_eutra_res_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, spec_sharing_group_id, (uint16_t)1u, (uint16_t)256u, false, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, eutra_cells_list, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE protected_eutra_res_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(spec_sharing_group_id, bref, (uint16_t)1u, (uint16_t)256u, false, true));
  HANDLE_CODE(unpack_dyn_seq_of(eutra_cells_list, bref, 1, 256, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void protected_eutra_res_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("spectrumSharingGroupID", spec_sharing_group_id);
  j.start_array("eUTRACells-List");
  for (const auto& e1 : eutra_cells_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// QoEInformationList-Item ::= SEQUENCE
SRSASN_CODE qo_e_info_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(qo_e_metrics_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (qo_e_metrics_present) {
    HANDLE_CODE(qo_e_metrics.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qo_e_info_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(qo_e_metrics_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (qo_e_metrics_present) {
    HANDLE_CODE(qo_e_metrics.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qo_e_info_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (qo_e_metrics_present) {
    j.write_fieldname("qoEMetrics");
    qo_e_metrics.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RedCapIndication ::= ENUMERATED
const char* red_cap_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "red_cap_ind_e");
}

// RequestedDLPRSTransmissionCharacteristics ::= SEQUENCE
SRSASN_CODE requested_dl_prs_tx_characteristics_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(numof_freq_layers_present, 1));
  HANDLE_CODE(bref.pack(start_time_and_dur_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, requested_dl_prs_res_set_list, 1, 8, true));
  if (numof_freq_layers_present) {
    HANDLE_CODE(pack_integer(bref, numof_freq_layers, (uint8_t)1u, (uint8_t)4u, false, true));
  }
  if (start_time_and_dur_present) {
    HANDLE_CODE(start_time_and_dur.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE requested_dl_prs_tx_characteristics_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(numof_freq_layers_present, 1));
  HANDLE_CODE(bref.unpack(start_time_and_dur_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(requested_dl_prs_res_set_list, bref, 1, 8, true));
  if (numof_freq_layers_present) {
    HANDLE_CODE(unpack_integer(numof_freq_layers, bref, (uint8_t)1u, (uint8_t)4u, false, true));
  }
  if (start_time_and_dur_present) {
    HANDLE_CODE(start_time_and_dur.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void requested_dl_prs_tx_characteristics_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("requestedDLPRSResourceSet-List");
  for (const auto& e1 : requested_dl_prs_res_set_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (numof_freq_layers_present) {
    j.write_int("numberofFrequencyLayers", numof_freq_layers);
  }
  if (start_time_and_dur_present) {
    j.write_fieldname("startTimeAndDuration");
    start_time_and_dur.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ResourceCoordinationEUTRACellInfo-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t res_coordination_eutra_cell_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {233};
  return map_enum_number(names, 1, idx, "id");
}
bool res_coordination_eutra_cell_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 233 == id;
}
crit_e res_coordination_eutra_cell_info_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 233) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
res_coordination_eutra_cell_info_ext_ies_o::ext_c
res_coordination_eutra_cell_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 233) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e res_coordination_eutra_cell_info_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 233) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void res_coordination_eutra_cell_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("IgnorePRACHConfiguration", "true");
  j.end_obj();
}
SRSASN_CODE res_coordination_eutra_cell_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE res_coordination_eutra_cell_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// SCell-FailedtoSetup-Item ::= SEQUENCE
SRSASN_CODE scell_failedto_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(scell_id.pack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE scell_failedto_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(scell_id.unpack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void scell_failedto_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sCell-ID");
  scell_id.to_json(j);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SCell-FailedtoSetupMod-Item ::= SEQUENCE
SRSASN_CODE scell_failedto_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(scell_id.pack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE scell_failedto_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(scell_id.unpack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void scell_failedto_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sCell-ID");
  scell_id.to_json(j);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SCell-ToBeRemoved-Item ::= SEQUENCE
SRSASN_CODE scell_to_be_remd_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(scell_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE scell_to_be_remd_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(scell_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void scell_to_be_remd_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sCell-ID");
  scell_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SCell-ToBeSetup-Item ::= SEQUENCE
SRSASN_CODE scell_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(scell_ul_cfg_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(scell_id.pack(bref));
  HANDLE_CODE(pack_integer(bref, scell_idx, (uint8_t)1u, (uint8_t)31u, true, true));
  if (scell_ul_cfg_present) {
    HANDLE_CODE(scell_ul_cfg.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE scell_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(scell_ul_cfg_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(scell_id.unpack(bref));
  HANDLE_CODE(unpack_integer(scell_idx, bref, (uint8_t)1u, (uint8_t)31u, true, true));
  if (scell_ul_cfg_present) {
    HANDLE_CODE(scell_ul_cfg.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void scell_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sCell-ID");
  scell_id.to_json(j);
  j.write_int("sCellIndex", scell_idx);
  if (scell_ul_cfg_present) {
    j.write_str("sCellULConfigured", scell_ul_cfg.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// SCell-ToBeSetupMod-Item ::= SEQUENCE
SRSASN_CODE scell_to_be_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(scell_ul_cfg_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(scell_id.pack(bref));
  HANDLE_CODE(pack_integer(bref, scell_idx, (uint8_t)1u, (uint8_t)31u, true, true));
  if (scell_ul_cfg_present) {
    HANDLE_CODE(scell_ul_cfg.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE scell_to_be_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(scell_ul_cfg_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(scell_id.unpack(bref));
  HANDLE_CODE(unpack_integer(scell_idx, bref, (uint8_t)1u, (uint8_t)31u, true, true));
  if (scell_ul_cfg_present) {
    HANDLE_CODE(scell_ul_cfg.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void scell_to_be_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sCell-ID");
  scell_id.to_json(j);
  j.write_int("sCellIndex", scell_idx);
  if (scell_ul_cfg_present) {
    j.write_str("sCellULConfigured", scell_ul_cfg.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// SDTBearerConfig-List-Item ::= SEQUENCE
SRSASN_CODE sdt_bearer_cfg_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sdt_bearer_type.pack(bref));
  HANDLE_CODE(sdt_rlc_bearer_cfg.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sdt_bearer_cfg_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sdt_bearer_type.unpack(bref));
  HANDLE_CODE(sdt_rlc_bearer_cfg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sdt_bearer_cfg_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sDTBearerType");
  sdt_bearer_type.to_json(j);
  j.write_str("sDTRLCBearerConfiguration", sdt_rlc_bearer_cfg.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRBs-FailedToBeModified-Item ::= SEQUENCE
SRSASN_CODE sl_drbs_failed_to_be_modified_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sl_drb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drbs_failed_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sl_drb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sl_drbs_failed_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sLDRBID", sl_drb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRBs-FailedToBeSetup-Item ::= SEQUENCE
SRSASN_CODE sl_drbs_failed_to_be_setup_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sl_drb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drbs_failed_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sl_drb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sl_drbs_failed_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sLDRBID", sl_drb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRBs-FailedToBeSetupMod-Item ::= SEQUENCE
SRSASN_CODE sl_drbs_failed_to_be_setup_mod_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sl_drb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drbs_failed_to_be_setup_mod_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sl_drb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sl_drbs_failed_to_be_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sLDRBID", sl_drb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRBs-Modified-Item ::= SEQUENCE
SRSASN_CODE sl_drbs_modified_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sl_drb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drbs_modified_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sl_drb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sl_drbs_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sLDRBID", sl_drb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRBs-ModifiedConf-Item ::= SEQUENCE
SRSASN_CODE sl_drbs_modified_conf_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sl_drb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drbs_modified_conf_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sl_drb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sl_drbs_modified_conf_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sLDRBID", sl_drb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRBs-Required-ToBeModified-Item ::= SEQUENCE
SRSASN_CODE sl_drbs_required_to_be_modified_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sl_drb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drbs_required_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sl_drb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sl_drbs_required_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sLDRBID", sl_drb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRBs-Required-ToBeReleased-Item ::= SEQUENCE
SRSASN_CODE sl_drbs_required_to_be_released_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sl_drb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drbs_required_to_be_released_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sl_drb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sl_drbs_required_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sLDRBID", sl_drb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRBs-Setup-Item ::= SEQUENCE
SRSASN_CODE sl_drbs_setup_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sl_drb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drbs_setup_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sl_drb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sl_drbs_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sLDRBID", sl_drb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRBs-SetupMod-Item ::= SEQUENCE
SRSASN_CODE sl_drbs_setup_mod_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sl_drb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drbs_setup_mod_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sl_drb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sl_drbs_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sLDRBID", sl_drb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRBs-ToBeModified-Item ::= SEQUENCE
SRSASN_CODE sl_drbs_to_be_modified_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(sl_drb_info_present, 1));
  HANDLE_CODE(bref.pack(rlc_mode_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sl_drb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (sl_drb_info_present) {
    HANDLE_CODE(sl_drb_info.pack(bref));
  }
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drbs_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(sl_drb_info_present, 1));
  HANDLE_CODE(bref.unpack(rlc_mode_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sl_drb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (sl_drb_info_present) {
    HANDLE_CODE(sl_drb_info.unpack(bref));
  }
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sl_drbs_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sLDRBID", sl_drb_id);
  if (sl_drb_info_present) {
    j.write_fieldname("sLDRBInformation");
    sl_drb_info.to_json(j);
  }
  if (rlc_mode_present) {
    j.write_str("rLCMode", rlc_mode.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRBs-ToBeReleased-Item ::= SEQUENCE
SRSASN_CODE sl_drbs_to_be_released_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sl_drb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drbs_to_be_released_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sl_drb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sl_drbs_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sLDRBID", sl_drb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRBs-ToBeSetup-Item ::= SEQUENCE
SRSASN_CODE sl_drbs_to_be_setup_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sl_drb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(sl_drb_info.pack(bref));
  HANDLE_CODE(rlc_mode.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drbs_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sl_drb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(sl_drb_info.unpack(bref));
  HANDLE_CODE(rlc_mode.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sl_drbs_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sLDRBID", sl_drb_id);
  j.write_fieldname("sLDRBInformation");
  sl_drb_info.to_json(j);
  j.write_str("rLCMode", rlc_mode.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRBs-ToBeSetupMod-Item ::= SEQUENCE
SRSASN_CODE sl_drbs_to_be_setup_mod_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(rlc_mode_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sl_drb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(sl_drb_info.pack(bref));
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sl_drbs_to_be_setup_mod_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(rlc_mode_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sl_drb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  HANDLE_CODE(sl_drb_info.unpack(bref));
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sl_drbs_to_be_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sLDRBID", sl_drb_id);
  j.write_fieldname("sLDRBInformation");
  sl_drb_info.to_json(j);
  if (rlc_mode_present) {
    j.write_str("rLCMode", rlc_mode.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRXInformation ::= CHOICE
void sldrx_info_c::destroy_()
{
  switch (type_) {
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<sldrx_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void sldrx_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::sldrx_cycle:
      break;
    case types::nos_ldrx:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<sldrx_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sldrx_info_c");
  }
}
sldrx_info_c::sldrx_info_c(const sldrx_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::sldrx_cycle:
      c.init(other.c.get<sldrx_cycle_len_e>());
      break;
    case types::nos_ldrx:
      c.init(other.c.get<sldrx_cfg_ind_e>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<sldrx_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sldrx_info_c");
  }
}
sldrx_info_c& sldrx_info_c::operator=(const sldrx_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::sldrx_cycle:
      c.set(other.c.get<sldrx_cycle_len_e>());
      break;
    case types::nos_ldrx:
      c.set(other.c.get<sldrx_cfg_ind_e>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<sldrx_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "sldrx_info_c");
  }

  return *this;
}
sldrx_cycle_len_e& sldrx_info_c::set_sldrx_cycle()
{
  set(types::sldrx_cycle);
  return c.get<sldrx_cycle_len_e>();
}
sldrx_cfg_ind_e& sldrx_info_c::set_nos_ldrx()
{
  set(types::nos_ldrx);
  return c.get<sldrx_cfg_ind_e>();
}
protocol_ie_single_container_s<sldrx_info_ext_ies_o>& sldrx_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<sldrx_info_ext_ies_o>>();
}
void sldrx_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::sldrx_cycle:
      j.write_str("sLDRXCycle", c.get<sldrx_cycle_len_e>().to_string());
      break;
    case types::nos_ldrx:
      j.write_str("nosLDRX", "release");
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<sldrx_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "sldrx_info_c");
  }
  j.end_obj();
}
SRSASN_CODE sldrx_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::sldrx_cycle:
      HANDLE_CODE(c.get<sldrx_cycle_len_e>().pack(bref));
      break;
    case types::nos_ldrx:
      HANDLE_CODE(c.get<sldrx_cfg_ind_e>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<sldrx_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sldrx_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE sldrx_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::sldrx_cycle:
      HANDLE_CODE(c.get<sldrx_cycle_len_e>().unpack(bref));
      break;
    case types::nos_ldrx:
      HANDLE_CODE(c.get<sldrx_cfg_ind_e>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<sldrx_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "sldrx_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* sldrx_info_c::types_opts::to_string() const
{
  static const char* names[] = {"sLDRXCycle", "nosLDRX", "choice-extension"};
  return convert_enum_idx(names, 3, value, "sldrx_info_c::types");
}

// SRBs-FailedToBeSetup-Item ::= SEQUENCE
SRSASN_CODE srbs_failed_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srb_id, (uint8_t)0u, (uint8_t)3u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srbs_failed_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srb_id, bref, (uint8_t)0u, (uint8_t)3u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srbs_failed_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRBID", srb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRBs-FailedToBeSetupMod-Item ::= SEQUENCE
SRSASN_CODE srbs_failed_to_be_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srb_id, (uint8_t)0u, (uint8_t)3u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srbs_failed_to_be_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srb_id, bref, (uint8_t)0u, (uint8_t)3u, true, true));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srbs_failed_to_be_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRBID", srb_id);
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRBs-Modified-Item ::= SEQUENCE
SRSASN_CODE srbs_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srb_id, (uint8_t)0u, (uint8_t)3u, true, true));
  HANDLE_CODE(pack_integer(bref, lcid, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srbs_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srb_id, bref, (uint8_t)0u, (uint8_t)3u, true, true));
  HANDLE_CODE(unpack_integer(lcid, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srbs_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRBID", srb_id);
  j.write_int("lCID", lcid);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRBs-Required-ToBeReleased-Item ::= SEQUENCE
SRSASN_CODE srbs_required_to_be_released_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srb_id, (uint8_t)0u, (uint8_t)3u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srbs_required_to_be_released_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srb_id, bref, (uint8_t)0u, (uint8_t)3u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srbs_required_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRBID", srb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRBs-Setup-Item ::= SEQUENCE
SRSASN_CODE srbs_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srb_id, (uint8_t)0u, (uint8_t)3u, true, true));
  HANDLE_CODE(pack_integer(bref, lcid, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srbs_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srb_id, bref, (uint8_t)0u, (uint8_t)3u, true, true));
  HANDLE_CODE(unpack_integer(lcid, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srbs_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRBID", srb_id);
  j.write_int("lCID", lcid);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRBs-SetupMod-Item ::= SEQUENCE
SRSASN_CODE srbs_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srb_id, (uint8_t)0u, (uint8_t)3u, true, true));
  HANDLE_CODE(pack_integer(bref, lcid, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srbs_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srb_id, bref, (uint8_t)0u, (uint8_t)3u, true, true));
  HANDLE_CODE(unpack_integer(lcid, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srbs_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRBID", srb_id);
  j.write_int("lCID", lcid);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRBs-ToBeReleased-Item ::= SEQUENCE
SRSASN_CODE srbs_to_be_released_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srb_id, (uint8_t)0u, (uint8_t)3u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srbs_to_be_released_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srb_id, bref, (uint8_t)0u, (uint8_t)3u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srbs_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRBID", srb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE srbs_to_be_setup_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_dupl_ind_present ? 1 : 0;
  nof_ies += sdt_rlc_bearer_cfg_present ? 1 : 0;
  nof_ies += srb_map_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_dupl_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)372, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(add_dupl_ind.pack(bref));
  }
  if (sdt_rlc_bearer_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)593, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sdt_rlc_bearer_cfg.pack(bref));
  }
  if (srb_map_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)597, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(srb_map_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srbs_to_be_setup_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 372: {
        add_dupl_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_dupl_ind.unpack(bref));
        break;
      }
      case 593: {
        sdt_rlc_bearer_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sdt_rlc_bearer_cfg.unpack(bref));
        break;
      }
      case 597: {
        srb_map_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srb_map_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void srbs_to_be_setup_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_dupl_ind_present) {
    j.write_int("id", 372);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", add_dupl_ind.to_string());
  }
  if (sdt_rlc_bearer_cfg_present) {
    j.write_int("id", 593);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", sdt_rlc_bearer_cfg.to_string());
  }
  if (srb_map_info_present) {
    j.write_int("id", 597);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", srb_map_info.to_string());
  }
  j.end_obj();
}

// SRBs-ToBeSetup-Item ::= SEQUENCE
SRSASN_CODE srbs_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dupl_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srb_id, (uint8_t)0u, (uint8_t)3u, true, true));
  if (dupl_ind_present) {
    HANDLE_CODE(dupl_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srbs_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dupl_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srb_id, bref, (uint8_t)0u, (uint8_t)3u, true, true));
  if (dupl_ind_present) {
    HANDLE_CODE(dupl_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srbs_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRBID", srb_id);
  if (dupl_ind_present) {
    j.write_str("duplicationIndication", dupl_ind.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE srbs_to_be_setup_mod_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += add_dupl_ind_present ? 1 : 0;
  nof_ies += srb_map_info_present ? 1 : 0;
  nof_ies += cg_sd_tind_setup_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (add_dupl_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)372, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(add_dupl_ind.pack(bref));
  }
  if (srb_map_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)597, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(srb_map_info.pack(bref));
  }
  if (cg_sd_tind_setup_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)589, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cg_sd_tind_setup.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srbs_to_be_setup_mod_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 372: {
        add_dupl_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(add_dupl_ind.unpack(bref));
        break;
      }
      case 597: {
        srb_map_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srb_map_info.unpack(bref));
        break;
      }
      case 589: {
        cg_sd_tind_setup_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cg_sd_tind_setup.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void srbs_to_be_setup_mod_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (add_dupl_ind_present) {
    j.write_int("id", 372);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", add_dupl_ind.to_string());
  }
  if (srb_map_info_present) {
    j.write_int("id", 597);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", srb_map_info.to_string());
  }
  if (cg_sd_tind_setup_present) {
    j.write_int("id", 589);
    j.write_str("criticality", "reject");
    j.write_str("Extension", "true");
  }
  j.end_obj();
}

// SRBs-ToBeSetupMod-Item ::= SEQUENCE
SRSASN_CODE srbs_to_be_setup_mod_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(dupl_ind_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, srb_id, (uint8_t)0u, (uint8_t)3u, true, true));
  if (dupl_ind_present) {
    HANDLE_CODE(dupl_ind.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srbs_to_be_setup_mod_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(dupl_ind_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(srb_id, bref, (uint8_t)0u, (uint8_t)3u, true, true));
  if (dupl_ind_present) {
    HANDLE_CODE(dupl_ind.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srbs_to_be_setup_mod_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sRBID", srb_id);
  if (dupl_ind_present) {
    j.write_str("duplicationIndication", dupl_ind.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRSCarrier-List-Item ::= SEQUENCE
SRSASN_CODE srs_carrier_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(pci_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, point_a, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(pack_dyn_seq_of(bref, ul_ch_bw_per_scs_list, 1, 5, true));
  HANDLE_CODE(active_ul_bwp.pack(bref));
  if (pci_present) {
    HANDLE_CODE(pack_integer(bref, pci, (uint16_t)0u, (uint16_t)1007u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srs_carrier_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(pci_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(point_a, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(unpack_dyn_seq_of(ul_ch_bw_per_scs_list, bref, 1, 5, true));
  HANDLE_CODE(active_ul_bwp.unpack(bref));
  if (pci_present) {
    HANDLE_CODE(unpack_integer(pci, bref, (uint16_t)0u, (uint16_t)1007u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void srs_carrier_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pointA", point_a);
  j.start_array("uplinkChannelBW-PerSCS-List");
  for (const auto& e1 : ul_ch_bw_per_scs_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_fieldname("activeULBWP");
  active_ul_bwp.to_json(j);
  if (pci_present) {
    j.write_int("pci", pci);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SRSResourceSetItem ::= SEQUENCE
SRSASN_CODE srs_res_set_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(num_srs_resperset_present, 1));
  HANDLE_CODE(bref.pack(periodicity_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(spatial_relation_info_present, 1));
  HANDLE_CODE(bref.pack(pathloss_ref_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (num_srs_resperset_present) {
    HANDLE_CODE(pack_integer(bref, num_srs_resperset, (uint8_t)1u, (uint8_t)16u, true, true));
  }
  if (periodicity_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, periodicity_list, 1, 16, true));
  }
  if (spatial_relation_info_present) {
    HANDLE_CODE(spatial_relation_info.pack(bref));
  }
  if (pathloss_ref_info_present) {
    HANDLE_CODE(pathloss_ref_info.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE srs_res_set_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(num_srs_resperset_present, 1));
  bool periodicity_list_present;
  HANDLE_CODE(bref.unpack(periodicity_list_present, 1));
  HANDLE_CODE(bref.unpack(spatial_relation_info_present, 1));
  HANDLE_CODE(bref.unpack(pathloss_ref_info_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (num_srs_resperset_present) {
    HANDLE_CODE(unpack_integer(num_srs_resperset, bref, (uint8_t)1u, (uint8_t)16u, true, true));
  }
  if (periodicity_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(periodicity_list, bref, 1, 16, true));
  }
  if (spatial_relation_info_present) {
    HANDLE_CODE(spatial_relation_info.unpack(bref));
  }
  if (pathloss_ref_info_present) {
    HANDLE_CODE(pathloss_ref_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void srs_res_set_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (num_srs_resperset_present) {
    j.write_int("numSRSresourcesperset", num_srs_resperset);
  }
  if (periodicity_list.size() > 0) {
    j.start_array("periodicityList");
    for (const auto& e1 : periodicity_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (spatial_relation_info_present) {
    j.write_fieldname("spatialRelationInfo");
    spatial_relation_info.to_json(j);
  }
  if (pathloss_ref_info_present) {
    j.write_fieldname("pathlossReferenceInfo");
    pathloss_ref_info.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// Search-window-information ::= SEQUENCE
SRSASN_CODE search_win_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, expected_propagation_delay, (int16_t)-3841, (int16_t)3841, true, true));
  HANDLE_CODE(pack_integer(bref, delay_uncertainty, (uint8_t)1u, (uint8_t)246u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE search_win_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(expected_propagation_delay, bref, (int16_t)-3841, (int16_t)3841, true, true));
  HANDLE_CODE(unpack_integer(delay_uncertainty, bref, (uint8_t)1u, (uint8_t)246u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void search_win_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("expectedPropagationDelay", expected_propagation_delay);
  j.write_int("delayUncertainty", delay_uncertainty);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Served-Cells-To-Add-Item ::= SEQUENCE
SRSASN_CODE served_cells_to_add_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(gnb_du_sys_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(served_cell_info.pack(bref));
  if (gnb_du_sys_info_present) {
    HANDLE_CODE(gnb_du_sys_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cells_to_add_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(gnb_du_sys_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(served_cell_info.unpack(bref));
  if (gnb_du_sys_info_present) {
    HANDLE_CODE(gnb_du_sys_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_cells_to_add_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("served-Cell-Information");
  served_cell_info.to_json(j);
  if (gnb_du_sys_info_present) {
    j.write_fieldname("gNB-DU-System-Information");
    gnb_du_sys_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Served-Cells-To-Delete-Item ::= SEQUENCE
SRSASN_CODE served_cells_to_delete_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(old_nr_cgi.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cells_to_delete_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(old_nr_cgi.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_cells_to_delete_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("oldNRCGI");
  old_nr_cgi.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Served-Cells-To-Modify-Item ::= SEQUENCE
SRSASN_CODE served_cells_to_modify_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(gnb_du_sys_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(old_nr_cgi.pack(bref));
  HANDLE_CODE(served_cell_info.pack(bref));
  if (gnb_du_sys_info_present) {
    HANDLE_CODE(gnb_du_sys_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE served_cells_to_modify_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(gnb_du_sys_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(old_nr_cgi.unpack(bref));
  HANDLE_CODE(served_cell_info.unpack(bref));
  if (gnb_du_sys_info_present) {
    HANDLE_CODE(gnb_du_sys_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void served_cells_to_modify_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("oldNRCGI");
  old_nr_cgi.to_json(j);
  j.write_fieldname("served-Cell-Information");
  served_cell_info.to_json(j);
  if (gnb_du_sys_info_present) {
    j.write_fieldname("gNB-DU-System-Information");
    gnb_du_sys_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ServingCellMO-List-Item ::= SEQUENCE
SRSASN_CODE serving_cell_mo_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, serving_cell_mo, (uint8_t)1u, (uint8_t)64u, true, true));
  HANDLE_CODE(pack_integer(bref, ssb_freq, (uint32_t)0u, (uint32_t)3279165u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE serving_cell_mo_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(serving_cell_mo, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  HANDLE_CODE(unpack_integer(ssb_freq, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void serving_cell_mo_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("servingCellMO", serving_cell_mo);
  j.write_int("sSB-Frequency", ssb_freq);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRP-MeasurementRequestItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t trp_meas_request_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {111, 552, 564, 565};
  return map_enum_number(names, 4, idx, "id");
}
bool trp_meas_request_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {111, 552, 564, 565};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trp_meas_request_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 111:
      return crit_e::ignore;
    case 552:
      return crit_e::ignore;
    case 564:
      return crit_e::ignore;
    case 565:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trp_meas_request_item_ext_ies_o::ext_c trp_meas_request_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 111:
      ret.set(ext_c::types::nr_cgi);
      break;
    case 552:
      ret.set(ext_c::types::ao_a_search_win);
      break;
    case 564:
      ret.set(ext_c::types::nof_trp_rx_teg);
      break;
    case 565:
      ret.set(ext_c::types::nof_trp_rx_tx_teg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trp_meas_request_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 111:
      return presence_e::optional;
    case 552:
      return presence_e::optional;
    case 564:
      return presence_e::optional;
    case 565:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void trp_meas_request_item_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::nr_cgi:
      c.destroy<nr_cgi_s>();
      break;
    case types::ao_a_search_win:
      c.destroy<ao_a_assist_info_s>();
      break;
    default:
      break;
  }
}
void trp_meas_request_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::nr_cgi:
      c.init<nr_cgi_s>();
      break;
    case types::ao_a_search_win:
      c.init<ao_a_assist_info_s>();
      break;
    case types::nof_trp_rx_teg:
      break;
    case types::nof_trp_rx_tx_teg:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_request_item_ext_ies_o::ext_c");
  }
}
trp_meas_request_item_ext_ies_o::ext_c::ext_c(const trp_meas_request_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nr_cgi:
      c.init(other.c.get<nr_cgi_s>());
      break;
    case types::ao_a_search_win:
      c.init(other.c.get<ao_a_assist_info_s>());
      break;
    case types::nof_trp_rx_teg:
      c.init(other.c.get<nof_trp_rx_teg_e>());
      break;
    case types::nof_trp_rx_tx_teg:
      c.init(other.c.get<nof_trp_rx_tx_teg_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_request_item_ext_ies_o::ext_c");
  }
}
trp_meas_request_item_ext_ies_o::ext_c&
trp_meas_request_item_ext_ies_o::ext_c::operator=(const trp_meas_request_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nr_cgi:
      c.set(other.c.get<nr_cgi_s>());
      break;
    case types::ao_a_search_win:
      c.set(other.c.get<ao_a_assist_info_s>());
      break;
    case types::nof_trp_rx_teg:
      c.set(other.c.get<nof_trp_rx_teg_e>());
      break;
    case types::nof_trp_rx_tx_teg:
      c.set(other.c.get<nof_trp_rx_tx_teg_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_request_item_ext_ies_o::ext_c");
  }

  return *this;
}
nr_cgi_s& trp_meas_request_item_ext_ies_o::ext_c::nr_cgi()
{
  assert_choice_type(types::nr_cgi, type_, "Extension");
  return c.get<nr_cgi_s>();
}
ao_a_assist_info_s& trp_meas_request_item_ext_ies_o::ext_c::ao_a_search_win()
{
  assert_choice_type(types::ao_a_search_win, type_, "Extension");
  return c.get<ao_a_assist_info_s>();
}
nof_trp_rx_teg_e& trp_meas_request_item_ext_ies_o::ext_c::nof_trp_rx_teg()
{
  assert_choice_type(types::nof_trp_rx_teg, type_, "Extension");
  return c.get<nof_trp_rx_teg_e>();
}
nof_trp_rx_tx_teg_e& trp_meas_request_item_ext_ies_o::ext_c::nof_trp_rx_tx_teg()
{
  assert_choice_type(types::nof_trp_rx_tx_teg, type_, "Extension");
  return c.get<nof_trp_rx_tx_teg_e>();
}
const nr_cgi_s& trp_meas_request_item_ext_ies_o::ext_c::nr_cgi() const
{
  assert_choice_type(types::nr_cgi, type_, "Extension");
  return c.get<nr_cgi_s>();
}
const ao_a_assist_info_s& trp_meas_request_item_ext_ies_o::ext_c::ao_a_search_win() const
{
  assert_choice_type(types::ao_a_search_win, type_, "Extension");
  return c.get<ao_a_assist_info_s>();
}
const nof_trp_rx_teg_e& trp_meas_request_item_ext_ies_o::ext_c::nof_trp_rx_teg() const
{
  assert_choice_type(types::nof_trp_rx_teg, type_, "Extension");
  return c.get<nof_trp_rx_teg_e>();
}
const nof_trp_rx_tx_teg_e& trp_meas_request_item_ext_ies_o::ext_c::nof_trp_rx_tx_teg() const
{
  assert_choice_type(types::nof_trp_rx_tx_teg, type_, "Extension");
  return c.get<nof_trp_rx_tx_teg_e>();
}
void trp_meas_request_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nr_cgi:
      j.write_fieldname("NRCGI");
      c.get<nr_cgi_s>().to_json(j);
      break;
    case types::ao_a_search_win:
      j.write_fieldname("AoA-AssistanceInfo");
      c.get<ao_a_assist_info_s>().to_json(j);
      break;
    case types::nof_trp_rx_teg:
      j.write_str("NumberOfTRPRxTEG", c.get<nof_trp_rx_teg_e>().to_string());
      break;
    case types::nof_trp_rx_tx_teg:
      j.write_str("NumberOfTRPRxTxTEG", c.get<nof_trp_rx_tx_teg_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_request_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE trp_meas_request_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::nr_cgi:
      HANDLE_CODE(c.get<nr_cgi_s>().pack(bref));
      break;
    case types::ao_a_search_win:
      HANDLE_CODE(c.get<ao_a_assist_info_s>().pack(bref));
      break;
    case types::nof_trp_rx_teg:
      HANDLE_CODE(c.get<nof_trp_rx_teg_e>().pack(bref));
      break;
    case types::nof_trp_rx_tx_teg:
      HANDLE_CODE(c.get<nof_trp_rx_tx_teg_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_request_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_meas_request_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::nr_cgi:
      HANDLE_CODE(c.get<nr_cgi_s>().unpack(bref));
      break;
    case types::ao_a_search_win:
      HANDLE_CODE(c.get<ao_a_assist_info_s>().unpack(bref));
      break;
    case types::nof_trp_rx_teg:
      HANDLE_CODE(c.get<nof_trp_rx_teg_e>().unpack(bref));
      break;
    case types::nof_trp_rx_tx_teg:
      HANDLE_CODE(c.get<nof_trp_rx_tx_teg_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_request_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// TRP-MeasurementUpdateItem-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t trp_meas_upd_item_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {564, 565};
  return map_enum_number(names, 2, idx, "id");
}
bool trp_meas_upd_item_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {564, 565};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trp_meas_upd_item_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 564:
      return crit_e::ignore;
    case 565:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trp_meas_upd_item_ext_ies_o::ext_c trp_meas_upd_item_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 564:
      ret.set(ext_c::types::nof_trp_rx_teg);
      break;
    case 565:
      ret.set(ext_c::types::nof_trp_rx_tx_teg);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trp_meas_upd_item_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 564:
      return presence_e::optional;
    case 565:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void trp_meas_upd_item_ext_ies_o::ext_c::destroy_() {}
void trp_meas_upd_item_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
trp_meas_upd_item_ext_ies_o::ext_c::ext_c(const trp_meas_upd_item_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::nof_trp_rx_teg:
      c.init(other.c.get<nof_trp_rx_teg_e>());
      break;
    case types::nof_trp_rx_tx_teg:
      c.init(other.c.get<nof_trp_rx_tx_teg_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_upd_item_ext_ies_o::ext_c");
  }
}
trp_meas_upd_item_ext_ies_o::ext_c&
trp_meas_upd_item_ext_ies_o::ext_c::operator=(const trp_meas_upd_item_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::nof_trp_rx_teg:
      c.set(other.c.get<nof_trp_rx_teg_e>());
      break;
    case types::nof_trp_rx_tx_teg:
      c.set(other.c.get<nof_trp_rx_tx_teg_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_upd_item_ext_ies_o::ext_c");
  }

  return *this;
}
nof_trp_rx_teg_e& trp_meas_upd_item_ext_ies_o::ext_c::nof_trp_rx_teg()
{
  assert_choice_type(types::nof_trp_rx_teg, type_, "Extension");
  return c.get<nof_trp_rx_teg_e>();
}
nof_trp_rx_tx_teg_e& trp_meas_upd_item_ext_ies_o::ext_c::nof_trp_rx_tx_teg()
{
  assert_choice_type(types::nof_trp_rx_tx_teg, type_, "Extension");
  return c.get<nof_trp_rx_tx_teg_e>();
}
const nof_trp_rx_teg_e& trp_meas_upd_item_ext_ies_o::ext_c::nof_trp_rx_teg() const
{
  assert_choice_type(types::nof_trp_rx_teg, type_, "Extension");
  return c.get<nof_trp_rx_teg_e>();
}
const nof_trp_rx_tx_teg_e& trp_meas_upd_item_ext_ies_o::ext_c::nof_trp_rx_tx_teg() const
{
  assert_choice_type(types::nof_trp_rx_tx_teg, type_, "Extension");
  return c.get<nof_trp_rx_tx_teg_e>();
}
void trp_meas_upd_item_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::nof_trp_rx_teg:
      j.write_str("NumberOfTRPRxTEG", c.get<nof_trp_rx_teg_e>().to_string());
      break;
    case types::nof_trp_rx_tx_teg:
      j.write_str("NumberOfTRPRxTxTEG", c.get<nof_trp_rx_tx_teg_e>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_upd_item_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE trp_meas_upd_item_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::nof_trp_rx_teg:
      HANDLE_CODE(c.get<nof_trp_rx_teg_e>().pack(bref));
      break;
    case types::nof_trp_rx_tx_teg:
      HANDLE_CODE(c.get<nof_trp_rx_tx_teg_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_upd_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_meas_upd_item_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::nof_trp_rx_teg:
      HANDLE_CODE(c.get<nof_trp_rx_teg_e>().unpack(bref));
      break;
    case types::nof_trp_rx_tx_teg:
      HANDLE_CODE(c.get<nof_trp_rx_tx_teg_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trp_meas_upd_item_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// TRPInformationItem ::= SEQUENCE
SRSASN_CODE trp_info_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(trp_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_info_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(trp_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_info_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("tRPInformation");
  trp_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRPInformationTypeItem ::= ENUMERATED
const char* trp_info_type_item_opts::to_string() const
{
  static const char* names[] = {"nrPCI",
                                "nG-RAN-CGI",
                                "arfcn",
                                "pRSConfig",
                                "sSBConfig",
                                "sFNInitTime",
                                "spatialDirectInfo",
                                "geoCoord",
                                "trp-type",
                                "ondemandPRS",
                                "trpTxTeg",
                                "beam-antenna-info"};
  return convert_enum_idx(names, 12, value, "trp_info_type_item_e");
}

// Transport-UP-Layer-Address-Info-To-Add-Item ::= SEQUENCE
SRSASN_CODE transport_up_layer_address_info_to_add_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(gtp_transport_layer_address_to_add.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ip_sec_transport_layer_address.pack(bref));
  if (gtp_transport_layer_address_to_add.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, gtp_transport_layer_address_to_add, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE transport_up_layer_address_info_to_add_item_s::unpack(cbit_ref& bref)
{
  bool gtp_transport_layer_address_to_add_present;
  HANDLE_CODE(bref.unpack(gtp_transport_layer_address_to_add_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ip_sec_transport_layer_address.unpack(bref));
  if (gtp_transport_layer_address_to_add_present) {
    HANDLE_CODE(unpack_dyn_seq_of(gtp_transport_layer_address_to_add, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void transport_up_layer_address_info_to_add_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("iP-SecTransportLayerAddress", ip_sec_transport_layer_address.to_string());
  if (gtp_transport_layer_address_to_add.size() > 0) {
    j.start_array("gTPTransportLayerAddressToAdd");
    for (const auto& e1 : gtp_transport_layer_address_to_add) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Transport-UP-Layer-Address-Info-To-Remove-Item ::= SEQUENCE
SRSASN_CODE transport_up_layer_address_info_to_rem_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(gtp_transport_layer_address_to_rem.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ip_sec_transport_layer_address.pack(bref));
  if (gtp_transport_layer_address_to_rem.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, gtp_transport_layer_address_to_rem, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE transport_up_layer_address_info_to_rem_item_s::unpack(cbit_ref& bref)
{
  bool gtp_transport_layer_address_to_rem_present;
  HANDLE_CODE(bref.unpack(gtp_transport_layer_address_to_rem_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ip_sec_transport_layer_address.unpack(bref));
  if (gtp_transport_layer_address_to_rem_present) {
    HANDLE_CODE(unpack_dyn_seq_of(gtp_transport_layer_address_to_rem, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void transport_up_layer_address_info_to_rem_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("iP-SecTransportLayerAddress", ip_sec_transport_layer_address.to_string());
  if (gtp_transport_layer_address_to_rem.size() > 0) {
    j.start_array("gTPTransportLayerAddressToRemove");
    for (const auto& e1 : gtp_transport_layer_address_to_rem) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UACPLMN-Item ::= SEQUENCE
SRSASN_CODE uac_plmn_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(plmn_id.pack(bref));
  HANDLE_CODE(pack_dyn_seq_of(bref, uac_type_list, 1, 64, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE uac_plmn_item_s::unpack(cbit_ref& bref)
{
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(plmn_id.unpack(bref));
  HANDLE_CODE(unpack_dyn_seq_of(uac_type_list, bref, 1, 64, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void uac_plmn_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("pLMNIdentity", plmn_id.to_string());
  j.start_array("uACType-List");
  for (const auto& e1 : uac_type_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// UE-MulticastMRBs-ConfirmedToBeModified-Item ::= SEQUENCE
SRSASN_CODE ue_multicast_m_rbs_confirmed_to_be_modified_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(mrb_type_recfg_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (mrb_type_recfg_present) {
    HANDLE_CODE(mrb_type_recfg.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_multicast_m_rbs_confirmed_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(mrb_type_recfg_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (mrb_type_recfg_present) {
    HANDLE_CODE(mrb_type_recfg.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_multicast_m_rbs_confirmed_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (mrb_type_recfg_present) {
    j.write_str("mrb-type-reconfiguration", "true");
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UE-MulticastMRBs-RequiredToBeModified-Item ::= SEQUENCE
SRSASN_CODE ue_multicast_m_rbs_required_to_be_modified_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(mrb_type_recfg_present, 1));
  HANDLE_CODE(bref.pack(mrb_recfg_rlc_type_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (mrb_type_recfg_present) {
    HANDLE_CODE(mrb_type_recfg.pack(bref));
  }
  if (mrb_recfg_rlc_type_present) {
    HANDLE_CODE(mrb_recfg_rlc_type.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_multicast_m_rbs_required_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(mrb_type_recfg_present, 1));
  HANDLE_CODE(bref.unpack(mrb_recfg_rlc_type_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (mrb_type_recfg_present) {
    HANDLE_CODE(mrb_type_recfg.unpack(bref));
  }
  if (mrb_recfg_rlc_type_present) {
    HANDLE_CODE(mrb_recfg_rlc_type.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void ue_multicast_m_rbs_required_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (mrb_type_recfg_present) {
    j.write_str("mrb-type-reconfiguration", "true");
  }
  if (mrb_recfg_rlc_type_present) {
    j.write_str("mrb-reconfigured-RLCtype", mrb_recfg_rlc_type.to_string());
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

const char* ue_multicast_m_rbs_required_to_be_modified_item_s::mrb_type_recfg_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "ue_multicast_m_rbs_required_to_be_modified_item_s::mrb_type_recfg_e_");
}

const char* ue_multicast_m_rbs_required_to_be_modified_item_s::mrb_recfg_rlc_type_opts::to_string() const
{
  static const char* names[] = {"rlc-um-ptp",
                                "rlc-am-ptp",
                                "rlc-um-dl-ptm",
                                "two-rlc-um-dl-ptp-and-dl-ptm",
                                "three-rlc-um-dl-ptp-ul-ptp-dl-ptm",
                                "two-rlc-am-ptp-um-dl-ptm"};
  return convert_enum_idx(names, 6, value, "ue_multicast_m_rbs_required_to_be_modified_item_s::mrb_recfg_rlc_type_e_");
}

// UE-MulticastMRBs-RequiredToBeReleased-Item ::= SEQUENCE
SRSASN_CODE ue_multicast_m_rbs_required_to_be_released_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_multicast_m_rbs_required_to_be_released_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_multicast_m_rbs_required_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UE-MulticastMRBs-Setup-Item ::= SEQUENCE
SRSASN_CODE ue_multicast_m_rbs_setup_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(multicast_f1_u_context_ref_cu_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (multicast_f1_u_context_ref_cu_present) {
    HANDLE_CODE(multicast_f1_u_context_ref_cu.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_multicast_m_rbs_setup_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(multicast_f1_u_context_ref_cu_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (multicast_f1_u_context_ref_cu_present) {
    HANDLE_CODE(multicast_f1_u_context_ref_cu.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_multicast_m_rbs_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (multicast_f1_u_context_ref_cu_present) {
    j.write_str("multicastF1UContextReferenceCU", multicast_f1_u_context_ref_cu.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UE-MulticastMRBs-ToBeReleased-Item ::= SEQUENCE
SRSASN_CODE ue_multicast_m_rbs_to_be_released_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_multicast_m_rbs_to_be_released_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_multicast_m_rbs_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UE-MulticastMRBs-ToBeSetup-Item ::= SEQUENCE
SRSASN_CODE ue_multicast_m_rbs_to_be_setup_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(mbs_ptp_retx_tunnel_required_present, 1));
  HANDLE_CODE(bref.pack(mbs_ptp_forwarding_required_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (mbs_ptp_retx_tunnel_required_present) {
    HANDLE_CODE(mbs_ptp_retx_tunnel_required.pack(bref));
  }
  if (mbs_ptp_forwarding_required_info_present) {
    HANDLE_CODE(mbs_ptp_forwarding_required_info.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_multicast_m_rbs_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(mbs_ptp_retx_tunnel_required_present, 1));
  HANDLE_CODE(bref.unpack(mbs_ptp_forwarding_required_info_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (mbs_ptp_retx_tunnel_required_present) {
    HANDLE_CODE(mbs_ptp_retx_tunnel_required.unpack(bref));
  }
  if (mbs_ptp_forwarding_required_info_present) {
    HANDLE_CODE(mbs_ptp_forwarding_required_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void ue_multicast_m_rbs_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (mbs_ptp_retx_tunnel_required_present) {
    j.write_str("mbsPTPRetransmissionTunnelRequired", "true");
  }
  if (mbs_ptp_forwarding_required_info_present) {
    j.write_fieldname("mbsPTPForwardingRequiredInformation");
    mbs_ptp_forwarding_required_info.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// UE-MulticastMRBs-ToBeSetup-atModify-Item ::= SEQUENCE
SRSASN_CODE ue_multicast_m_rbs_to_be_setup_at_modify_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(mbs_ptp_retx_tunnel_required_present, 1));
  HANDLE_CODE(bref.pack(mbs_ptp_forwarding_required_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, mrb_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (mbs_ptp_retx_tunnel_required_present) {
    HANDLE_CODE(mbs_ptp_retx_tunnel_required.pack(bref));
  }
  if (mbs_ptp_forwarding_required_info_present) {
    HANDLE_CODE(mbs_ptp_forwarding_required_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_multicast_m_rbs_to_be_setup_at_modify_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(mbs_ptp_retx_tunnel_required_present, 1));
  HANDLE_CODE(bref.unpack(mbs_ptp_forwarding_required_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(mrb_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (mbs_ptp_retx_tunnel_required_present) {
    HANDLE_CODE(mbs_ptp_retx_tunnel_required.unpack(bref));
  }
  if (mbs_ptp_forwarding_required_info_present) {
    HANDLE_CODE(mbs_ptp_forwarding_required_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_multicast_m_rbs_to_be_setup_at_modify_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("mRB-ID", mrb_id);
  if (mbs_ptp_retx_tunnel_required_present) {
    j.write_str("mbsPTPRetransmissionTunnelRequired", "true");
  }
  if (mbs_ptp_forwarding_required_info_present) {
    j.write_fieldname("mbsPTPForwardingRequiredInformation");
    mbs_ptp_forwarding_required_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEIdentity-List-For-Paging-Item ::= SEQUENCE
SRSASN_CODE ue_id_list_for_paging_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(paging_drx_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ue_id_idx_value.pack(bref));
  if (paging_drx_present) {
    HANDLE_CODE(paging_drx.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_id_list_for_paging_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(paging_drx_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ue_id_idx_value.unpack(bref));
  if (paging_drx_present) {
    HANDLE_CODE(paging_drx.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_id_list_for_paging_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uEIdentityIndexValue");
  ue_id_idx_value.to_json(j);
  if (paging_drx_present) {
    j.write_str("pagingDRX", paging_drx.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UL-BH-Non-UP-Traffic-Mapping-Item ::= SEQUENCE
SRSASN_CODE ul_bh_non_up_traffic_map_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(non_up_traffic_type.pack(bref));
  HANDLE_CODE(bh_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_bh_non_up_traffic_map_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(non_up_traffic_type.unpack(bref));
  HANDLE_CODE(bh_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_bh_non_up_traffic_map_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nonUPTrafficType", non_up_traffic_type.to_string());
  j.write_fieldname("bHInfo");
  bh_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UL-UP-TNL-Address-to-Update-List-Item ::= SEQUENCE
SRSASN_CODE ul_up_tnl_address_to_upd_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(old_ip_adress.pack(bref));
  HANDLE_CODE(new_ip_adress.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_up_tnl_address_to_upd_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(old_ip_adress.unpack(bref));
  HANDLE_CODE(new_ip_adress.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_up_tnl_address_to_upd_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("oldIPAdress", old_ip_adress.to_string());
  j.write_str("newIPAdress", new_ip_adress.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UL-UP-TNL-Information-to-Update-List-Item ::= SEQUENCE
SRSASN_CODE ul_up_tnl_info_to_upd_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(new_ul_up_tnl_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ul_up_tnl_info.pack(bref));
  if (new_ul_up_tnl_info_present) {
    HANDLE_CODE(new_ul_up_tnl_info.pack(bref));
  }
  HANDLE_CODE(bh_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_up_tnl_info_to_upd_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(new_ul_up_tnl_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ul_up_tnl_info.unpack(bref));
  if (new_ul_up_tnl_info_present) {
    HANDLE_CODE(new_ul_up_tnl_info.unpack(bref));
  }
  HANDLE_CODE(bh_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_up_tnl_info_to_upd_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("uLUPTNLInformation");
  ul_up_tnl_info.to_json(j);
  if (new_ul_up_tnl_info_present) {
    j.write_fieldname("newULUPTNLInformation");
    new_ul_up_tnl_info.to_json(j);
  }
  j.write_fieldname("bHInfo");
  bh_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UuRLCChannelQoSInformation ::= CHOICE
void uu_rlc_ch_qos_info_c::destroy_()
{
  switch (type_) {
    case types::uu_rlc_ch_qos:
      c.destroy<qos_flow_level_qos_params_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void uu_rlc_ch_qos_info_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::uu_rlc_ch_qos:
      c.init<qos_flow_level_qos_params_s>();
      break;
    case types::uu_ctrl_plane_traffic_type:
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "uu_rlc_ch_qos_info_c");
  }
}
uu_rlc_ch_qos_info_c::uu_rlc_ch_qos_info_c(const uu_rlc_ch_qos_info_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::uu_rlc_ch_qos:
      c.init(other.c.get<qos_flow_level_qos_params_s>());
      break;
    case types::uu_ctrl_plane_traffic_type:
      c.init(other.c.get<uu_ctrl_plane_traffic_type_e_>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "uu_rlc_ch_qos_info_c");
  }
}
uu_rlc_ch_qos_info_c& uu_rlc_ch_qos_info_c::operator=(const uu_rlc_ch_qos_info_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::uu_rlc_ch_qos:
      c.set(other.c.get<qos_flow_level_qos_params_s>());
      break;
    case types::uu_ctrl_plane_traffic_type:
      c.set(other.c.get<uu_ctrl_plane_traffic_type_e_>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "uu_rlc_ch_qos_info_c");
  }

  return *this;
}
qos_flow_level_qos_params_s& uu_rlc_ch_qos_info_c::set_uu_rlc_ch_qos()
{
  set(types::uu_rlc_ch_qos);
  return c.get<qos_flow_level_qos_params_s>();
}
uu_rlc_ch_qos_info_c::uu_ctrl_plane_traffic_type_e_& uu_rlc_ch_qos_info_c::set_uu_ctrl_plane_traffic_type()
{
  set(types::uu_ctrl_plane_traffic_type);
  return c.get<uu_ctrl_plane_traffic_type_e_>();
}
protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>& uu_rlc_ch_qos_info_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>>();
}
void uu_rlc_ch_qos_info_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::uu_rlc_ch_qos:
      j.write_fieldname("uuRLCChannelQoS");
      c.get<qos_flow_level_qos_params_s>().to_json(j);
      break;
    case types::uu_ctrl_plane_traffic_type:
      j.write_str("uuControlPlaneTrafficType", c.get<uu_ctrl_plane_traffic_type_e_>().to_string());
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "uu_rlc_ch_qos_info_c");
  }
  j.end_obj();
}
SRSASN_CODE uu_rlc_ch_qos_info_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::uu_rlc_ch_qos:
      HANDLE_CODE(c.get<qos_flow_level_qos_params_s>().pack(bref));
      break;
    case types::uu_ctrl_plane_traffic_type:
      HANDLE_CODE(c.get<uu_ctrl_plane_traffic_type_e_>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "uu_rlc_ch_qos_info_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE uu_rlc_ch_qos_info_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::uu_rlc_ch_qos:
      HANDLE_CODE(c.get<qos_flow_level_qos_params_s>().unpack(bref));
      break;
    case types::uu_ctrl_plane_traffic_type:
      HANDLE_CODE(c.get<uu_ctrl_plane_traffic_type_e_>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<uu_rlc_ch_qos_info_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "uu_rlc_ch_qos_info_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* uu_rlc_ch_qos_info_c::uu_ctrl_plane_traffic_type_opts::to_string() const
{
  static const char* names[] = {"srb0", "srb1", "srb2"};
  return convert_enum_idx(names, 3, value, "uu_rlc_ch_qos_info_c::uu_ctrl_plane_traffic_type_e_");
}
uint8_t uu_rlc_ch_qos_info_c::uu_ctrl_plane_traffic_type_opts::to_number() const
{
  static const uint8_t numbers[] = {0, 1, 2};
  return map_enum_number(numbers, 3, value, "uu_rlc_ch_qos_info_c::uu_ctrl_plane_traffic_type_e_");
}

const char* uu_rlc_ch_qos_info_c::types_opts::to_string() const
{
  static const char* names[] = {"uuRLCChannelQoS", "uuControlPlaneTrafficType", "choice-extension"};
  return convert_enum_idx(names, 3, value, "uu_rlc_ch_qos_info_c::types");
}

// EventType ::= ENUMERATED
const char* event_type_opts::to_string() const
{
  static const char* names[] = {"on-demand", "periodic", "stop"};
  return convert_enum_idx(names, 3, value, "event_type_e");
}

// F1CPathNRDC ::= ENUMERATED
const char* f1_cp_ath_nr_dc_opts::to_string() const
{
  static const char* names[] = {"mcg", "scg", "both"};
  return convert_enum_idx(names, 3, value, "f1_cp_ath_nr_dc_e");
}

// F1CPathNSA ::= ENUMERATED
const char* f1_cp_ath_nsa_opts::to_string() const
{
  static const char* names[] = {"lte", "nr", "both"};
  return convert_enum_idx(names, 3, value, "f1_cp_ath_nsa_e");
}

// FiveG-ProSeDirectCommunication ::= ENUMERATED
const char* five_g_pro_se_direct_communication_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_direct_communication_e");
}

// FiveG-ProSeDirectDiscovery ::= ENUMERATED
const char* five_g_pro_se_direct_discovery_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_direct_discovery_e");
}

// FiveG-ProSeLayer2RemoteUE ::= ENUMERATED
const char* five_g_pro_se_layer2_remote_ue_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_layer2_remote_ue_e");
}

// FiveG-ProSeLayer2UEtoNetworkRelay ::= ENUMERATED
const char* five_g_pro_se_layer2_ue_to_network_relay_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_layer2_ue_to_network_relay_e");
}

// FiveG-ProSeLayer3UEtoNetworkRelay ::= ENUMERATED
const char* five_g_pro_se_layer3_ue_to_network_relay_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "five_g_pro_se_layer3_ue_to_network_relay_e");
}

// GNBDUUESliceMaximumBitRateItem ::= SEQUENCE
SRSASN_CODE gnb_du_ue_slice_max_bit_rate_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(snssai.pack(bref));
  HANDLE_CODE(pack_integer(bref, ue_slice_max_bit_rate_ul, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE gnb_du_ue_slice_max_bit_rate_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(snssai.unpack(bref));
  HANDLE_CODE(unpack_integer(ue_slice_max_bit_rate_ul, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void gnb_du_ue_slice_max_bit_rate_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("sNSSAI");
  snssai.to_json(j);
  j.write_int("uESliceMaximumBitRateUL", ue_slice_max_bit_rate_ul);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IABTNLAddressesRequested ::= SEQUENCE
SRSASN_CODE iab_tnl_addresses_requested_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(tnl_addresses_or_prefixes_requested_all_traffic_present, 1));
  HANDLE_CODE(bref.pack(tnl_addresses_or_prefixes_requested_f1_c_present, 1));
  HANDLE_CODE(bref.pack(tnl_addresses_or_prefixes_requested_f1_u_present, 1));
  HANDLE_CODE(bref.pack(tnl_addresses_or_prefixes_requested_no_nf1_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (tnl_addresses_or_prefixes_requested_all_traffic_present) {
    HANDLE_CODE(
        pack_integer(bref, tnl_addresses_or_prefixes_requested_all_traffic, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (tnl_addresses_or_prefixes_requested_f1_c_present) {
    HANDLE_CODE(
        pack_integer(bref, tnl_addresses_or_prefixes_requested_f1_c, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (tnl_addresses_or_prefixes_requested_f1_u_present) {
    HANDLE_CODE(
        pack_integer(bref, tnl_addresses_or_prefixes_requested_f1_u, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (tnl_addresses_or_prefixes_requested_no_nf1_present) {
    HANDLE_CODE(
        pack_integer(bref, tnl_addresses_or_prefixes_requested_no_nf1, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_tnl_addresses_requested_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(tnl_addresses_or_prefixes_requested_all_traffic_present, 1));
  HANDLE_CODE(bref.unpack(tnl_addresses_or_prefixes_requested_f1_c_present, 1));
  HANDLE_CODE(bref.unpack(tnl_addresses_or_prefixes_requested_f1_u_present, 1));
  HANDLE_CODE(bref.unpack(tnl_addresses_or_prefixes_requested_no_nf1_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (tnl_addresses_or_prefixes_requested_all_traffic_present) {
    HANDLE_CODE(unpack_integer(
        tnl_addresses_or_prefixes_requested_all_traffic, bref, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (tnl_addresses_or_prefixes_requested_f1_c_present) {
    HANDLE_CODE(
        unpack_integer(tnl_addresses_or_prefixes_requested_f1_c, bref, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (tnl_addresses_or_prefixes_requested_f1_u_present) {
    HANDLE_CODE(
        unpack_integer(tnl_addresses_or_prefixes_requested_f1_u, bref, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (tnl_addresses_or_prefixes_requested_no_nf1_present) {
    HANDLE_CODE(
        unpack_integer(tnl_addresses_or_prefixes_requested_no_nf1, bref, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_tnl_addresses_requested_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (tnl_addresses_or_prefixes_requested_all_traffic_present) {
    j.write_int("tNLAddressesOrPrefixesRequestedAllTraffic", tnl_addresses_or_prefixes_requested_all_traffic);
  }
  if (tnl_addresses_or_prefixes_requested_f1_c_present) {
    j.write_int("tNLAddressesOrPrefixesRequestedF1-C", tnl_addresses_or_prefixes_requested_f1_c);
  }
  if (tnl_addresses_or_prefixes_requested_f1_u_present) {
    j.write_int("tNLAddressesOrPrefixesRequestedF1-U", tnl_addresses_or_prefixes_requested_f1_u);
  }
  if (tnl_addresses_or_prefixes_requested_no_nf1_present) {
    j.write_int("tNLAddressesOrPrefixesRequestedNoNF1", tnl_addresses_or_prefixes_requested_no_nf1);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// MulticastMBSSessionList-Item ::= SEQUENCE
SRSASN_CODE multicast_mbs_session_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_mbs_session_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(mbs_session_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void multicast_mbs_session_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("mbsSessionId");
  mbs_session_id.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRPaging-Time-Window ::= ENUMERATED
const char* nr_paging_time_win_opts::to_string() const
{
  static const char* names[] = {"s1",  "s2",  "s3",  "s4",  "s5",  "s6",  "s7",  "s8",  "s9",  "s10", "s11",
                                "s12", "s13", "s14", "s15", "s16", "s17", "s18", "s19", "s20", "s21", "s22",
                                "s23", "s24", "s25", "s26", "s27", "s28", "s29", "s30", "s31", "s32"};
  return convert_enum_idx(names, 32, value, "nr_paging_time_win_e");
}
uint8_t nr_paging_time_win_opts::to_number() const
{
  static const uint8_t numbers[] = {1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16,
                                    17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32};
  return map_enum_number(numbers, 32, value, "nr_paging_time_win_e");
}

// NRPaging-eDRX-Cycle-Idle ::= ENUMERATED
const char* nr_paging_e_drx_cycle_idle_opts::to_string() const
{
  static const char* names[] = {
      "hfquarter", "hfhalf", "hf1", "hf2", "hf4", "hf8", "hf16", "hf32", "hf64", "hf128", "hf256", "hf512", "hf1024"};
  return convert_enum_idx(names, 13, value, "nr_paging_e_drx_cycle_idle_e");
}
float nr_paging_e_drx_cycle_idle_opts::to_number() const
{
  static const float numbers[] = {0.25, 0.5, 1.0, 2.0, 4.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0, 512.0, 1024.0};
  return map_enum_number(numbers, 13, value, "nr_paging_e_drx_cycle_idle_e");
}
const char* nr_paging_e_drx_cycle_idle_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.25", "0.5", "1", "2", "4", "8", "16", "32", "64", "128", "256", "512", "1024"};
  return convert_enum_idx(number_strs, 13, value, "nr_paging_e_drx_cycle_idle_e");
}

// NRPaging-eDRX-Cycle-Inactive ::= ENUMERATED
const char* nr_paging_e_drx_cycle_inactive_opts::to_string() const
{
  static const char* names[] = {"hfquarter", "hfhalf", "hf1"};
  return convert_enum_idx(names, 3, value, "nr_paging_e_drx_cycle_inactive_e");
}
float nr_paging_e_drx_cycle_inactive_opts::to_number() const
{
  static const float numbers[] = {0.25, 0.5, 1.0};
  return map_enum_number(numbers, 3, value, "nr_paging_e_drx_cycle_inactive_e");
}
const char* nr_paging_e_drx_cycle_inactive_opts::to_number_string() const
{
  static const char* number_strs[] = {"0.25", "0.5", "1"};
  return convert_enum_idx(number_strs, 3, value, "nr_paging_e_drx_cycle_inactive_e");
}

// Neighbour-Node-Cells-List-Item ::= SEQUENCE
SRSASN_CODE neighbour_node_cells_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(gnb_cu_ue_f1ap_id_present, 1));
  HANDLE_CODE(bref.pack(gnb_du_ue_f1ap_id_present, 1));
  HANDLE_CODE(bref.pack(peer_parent_node_ind_present, 1));
  HANDLE_CODE(bref.pack(iab_du_cell_res_cfg_mode_info_present, 1));
  HANDLE_CODE(bref.pack(iab_stc_info_present, 1));
  HANDLE_CODE(bref.pack(rach_cfg_common.size() > 0, 1));
  HANDLE_CODE(bref.pack(rach_cfg_common_iab.size() > 0, 1));
  HANDLE_CODE(bref.pack(csi_rs_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(sr_cfg.size() > 0, 1));
  HANDLE_CODE(bref.pack(pdcch_cfg_sib1.size() > 0, 1));
  HANDLE_CODE(bref.pack(scs_common.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (gnb_cu_ue_f1ap_id_present) {
    HANDLE_CODE(pack_integer(bref, gnb_cu_ue_f1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (gnb_du_ue_f1ap_id_present) {
    HANDLE_CODE(pack_integer(bref, gnb_du_ue_f1ap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (peer_parent_node_ind_present) {
    HANDLE_CODE(peer_parent_node_ind.pack(bref));
  }
  if (iab_du_cell_res_cfg_mode_info_present) {
    HANDLE_CODE(iab_du_cell_res_cfg_mode_info.pack(bref));
  }
  if (iab_stc_info_present) {
    HANDLE_CODE(iab_stc_info.pack(bref));
  }
  if (rach_cfg_common.size() > 0) {
    HANDLE_CODE(rach_cfg_common.pack(bref));
  }
  if (rach_cfg_common_iab.size() > 0) {
    HANDLE_CODE(rach_cfg_common_iab.pack(bref));
  }
  if (csi_rs_cfg.size() > 0) {
    HANDLE_CODE(csi_rs_cfg.pack(bref));
  }
  if (sr_cfg.size() > 0) {
    HANDLE_CODE(sr_cfg.pack(bref));
  }
  if (pdcch_cfg_sib1.size() > 0) {
    HANDLE_CODE(pdcch_cfg_sib1.pack(bref));
  }
  if (scs_common.size() > 0) {
    HANDLE_CODE(scs_common.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE neighbour_node_cells_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(gnb_cu_ue_f1ap_id_present, 1));
  HANDLE_CODE(bref.unpack(gnb_du_ue_f1ap_id_present, 1));
  HANDLE_CODE(bref.unpack(peer_parent_node_ind_present, 1));
  HANDLE_CODE(bref.unpack(iab_du_cell_res_cfg_mode_info_present, 1));
  HANDLE_CODE(bref.unpack(iab_stc_info_present, 1));
  bool rach_cfg_common_present;
  HANDLE_CODE(bref.unpack(rach_cfg_common_present, 1));
  bool rach_cfg_common_iab_present;
  HANDLE_CODE(bref.unpack(rach_cfg_common_iab_present, 1));
  bool csi_rs_cfg_present;
  HANDLE_CODE(bref.unpack(csi_rs_cfg_present, 1));
  bool sr_cfg_present;
  HANDLE_CODE(bref.unpack(sr_cfg_present, 1));
  bool pdcch_cfg_sib1_present;
  HANDLE_CODE(bref.unpack(pdcch_cfg_sib1_present, 1));
  bool scs_common_present;
  HANDLE_CODE(bref.unpack(scs_common_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (gnb_cu_ue_f1ap_id_present) {
    HANDLE_CODE(unpack_integer(gnb_cu_ue_f1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (gnb_du_ue_f1ap_id_present) {
    HANDLE_CODE(unpack_integer(gnb_du_ue_f1ap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (peer_parent_node_ind_present) {
    HANDLE_CODE(peer_parent_node_ind.unpack(bref));
  }
  if (iab_du_cell_res_cfg_mode_info_present) {
    HANDLE_CODE(iab_du_cell_res_cfg_mode_info.unpack(bref));
  }
  if (iab_stc_info_present) {
    HANDLE_CODE(iab_stc_info.unpack(bref));
  }
  if (rach_cfg_common_present) {
    HANDLE_CODE(rach_cfg_common.unpack(bref));
  }
  if (rach_cfg_common_iab_present) {
    HANDLE_CODE(rach_cfg_common_iab.unpack(bref));
  }
  if (csi_rs_cfg_present) {
    HANDLE_CODE(csi_rs_cfg.unpack(bref));
  }
  if (sr_cfg_present) {
    HANDLE_CODE(sr_cfg.unpack(bref));
  }
  if (pdcch_cfg_sib1_present) {
    HANDLE_CODE(pdcch_cfg_sib1.unpack(bref));
  }
  if (scs_common_present) {
    HANDLE_CODE(scs_common.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void neighbour_node_cells_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (gnb_cu_ue_f1ap_id_present) {
    j.write_int("gNB-CU-UE-F1AP-ID", gnb_cu_ue_f1ap_id);
  }
  if (gnb_du_ue_f1ap_id_present) {
    j.write_int("gNB-DU-UE-F1AP-ID", gnb_du_ue_f1ap_id);
  }
  if (peer_parent_node_ind_present) {
    j.write_str("peer-Parent-Node-Indicator", "true");
  }
  if (iab_du_cell_res_cfg_mode_info_present) {
    j.write_fieldname("iAB-DU-Cell-Resource-Configuration-Mode-Info");
    iab_du_cell_res_cfg_mode_info.to_json(j);
  }
  if (iab_stc_info_present) {
    j.write_fieldname("iAB-STC-Info");
    iab_stc_info.to_json(j);
  }
  if (rach_cfg_common.size() > 0) {
    j.write_str("rACH-Config-Common", rach_cfg_common.to_string());
  }
  if (rach_cfg_common_iab.size() > 0) {
    j.write_str("rACH-Config-Common-IAB", rach_cfg_common_iab.to_string());
  }
  if (csi_rs_cfg.size() > 0) {
    j.write_str("cSI-RS-Configuration", csi_rs_cfg.to_string());
  }
  if (sr_cfg.size() > 0) {
    j.write_str("sR-Configuration", sr_cfg.to_string());
  }
  if (pdcch_cfg_sib1.size() > 0) {
    j.write_str("pDCCH-ConfigSIB1", pdcch_cfg_sib1.to_string());
  }
  if (scs_common.size() > 0) {
    j.write_str("sCS-Common", scs_common.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* neighbour_node_cells_list_item_s::peer_parent_node_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "neighbour_node_cells_list_item_s::peer_parent_node_ind_e_");
}

// PC5RLCChannelFailedToBeModifiedItem ::= SEQUENCE
SRSASN_CODE pc5_rlc_ch_failed_to_be_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pc5_rlc_ch_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(pack_integer(bref, remote_ue_local_id, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_rlc_ch_failed_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pc5_rlc_ch_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(unpack_integer(remote_ue_local_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_rlc_ch_failed_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pC5RLCChannelID", pc5_rlc_ch_id);
  if (remote_ue_local_id_present) {
    j.write_int("remoteUELocalID", remote_ue_local_id);
  }
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5RLCChannelFailedToBeSetupItem ::= SEQUENCE
SRSASN_CODE pc5_rlc_ch_failed_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pc5_rlc_ch_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(pack_integer(bref, remote_ue_local_id, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_rlc_ch_failed_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pc5_rlc_ch_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(unpack_integer(remote_ue_local_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_rlc_ch_failed_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pC5RLCChannelID", pc5_rlc_ch_id);
  if (remote_ue_local_id_present) {
    j.write_int("remoteUELocalID", remote_ue_local_id);
  }
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5RLCChannelModifiedItem ::= SEQUENCE
SRSASN_CODE pc5_rlc_ch_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pc5_rlc_ch_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(pack_integer(bref, remote_ue_local_id, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_rlc_ch_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pc5_rlc_ch_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(unpack_integer(remote_ue_local_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_rlc_ch_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pC5RLCChannelID", pc5_rlc_ch_id);
  if (remote_ue_local_id_present) {
    j.write_int("remoteUELocalID", remote_ue_local_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5RLCChannelRequiredToBeModifiedItem ::= SEQUENCE
SRSASN_CODE pc5_rlc_ch_required_to_be_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pc5_rlc_ch_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(pack_integer(bref, remote_ue_local_id, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_rlc_ch_required_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pc5_rlc_ch_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(unpack_integer(remote_ue_local_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_rlc_ch_required_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pC5RLCChannelID", pc5_rlc_ch_id);
  if (remote_ue_local_id_present) {
    j.write_int("remoteUELocalID", remote_ue_local_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5RLCChannelRequiredToBeReleasedItem ::= SEQUENCE
SRSASN_CODE pc5_rlc_ch_required_to_be_released_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pc5_rlc_ch_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(pack_integer(bref, remote_ue_local_id, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_rlc_ch_required_to_be_released_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pc5_rlc_ch_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(unpack_integer(remote_ue_local_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_rlc_ch_required_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pC5RLCChannelID", pc5_rlc_ch_id);
  if (remote_ue_local_id_present) {
    j.write_int("remoteUELocalID", remote_ue_local_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5RLCChannelSetupItem ::= SEQUENCE
SRSASN_CODE pc5_rlc_ch_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pc5_rlc_ch_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(pack_integer(bref, remote_ue_local_id, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_rlc_ch_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pc5_rlc_ch_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(unpack_integer(remote_ue_local_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_rlc_ch_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pC5RLCChannelID", pc5_rlc_ch_id);
  if (remote_ue_local_id_present) {
    j.write_int("remoteUELocalID", remote_ue_local_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5RLCChannelToBeModifiedItem ::= SEQUENCE
SRSASN_CODE pc5_rlc_ch_to_be_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.pack(pc5_rlc_ch_qos_info_present, 1));
  HANDLE_CODE(bref.pack(rlc_mode_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pc5_rlc_ch_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(pack_integer(bref, remote_ue_local_id, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (pc5_rlc_ch_qos_info_present) {
    HANDLE_CODE(pc5_rlc_ch_qos_info.pack(bref));
  }
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_rlc_ch_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.unpack(pc5_rlc_ch_qos_info_present, 1));
  HANDLE_CODE(bref.unpack(rlc_mode_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pc5_rlc_ch_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(unpack_integer(remote_ue_local_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (pc5_rlc_ch_qos_info_present) {
    HANDLE_CODE(pc5_rlc_ch_qos_info.unpack(bref));
  }
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_rlc_ch_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pC5RLCChannelID", pc5_rlc_ch_id);
  if (remote_ue_local_id_present) {
    j.write_int("remoteUELocalID", remote_ue_local_id);
  }
  if (pc5_rlc_ch_qos_info_present) {
    j.write_fieldname("pC5RLCChannelQoSInformation");
    pc5_rlc_ch_qos_info.to_json(j);
  }
  if (rlc_mode_present) {
    j.write_str("rLCMode", rlc_mode.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5RLCChannelToBeReleasedItem ::= SEQUENCE
SRSASN_CODE pc5_rlc_ch_to_be_released_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pc5_rlc_ch_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(pack_integer(bref, remote_ue_local_id, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_rlc_ch_to_be_released_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pc5_rlc_ch_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(unpack_integer(remote_ue_local_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_rlc_ch_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pC5RLCChannelID", pc5_rlc_ch_id);
  if (remote_ue_local_id_present) {
    j.write_int("remoteUELocalID", remote_ue_local_id);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PC5RLCChannelToBeSetupItem ::= SEQUENCE
SRSASN_CODE pc5_rlc_ch_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pc5_rlc_ch_id, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(pack_integer(bref, remote_ue_local_id, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  HANDLE_CODE(pc5_rlc_ch_qos_info.pack(bref));
  HANDLE_CODE(rlc_mode.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pc5_rlc_ch_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(remote_ue_local_id_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pc5_rlc_ch_id, bref, (uint16_t)1u, (uint16_t)512u, true, true));
  if (remote_ue_local_id_present) {
    HANDLE_CODE(unpack_integer(remote_ue_local_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  HANDLE_CODE(pc5_rlc_ch_qos_info.unpack(bref));
  HANDLE_CODE(rlc_mode.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pc5_rlc_ch_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pC5RLCChannelID", pc5_rlc_ch_id);
  if (remote_ue_local_id_present) {
    j.write_int("remoteUELocalID", remote_ue_local_id);
  }
  j.write_fieldname("pC5RLCChannelQoSInformation");
  pc5_rlc_ch_qos_info.to_json(j);
  j.write_str("rLCMode", rlc_mode.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDCMeasurementQuantities-ItemIEs ::= OBJECT SET OF F1AP-PROTOCOL-IES
uint32_t pdc_meas_quantities_item_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {543};
  return map_enum_number(names, 1, idx, "id");
}
bool pdc_meas_quantities_item_ies_o::is_id_valid(const uint32_t& id)
{
  return 543 == id;
}
crit_e pdc_meas_quantities_item_ies_o::get_crit(const uint32_t& id)
{
  if (id == 543) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
pdc_meas_quantities_item_ies_o::value_c pdc_meas_quantities_item_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 543) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdc_meas_quantities_item_ies_o::get_presence(const uint32_t& id)
{
  if (id == 543) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void pdc_meas_quantities_item_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("PDCMeasurementQuantities-Item");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE pdc_meas_quantities_item_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdc_meas_quantities_item_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// PRS-Measurement-Info-List-Item ::= SEQUENCE
SRSASN_CODE prs_meas_info_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, point_a, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(meas_prs_periodicity.pack(bref));
  HANDLE_CODE(pack_integer(bref, meas_prs_offset, (uint8_t)0u, (uint8_t)159u, true, true));
  HANDLE_CODE(meas_prs_len.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_meas_info_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(point_a, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  HANDLE_CODE(meas_prs_periodicity.unpack(bref));
  HANDLE_CODE(unpack_integer(meas_prs_offset, bref, (uint8_t)0u, (uint8_t)159u, true, true));
  HANDLE_CODE(meas_prs_len.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_meas_info_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("pointA", point_a);
  j.write_str("measPRSPeriodicity", meas_prs_periodicity.to_string());
  j.write_int("measPRSOffset", meas_prs_offset);
  j.write_str("measurementPRSLength", meas_prs_len.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* prs_meas_info_list_item_s::meas_prs_periodicity_opts::to_string() const
{
  static const char* names[] = {"ms20", "ms40", "ms80", "ms160"};
  return convert_enum_idx(names, 4, value, "prs_meas_info_list_item_s::meas_prs_periodicity_e_");
}
uint8_t prs_meas_info_list_item_s::meas_prs_periodicity_opts::to_number() const
{
  static const uint8_t numbers[] = {20, 40, 80, 160};
  return map_enum_number(numbers, 4, value, "prs_meas_info_list_item_s::meas_prs_periodicity_e_");
}

const char* prs_meas_info_list_item_s::meas_prs_len_opts::to_string() const
{
  static const char* names[] = {"ms1dot5", "ms3", "ms3dot5", "ms4", "ms5dot5", "ms6", "ms10", "ms20"};
  return convert_enum_idx(names, 8, value, "prs_meas_info_list_item_s::meas_prs_len_e_");
}
float prs_meas_info_list_item_s::meas_prs_len_opts::to_number() const
{
  static const float numbers[] = {1.5, 3.0, 3.5, 4.0, 5.5, 6.0, 10.0, 20.0};
  return map_enum_number(numbers, 8, value, "prs_meas_info_list_item_s::meas_prs_len_e_");
}
const char* prs_meas_info_list_item_s::meas_prs_len_opts::to_number_string() const
{
  static const char* number_strs[] = {"1.5", "3", "3.5", "4", "5.5", "6", "10", "20"};
  return convert_enum_idx(number_strs, 8, value, "prs_meas_info_list_item_s::meas_prs_len_e_");
}

// PRSTRPItem ::= SEQUENCE
SRSASN_CODE prstrp_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(requested_dl_prs_tx_characteristics_present, 1));
  HANDLE_CODE(bref.pack(prs_tx_off_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, trp_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (requested_dl_prs_tx_characteristics_present) {
    HANDLE_CODE(requested_dl_prs_tx_characteristics.pack(bref));
  }
  if (prs_tx_off_info_present) {
    HANDLE_CODE(prs_tx_off_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prstrp_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(requested_dl_prs_tx_characteristics_present, 1));
  HANDLE_CODE(bref.unpack(prs_tx_off_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(trp_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (requested_dl_prs_tx_characteristics_present) {
    HANDLE_CODE(requested_dl_prs_tx_characteristics.unpack(bref));
  }
  if (prs_tx_off_info_present) {
    HANDLE_CODE(prs_tx_off_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prstrp_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("tRP-ID", trp_id);
  if (requested_dl_prs_tx_characteristics_present) {
    j.write_fieldname("requestedDLPRSTransmissionCharacteristics");
    requested_dl_prs_tx_characteristics.to_json(j);
  }
  if (prs_tx_off_info_present) {
    j.write_fieldname("pRSTransmissionOffInformation");
    prs_tx_off_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PRSTransmissionTRPItem ::= SEQUENCE
SRSASN_CODE prs_tx_trp_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, trp_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(prs_cfg.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE prs_tx_trp_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(trp_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(prs_cfg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void prs_tx_trp_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("tRP-ID", trp_id);
  j.write_fieldname("pRSConfiguration");
  prs_cfg.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PWSSystemInformationExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t pws_sys_info_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {220, 231};
  return map_enum_number(names, 2, idx, "id");
}
bool pws_sys_info_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {220, 231};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_sys_info_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 220:
      return crit_e::ignore;
    case 231:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_sys_info_ext_ies_o::ext_c pws_sys_info_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 220:
      ret.set(ext_c::types::notif_info);
      break;
    case 231:
      ret.set(ext_c::types::add_sib_msg_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_sys_info_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 220:
      return presence_e::optional;
    case 231:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void pws_sys_info_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::notif_info:
      c.destroy<notif_info_s>();
      break;
    case types::add_sib_msg_list:
      c.destroy<add_sib_msg_list_l>();
      break;
    default:
      break;
  }
}
void pws_sys_info_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::notif_info:
      c.init<notif_info_s>();
      break;
    case types::add_sib_msg_list:
      c.init<add_sib_msg_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_sys_info_ext_ies_o::ext_c");
  }
}
pws_sys_info_ext_ies_o::ext_c::ext_c(const pws_sys_info_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::notif_info:
      c.init(other.c.get<notif_info_s>());
      break;
    case types::add_sib_msg_list:
      c.init(other.c.get<add_sib_msg_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_sys_info_ext_ies_o::ext_c");
  }
}
pws_sys_info_ext_ies_o::ext_c& pws_sys_info_ext_ies_o::ext_c::operator=(const pws_sys_info_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::notif_info:
      c.set(other.c.get<notif_info_s>());
      break;
    case types::add_sib_msg_list:
      c.set(other.c.get<add_sib_msg_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_sys_info_ext_ies_o::ext_c");
  }

  return *this;
}
notif_info_s& pws_sys_info_ext_ies_o::ext_c::notif_info()
{
  assert_choice_type(types::notif_info, type_, "Extension");
  return c.get<notif_info_s>();
}
add_sib_msg_list_l& pws_sys_info_ext_ies_o::ext_c::add_sib_msg_list()
{
  assert_choice_type(types::add_sib_msg_list, type_, "Extension");
  return c.get<add_sib_msg_list_l>();
}
const notif_info_s& pws_sys_info_ext_ies_o::ext_c::notif_info() const
{
  assert_choice_type(types::notif_info, type_, "Extension");
  return c.get<notif_info_s>();
}
const add_sib_msg_list_l& pws_sys_info_ext_ies_o::ext_c::add_sib_msg_list() const
{
  assert_choice_type(types::add_sib_msg_list, type_, "Extension");
  return c.get<add_sib_msg_list_l>();
}
void pws_sys_info_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::notif_info:
      j.write_fieldname("NotificationInformation");
      c.get<notif_info_s>().to_json(j);
      break;
    case types::add_sib_msg_list:
      j.start_array("AdditionalSIBMessageList");
      for (const auto& e1 : c.get<add_sib_msg_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pws_sys_info_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_sys_info_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::notif_info:
      HANDLE_CODE(c.get<notif_info_s>().pack(bref));
      break;
    case types::add_sib_msg_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<add_sib_msg_list_l>(), 1, 63, true));
      break;
    default:
      log_invalid_choice_id(type_, "pws_sys_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_sys_info_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::notif_info:
      HANDLE_CODE(c.get<notif_info_s>().unpack(bref));
      break;
    case types::add_sib_msg_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<add_sib_msg_list_l>(), bref, 1, 63, true));
      break;
    default:
      log_invalid_choice_id(type_, "pws_sys_info_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PedestrianUE ::= ENUMERATED
const char* pedestrian_ue_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "pedestrian_ue_e");
}

// PosMeasurementQuantities-Item ::= SEQUENCE
SRSASN_CODE pos_meas_quantities_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(timing_report_granularity_factor_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pos_meas_type.pack(bref));
  if (timing_report_granularity_factor_present) {
    HANDLE_CODE(pack_integer(bref, timing_report_granularity_factor, (uint8_t)0u, (uint8_t)5u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_meas_quantities_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(timing_report_granularity_factor_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(pos_meas_type.unpack(bref));
  if (timing_report_granularity_factor_present) {
    HANDLE_CODE(unpack_integer(timing_report_granularity_factor, bref, (uint8_t)0u, (uint8_t)5u, false, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pos_meas_quantities_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("posMeasurementType", pos_meas_type.to_string());
  if (timing_report_granularity_factor_present) {
    j.write_int("timingReportingGranularityFactor", timing_report_granularity_factor);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PosMeasurementResultList-Item ::= SEQUENCE
SRSASN_CODE pos_meas_result_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, pos_meas_result, 1, 16384, true));
  HANDLE_CODE(pack_integer(bref, trp_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_meas_result_list_item_s::unpack(cbit_ref& bref)
{
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(pos_meas_result, bref, 1, 16384, true));
  HANDLE_CODE(unpack_integer(trp_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void pos_meas_result_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("posMeasurementResult");
  for (const auto& e1 : pos_meas_result) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("tRPID", trp_id);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// PosSItype-Item ::= SEQUENCE
SRSASN_CODE pos_sitype_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, pos_itype, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_sitype_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(pos_itype, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pos_sitype_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("posItype", pos_itype);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RANUEPagingIdentity ::= SEQUENCE
SRSASN_CODE ran_ue_paging_id_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(irnti.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_ue_paging_id_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(irnti.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ran_ue_paging_id_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("iRNTI", irnti.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RRC-Version-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t rrc_version_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {199};
  return map_enum_number(names, 1, idx, "id");
}
bool rrc_version_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 199 == id;
}
crit_e rrc_version_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 199) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
rrc_version_ext_ies_o::ext_c rrc_version_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 199) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e rrc_version_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 199) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void rrc_version_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("OCTET STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE rrc_version_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_version_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// RequestedSRSTransmissionCharacteristics-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t requested_srs_tx_characteristics_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {431};
  return map_enum_number(names, 1, idx, "id");
}
bool requested_srs_tx_characteristics_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 431 == id;
}
crit_e requested_srs_tx_characteristics_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 431) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
requested_srs_tx_characteristics_ext_ies_o::ext_c
requested_srs_tx_characteristics_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 431) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e requested_srs_tx_characteristics_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 431) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void requested_srs_tx_characteristics_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("INTEGER (0..3279165)", c);
  j.end_obj();
}
SRSASN_CODE requested_srs_tx_characteristics_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_integer(bref, c, (uint32_t)0u, (uint32_t)3279165u, false, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE requested_srs_tx_characteristics_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_integer(c, bref, (uint32_t)0u, (uint32_t)3279165u, false, true));
  return SRSASN_SUCCESS;
}

// ResourceCoordinationEUTRACellInfo ::= SEQUENCE
SRSASN_CODE res_coordination_eutra_cell_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(eutra_mode_info.pack(bref));
  HANDLE_CODE(eutra_prach_cfg.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE res_coordination_eutra_cell_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(eutra_mode_info.unpack(bref));
  HANDLE_CODE(eutra_prach_cfg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void res_coordination_eutra_cell_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("eUTRA-Mode-Info");
  eutra_mode_info.to_json(j);
  j.write_fieldname("eUTRA-PRACH-Configuration");
  eutra_prach_cfg.to_json(j);
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// SItype-Item ::= SEQUENCE
SRSASN_CODE sitype_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sitype, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sitype_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sitype, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sitype_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sItype", sitype);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SLDRXCycleItem ::= SEQUENCE
SRSASN_CODE sldrx_cycle_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(rx_ue_id.pack(bref));
  HANDLE_CODE(sldrx_info.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sldrx_cycle_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(rx_ue_id.unpack(bref));
  HANDLE_CODE(sldrx_info.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sldrx_cycle_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("rXUEID", rx_ue_id.to_string());
  j.write_fieldname("sLDRXInformation");
  sldrx_info.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// Serving-Cells-List-Item ::= SEQUENCE
SRSASN_CODE serving_cells_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(iab_mt_cell_na_res_cfg_mode_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.pack(bref));
  if (iab_mt_cell_na_res_cfg_mode_info_present) {
    HANDLE_CODE(iab_mt_cell_na_res_cfg_mode_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE serving_cells_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(iab_mt_cell_na_res_cfg_mode_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nr_cgi.unpack(bref));
  if (iab_mt_cell_na_res_cfg_mode_info_present) {
    HANDLE_CODE(iab_mt_cell_na_res_cfg_mode_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void serving_cells_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("nRCGI");
  nr_cgi.to_json(j);
  if (iab_mt_cell_na_res_cfg_mode_info_present) {
    j.write_fieldname("iAB-MT-Cell-NA-Resource-Configuration-Mode-Info");
    iab_mt_cell_na_res_cfg_mode_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ServingCellMO-encoded-in-CGC-Item ::= SEQUENCE
SRSASN_CODE serving_cell_mo_encoded_in_cgc_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, serving_cell_mo, (uint8_t)1u, (uint8_t)64u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE serving_cell_mo_encoded_in_cgc_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(serving_cell_mo, bref, (uint8_t)1u, (uint8_t)64u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void serving_cell_mo_encoded_in_cgc_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("servingCellMO", serving_cell_mo);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE trp_meas_request_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += nr_cgi_present ? 1 : 0;
  nof_ies += ao_a_search_win_present ? 1 : 0;
  nof_ies += nof_trp_rx_teg_present ? 1 : 0;
  nof_ies += nof_trp_rx_tx_teg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (nr_cgi_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)111, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_cgi.pack(bref));
  }
  if (ao_a_search_win_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)552, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ao_a_search_win.pack(bref));
  }
  if (nof_trp_rx_teg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)564, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nof_trp_rx_teg.pack(bref));
  }
  if (nof_trp_rx_tx_teg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)565, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nof_trp_rx_tx_teg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_meas_request_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 111: {
        nr_cgi_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_cgi.unpack(bref));
        break;
      }
      case 552: {
        ao_a_search_win_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ao_a_search_win.unpack(bref));
        break;
      }
      case 564: {
        nof_trp_rx_teg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nof_trp_rx_teg.unpack(bref));
        break;
      }
      case 565: {
        nof_trp_rx_tx_teg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nof_trp_rx_tx_teg.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void trp_meas_request_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (nr_cgi_present) {
    j.write_int("id", 111);
    j.write_str("criticality", "ignore");
    nr_cgi.to_json(j);
  }
  if (ao_a_search_win_present) {
    j.write_int("id", 552);
    j.write_str("criticality", "ignore");
    ao_a_search_win.to_json(j);
  }
  if (nof_trp_rx_teg_present) {
    j.write_int("id", 564);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", nof_trp_rx_teg.to_string());
  }
  if (nof_trp_rx_tx_teg_present) {
    j.write_int("id", 565);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", nof_trp_rx_tx_teg.to_string());
  }
  j.end_obj();
}

// TRP-MeasurementRequestItem ::= SEQUENCE
SRSASN_CODE trp_meas_request_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(search_win_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, trp_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (search_win_info_present) {
    HANDLE_CODE(search_win_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_meas_request_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(search_win_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(trp_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (search_win_info_present) {
    HANDLE_CODE(search_win_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_meas_request_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("tRPID", trp_id);
  if (search_win_info_present) {
    j.write_fieldname("search-window-information");
    search_win_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE trp_meas_upd_item_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += nof_trp_rx_teg_present ? 1 : 0;
  nof_ies += nof_trp_rx_tx_teg_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (nof_trp_rx_teg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)564, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nof_trp_rx_teg.pack(bref));
  }
  if (nof_trp_rx_tx_teg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)565, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nof_trp_rx_tx_teg.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_meas_upd_item_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 564: {
        nof_trp_rx_teg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nof_trp_rx_teg.unpack(bref));
        break;
      }
      case 565: {
        nof_trp_rx_tx_teg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nof_trp_rx_tx_teg.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void trp_meas_upd_item_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (nof_trp_rx_teg_present) {
    j.write_int("id", 564);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", nof_trp_rx_teg.to_string());
  }
  if (nof_trp_rx_tx_teg_present) {
    j.write_int("id", 565);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", nof_trp_rx_tx_teg.to_string());
  }
  j.end_obj();
}

// TRP-MeasurementUpdateItem ::= SEQUENCE
SRSASN_CODE trp_meas_upd_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ao_a_win_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, trp_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (ao_a_win_info_present) {
    HANDLE_CODE(ao_a_win_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_meas_upd_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ao_a_win_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(trp_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (ao_a_win_info_present) {
    HANDLE_CODE(ao_a_win_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_meas_upd_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("tRP-ID", trp_id);
  if (ao_a_win_info_present) {
    j.write_fieldname("aoA-window-information");
    ao_a_win_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRP-PRS-Info-List-Item ::= SEQUENCE
SRSASN_CODE trp_prs_info_list_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cgi_nr_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, trp_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(pack_integer(bref, nr_pci, (uint16_t)0u, (uint16_t)1007u, false, true));
  if (cgi_nr_present) {
    HANDLE_CODE(cgi_nr.pack(bref));
  }
  HANDLE_CODE(prs_cfg.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_prs_info_list_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cgi_nr_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(trp_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  HANDLE_CODE(unpack_integer(nr_pci, bref, (uint16_t)0u, (uint16_t)1007u, false, true));
  if (cgi_nr_present) {
    HANDLE_CODE(cgi_nr.unpack(bref));
  }
  HANDLE_CODE(prs_cfg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_prs_info_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("tRP-ID", trp_id);
  j.write_int("nR-PCI", nr_pci);
  if (cgi_nr_present) {
    j.write_fieldname("cGI-NR");
    cgi_nr.to_json(j);
  }
  j.write_fieldname("pRSConfiguration");
  prs_cfg.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TRPListItem ::= SEQUENCE
SRSASN_CODE trp_list_item_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, trp_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trp_list_item_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(trp_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trp_list_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("tRPID", trp_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TraceActivation-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t trace_activation_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {381, 380};
  return map_enum_number(names, 2, idx, "id");
}
bool trace_activation_ext_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {381, 380};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_activation_ext_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 381:
      return crit_e::ignore;
    case 380:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trace_activation_ext_ies_o::ext_c trace_activation_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  switch (id) {
    case 381:
      ret.set(ext_c::types::mdt_cfg);
      break;
    case 380:
      ret.set(ext_c::types::trace_collection_entity_uri);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trace_activation_ext_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 381:
      return presence_e::optional;
    case 380:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Extension ::= OPEN TYPE
void trace_activation_ext_ies_o::ext_c::destroy_()
{
  switch (type_) {
    case types::mdt_cfg:
      c.destroy<mdt_cfg_s>();
      break;
    case types::trace_collection_entity_uri:
      c.destroy<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
      break;
    default:
      break;
  }
}
void trace_activation_ext_ies_o::ext_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mdt_cfg:
      c.init<mdt_cfg_s>();
      break;
    case types::trace_collection_entity_uri:
      c.init<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }
}
trace_activation_ext_ies_o::ext_c::ext_c(const trace_activation_ext_ies_o::ext_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mdt_cfg:
      c.init(other.c.get<mdt_cfg_s>());
      break;
    case types::trace_collection_entity_uri:
      c.init(other.c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }
}
trace_activation_ext_ies_o::ext_c&
trace_activation_ext_ies_o::ext_c::operator=(const trace_activation_ext_ies_o::ext_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mdt_cfg:
      c.set(other.c.get<mdt_cfg_s>());
      break;
    case types::trace_collection_entity_uri:
      c.set(other.c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }

  return *this;
}
mdt_cfg_s& trace_activation_ext_ies_o::ext_c::mdt_cfg()
{
  assert_choice_type(types::mdt_cfg, type_, "Extension");
  return c.get<mdt_cfg_s>();
}
visible_string<0, MAX_ASN_STRING_LENGTH, false, true>& trace_activation_ext_ies_o::ext_c::trace_collection_entity_uri()
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Extension");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
const mdt_cfg_s& trace_activation_ext_ies_o::ext_c::mdt_cfg() const
{
  assert_choice_type(types::mdt_cfg, type_, "Extension");
  return c.get<mdt_cfg_s>();
}
const visible_string<0, MAX_ASN_STRING_LENGTH, false, true>&
trace_activation_ext_ies_o::ext_c::trace_collection_entity_uri() const
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Extension");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
void trace_activation_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mdt_cfg:
      j.write_fieldname("MDTConfiguration");
      c.get<mdt_cfg_s>().to_json(j);
      break;
    case types::trace_collection_entity_uri:
      j.write_str("VisibleString", c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_activation_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mdt_cfg:
      HANDLE_CODE(c.get<mdt_cfg_s>().pack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mdt_cfg:
      HANDLE_CODE(c.get<mdt_cfg_s>().unpack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "trace_activation_ext_ies_o::ext_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// TraceDepth ::= ENUMERATED
const char* trace_depth_opts::to_string() const
{
  static const char* names[] = {"minimum",
                                "medium",
                                "maximum",
                                "minimumWithoutVendorSpecificExtension",
                                "mediumWithoutVendorSpecificExtension",
                                "maximumWithoutVendorSpecificExtension"};
  return convert_enum_idx(names, 6, value, "trace_depth_e");
}

// UEPagingCapability-ExtIEs ::= OBJECT SET OF F1AP-PROTOCOL-EXTENSION
uint32_t ue_paging_cap_ext_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {673};
  return map_enum_number(names, 1, idx, "id");
}
bool ue_paging_cap_ext_ies_o::is_id_valid(const uint32_t& id)
{
  return 673 == id;
}
crit_e ue_paging_cap_ext_ies_o::get_crit(const uint32_t& id)
{
  if (id == 673) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ue_paging_cap_ext_ies_o::ext_c ue_paging_cap_ext_ies_o::get_ext(const uint32_t& id)
{
  ext_c ret{};
  if (id != 673) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_paging_cap_ext_ies_o::get_presence(const uint32_t& id)
{
  if (id == 673) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Extension ::= OPEN TYPE
void ue_paging_cap_ext_ies_o::ext_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("RedCapIndication", "true");
  j.end_obj();
}
SRSASN_CODE ue_paging_cap_ext_ies_o::ext_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_paging_cap_ext_ies_o::ext_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// UuRLCChannelFailedToBeModifiedItem ::= SEQUENCE
SRSASN_CODE uu_rlc_ch_failed_to_be_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.pack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE uu_rlc_ch_failed_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.unpack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void uu_rlc_ch_failed_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("uuRLCChannelID", uu_rlc_ch_id.to_string());
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UuRLCChannelFailedToBeSetupItem ::= SEQUENCE
SRSASN_CODE uu_rlc_ch_failed_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(cause_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.pack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE uu_rlc_ch_failed_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(cause_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.unpack(bref));
  if (cause_present) {
    HANDLE_CODE(cause.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void uu_rlc_ch_failed_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("uuRLCChannelID", uu_rlc_ch_id.to_string());
  if (cause_present) {
    j.write_fieldname("cause");
    cause.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UuRLCChannelModifiedItem ::= SEQUENCE
SRSASN_CODE uu_rlc_ch_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE uu_rlc_ch_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void uu_rlc_ch_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("uuRLCChannelID", uu_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UuRLCChannelRequiredToBeModifiedItem ::= SEQUENCE
SRSASN_CODE uu_rlc_ch_required_to_be_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE uu_rlc_ch_required_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void uu_rlc_ch_required_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("uuRLCChannelID", uu_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UuRLCChannelRequiredToBeReleasedItem ::= SEQUENCE
SRSASN_CODE uu_rlc_ch_required_to_be_released_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE uu_rlc_ch_required_to_be_released_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void uu_rlc_ch_required_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("uuRLCChannelID", uu_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UuRLCChannelSetupItem ::= SEQUENCE
SRSASN_CODE uu_rlc_ch_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE uu_rlc_ch_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void uu_rlc_ch_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("uuRLCChannelID", uu_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UuRLCChannelToBeModifiedItem ::= SEQUENCE
SRSASN_CODE uu_rlc_ch_to_be_modified_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(uu_rlc_ch_qos_info_present, 1));
  HANDLE_CODE(bref.pack(rlc_mode_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.pack(bref));
  if (uu_rlc_ch_qos_info_present) {
    HANDLE_CODE(uu_rlc_ch_qos_info.pack(bref));
  }
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE uu_rlc_ch_to_be_modified_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(uu_rlc_ch_qos_info_present, 1));
  HANDLE_CODE(bref.unpack(rlc_mode_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.unpack(bref));
  if (uu_rlc_ch_qos_info_present) {
    HANDLE_CODE(uu_rlc_ch_qos_info.unpack(bref));
  }
  if (rlc_mode_present) {
    HANDLE_CODE(rlc_mode.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void uu_rlc_ch_to_be_modified_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("uuRLCChannelID", uu_rlc_ch_id.to_string());
  if (uu_rlc_ch_qos_info_present) {
    j.write_fieldname("uuRLCChannelQoSInformation");
    uu_rlc_ch_qos_info.to_json(j);
  }
  if (rlc_mode_present) {
    j.write_str("rLCMode", rlc_mode.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UuRLCChannelToBeReleasedItem ::= SEQUENCE
SRSASN_CODE uu_rlc_ch_to_be_released_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE uu_rlc_ch_to_be_released_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void uu_rlc_ch_to_be_released_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("uuRLCChannelID", uu_rlc_ch_id.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UuRLCChannelToBeSetupItem ::= SEQUENCE
SRSASN_CODE uu_rlc_ch_to_be_setup_item_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.pack(bref));
  HANDLE_CODE(uu_rlc_ch_qos_info.pack(bref));
  HANDLE_CODE(rlc_mode.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE uu_rlc_ch_to_be_setup_item_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(uu_rlc_ch_id.unpack(bref));
  HANDLE_CODE(uu_rlc_ch_qos_info.unpack(bref));
  HANDLE_CODE(rlc_mode.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void uu_rlc_ch_to_be_setup_item_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("uuRLCChannelID", uu_rlc_ch_id.to_string());
  j.write_fieldname("uuRLCChannelQoSInformation");
  uu_rlc_ch_qos_info.to_json(j);
  j.write_str("rLCMode", rlc_mode.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// VehicleUE ::= ENUMERATED
const char* vehicle_ue_opts::to_string() const
{
  static const char* names[] = {"authorized", "not-authorized"};
  return convert_enum_idx(names, 2, value, "vehicle_ue_e");
}

// ActivationRequestType ::= ENUMERATED
const char* activation_request_type_opts::to_string() const
{
  static const char* names[] = {"activate", "deactivate"};
  return convert_enum_idx(names, 2, value, "activation_request_type_e");
}

// CG-SDTKeptIndicator ::= ENUMERATED
const char* cg_sdt_kept_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "cg_sdt_kept_ind_e");
}

// CG-SDTQueryIndication ::= ENUMERATED
const char* cg_sdt_query_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "cg_sdt_query_ind_e");
}

// Cancel-all-Warning-Messages-Indicator ::= ENUMERATED
const char* cancel_all_warning_msgs_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "cancel_all_warning_msgs_ind_e");
}

// DAPS-HO-Status ::= ENUMERATED
const char* daps_ho_status_opts::to_string() const
{
  static const char* names[] = {"initiation"};
  return convert_enum_idx(names, 1, value, "daps_ho_status_e");
}

// DRXConfigurationIndicator ::= ENUMERATED
const char* drx_cfg_ind_opts::to_string() const
{
  static const char* names[] = {"release"};
  return convert_enum_idx(names, 1, value, "drx_cfg_ind_e");
}

// F1CTransferPath ::= SEQUENCE
SRSASN_CODE f1_c_transfer_path_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(f1_cp_ath_nsa.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE f1_c_transfer_path_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(f1_cp_ath_nsa.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void f1_c_transfer_path_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("f1CPathNSA", f1_cp_ath_nsa.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// F1CTransferPathNRDC ::= SEQUENCE
SRSASN_CODE f1_c_transfer_path_nr_dc_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(f1_cp_ath_nr_dc.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE f1_c_transfer_path_nr_dc_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(f1_cp_ath_nr_dc.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void f1_c_transfer_path_nr_dc_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("f1CPathNRDC", f1_cp_ath_nr_dc.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FiveG-ProSeAuthorized ::= SEQUENCE
SRSASN_CODE five_g_pro_se_authorized_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(five_g_pro_se_direct_discovery_present, 1));
  HANDLE_CODE(bref.pack(five_g_pro_se_direct_communication_present, 1));
  HANDLE_CODE(bref.pack(five_g_pro_se_layer2_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.pack(five_g_pro_se_layer3_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.pack(five_g_pro_se_layer2_remote_ue_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (five_g_pro_se_direct_discovery_present) {
    HANDLE_CODE(five_g_pro_se_direct_discovery.pack(bref));
  }
  if (five_g_pro_se_direct_communication_present) {
    HANDLE_CODE(five_g_pro_se_direct_communication.pack(bref));
  }
  if (five_g_pro_se_layer2_ue_to_network_relay_present) {
    HANDLE_CODE(five_g_pro_se_layer2_ue_to_network_relay.pack(bref));
  }
  if (five_g_pro_se_layer3_ue_to_network_relay_present) {
    HANDLE_CODE(five_g_pro_se_layer3_ue_to_network_relay.pack(bref));
  }
  if (five_g_pro_se_layer2_remote_ue_present) {
    HANDLE_CODE(five_g_pro_se_layer2_remote_ue.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE five_g_pro_se_authorized_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(five_g_pro_se_direct_discovery_present, 1));
  HANDLE_CODE(bref.unpack(five_g_pro_se_direct_communication_present, 1));
  HANDLE_CODE(bref.unpack(five_g_pro_se_layer2_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.unpack(five_g_pro_se_layer3_ue_to_network_relay_present, 1));
  HANDLE_CODE(bref.unpack(five_g_pro_se_layer2_remote_ue_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (five_g_pro_se_direct_discovery_present) {
    HANDLE_CODE(five_g_pro_se_direct_discovery.unpack(bref));
  }
  if (five_g_pro_se_direct_communication_present) {
    HANDLE_CODE(five_g_pro_se_direct_communication.unpack(bref));
  }
  if (five_g_pro_se_layer2_ue_to_network_relay_present) {
    HANDLE_CODE(five_g_pro_se_layer2_ue_to_network_relay.unpack(bref));
  }
  if (five_g_pro_se_layer3_ue_to_network_relay_present) {
    HANDLE_CODE(five_g_pro_se_layer3_ue_to_network_relay.unpack(bref));
  }
  if (five_g_pro_se_layer2_remote_ue_present) {
    HANDLE_CODE(five_g_pro_se_layer2_remote_ue.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void five_g_pro_se_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (five_g_pro_se_direct_discovery_present) {
    j.write_str("fiveG-proSeDirectDiscovery", five_g_pro_se_direct_discovery.to_string());
  }
  if (five_g_pro_se_direct_communication_present) {
    j.write_str("fiveG-proSeDirectCommunication", five_g_pro_se_direct_communication.to_string());
  }
  if (five_g_pro_se_layer2_ue_to_network_relay_present) {
    j.write_str("fiveG-ProSeLayer2UEtoNetworkRelay", five_g_pro_se_layer2_ue_to_network_relay.to_string());
  }
  if (five_g_pro_se_layer3_ue_to_network_relay_present) {
    j.write_str("fiveG-ProSeLayer3UEtoNetworkRelay", five_g_pro_se_layer3_ue_to_network_relay.to_string());
  }
  if (five_g_pro_se_layer2_remote_ue_present) {
    j.write_str("fiveG-ProSeLayer2RemoteUE", five_g_pro_se_layer2_remote_ue.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// FullConfiguration ::= ENUMERATED
const char* full_cfg_opts::to_string() const
{
  static const char* names[] = {"full"};
  return convert_enum_idx(names, 1, value, "full_cfg_e");
}

// GNB-DUConfigurationQuery ::= ENUMERATED
const char* gnb_du_cfg_query_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "gnb_du_cfg_query_e");
}

// GNBDUOverloadInformation ::= ENUMERATED
const char* gnb_du_overload_info_opts::to_string() const
{
  static const char* names[] = {"overloaded", "not-overloaded"};
  return convert_enum_idx(names, 2, value, "gnb_du_overload_info_e");
}

// HardwareLoadIndicator ::= SEQUENCE
SRSASN_CODE hardware_load_ind_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_hardware_load_ind, (uint8_t)0u, (uint8_t)100u, true, true));
  HANDLE_CODE(pack_integer(bref, ul_hardware_load_ind, (uint8_t)0u, (uint8_t)100u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE hardware_load_ind_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_hardware_load_ind, bref, (uint8_t)0u, (uint8_t)100u, true, true));
  HANDLE_CODE(unpack_integer(ul_hardware_load_ind, bref, (uint8_t)0u, (uint8_t)100u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void hardware_load_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dLHardwareLoadIndicator", dl_hardware_load_ind);
  j.write_int("uLHardwareLoadIndicator", ul_hardware_load_ind);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IAB-TNL-Addresses-Exception ::= SEQUENCE
SRSASN_CODE iab_tnl_addresses_exception_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, iab_tnl_address_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_tnl_addresses_exception_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(iab_tnl_address_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_tnl_addresses_exception_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("iABTNLAddressList");
  for (const auto& e1 : iab_tnl_address_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IABConditionalRRCMessageDeliveryIndication ::= ENUMERATED
const char* iab_conditional_rrc_msg_delivery_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "iab_conditional_rrc_msg_delivery_ind_e");
}

// IABCongestionIndication ::= SEQUENCE
SRSASN_CODE iab_congestion_ind_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, iab_congestion_ind_list, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_congestion_ind_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(iab_congestion_ind_list, bref, 1, 1024, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void iab_congestion_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("iAB-Congestion-Indication-List");
  for (const auto& e1 : iab_congestion_ind_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IABIPv6RequestType ::= CHOICE
void iab_ip_v6_request_type_c::destroy_()
{
  switch (type_) {
    case types::ip_v6_address:
      c.destroy<iab_tnl_addresses_requested_s>();
      break;
    case types::ip_v6_prefix:
      c.destroy<iab_tnl_addresses_requested_s>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void iab_ip_v6_request_type_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ip_v6_address:
      c.init<iab_tnl_addresses_requested_s>();
      break;
    case types::ip_v6_prefix:
      c.init<iab_tnl_addresses_requested_s>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_ip_v6_request_type_c");
  }
}
iab_ip_v6_request_type_c::iab_ip_v6_request_type_c(const iab_ip_v6_request_type_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ip_v6_address:
      c.init(other.c.get<iab_tnl_addresses_requested_s>());
      break;
    case types::ip_v6_prefix:
      c.init(other.c.get<iab_tnl_addresses_requested_s>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_ip_v6_request_type_c");
  }
}
iab_ip_v6_request_type_c& iab_ip_v6_request_type_c::operator=(const iab_ip_v6_request_type_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ip_v6_address:
      c.set(other.c.get<iab_tnl_addresses_requested_s>());
      break;
    case types::ip_v6_prefix:
      c.set(other.c.get<iab_tnl_addresses_requested_s>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "iab_ip_v6_request_type_c");
  }

  return *this;
}
iab_tnl_addresses_requested_s& iab_ip_v6_request_type_c::set_ip_v6_address()
{
  set(types::ip_v6_address);
  return c.get<iab_tnl_addresses_requested_s>();
}
iab_tnl_addresses_requested_s& iab_ip_v6_request_type_c::set_ip_v6_prefix()
{
  set(types::ip_v6_prefix);
  return c.get<iab_tnl_addresses_requested_s>();
}
protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>& iab_ip_v6_request_type_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>();
}
void iab_ip_v6_request_type_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ip_v6_address:
      j.write_fieldname("iPv6Address");
      c.get<iab_tnl_addresses_requested_s>().to_json(j);
      break;
    case types::ip_v6_prefix:
      j.write_fieldname("iPv6Prefix");
      c.get<iab_tnl_addresses_requested_s>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "iab_ip_v6_request_type_c");
  }
  j.end_obj();
}
SRSASN_CODE iab_ip_v6_request_type_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ip_v6_address:
      HANDLE_CODE(c.get<iab_tnl_addresses_requested_s>().pack(bref));
      break;
    case types::ip_v6_prefix:
      HANDLE_CODE(c.get<iab_tnl_addresses_requested_s>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_ip_v6_request_type_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE iab_ip_v6_request_type_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ip_v6_address:
      HANDLE_CODE(c.get<iab_tnl_addresses_requested_s>().unpack(bref));
      break;
    case types::ip_v6_prefix:
      HANDLE_CODE(c.get<iab_tnl_addresses_requested_s>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<iab_ip_v6_request_type_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "iab_ip_v6_request_type_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* iab_ip_v6_request_type_c::types_opts::to_string() const
{
  static const char* names[] = {"iPv6Address", "iPv6Prefix", "choice-extension"};
  return convert_enum_idx(names, 3, value, "iab_ip_v6_request_type_c::types");
}

// IABv4AddressesRequested ::= SEQUENCE
SRSASN_CODE ia_bv4_addresses_requested_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ia_bv4_addresses_requested.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ia_bv4_addresses_requested_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ia_bv4_addresses_requested.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ia_bv4_addresses_requested_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("iABv4AddressesRequested");
  ia_bv4_addresses_requested.to_json(j);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// IgnoreResourceCoordinationContainer ::= ENUMERATED
const char* ignore_res_coordination_container_opts::to_string() const
{
  static const char* names[] = {"yes"};
  return convert_enum_idx(names, 1, value, "ignore_res_coordination_container_e");
}

// InactivityMonitoringRequest ::= ENUMERATED
const char* inactivity_monitoring_request_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "inactivity_monitoring_request_e");
}

// InactivityMonitoringResponse ::= ENUMERATED
const char* inactivity_monitoring_resp_opts::to_string() const
{
  static const char* names[] = {"not-supported"};
  return convert_enum_idx(names, 1, value, "inactivity_monitoring_resp_e");
}

// LTEUESidelinkAggregateMaximumBitrate ::= SEQUENCE
SRSASN_CODE lte_ue_sidelink_aggr_max_bitrate_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ue_lte_sidelink_aggr_max_bitrate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE lte_ue_sidelink_aggr_max_bitrate_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(
      unpack_integer(ue_lte_sidelink_aggr_max_bitrate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void lte_ue_sidelink_aggr_max_bitrate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uELTESidelinkAggregateMaximumBitrate", ue_lte_sidelink_aggr_max_bitrate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LTEV2XServicesAuthorized ::= SEQUENCE
SRSASN_CODE ltev2x_services_authorized_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.pack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.pack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ltev2x_services_authorized_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.unpack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.unpack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ltev2x_services_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (vehicle_ue_present) {
    j.write_str("vehicleUE", vehicle_ue.to_string());
  }
  if (pedestrian_ue_present) {
    j.write_str("pedestrianUE", pedestrian_ue.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// LowerLayerPresenceStatusChange ::= ENUMERATED
const char* lower_layer_presence_status_change_opts::to_string() const
{
  static const char* names[] = {"suspend-lower-layers", "resume-lower-layers"};
  return convert_enum_idx(names, 2, value, "lower_layer_presence_status_change_e");
}

// MBSMulticastF1UContextDescriptor ::= SEQUENCE
SRSASN_CODE mbs_multicast_f1_u_context_descriptor_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(mbs_area_session_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(multicast_f1_u_context_ref_f1.pack(bref));
  HANDLE_CODE(mc_f1_u_ctxtusage.pack(bref));
  if (mbs_area_session_present) {
    HANDLE_CODE(pack_integer(bref, mbs_area_session, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE mbs_multicast_f1_u_context_descriptor_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(mbs_area_session_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(multicast_f1_u_context_ref_f1.unpack(bref));
  HANDLE_CODE(mc_f1_u_ctxtusage.unpack(bref));
  if (mbs_area_session_present) {
    HANDLE_CODE(unpack_integer(mbs_area_session, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void mbs_multicast_f1_u_context_descriptor_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("multicastF1UContextReferenceF1", multicast_f1_u_context_ref_f1.to_string());
  j.write_str("mc-F1UCtxtusage", mc_f1_u_ctxtusage.to_string());
  if (mbs_area_session_present) {
    j.write_int("mbsAreaSession", mbs_area_session);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* mbs_multicast_f1_u_context_descriptor_s::mc_f1_u_ctxtusage_opts::to_string() const
{
  static const char* names[] = {"ptm", "ptp", "ptp-retransmission", "ptp-forwarding"};
  return convert_enum_idx(names, 4, value, "mbs_multicast_f1_u_context_descriptor_s::mc_f1_u_ctxtusage_e_");
}

// MDTPollutedMeasurementIndicator ::= ENUMERATED
const char* mdt_polluted_meas_ind_opts::to_string() const
{
  static const char* names[] = {"iDC", "no-IDC"};
  return convert_enum_idx(names, 2, value, "mdt_polluted_meas_ind_e");
}

// MeasurementBeamInfoRequest ::= ENUMERATED
const char* meas_beam_info_request_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "meas_beam_info_request_e");
}

// MeasurementPeriodicityExtended ::= ENUMERATED
const char* meas_periodicity_extended_opts::to_string() const
{
  static const char* names[] = {
      "ms160", "ms320", "ms1280", "ms2560", "ms61440", "ms81920", "ms368640", "ms737280", "ms1843200"};
  return convert_enum_idx(names, 9, value, "meas_periodicity_extended_e");
}
uint32_t meas_periodicity_extended_opts::to_number() const
{
  static const uint32_t numbers[] = {160, 320, 1280, 2560, 61440, 81920, 368640, 737280, 1843200};
  return map_enum_number(numbers, 9, value, "meas_periodicity_extended_e");
}

// MeasurementTimeOccasion ::= ENUMERATED
const char* meas_time_occasion_opts::to_string() const
{
  static const char* names[] = {"o1", "o4"};
  return convert_enum_idx(names, 2, value, "meas_time_occasion_e");
}
uint8_t meas_time_occasion_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 4};
  return map_enum_number(numbers, 2, value, "meas_time_occasion_e");
}

// NRPagingeDRXInformation ::= SEQUENCE
SRSASN_CODE nr_paginge_drx_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(nrpaging_time_win_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nrpaging_e_drx_cycle_idle.pack(bref));
  if (nrpaging_time_win_present) {
    HANDLE_CODE(nrpaging_time_win.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_paginge_drx_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(nrpaging_time_win_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nrpaging_e_drx_cycle_idle.unpack(bref));
  if (nrpaging_time_win_present) {
    HANDLE_CODE(nrpaging_time_win.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_paginge_drx_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nrpaging-eDRX-Cycle-Idle", nrpaging_e_drx_cycle_idle.to_string());
  if (nrpaging_time_win_present) {
    j.write_str("nrpaging-Time-Window", nrpaging_time_win.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRPagingeDRXInformationforRRCINACTIVE ::= SEQUENCE
SRSASN_CODE nr_paginge_drx_infofor_rrc_inactive_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(nrpaging_e_drx_cycle_inactive.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_paginge_drx_infofor_rrc_inactive_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(nrpaging_e_drx_cycle_inactive.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_paginge_drx_infofor_rrc_inactive_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("nrpaging-eDRX-Cycle-Inactive", nrpaging_e_drx_cycle_inactive.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRRedCapUEIndication ::= ENUMERATED
const char* nr_red_cap_ue_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "nr_red_cap_ue_ind_e");
}

// NRUESidelinkAggregateMaximumBitrate ::= SEQUENCE
SRSASN_CODE nr_ue_sidelink_aggr_max_bitrate_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, ue_nr_sidelink_aggr_max_bitrate, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_ue_sidelink_aggr_max_bitrate_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(
      unpack_integer(ue_nr_sidelink_aggr_max_bitrate, bref, (uint64_t)0u, (uint64_t)4000000000000u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_ue_sidelink_aggr_max_bitrate_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("uENRSidelinkAggregateMaximumBitrate", ue_nr_sidelink_aggr_max_bitrate);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NRV2XServicesAuthorized ::= SEQUENCE
SRSASN_CODE nr_v2x_services_authorized_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.pack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.pack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nr_v2x_services_authorized_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(vehicle_ue_present, 1));
  HANDLE_CODE(bref.unpack(pedestrian_ue_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (vehicle_ue_present) {
    HANDLE_CODE(vehicle_ue.unpack(bref));
  }
  if (pedestrian_ue_present) {
    HANDLE_CODE(pedestrian_ue.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void nr_v2x_services_authorized_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (vehicle_ue_present) {
    j.write_str("vehicleUE", vehicle_ue.to_string());
  }
  if (pedestrian_ue_present) {
    j.write_str("pedestrianUE", pedestrian_ue.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// NeedforGap ::= ENUMERATED
const char* needfor_gap_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "needfor_gap_e");
}

// PDCMeasurementPeriodicity ::= ENUMERATED
const char* pdc_meas_periodicity_opts::to_string() const
{
  static const char* names[] = {
      "ms80", "ms120", "ms160", "ms240", "ms320", "ms480", "ms640", "ms1024", "ms1280", "ms2048", "ms2560", "ms5120"};
  return convert_enum_idx(names, 12, value, "pdc_meas_periodicity_e");
}
uint16_t pdc_meas_periodicity_opts::to_number() const
{
  static const uint16_t numbers[] = {80, 120, 160, 240, 320, 480, 640, 1024, 1280, 2048, 2560, 5120};
  return map_enum_number(numbers, 12, value, "pdc_meas_periodicity_e");
}

template struct asn1::protocol_ie_single_container_s<pdc_meas_quantities_item_ies_o>;

// PDCMeasurementResult ::= SEQUENCE
SRSASN_CODE pdc_meas_result_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, pdc_measured_results_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdc_meas_result_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(pdc_measured_results_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pdc_meas_result_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("pDCMeasuredResultsList");
  for (const auto& e1 : pdc_measured_results_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PDCReportType ::= ENUMERATED
const char* pdc_report_type_opts::to_string() const
{
  static const char* names[] = {"onDemand", "periodic"};
  return convert_enum_idx(names, 2, value, "pdc_report_type_e");
}

// PEIPSAssistanceInfo ::= SEQUENCE
SRSASN_CODE pe_ip_s_assist_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, cn_subgroup_id, (uint8_t)0u, (uint8_t)7u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pe_ip_s_assist_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(cn_subgroup_id, bref, (uint8_t)0u, (uint8_t)7u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pe_ip_s_assist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("cNSubgroupID", cn_subgroup_id);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PRSConfigRequestType ::= ENUMERATED
const char* prs_cfg_request_type_opts::to_string() const
{
  static const char* names[] = {"configure", "off"};
  return convert_enum_idx(names, 2, value, "prs_cfg_request_type_e");
}

SRSASN_CODE pws_sys_info_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += notif_info_present ? 1 : 0;
  nof_ies += add_sib_msg_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (notif_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)220, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(notif_info.pack(bref));
  }
  if (add_sib_msg_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)231, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, add_sib_msg_list, 1, 63, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_sys_info_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 220: {
        notif_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(notif_info.unpack(bref));
        break;
      }
      case 231: {
        add_sib_msg_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(add_sib_msg_list, bref, 1, 63, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void pws_sys_info_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (notif_info_present) {
    j.write_int("id", 220);
    j.write_str("criticality", "ignore");
    notif_info.to_json(j);
  }
  if (add_sib_msg_list_present) {
    j.write_int("id", 231);
    j.write_str("criticality", "reject");
    j.start_array("Extension");
    for (const auto& e1 : add_sib_msg_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// PWSSystemInformation ::= SEQUENCE
SRSASN_CODE pws_sys_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, sib_type, (uint8_t)6u, (uint8_t)8u, true, true));
  HANDLE_CODE(sib_msg.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_sys_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(sib_type, bref, (uint8_t)6u, (uint8_t)8u, true, true));
  HANDLE_CODE(sib_msg.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pws_sys_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("sIBtype", sib_type);
  j.write_str("sIBmessage", sib_msg.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PagingCause ::= ENUMERATED
const char* paging_cause_opts::to_string() const
{
  static const char* names[] = {"voice"};
  return convert_enum_idx(names, 1, value, "paging_cause_e");
}

// PagingIdentity ::= CHOICE
void paging_id_c::destroy_()
{
  switch (type_) {
    case types::ran_ue_paging_id:
      c.destroy<ran_ue_paging_id_s>();
      break;
    case types::cn_ue_paging_id:
      c.destroy<cn_ue_paging_id_c>();
      break;
    case types::choice_ext:
      c.destroy<protocol_ie_single_container_s<paging_id_ext_ies_o>>();
      break;
    default:
      break;
  }
}
void paging_id_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_ue_paging_id:
      c.init<ran_ue_paging_id_s>();
      break;
    case types::cn_ue_paging_id:
      c.init<cn_ue_paging_id_c>();
      break;
    case types::choice_ext:
      c.init<protocol_ie_single_container_s<paging_id_ext_ies_o>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_id_c");
  }
}
paging_id_c::paging_id_c(const paging_id_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_ue_paging_id:
      c.init(other.c.get<ran_ue_paging_id_s>());
      break;
    case types::cn_ue_paging_id:
      c.init(other.c.get<cn_ue_paging_id_c>());
      break;
    case types::choice_ext:
      c.init(other.c.get<protocol_ie_single_container_s<paging_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_id_c");
  }
}
paging_id_c& paging_id_c::operator=(const paging_id_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_ue_paging_id:
      c.set(other.c.get<ran_ue_paging_id_s>());
      break;
    case types::cn_ue_paging_id:
      c.set(other.c.get<cn_ue_paging_id_c>());
      break;
    case types::choice_ext:
      c.set(other.c.get<protocol_ie_single_container_s<paging_id_ext_ies_o>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_id_c");
  }

  return *this;
}
ran_ue_paging_id_s& paging_id_c::set_ran_ue_paging_id()
{
  set(types::ran_ue_paging_id);
  return c.get<ran_ue_paging_id_s>();
}
cn_ue_paging_id_c& paging_id_c::set_cn_ue_paging_id()
{
  set(types::cn_ue_paging_id);
  return c.get<cn_ue_paging_id_c>();
}
protocol_ie_single_container_s<paging_id_ext_ies_o>& paging_id_c::set_choice_ext()
{
  set(types::choice_ext);
  return c.get<protocol_ie_single_container_s<paging_id_ext_ies_o>>();
}
void paging_id_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_paging_id:
      j.write_fieldname("rANUEPagingIdentity");
      c.get<ran_ue_paging_id_s>().to_json(j);
      break;
    case types::cn_ue_paging_id:
      j.write_fieldname("cNUEPagingIdentity");
      c.get<cn_ue_paging_id_c>().to_json(j);
      break;
    case types::choice_ext:
      j.write_fieldname("choice-extension");
      c.get<protocol_ie_single_container_s<paging_id_ext_ies_o>>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "paging_id_c");
  }
  j.end_obj();
}
SRSASN_CODE paging_id_c::pack(bit_ref& bref) const
{
  type_.pack(bref);
  switch (type_) {
    case types::ran_ue_paging_id:
      HANDLE_CODE(c.get<ran_ue_paging_id_s>().pack(bref));
      break;
    case types::cn_ue_paging_id:
      HANDLE_CODE(c.get<cn_ue_paging_id_c>().pack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<paging_id_ext_ies_o>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_id_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_id_c::unpack(cbit_ref& bref)
{
  types e;
  e.unpack(bref);
  set(e);
  switch (type_) {
    case types::ran_ue_paging_id:
      HANDLE_CODE(c.get<ran_ue_paging_id_s>().unpack(bref));
      break;
    case types::cn_ue_paging_id:
      HANDLE_CODE(c.get<cn_ue_paging_id_c>().unpack(bref));
      break;
    case types::choice_ext:
      HANDLE_CODE(c.get<protocol_ie_single_container_s<paging_id_ext_ies_o>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_id_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

const char* paging_id_c::types_opts::to_string() const
{
  static const char* names[] = {"rANUEPagingIdentity", "cNUEPagingIdentity", "choice-extension"};
  return convert_enum_idx(names, 3, value, "paging_id_c::types");
}

// PagingOrigin ::= ENUMERATED
const char* paging_origin_opts::to_string() const
{
  static const char* names[] = {"non-3gpp"};
  return convert_enum_idx(names, 1, value, "paging_origin_e");
}
int8_t paging_origin_opts::to_number() const
{
  static const int8_t numbers[] = {-3};
  return map_enum_number(numbers, 1, value, "paging_origin_e");
}

// PagingPriority ::= ENUMERATED
const char* paging_prio_opts::to_string() const
{
  static const char* names[] = {
      "priolevel1", "priolevel2", "priolevel3", "priolevel4", "priolevel5", "priolevel6", "priolevel7", "priolevel8"};
  return convert_enum_idx(names, 8, value, "paging_prio_e");
}
uint8_t paging_prio_opts::to_number() const
{
  static const uint8_t numbers[] = {1, 2, 3, 4, 5, 6, 7, 8};
  return map_enum_number(numbers, 8, value, "paging_prio_e");
}

// PathSwitchConfiguration ::= SEQUENCE
SRSASN_CODE path_switch_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(target_relay_ue_id.pack(bref));
  HANDLE_CODE(pack_integer(bref, remote_ue_local_id, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(t420.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(target_relay_ue_id.unpack(bref));
  HANDLE_CODE(unpack_integer(remote_ue_local_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  HANDLE_CODE(t420.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void path_switch_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("targetRelayUEID", target_relay_ue_id.to_string());
  j.write_int("remoteUELocalID", remote_ue_local_id);
  j.write_str("t420", t420.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* path_switch_cfg_s::t420_opts::to_string() const
{
  static const char* names[] = {"ms50", "ms100", "ms150", "ms200", "ms500", "ms1000", "ms2000", "ms10000"};
  return convert_enum_idx(names, 8, value, "path_switch_cfg_s::t420_e_");
}
uint16_t path_switch_cfg_s::t420_opts::to_number() const
{
  static const uint16_t numbers[] = {50, 100, 150, 200, 500, 1000, 2000, 10000};
  return map_enum_number(numbers, 8, value, "path_switch_cfg_s::t420_e_");
}

// PosBroadcast ::= ENUMERATED
const char* pos_broadcast_opts::to_string() const
{
  static const char* names[] = {"start", "stop"};
  return convert_enum_idx(names, 2, value, "pos_broadcast_e");
}

// PosConextRevIndication ::= ENUMERATED
const char* pos_conext_rev_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "pos_conext_rev_ind_e");
}

// PosMeasGapPreConfigList ::= SEQUENCE
SRSASN_CODE pos_meas_gap_pre_cfg_list_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(pos_meas_gap_pre_cfg_to_add_mod_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(pos_meas_gap_pre_cfg_to_release_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (pos_meas_gap_pre_cfg_to_add_mod_list.size() > 0) {
    HANDLE_CODE(pos_meas_gap_pre_cfg_to_add_mod_list.pack(bref));
  }
  if (pos_meas_gap_pre_cfg_to_release_list.size() > 0) {
    HANDLE_CODE(pos_meas_gap_pre_cfg_to_release_list.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pos_meas_gap_pre_cfg_list_s::unpack(cbit_ref& bref)
{
  bool pos_meas_gap_pre_cfg_to_add_mod_list_present;
  HANDLE_CODE(bref.unpack(pos_meas_gap_pre_cfg_to_add_mod_list_present, 1));
  bool pos_meas_gap_pre_cfg_to_release_list_present;
  HANDLE_CODE(bref.unpack(pos_meas_gap_pre_cfg_to_release_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (pos_meas_gap_pre_cfg_to_add_mod_list_present) {
    HANDLE_CODE(pos_meas_gap_pre_cfg_to_add_mod_list.unpack(bref));
  }
  if (pos_meas_gap_pre_cfg_to_release_list_present) {
    HANDLE_CODE(pos_meas_gap_pre_cfg_to_release_list.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void pos_meas_gap_pre_cfg_list_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (pos_meas_gap_pre_cfg_to_add_mod_list.size() > 0) {
    j.write_str("posMeasGapPreConfigToAddModList", pos_meas_gap_pre_cfg_to_add_mod_list.to_string());
  }
  if (pos_meas_gap_pre_cfg_to_release_list.size() > 0) {
    j.write_str("posMeasGapPreConfigToReleaseList", pos_meas_gap_pre_cfg_to_release_list.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// PosMeasurementAmount ::= ENUMERATED
const char* pos_meas_amount_opts::to_string() const
{
  static const char* names[] = {"ma0", "ma1", "ma2", "ma4", "ma8", "ma16", "ma32", "ma64"};
  return convert_enum_idx(names, 8, value, "pos_meas_amount_e");
}
uint8_t pos_meas_amount_opts::to_number() const
{
  static const uint8_t numbers[] = {0, 1, 2, 4, 8, 16, 32, 64};
  return map_enum_number(numbers, 8, value, "pos_meas_amount_e");
}

// PosReportCharacteristics ::= ENUMERATED
const char* pos_report_characteristics_opts::to_string() const
{
  static const char* names[] = {"ondemand", "periodic"};
  return convert_enum_idx(names, 2, value, "pos_report_characteristics_e");
}

// QoEInformation ::= SEQUENCE
SRSASN_CODE qo_e_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, qo_e_info_list, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE qo_e_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(qo_e_info_list, bref, 1, 16, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void qo_e_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("qoEInformationList");
  for (const auto& e1 : qo_e_info_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RLCFailureIndication ::= SEQUENCE
SRSASN_CODE rlc_fail_ind_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, assocated_lcid, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rlc_fail_ind_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(assocated_lcid, bref, (uint8_t)1u, (uint8_t)32u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rlc_fail_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("assocatedLCID", assocated_lcid);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RRC-Version ::= SEQUENCE
SRSASN_CODE rrc_version_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  HANDLE_CODE(latest_rrc_version.pack(bref));
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_version_s::unpack(cbit_ref& bref)
{
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(latest_rrc_version.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void rrc_version_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("latest-RRC-Version", latest_rrc_version.to_string());
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

// RRCDeliveryStatus ::= SEQUENCE
SRSASN_CODE rrc_delivery_status_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, delivery_status, (uint16_t)0u, (uint16_t)4095u, false, true));
  HANDLE_CODE(pack_integer(bref, trigger_msg, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_delivery_status_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(delivery_status, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  HANDLE_CODE(unpack_integer(trigger_msg, bref, (uint16_t)0u, (uint16_t)4095u, false, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void rrc_delivery_status_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("delivery-status", delivery_status);
  j.write_int("triggering-message", trigger_msg);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RRCReconfigurationCompleteIndicator ::= ENUMERATED
const char* rrc_recfg_complete_ind_opts::to_string() const
{
  static const char* names[] = {"true", "failure"};
  return convert_enum_idx(names, 2, value, "rrc_recfg_complete_ind_e");
}

// RegistrationRequest ::= ENUMERATED
const char* regist_request_opts::to_string() const
{
  static const char* names[] = {"start", "stop", "add"};
  return convert_enum_idx(names, 3, value, "regist_request_e");
}

// ReportingPeriodicity ::= ENUMERATED
const char* report_periodicity_opts::to_string() const
{
  static const char* names[] = {"ms500", "ms1000", "ms2000", "ms5000", "ms10000"};
  return convert_enum_idx(names, 5, value, "report_periodicity_e");
}
uint16_t report_periodicity_opts::to_number() const
{
  static const uint16_t numbers[] = {500, 1000, 2000, 5000, 10000};
  return map_enum_number(numbers, 5, value, "report_periodicity_e");
}

// ReportingRequestType ::= SEQUENCE
SRSASN_CODE report_request_type_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(report_periodicity_value_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(event_type.pack(bref));
  if (report_periodicity_value_present) {
    HANDLE_CODE(pack_integer(bref, report_periodicity_value, (uint16_t)0u, (uint16_t)512u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE report_request_type_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(report_periodicity_value_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(event_type.unpack(bref));
  if (report_periodicity_value_present) {
    HANDLE_CODE(unpack_integer(report_periodicity_value, bref, (uint16_t)0u, (uint16_t)512u, true, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void report_request_type_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("eventType", event_type.to_string());
  if (report_periodicity_value_present) {
    j.write_int("reportingPeriodicityValue", report_periodicity_value);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// RequestType ::= ENUMERATED
const char* request_type_opts::to_string() const
{
  static const char* names[] = {"offer", "execution"};
  return convert_enum_idx(names, 2, value, "request_type_e");
}

// RequestedSRSTransmissionCharacteristics ::= SEQUENCE
SRSASN_CODE requested_srs_tx_characteristics_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(nof_txs_present, 1));
  HANDLE_CODE(bref.pack(srs_res_set_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ssb_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts.size() > 0, 1));

  if (nof_txs_present) {
    HANDLE_CODE(pack_integer(bref, nof_txs, (uint16_t)0u, (uint16_t)500u, true, true));
  }
  HANDLE_CODE(res_type.pack(bref));
  HANDLE_CODE(bw_srs.pack(bref));
  if (srs_res_set_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, srs_res_set_list, 1, 16, true));
  }
  if (ssb_info_present) {
    HANDLE_CODE(ssb_info.pack(bref));
  }
  if (ie_exts.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_exts, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE requested_srs_tx_characteristics_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(nof_txs_present, 1));
  bool srs_res_set_list_present;
  HANDLE_CODE(bref.unpack(srs_res_set_list_present, 1));
  HANDLE_CODE(bref.unpack(ssb_info_present, 1));
  bool ie_exts_present;
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (nof_txs_present) {
    HANDLE_CODE(unpack_integer(nof_txs, bref, (uint16_t)0u, (uint16_t)500u, true, true));
  }
  HANDLE_CODE(res_type.unpack(bref));
  HANDLE_CODE(bw_srs.unpack(bref));
  if (srs_res_set_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(srs_res_set_list, bref, 1, 16, true));
  }
  if (ssb_info_present) {
    HANDLE_CODE(ssb_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_exts, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void requested_srs_tx_characteristics_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (nof_txs_present) {
    j.write_int("numberOfTransmissions", nof_txs);
  }
  j.write_str("resourceType", res_type.to_string());
  j.write_fieldname("bandwidthSRS");
  bw_srs.to_json(j);
  if (srs_res_set_list.size() > 0) {
    j.start_array("sRSResourceSetList");
    for (const auto& e1 : srs_res_set_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ssb_info_present) {
    j.write_fieldname("sSBInformation");
    ssb_info.to_json(j);
  }
  if (ie_exts.size() > 0) {
    j.write_fieldname("iE-Extensions");
  }
  j.end_obj();
}

const char* requested_srs_tx_characteristics_s::res_type_opts::to_string() const
{
  static const char* names[] = {"periodic", "semi-persistent", "aperiodic"};
  return convert_enum_idx(names, 3, value, "requested_srs_tx_characteristics_s::res_type_e_");
}

// ResourceCoordinationTransferInformation ::= SEQUENCE
SRSASN_CODE res_coordination_transfer_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(res_coordination_eutra_cell_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(m_enb_cell_id.pack(bref));
  if (res_coordination_eutra_cell_info_present) {
    HANDLE_CODE(res_coordination_eutra_cell_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE res_coordination_transfer_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(res_coordination_eutra_cell_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(m_enb_cell_id.unpack(bref));
  if (res_coordination_eutra_cell_info_present) {
    HANDLE_CODE(res_coordination_eutra_cell_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void res_coordination_transfer_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("meNB-Cell-ID", m_enb_cell_id.to_string());
  if (res_coordination_eutra_cell_info_present) {
    j.write_fieldname("resourceCoordinationEUTRACellInfo");
    res_coordination_eutra_cell_info.to_json(j);
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// ResponseTime ::= SEQUENCE
SRSASN_CODE resp_time_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, time, (uint8_t)1u, (uint8_t)128u, true, true));
  HANDLE_CODE(time_unit.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE resp_time_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(time, bref, (uint8_t)1u, (uint8_t)128u, true, true));
  HANDLE_CODE(time_unit.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void resp_time_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("time", time);
  j.write_str("timeUnit", time_unit.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* resp_time_s::time_unit_opts::to_string() const
{
  static const char* names[] = {"second", "ten-seconds", "ten-milliseconds"};
  return convert_enum_idx(names, 3, value, "resp_time_s::time_unit_e_");
}

// SCGActivationRequest ::= ENUMERATED
const char* scg_activation_request_opts::to_string() const
{
  static const char* names[] = {"activate-scg", "deactivate-scg"};
  return convert_enum_idx(names, 2, value, "scg_activation_request_e");
}

// SCGActivationStatus ::= ENUMERATED
const char* scg_activation_status_opts::to_string() const
{
  static const char* names[] = {"scg-activated", "scg-deactivated"};
  return convert_enum_idx(names, 2, value, "scg_activation_status_e");
}

// SCGIndicator ::= ENUMERATED
const char* scg_ind_opts::to_string() const
{
  static const char* names[] = {"released"};
  return convert_enum_idx(names, 1, value, "scg_ind_e");
}

// SDT-Termination-Request ::= ENUMERATED
const char* sdt_termination_request_opts::to_string() const
{
  static const char* names[] = {"radio-link-problem", "normal"};
  return convert_enum_idx(names, 2, value, "sdt_termination_request_e");
}

// SDTBearerConfigurationInfo ::= SEQUENCE
SRSASN_CODE sdt_bearer_cfg_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, sdt_bearer_cfg_list, 1, 72, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sdt_bearer_cfg_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(sdt_bearer_cfg_list, bref, 1, 72, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sdt_bearer_cfg_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("sDTBearerConfig-List");
  for (const auto& e1 : sdt_bearer_cfg_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// SDTBearerConfigurationQueryIndication ::= ENUMERATED
const char* sdt_bearer_cfg_query_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sdt_bearer_cfg_query_ind_e");
}

// SDTInformation ::= SEQUENCE
SRSASN_CODE sdt_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(sdt_assistant_info_present, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(sdt_ind.pack(bref));
  if (sdt_assistant_info_present) {
    HANDLE_CODE(sdt_assistant_info.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sdt_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(sdt_assistant_info_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(sdt_ind.unpack(bref));
  if (sdt_assistant_info_present) {
    HANDLE_CODE(sdt_assistant_info.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sdt_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("sdtIndicator", "true");
  if (sdt_assistant_info_present) {
    j.write_str("sdtAssistantInformation", sdt_assistant_info.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* sdt_info_s::sdt_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sdt_info_s::sdt_ind_e_");
}

const char* sdt_info_s::sdt_assistant_info_opts::to_string() const
{
  static const char* names[] = {"singlepacket", "multiplepackets"};
  return convert_enum_idx(names, 2, value, "sdt_info_s::sdt_assistant_info_e_");
}

// SRSPosRRCInactiveQueryIndication ::= ENUMERATED
const char* srs_pos_rrc_inactive_query_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "srs_pos_rrc_inactive_query_ind_e");
}

// SULAccessIndication ::= ENUMERATED
const char* sul_access_ind_opts::to_string() const
{
  static const char* names[] = {"true"};
  return convert_enum_idx(names, 1, value, "sul_access_ind_e");
}

// SidelinkRelayConfiguration ::= SEQUENCE
SRSASN_CODE sidelink_relay_cfg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(sidelink_cfg_container.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, gnb_du_ue_f1ap_id_of_relay_ue, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  HANDLE_CODE(pack_integer(bref, remote_ue_local_id, (uint16_t)0u, (uint16_t)255u, true, true));
  if (sidelink_cfg_container.size() > 0) {
    HANDLE_CODE(sidelink_cfg_container.pack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE sidelink_relay_cfg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  bool sidelink_cfg_container_present;
  HANDLE_CODE(bref.unpack(sidelink_cfg_container_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(gnb_du_ue_f1ap_id_of_relay_ue, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  HANDLE_CODE(unpack_integer(remote_ue_local_id, bref, (uint16_t)0u, (uint16_t)255u, true, true));
  if (sidelink_cfg_container_present) {
    HANDLE_CODE(sidelink_cfg_container.unpack(bref));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void sidelink_relay_cfg_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("gNB-DU-UE-F1APIDofRelayUE", gnb_du_ue_f1ap_id_of_relay_ue);
  j.write_int("remoteUELocalID", remote_ue_local_id);
  if (sidelink_cfg_container.size() > 0) {
    j.write_str("sidelinkConfigurationContainer", sidelink_cfg_container.to_string());
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TNLCapacityIndicator ::= SEQUENCE
SRSASN_CODE tnl_capacity_ind_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_integer(bref, dl_tnl_offered_capacity, (uint32_t)1u, (uint32_t)16777216u, true, true));
  HANDLE_CODE(pack_integer(bref, dl_tnl_available_capacity, (uint8_t)0u, (uint8_t)100u, true, true));
  HANDLE_CODE(pack_integer(bref, ul_tnl_offered_capacity, (uint32_t)1u, (uint32_t)16777216u, true, true));
  HANDLE_CODE(pack_integer(bref, ul_tnl_available_capacity, (uint8_t)0u, (uint8_t)100u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE tnl_capacity_ind_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_integer(dl_tnl_offered_capacity, bref, (uint32_t)1u, (uint32_t)16777216u, true, true));
  HANDLE_CODE(unpack_integer(dl_tnl_available_capacity, bref, (uint8_t)0u, (uint8_t)100u, true, true));
  HANDLE_CODE(unpack_integer(ul_tnl_offered_capacity, bref, (uint32_t)1u, (uint32_t)16777216u, true, true));
  HANDLE_CODE(unpack_integer(ul_tnl_available_capacity, bref, (uint8_t)0u, (uint8_t)100u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void tnl_capacity_ind_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("dLTNLOfferedCapacity", dl_tnl_offered_capacity);
  j.write_int("dLTNLAvailableCapacity", dl_tnl_available_capacity);
  j.write_int("uLTNLOfferedCapacity", ul_tnl_offered_capacity);
  j.write_int("uLTNLAvailableCapacity", ul_tnl_available_capacity);
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TimeReferenceInformation ::= SEQUENCE
SRSASN_CODE time_ref_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(ref_time.pack(bref));
  HANDLE_CODE(pack_integer(bref, ref_sfn, (uint16_t)0u, (uint16_t)1023u, false, true));
  HANDLE_CODE(pack_integer(bref, uncertainty, (uint16_t)0u, (uint16_t)32767u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE time_ref_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(ref_time.unpack(bref));
  HANDLE_CODE(unpack_integer(ref_sfn, bref, (uint16_t)0u, (uint16_t)1023u, false, true));
  HANDLE_CODE(unpack_integer(uncertainty, bref, (uint16_t)0u, (uint16_t)32767u, true, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void time_ref_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("referenceTime", ref_time.to_string());
  j.write_int("referenceSFN", ref_sfn);
  j.write_int("uncertainty", uncertainty);
  j.write_str("timeInformationType", "localClock");
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE trace_activation_ext_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += mdt_cfg_present ? 1 : 0;
  nof_ies += trace_collection_entity_uri_present ? 1 : 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  if (mdt_cfg_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)381, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mdt_cfg.pack(bref));
  }
  if (trace_collection_entity_uri_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)380, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trace_collection_entity_uri.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_ext_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 381: {
        mdt_cfg_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mdt_cfg.unpack(bref));
        break;
      }
      case 380: {
        trace_collection_entity_uri_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_collection_entity_uri.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void trace_activation_ext_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (mdt_cfg_present) {
    j.write_int("id", 381);
    j.write_str("criticality", "ignore");
    mdt_cfg.to_json(j);
  }
  if (trace_collection_entity_uri_present) {
    j.write_int("id", 380);
    j.write_str("criticality", "ignore");
    j.write_str("Extension", trace_collection_entity_uri.to_string());
  }
  j.end_obj();
}

// TraceActivation ::= SEQUENCE
SRSASN_CODE trace_activation_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(trace_id.pack(bref));
  HANDLE_CODE(interfaces_to_trace.pack(bref));
  HANDLE_CODE(trace_depth.pack(bref));
  HANDLE_CODE(trace_collection_entity_ip_address.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_activation_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(trace_id.unpack(bref));
  HANDLE_CODE(interfaces_to_trace.unpack(bref));
  HANDLE_CODE(trace_depth.unpack(bref));
  HANDLE_CODE(trace_collection_entity_ip_address.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void trace_activation_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("traceID", trace_id.to_string());
  j.write_str("interfacesToTrace", interfaces_to_trace.to_string());
  j.write_str("traceDepth", trace_depth.to_string());
  j.write_str("traceCollectionEntityIPAddress", trace_collection_entity_ip_address.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// TransmissionActionIndicator ::= ENUMERATED
const char* tx_action_ind_opts::to_string() const
{
  static const char* names[] = {"stop", "restart"};
  return convert_enum_idx(names, 2, value, "tx_action_ind_e");
}

// Transport-Layer-Address-Info ::= SEQUENCE
SRSASN_CODE transport_layer_address_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(transport_up_layer_address_info_to_add_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(transport_up_layer_address_info_to_rem_list.size() > 0, 1));
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  if (transport_up_layer_address_info_to_add_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, transport_up_layer_address_info_to_add_list, 1, 16, true));
  }
  if (transport_up_layer_address_info_to_rem_list.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, transport_up_layer_address_info_to_rem_list, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE transport_layer_address_info_s::unpack(cbit_ref& bref)
{
  bool transport_up_layer_address_info_to_add_list_present;
  HANDLE_CODE(bref.unpack(transport_up_layer_address_info_to_add_list_present, 1));
  bool transport_up_layer_address_info_to_rem_list_present;
  HANDLE_CODE(bref.unpack(transport_up_layer_address_info_to_rem_list_present, 1));
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  if (transport_up_layer_address_info_to_add_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(transport_up_layer_address_info_to_add_list, bref, 1, 16, true));
  }
  if (transport_up_layer_address_info_to_rem_list_present) {
    HANDLE_CODE(unpack_dyn_seq_of(transport_up_layer_address_info_to_rem_list, bref, 1, 16, true));
  }
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void transport_layer_address_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (transport_up_layer_address_info_to_add_list.size() > 0) {
    j.start_array("transport-UP-Layer-Address-Info-To-Add-List");
    for (const auto& e1 : transport_up_layer_address_info_to_add_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (transport_up_layer_address_info_to_rem_list.size() > 0) {
    j.start_array("transport-UP-Layer-Address-Info-To-Remove-List");
    for (const auto& e1 : transport_up_layer_address_info_to_rem_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UAC-Assistance-Info ::= SEQUENCE
SRSASN_CODE uac_assist_info_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, uac_plmn_list, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE uac_assist_info_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(uac_plmn_list, bref, 1, 12, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void uac_assist_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("uACPLMN-List");
  for (const auto& e1 : uac_plmn_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

// UEPagingCapability ::= SEQUENCE
SRSASN_CODE ue_paging_cap_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(inactive_state_po_determination_present, 1));
  HANDLE_CODE(bref.pack(ie_ext.size() > 0, 1));

  if (inactive_state_po_determination_present) {
    HANDLE_CODE(inactive_state_po_determination.pack(bref));
  }
  if (ie_ext.size() > 0) {
    HANDLE_CODE(pack_dyn_seq_of(bref, ie_ext, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_paging_cap_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(inactive_state_po_determination_present, 1));
  bool ie_ext_present;
  HANDLE_CODE(bref.unpack(ie_ext_present, 1));

  if (inactive_state_po_determination_present) {
    HANDLE_CODE(inactive_state_po_determination.unpack(bref));
  }
  if (ie_ext_present) {
    HANDLE_CODE(unpack_dyn_seq_of(ie_ext, bref, 1, 65535, true));
  }

  return SRSASN_SUCCESS;
}
void ue_paging_cap_s::to_json(json_writer& j) const
{
  j.start_obj();
  if (inactive_state_po_determination_present) {
    j.write_str("iNACTIVEStatePODetermination", "supported");
  }
  if (ie_ext.size() > 0) {
    j.write_fieldname("iE-Extension");
  }
  j.end_obj();
}

const char* ue_paging_cap_s::inactive_state_po_determination_opts::to_string() const
{
  static const char* names[] = {"supported"};
  return convert_enum_idx(names, 1, value, "ue_paging_cap_s::inactive_state_po_determination_e_");
}

// UEReportingInformation ::= SEQUENCE
SRSASN_CODE ue_report_info_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(report_amount.pack(bref));
  HANDLE_CODE(report_interv.pack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_report_info_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(report_amount.unpack(bref));
  HANDLE_CODE(report_interv.unpack(bref));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ue_report_info_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("reportingAmount", report_amount.to_string());
  j.write_str("reportingInterval", report_interv.to_string());
  if (ie_exts_present) {
    j.write_fieldname("iE-extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}

const char* ue_report_info_s::report_amount_opts::to_string() const
{
  static const char* names[] = {"ma0", "ma1", "ma2", "ma4", "ma8", "ma16", "ma32", "ma64"};
  return convert_enum_idx(names, 8, value, "ue_report_info_s::report_amount_e_");
}
uint8_t ue_report_info_s::report_amount_opts::to_number() const
{
  static const uint8_t numbers[] = {0, 1, 2, 4, 8, 16, 32, 64};
  return map_enum_number(numbers, 8, value, "ue_report_info_s::report_amount_e_");
}

const char* ue_report_info_s::report_interv_opts::to_string() const
{
  static const char* names[] = {
      "none", "one", "two", "four", "eight", "ten", "sixteen", "twenty", "thirty-two", "sixty-four"};
  return convert_enum_idx(names, 10, value, "ue_report_info_s::report_interv_e_");
}

// UL-BH-Non-UP-Traffic-Mapping ::= SEQUENCE
SRSASN_CODE ul_bh_non_up_traffic_map_s::pack(bit_ref& bref) const
{
  HANDLE_CODE(bref.pack(ie_exts_present, 1));

  HANDLE_CODE(pack_dyn_seq_of(bref, ul_bh_non_up_traffic_map_list, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_bh_non_up_traffic_map_s::unpack(cbit_ref& bref)
{
  HANDLE_CODE(bref.unpack(ie_exts_present, 1));

  HANDLE_CODE(unpack_dyn_seq_of(ul_bh_non_up_traffic_map_list, bref, 1, 32, true));
  if (ie_exts_present) {
    HANDLE_CODE(ie_exts.unpack(bref));
  }

  return SRSASN_SUCCESS;
}
void ul_bh_non_up_traffic_map_s::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("uL-BH-Non-UP-Traffic-Mapping-List");
  for (const auto& e1 : ul_bh_non_up_traffic_map_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ie_exts_present) {
    j.write_fieldname("iE-Extensions");
    ie_exts.to_json(j);
  }
  j.end_obj();
}
