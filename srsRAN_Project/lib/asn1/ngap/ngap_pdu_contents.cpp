/*
 *
 * Copyright 2021-2023 Software Radio Systems Limited
 *
 * This file is part of srsRAN.
 *
 * srsRAN is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * srsRAN is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * A copy of the GNU Affero General Public License can be found in
 * the LICENSE file in the top-level directory of this distribution
 * and at http://www.gnu.org/licenses/.
 *
 */

#include "srsran/asn1/ngap/ngap_pdu_contents.h"
#include <sstream>

using namespace asn1;
using namespace asn1::ngap;

/*******************************************************************************
 *                                Struct Methods
 ******************************************************************************/

// AMFCPRelocationIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cp_relocation_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 148, 0};
  return map_enum_number(names, 4, idx, "id");
}
bool amf_cp_relocation_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 148, 0};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cp_relocation_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 148:
      return crit_e::ignore;
    case 0:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cp_relocation_ind_ies_o::value_c amf_cp_relocation_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cp_relocation_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 148:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cp_relocation_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::s_nssai:
      c.destroy<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    default:
      break;
  }
}
void amf_cp_relocation_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::s_nssai:
      c.init<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }
}
amf_cp_relocation_ind_ies_o::value_c::value_c(const amf_cp_relocation_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::s_nssai:
      c.init(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }
}
amf_cp_relocation_ind_ies_o::value_c&
amf_cp_relocation_ind_ies_o::value_c::operator=(const amf_cp_relocation_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::s_nssai:
      c.set(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& amf_cp_relocation_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& amf_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
s_nssai_s& amf_cp_relocation_ind_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
allowed_nssai_l& amf_cp_relocation_ind_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const uint64_t& amf_cp_relocation_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& amf_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const s_nssai_s& amf_cp_relocation_ind_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const allowed_nssai_l& amf_cp_relocation_ind_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
void amf_cp_relocation_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cp_relocation_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cp_relocation_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE amf_cp_relocation_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (s_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)148, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cp_relocation_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 148: {
        s_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void amf_cp_relocation_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (s_nssai_present) {
    j.write_int("id", 148);
    j.write_str("criticality", "ignore");
    s_nssai.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_int("id", 0);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : allowed_nssai) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

// AMFConfigurationUpdateIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cfg_upd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {1, 96, 86, 80, 6, 7, 8, 274};
  return map_enum_number(names, 8, idx, "id");
}
bool amf_cfg_upd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {1, 96, 86, 80, 6, 7, 8, 274};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cfg_upd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 1:
      return crit_e::reject;
    case 96:
      return crit_e::reject;
    case 86:
      return crit_e::ignore;
    case 80:
      return crit_e::reject;
    case 6:
      return crit_e::ignore;
    case 7:
      return crit_e::ignore;
    case 8:
      return crit_e::ignore;
    case 274:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cfg_upd_ies_o::value_c amf_cfg_upd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 1:
      ret.set(value_c::types::amf_name);
      break;
    case 96:
      ret.set(value_c::types::served_guami_list);
      break;
    case 86:
      ret.set(value_c::types::relative_amf_capacity);
      break;
    case 80:
      ret.set(value_c::types::plmn_support_list);
      break;
    case 6:
      ret.set(value_c::types::amf_tnl_assoc_to_add_list);
      break;
    case 7:
      ret.set(value_c::types::amf_tnl_assoc_to_rem_list);
      break;
    case 8:
      ret.set(value_c::types::amf_tnl_assoc_to_upd_list);
      break;
    case 274:
      ret.set(value_c::types::extended_amf_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cfg_upd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 1:
      return presence_e::optional;
    case 96:
      return presence_e::optional;
    case 86:
      return presence_e::optional;
    case 80:
      return presence_e::optional;
    case 6:
      return presence_e::optional;
    case 7:
      return presence_e::optional;
    case 8:
      return presence_e::optional;
    case 274:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cfg_upd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::amf_name:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::served_guami_list:
      c.destroy<served_guami_list_l>();
      break;
    case types::plmn_support_list:
      c.destroy<plmn_support_list_l>();
      break;
    case types::amf_tnl_assoc_to_add_list:
      c.destroy<amf_tnl_assoc_to_add_list_l>();
      break;
    case types::amf_tnl_assoc_to_rem_list:
      c.destroy<amf_tnl_assoc_to_rem_list_l>();
      break;
    case types::amf_tnl_assoc_to_upd_list:
      c.destroy<amf_tnl_assoc_to_upd_list_l>();
      break;
    case types::extended_amf_name:
      c.destroy<extended_amf_name_s>();
      break;
    default:
      break;
  }
}
void amf_cfg_upd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_name:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::served_guami_list:
      c.init<served_guami_list_l>();
      break;
    case types::relative_amf_capacity:
      break;
    case types::plmn_support_list:
      c.init<plmn_support_list_l>();
      break;
    case types::amf_tnl_assoc_to_add_list:
      c.init<amf_tnl_assoc_to_add_list_l>();
      break;
    case types::amf_tnl_assoc_to_rem_list:
      c.init<amf_tnl_assoc_to_rem_list_l>();
      break;
    case types::amf_tnl_assoc_to_upd_list:
      c.init<amf_tnl_assoc_to_upd_list_l>();
      break;
    case types::extended_amf_name:
      c.init<extended_amf_name_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }
}
amf_cfg_upd_ies_o::value_c::value_c(const amf_cfg_upd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_name:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::served_guami_list:
      c.init(other.c.get<served_guami_list_l>());
      break;
    case types::relative_amf_capacity:
      c.init(other.c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      c.init(other.c.get<plmn_support_list_l>());
      break;
    case types::amf_tnl_assoc_to_add_list:
      c.init(other.c.get<amf_tnl_assoc_to_add_list_l>());
      break;
    case types::amf_tnl_assoc_to_rem_list:
      c.init(other.c.get<amf_tnl_assoc_to_rem_list_l>());
      break;
    case types::amf_tnl_assoc_to_upd_list:
      c.init(other.c.get<amf_tnl_assoc_to_upd_list_l>());
      break;
    case types::extended_amf_name:
      c.init(other.c.get<extended_amf_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }
}
amf_cfg_upd_ies_o::value_c& amf_cfg_upd_ies_o::value_c::operator=(const amf_cfg_upd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_name:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::served_guami_list:
      c.set(other.c.get<served_guami_list_l>());
      break;
    case types::relative_amf_capacity:
      c.set(other.c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      c.set(other.c.get<plmn_support_list_l>());
      break;
    case types::amf_tnl_assoc_to_add_list:
      c.set(other.c.get<amf_tnl_assoc_to_add_list_l>());
      break;
    case types::amf_tnl_assoc_to_rem_list:
      c.set(other.c.get<amf_tnl_assoc_to_rem_list_l>());
      break;
    case types::amf_tnl_assoc_to_upd_list:
      c.set(other.c.get<amf_tnl_assoc_to_upd_list_l>());
      break;
    case types::extended_amf_name:
      c.set(other.c.get<extended_amf_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }

  return *this;
}
printable_string<1, 150, true, true>& amf_cfg_upd_ies_o::value_c::amf_name()
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
served_guami_list_l& amf_cfg_upd_ies_o::value_c::served_guami_list()
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
uint16_t& amf_cfg_upd_ies_o::value_c::relative_amf_capacity()
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
plmn_support_list_l& amf_cfg_upd_ies_o::value_c::plmn_support_list()
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
amf_tnl_assoc_to_add_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_add_list()
{
  assert_choice_type(types::amf_tnl_assoc_to_add_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_add_list_l>();
}
amf_tnl_assoc_to_rem_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_rem_list()
{
  assert_choice_type(types::amf_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_rem_list_l>();
}
amf_tnl_assoc_to_upd_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_upd_list()
{
  assert_choice_type(types::amf_tnl_assoc_to_upd_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_upd_list_l>();
}
extended_amf_name_s& amf_cfg_upd_ies_o::value_c::extended_amf_name()
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
const printable_string<1, 150, true, true>& amf_cfg_upd_ies_o::value_c::amf_name() const
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const served_guami_list_l& amf_cfg_upd_ies_o::value_c::served_guami_list() const
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
const uint16_t& amf_cfg_upd_ies_o::value_c::relative_amf_capacity() const
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
const plmn_support_list_l& amf_cfg_upd_ies_o::value_c::plmn_support_list() const
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
const amf_tnl_assoc_to_add_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_add_list() const
{
  assert_choice_type(types::amf_tnl_assoc_to_add_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_add_list_l>();
}
const amf_tnl_assoc_to_rem_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_rem_list() const
{
  assert_choice_type(types::amf_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_rem_list_l>();
}
const amf_tnl_assoc_to_upd_list_l& amf_cfg_upd_ies_o::value_c::amf_tnl_assoc_to_upd_list() const
{
  assert_choice_type(types::amf_tnl_assoc_to_upd_list, type_, "Value");
  return c.get<amf_tnl_assoc_to_upd_list_l>();
}
const extended_amf_name_s& amf_cfg_upd_ies_o::value_c::extended_amf_name() const
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
void amf_cfg_upd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::served_guami_list:
      j.start_array("ServedGUAMIList");
      for (const auto& e1 : c.get<served_guami_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::relative_amf_capacity:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      j.start_array("PLMNSupportList");
      for (const auto& e1 : c.get<plmn_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_to_add_list:
      j.start_array("AMF-TNLAssociationToAddList");
      for (const auto& e1 : c.get<amf_tnl_assoc_to_add_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_to_rem_list:
      j.start_array("AMF-TNLAssociationToRemoveList");
      for (const auto& e1 : c.get<amf_tnl_assoc_to_rem_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_to_upd_list:
      j.start_array("AMF-TNLAssociationToUpdateList");
      for (const auto& e1 : c.get<amf_tnl_assoc_to_upd_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::extended_amf_name:
      j.write_fieldname("Extended-AMFName");
      c.get<extended_amf_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cfg_upd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<served_guami_list_l>(), 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<plmn_support_list_l>(), 1, 12, true));
      break;
    case types::amf_tnl_assoc_to_add_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_to_add_list_l>(), 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_rem_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_to_rem_list_l>(), 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_upd_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_to_upd_list_l>(), 1, 32, true));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<served_guami_list_l>(), bref, 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<plmn_support_list_l>(), bref, 1, 12, true));
      break;
    case types::amf_tnl_assoc_to_add_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_to_add_list_l>(), bref, 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_rem_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_to_rem_list_l>(), bref, 1, 32, true));
      break;
    case types::amf_tnl_assoc_to_upd_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_to_upd_list_l>(), bref, 1, 32, true));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE amf_cfg_upd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_name_present ? 1 : 0;
  nof_ies += served_guami_list_present ? 1 : 0;
  nof_ies += relative_amf_capacity_present ? 1 : 0;
  nof_ies += plmn_support_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_to_add_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_to_rem_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_to_upd_list_present ? 1 : 0;
  nof_ies += extended_amf_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)1, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(amf_name.pack(bref));
  }
  if (served_guami_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)96, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, served_guami_list, 1, 256, true));
  }
  if (relative_amf_capacity_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)86, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, relative_amf_capacity, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (plmn_support_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)80, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, plmn_support_list, 1, 12, true));
  }
  if (amf_tnl_assoc_to_add_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)6, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, amf_tnl_assoc_to_add_list, 1, 32, true));
  }
  if (amf_tnl_assoc_to_rem_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)7, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, amf_tnl_assoc_to_rem_list, 1, 32, true));
  }
  if (amf_tnl_assoc_to_upd_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)8, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, amf_tnl_assoc_to_upd_list, 1, 32, true));
  }
  if (extended_amf_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)274, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(extended_amf_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 1: {
        amf_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_name.unpack(bref));
        break;
      }
      case 96: {
        served_guami_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(served_guami_list, bref, 1, 256, true));
        break;
      }
      case 86: {
        relative_amf_capacity_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(relative_amf_capacity, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 80: {
        plmn_support_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(plmn_support_list, bref, 1, 12, true));
        break;
      }
      case 6: {
        amf_tnl_assoc_to_add_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(amf_tnl_assoc_to_add_list, bref, 1, 32, true));
        break;
      }
      case 7: {
        amf_tnl_assoc_to_rem_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(amf_tnl_assoc_to_rem_list, bref, 1, 32, true));
        break;
      }
      case 8: {
        amf_tnl_assoc_to_upd_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(amf_tnl_assoc_to_upd_list, bref, 1, 32, true));
        break;
      }
      case 274: {
        extended_amf_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_amf_name.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void amf_cfg_upd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_name_present) {
    j.write_int("id", 1);
    j.write_str("criticality", "reject");
    j.write_str("Value", amf_name.to_string());
  }
  if (served_guami_list_present) {
    j.write_int("id", 96);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : served_guami_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (relative_amf_capacity_present) {
    j.write_int("id", 86);
    j.write_str("criticality", "ignore");
    j.write_int("Value", relative_amf_capacity);
  }
  if (plmn_support_list_present) {
    j.write_int("id", 80);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : plmn_support_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (amf_tnl_assoc_to_add_list_present) {
    j.write_int("id", 6);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : amf_tnl_assoc_to_add_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (amf_tnl_assoc_to_rem_list_present) {
    j.write_int("id", 7);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : amf_tnl_assoc_to_rem_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (amf_tnl_assoc_to_upd_list_present) {
    j.write_int("id", 8);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : amf_tnl_assoc_to_upd_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (extended_amf_name_present) {
    j.write_int("id", 274);
    j.write_str("criticality", "ignore");
    extended_amf_name.to_json(j);
  }
  j.end_obj();
}

// AMFConfigurationUpdateAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cfg_upd_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {5, 4, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool amf_cfg_upd_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {5, 4, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cfg_upd_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 5:
      return crit_e::ignore;
    case 4:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cfg_upd_ack_ies_o::value_c amf_cfg_upd_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 5:
      ret.set(value_c::types::amf_tnl_assoc_setup_list);
      break;
    case 4:
      ret.set(value_c::types::amf_tnl_assoc_failed_to_setup_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cfg_upd_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 5:
      return presence_e::optional;
    case 4:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cfg_upd_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      c.destroy<amf_tnl_assoc_setup_list_l>();
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      c.destroy<tnl_assoc_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void amf_cfg_upd_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      c.init<amf_tnl_assoc_setup_list_l>();
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      c.init<tnl_assoc_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }
}
amf_cfg_upd_ack_ies_o::value_c::value_c(const amf_cfg_upd_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      c.init(other.c.get<amf_tnl_assoc_setup_list_l>());
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      c.init(other.c.get<tnl_assoc_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }
}
amf_cfg_upd_ack_ies_o::value_c& amf_cfg_upd_ack_ies_o::value_c::operator=(const amf_cfg_upd_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      c.set(other.c.get<amf_tnl_assoc_setup_list_l>());
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      c.set(other.c.get<tnl_assoc_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }

  return *this;
}
amf_tnl_assoc_setup_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_setup_list()
{
  assert_choice_type(types::amf_tnl_assoc_setup_list, type_, "Value");
  return c.get<amf_tnl_assoc_setup_list_l>();
}
tnl_assoc_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_failed_to_setup_list()
{
  assert_choice_type(types::amf_tnl_assoc_failed_to_setup_list, type_, "Value");
  return c.get<tnl_assoc_list_l>();
}
crit_diagnostics_s& amf_cfg_upd_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const amf_tnl_assoc_setup_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_setup_list() const
{
  assert_choice_type(types::amf_tnl_assoc_setup_list, type_, "Value");
  return c.get<amf_tnl_assoc_setup_list_l>();
}
const tnl_assoc_list_l& amf_cfg_upd_ack_ies_o::value_c::amf_tnl_assoc_failed_to_setup_list() const
{
  assert_choice_type(types::amf_tnl_assoc_failed_to_setup_list, type_, "Value");
  return c.get<tnl_assoc_list_l>();
}
const crit_diagnostics_s& amf_cfg_upd_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void amf_cfg_upd_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      j.start_array("AMF-TNLAssociationSetupList");
      for (const auto& e1 : c.get<amf_tnl_assoc_setup_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      j.start_array("TNLAssociationList");
      for (const auto& e1 : c.get<tnl_assoc_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cfg_upd_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<amf_tnl_assoc_setup_list_l>(), 1, 32, true));
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tnl_assoc_list_l>(), 1, 32, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_tnl_assoc_setup_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<amf_tnl_assoc_setup_list_l>(), bref, 1, 32, true));
      break;
    case types::amf_tnl_assoc_failed_to_setup_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tnl_assoc_list_l>(), bref, 1, 32, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE amf_cfg_upd_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_tnl_assoc_setup_list_present ? 1 : 0;
  nof_ies += amf_tnl_assoc_failed_to_setup_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_tnl_assoc_setup_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)5, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, amf_tnl_assoc_setup_list, 1, 32, true));
  }
  if (amf_tnl_assoc_failed_to_setup_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)4, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, amf_tnl_assoc_failed_to_setup_list, 1, 32, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 5: {
        amf_tnl_assoc_setup_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(amf_tnl_assoc_setup_list, bref, 1, 32, true));
        break;
      }
      case 4: {
        amf_tnl_assoc_failed_to_setup_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(amf_tnl_assoc_failed_to_setup_list, bref, 1, 32, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void amf_cfg_upd_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_tnl_assoc_setup_list_present) {
    j.write_int("id", 5);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : amf_tnl_assoc_setup_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (amf_tnl_assoc_failed_to_setup_list_present) {
    j.write_int("id", 4);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : amf_tnl_assoc_failed_to_setup_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// AMFConfigurationUpdateFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_cfg_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 107, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool amf_cfg_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 107, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e amf_cfg_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 107:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
amf_cfg_upd_fail_ies_o::value_c amf_cfg_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 107:
      ret.set(value_c::types::time_to_wait);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_cfg_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 107:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void amf_cfg_upd_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void amf_cfg_upd_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::time_to_wait:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }
}
amf_cfg_upd_fail_ies_o::value_c::value_c(const amf_cfg_upd_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.init(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }
}
amf_cfg_upd_fail_ies_o::value_c&
amf_cfg_upd_fail_ies_o::value_c::operator=(const amf_cfg_upd_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.set(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }

  return *this;
}
cause_c& amf_cfg_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& amf_cfg_upd_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& amf_cfg_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& amf_cfg_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& amf_cfg_upd_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& amf_cfg_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void amf_cfg_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE amf_cfg_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "amf_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE amf_cfg_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (time_to_wait_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)107, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_cfg_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 107: {
        time_to_wait_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_to_wait.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void amf_cfg_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_int("id", 107);
    j.write_str("criticality", "ignore");
    j.write_str("Value", time_to_wait.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// AMFStatusIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t amf_status_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {120};
  return map_enum_number(names, 1, idx, "id");
}
bool amf_status_ind_ies_o::is_id_valid(const uint32_t& id)
{
  return 120 == id;
}
crit_e amf_status_ind_ies_o::get_crit(const uint32_t& id)
{
  if (id == 120) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
amf_status_ind_ies_o::value_c amf_status_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 120) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e amf_status_ind_ies_o::get_presence(const uint32_t& id)
{
  if (id == 120) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void amf_status_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.start_array("UnavailableGUAMIList");
  for (const auto& e1 : c) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}
SRSASN_CODE amf_status_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(pack_dyn_seq_of(bref, c, 1, 256, true));
  return SRSASN_SUCCESS;
}
SRSASN_CODE amf_status_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(unpack_dyn_seq_of(c, bref, 1, 256, true));
  return SRSASN_SUCCESS;
}

// BroadcastSessionModificationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_mod_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 348, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool broadcast_session_mod_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 348, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_mod_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 348:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_mod_fail_ies_o::value_c broadcast_session_mod_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 348:
      ret.set(value_c::types::mbs_session_mod_fail_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_mod_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 348:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_mod_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_mod_fail_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_mod_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_mod_fail_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }
}
broadcast_session_mod_fail_ies_o::value_c::value_c(const broadcast_session_mod_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_mod_fail_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }
}
broadcast_session_mod_fail_ies_o::value_c&
broadcast_session_mod_fail_ies_o::value_c::operator=(const broadcast_session_mod_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_mod_fail_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_mod_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_mod_fail_ies_o::value_c::mbs_session_mod_fail_transfer()
{
  assert_choice_type(types::mbs_session_mod_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& broadcast_session_mod_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& broadcast_session_mod_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_mod_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_mod_fail_ies_o::value_c::mbs_session_mod_fail_transfer() const
{
  assert_choice_type(types::mbs_session_mod_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& broadcast_session_mod_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& broadcast_session_mod_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_mod_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_mod_fail_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_mod_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_mod_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_mod_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE broadcast_session_mod_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_session_mod_fail_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_session_mod_fail_transfer_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)348, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_mod_fail_transfer.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 348: {
        mbs_session_mod_fail_transfer_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_mod_fail_transfer.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_mod_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_session_mod_fail_transfer_present) {
    j.write_int("id", 348);
    j.write_str("criticality", "reject");
    j.write_str("Value", mbs_session_mod_fail_transfer.to_string());
  }
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionModificationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_mod_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 298, 349};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_mod_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 298, 349};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_mod_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 298:
      return crit_e::reject;
    case 349:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_mod_request_ies_o::value_c broadcast_session_mod_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 349:
      ret.set(value_c::types::mbs_session_mod_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_mod_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 298:
      return presence_e::optional;
    case 349:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_mod_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.destroy<mbs_service_area_c>();
      break;
    case types::mbs_session_mod_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void broadcast_session_mod_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.init<mbs_service_area_c>();
      break;
    case types::mbs_session_mod_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }
}
broadcast_session_mod_request_ies_o::value_c::value_c(const broadcast_session_mod_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.init(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_session_mod_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }
}
broadcast_session_mod_request_ies_o::value_c&
broadcast_session_mod_request_ies_o::value_c::operator=(const broadcast_session_mod_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.set(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_session_mod_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_mod_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
mbs_service_area_c& broadcast_session_mod_request_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
unbounded_octstring<true>& broadcast_session_mod_request_ies_o::value_c::mbs_session_mod_request_transfer()
{
  assert_choice_type(types::mbs_session_mod_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& broadcast_session_mod_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const mbs_service_area_c& broadcast_session_mod_request_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const unbounded_octstring<true>& broadcast_session_mod_request_ies_o::value_c::mbs_session_mod_request_transfer() const
{
  assert_choice_type(types::mbs_session_mod_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void broadcast_session_mod_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::mbs_session_mod_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_mod_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::mbs_session_mod_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::mbs_session_mod_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE broadcast_session_mod_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_service_area_present ? 1 : 0;
  nof_ies += mbs_session_mod_request_transfer_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_service_area_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)298, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  if (mbs_session_mod_request_transfer_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)349, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_mod_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 298: {
        mbs_service_area_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.unpack(bref));
        break;
      }
      case 349: {
        mbs_session_mod_request_transfer_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_mod_request_transfer.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_mod_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_service_area_present) {
    j.write_int("id", 298);
    j.write_str("criticality", "reject");
    mbs_service_area.to_json(j);
  }
  if (mbs_session_mod_request_transfer_present) {
    j.write_int("id", 349);
    j.write_str("criticality", "reject");
    j.write_str("Value", mbs_session_mod_request_transfer.to_string());
  }
  j.end_obj();
}

// BroadcastSessionModificationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_mod_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 350, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_mod_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 350, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_mod_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 350:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_mod_resp_ies_o::value_c broadcast_session_mod_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 350:
      ret.set(value_c::types::mbs_session_mod_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_mod_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 350:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_mod_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_mod_resp_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_mod_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_mod_resp_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }
}
broadcast_session_mod_resp_ies_o::value_c::value_c(const broadcast_session_mod_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_mod_resp_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }
}
broadcast_session_mod_resp_ies_o::value_c&
broadcast_session_mod_resp_ies_o::value_c::operator=(const broadcast_session_mod_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_mod_resp_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_mod_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_mod_resp_ies_o::value_c::mbs_session_mod_resp_transfer()
{
  assert_choice_type(types::mbs_session_mod_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& broadcast_session_mod_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_mod_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_mod_resp_ies_o::value_c::mbs_session_mod_resp_transfer() const
{
  assert_choice_type(types::mbs_session_mod_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& broadcast_session_mod_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_mod_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_mod_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_mod_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_mod_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_mod_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE broadcast_session_mod_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_mod_resp_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_session_mod_resp_transfer_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)350, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_mod_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_mod_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 350: {
        mbs_session_mod_resp_transfer_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_mod_resp_transfer.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_mod_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_session_mod_resp_transfer_present) {
    j.write_int("id", 350);
    j.write_str("criticality", "reject");
    j.write_str("Value", mbs_session_mod_resp_transfer.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionReleaseRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 15};
  return map_enum_number(names, 2, idx, "id");
}
bool broadcast_session_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_release_request_ies_o::value_c broadcast_session_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_release_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void broadcast_session_release_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }
}
broadcast_session_release_request_ies_o::value_c::value_c(const broadcast_session_release_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }
}
broadcast_session_release_request_ies_o::value_c& broadcast_session_release_request_ies_o::value_c::operator=(
    const broadcast_session_release_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_release_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
cause_c& broadcast_session_release_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const mbs_session_id_s& broadcast_session_release_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const cause_c& broadcast_session_release_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void broadcast_session_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE broadcast_session_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

// BroadcastSessionReleaseRequiredIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_release_required_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 15};
  return map_enum_number(names, 2, idx, "id");
}
bool broadcast_session_release_required_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_release_required_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_release_required_ies_o::value_c
broadcast_session_release_required_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_release_required_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_release_required_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void broadcast_session_release_required_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }
}
broadcast_session_release_required_ies_o::value_c::value_c(
    const broadcast_session_release_required_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }
}
broadcast_session_release_required_ies_o::value_c& broadcast_session_release_required_ies_o::value_c::operator=(
    const broadcast_session_release_required_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_release_required_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
cause_c& broadcast_session_release_required_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const mbs_session_id_s& broadcast_session_release_required_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const cause_c& broadcast_session_release_required_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void broadcast_session_release_required_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_release_required_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_required_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_required_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE broadcast_session_release_required_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_required_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_release_required_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

// BroadcastSessionReleaseResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_release_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 358, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_release_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 358, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_release_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 358:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_release_resp_ies_o::value_c broadcast_session_release_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 358:
      ret.set(value_c::types::mbs_session_release_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_release_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 358:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_release_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_release_resp_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_release_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_release_resp_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }
}
broadcast_session_release_resp_ies_o::value_c::value_c(const broadcast_session_release_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_release_resp_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }
}
broadcast_session_release_resp_ies_o::value_c&
broadcast_session_release_resp_ies_o::value_c::operator=(const broadcast_session_release_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_release_resp_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_release_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_release_resp_ies_o::value_c::mbs_session_release_resp_transfer()
{
  assert_choice_type(types::mbs_session_release_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& broadcast_session_release_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_release_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>&
broadcast_session_release_resp_ies_o::value_c::mbs_session_release_resp_transfer() const
{
  assert_choice_type(types::mbs_session_release_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& broadcast_session_release_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_release_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_release_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_release_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_release_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_release_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_release_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE broadcast_session_release_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_release_resp_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_session_release_resp_transfer_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)358, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_release_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_release_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 358: {
        mbs_session_release_resp_transfer_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_release_resp_transfer.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_release_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_session_release_resp_transfer_present) {
    j.write_int("id", 358);
    j.write_str("criticality", "ignore");
    j.write_str("Value", mbs_session_release_resp_transfer.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 314, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool broadcast_session_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 314, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 314:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_setup_fail_ies_o::value_c broadcast_session_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 314:
      ret.set(value_c::types::mbs_session_setup_fail_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 314:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_setup_fail_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_setup_fail_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }
}
broadcast_session_setup_fail_ies_o::value_c::value_c(const broadcast_session_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_setup_fail_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }
}
broadcast_session_setup_fail_ies_o::value_c&
broadcast_session_setup_fail_ies_o::value_c::operator=(const broadcast_session_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_setup_fail_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_setup_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_setup_fail_ies_o::value_c::mbs_session_setup_fail_transfer()
{
  assert_choice_type(types::mbs_session_setup_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& broadcast_session_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& broadcast_session_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_setup_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_setup_fail_ies_o::value_c::mbs_session_setup_fail_transfer() const
{
  assert_choice_type(types::mbs_session_setup_fail_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& broadcast_session_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& broadcast_session_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_setup_fail_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_setup_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_setup_fail_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE broadcast_session_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_session_setup_fail_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_session_setup_fail_transfer_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)314, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_setup_fail_transfer.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 314: {
        mbs_session_setup_fail_transfer_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_fail_transfer.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_session_setup_fail_transfer_present) {
    j.write_int("id", 314);
    j.write_str("criticality", "reject");
    j.write_str("Value", mbs_session_setup_fail_transfer.to_string());
  }
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// BroadcastSessionSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 148, 298, 315};
  return map_enum_number(names, 4, idx, "id");
}
bool broadcast_session_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 148, 298, 315};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 148:
      return crit_e::reject;
    case 298:
      return crit_e::reject;
    case 315:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_setup_request_ies_o::value_c broadcast_session_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 315:
      ret.set(value_c::types::mbs_session_setup_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 148:
      return presence_e::mandatory;
    case 298:
      return presence_e::mandatory;
    case 315:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::s_nssai:
      c.destroy<s_nssai_s>();
      break;
    case types::mbs_service_area:
      c.destroy<mbs_service_area_c>();
      break;
    case types::mbs_session_setup_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void broadcast_session_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::s_nssai:
      c.init<s_nssai_s>();
      break;
    case types::mbs_service_area:
      c.init<mbs_service_area_c>();
      break;
    case types::mbs_session_setup_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }
}
broadcast_session_setup_request_ies_o::value_c::value_c(const broadcast_session_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::s_nssai:
      c.init(other.c.get<s_nssai_s>());
      break;
    case types::mbs_service_area:
      c.init(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_session_setup_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }
}
broadcast_session_setup_request_ies_o::value_c&
broadcast_session_setup_request_ies_o::value_c::operator=(const broadcast_session_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::s_nssai:
      c.set(other.c.get<s_nssai_s>());
      break;
    case types::mbs_service_area:
      c.set(other.c.get<mbs_service_area_c>());
      break;
    case types::mbs_session_setup_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_setup_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
s_nssai_s& broadcast_session_setup_request_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
mbs_service_area_c& broadcast_session_setup_request_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
unbounded_octstring<true>& broadcast_session_setup_request_ies_o::value_c::mbs_session_setup_request_transfer()
{
  assert_choice_type(types::mbs_session_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& broadcast_session_setup_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const s_nssai_s& broadcast_session_setup_request_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const mbs_service_area_c& broadcast_session_setup_request_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const unbounded_octstring<true>&
broadcast_session_setup_request_ies_o::value_c::mbs_session_setup_request_transfer() const
{
  assert_choice_type(types::mbs_session_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void broadcast_session_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::mbs_session_setup_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::mbs_session_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::mbs_session_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE broadcast_session_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)148, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(s_nssai.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)298, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)315, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_setup_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 148: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.unpack(bref));
        break;
      }
      case 298: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.unpack(bref));
        break;
      }
      case 315: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_request_transfer.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  j.write_int("id", 148);
  j.write_str("criticality", "reject");
  s_nssai.to_json(j);
  j.write_int("id", 298);
  j.write_str("criticality", "reject");
  mbs_service_area.to_json(j);
  j.write_int("id", 315);
  j.write_str("criticality", "reject");
  j.write_str("Value", mbs_session_setup_request_transfer.to_string());
  j.end_obj();
}

// BroadcastSessionSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t broadcast_session_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 316, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool broadcast_session_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 316, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e broadcast_session_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 316:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
broadcast_session_setup_resp_ies_o::value_c broadcast_session_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 316:
      ret.set(value_c::types::mbs_session_setup_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e broadcast_session_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 316:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void broadcast_session_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_session_setup_resp_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void broadcast_session_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_session_setup_resp_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }
}
broadcast_session_setup_resp_ies_o::value_c::value_c(const broadcast_session_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_setup_resp_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }
}
broadcast_session_setup_resp_ies_o::value_c&
broadcast_session_setup_resp_ies_o::value_c::operator=(const broadcast_session_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_session_setup_resp_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& broadcast_session_setup_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>& broadcast_session_setup_resp_ies_o::value_c::mbs_session_setup_resp_transfer()
{
  assert_choice_type(types::mbs_session_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& broadcast_session_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& broadcast_session_setup_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>& broadcast_session_setup_resp_ies_o::value_c::mbs_session_setup_resp_transfer() const
{
  assert_choice_type(types::mbs_session_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& broadcast_session_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void broadcast_session_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_session_setup_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE broadcast_session_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_session_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_session_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "broadcast_session_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE broadcast_session_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_session_setup_resp_transfer_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_session_setup_resp_transfer_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)316, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_setup_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE broadcast_session_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 316: {
        mbs_session_setup_resp_transfer_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_setup_resp_transfer.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void broadcast_session_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_session_setup_resp_transfer_present) {
    j.write_int("id", 316);
    j.write_str("criticality", "reject");
    j.write_str("Value", mbs_session_setup_resp_transfer.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// CellTrafficTraceIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t cell_traffic_trace_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 44, 43, 109, 256, 257};
  return map_enum_number(names, 7, idx, "id");
}
bool cell_traffic_trace_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 44, 43, 109, 256, 257};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e cell_traffic_trace_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 44:
      return crit_e::ignore;
    case 43:
      return crit_e::ignore;
    case 109:
      return crit_e::ignore;
    case 256:
      return crit_e::ignore;
    case 257:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
cell_traffic_trace_ies_o::value_c cell_traffic_trace_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 44:
      ret.set(value_c::types::ngran_trace_id);
      break;
    case 43:
      ret.set(value_c::types::ngran_cgi);
      break;
    case 109:
      ret.set(value_c::types::trace_collection_entity_ip_address);
      break;
    case 256:
      ret.set(value_c::types::privacy_ind);
      break;
    case 257:
      ret.set(value_c::types::trace_collection_entity_uri);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e cell_traffic_trace_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 44:
      return presence_e::mandatory;
    case 43:
      return presence_e::mandatory;
    case 109:
      return presence_e::mandatory;
    case 256:
      return presence_e::optional;
    case 257:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void cell_traffic_trace_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ngran_trace_id:
      c.destroy<fixed_octstring<8, true>>();
      break;
    case types::ngran_cgi:
      c.destroy<ngran_cgi_c>();
      break;
    case types::trace_collection_entity_ip_address:
      c.destroy<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::trace_collection_entity_uri:
      c.destroy<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
      break;
    default:
      break;
  }
}
void cell_traffic_trace_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ngran_trace_id:
      c.init<fixed_octstring<8, true>>();
      break;
    case types::ngran_cgi:
      c.init<ngran_cgi_c>();
      break;
    case types::trace_collection_entity_ip_address:
      c.init<bounded_bitstring<1, 160, true, true>>();
      break;
    case types::privacy_ind:
      break;
    case types::trace_collection_entity_uri:
      c.init<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
}
cell_traffic_trace_ies_o::value_c::value_c(const cell_traffic_trace_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.init(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::ngran_cgi:
      c.init(other.c.get<ngran_cgi_c>());
      break;
    case types::trace_collection_entity_ip_address:
      c.init(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::privacy_ind:
      c.init(other.c.get<privacy_ind_e>());
      break;
    case types::trace_collection_entity_uri:
      c.init(other.c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
}
cell_traffic_trace_ies_o::value_c&
cell_traffic_trace_ies_o::value_c::operator=(const cell_traffic_trace_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.set(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::ngran_cgi:
      c.set(other.c.get<ngran_cgi_c>());
      break;
    case types::trace_collection_entity_ip_address:
      c.set(other.c.get<bounded_bitstring<1, 160, true, true>>());
      break;
    case types::privacy_ind:
      c.set(other.c.get<privacy_ind_e>());
      break;
    case types::trace_collection_entity_uri:
      c.set(other.c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }

  return *this;
}
uint64_t& cell_traffic_trace_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& cell_traffic_trace_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
fixed_octstring<8, true>& cell_traffic_trace_ies_o::value_c::ngran_trace_id()
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
ngran_cgi_c& cell_traffic_trace_ies_o::value_c::ngran_cgi()
{
  assert_choice_type(types::ngran_cgi, type_, "Value");
  return c.get<ngran_cgi_c>();
}
bounded_bitstring<1, 160, true, true>& cell_traffic_trace_ies_o::value_c::trace_collection_entity_ip_address()
{
  assert_choice_type(types::trace_collection_entity_ip_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
privacy_ind_e& cell_traffic_trace_ies_o::value_c::privacy_ind()
{
  assert_choice_type(types::privacy_ind, type_, "Value");
  return c.get<privacy_ind_e>();
}
visible_string<0, MAX_ASN_STRING_LENGTH, false, true>& cell_traffic_trace_ies_o::value_c::trace_collection_entity_uri()
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Value");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
const uint64_t& cell_traffic_trace_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& cell_traffic_trace_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const fixed_octstring<8, true>& cell_traffic_trace_ies_o::value_c::ngran_trace_id() const
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
const ngran_cgi_c& cell_traffic_trace_ies_o::value_c::ngran_cgi() const
{
  assert_choice_type(types::ngran_cgi, type_, "Value");
  return c.get<ngran_cgi_c>();
}
const bounded_bitstring<1, 160, true, true>&
cell_traffic_trace_ies_o::value_c::trace_collection_entity_ip_address() const
{
  assert_choice_type(types::trace_collection_entity_ip_address, type_, "Value");
  return c.get<bounded_bitstring<1, 160, true, true>>();
}
const privacy_ind_e& cell_traffic_trace_ies_o::value_c::privacy_ind() const
{
  assert_choice_type(types::privacy_ind, type_, "Value");
  return c.get<privacy_ind_e>();
}
const visible_string<0, MAX_ASN_STRING_LENGTH, false, true>&
cell_traffic_trace_ies_o::value_c::trace_collection_entity_uri() const
{
  assert_choice_type(types::trace_collection_entity_uri, type_, "Value");
  return c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>();
}
void cell_traffic_trace_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true>>().to_string());
      break;
    case types::ngran_cgi:
      j.write_fieldname("NGRAN-CGI");
      c.get<ngran_cgi_c>().to_json(j);
      break;
    case types::trace_collection_entity_ip_address:
      j.write_str("BIT STRING", c.get<bounded_bitstring<1, 160, true, true>>().to_string());
      break;
    case types::privacy_ind:
      j.write_str("PrivacyIndicator", c.get<privacy_ind_e>().to_string());
      break;
    case types::trace_collection_entity_uri:
      j.write_str("VisibleString", c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE cell_traffic_trace_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    case types::ngran_cgi:
      HANDLE_CODE(c.get<ngran_cgi_c>().pack(bref));
      break;
    case types::trace_collection_entity_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().pack(bref)));
      break;
    case types::privacy_ind:
      HANDLE_CODE(c.get<privacy_ind_e>().pack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_traffic_trace_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    case types::ngran_cgi:
      HANDLE_CODE(c.get<ngran_cgi_c>().unpack(bref));
      break;
    case types::trace_collection_entity_ip_address:
      HANDLE_CODE((c.get<bounded_bitstring<1, 160, true, true>>().unpack(bref)));
      break;
    case types::privacy_ind:
      HANDLE_CODE(c.get<privacy_ind_e>().unpack(bref));
      break;
    case types::trace_collection_entity_uri:
      HANDLE_CODE((c.get<visible_string<0, MAX_ASN_STRING_LENGTH, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "cell_traffic_trace_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE cell_traffic_trace_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += privacy_ind_present ? 1 : 0;
  nof_ies += trace_collection_entity_uri_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)44, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ngran_trace_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)43, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ngran_cgi.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)109, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trace_collection_entity_ip_address.pack(bref));
  }
  if (privacy_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)256, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(privacy_ind.pack(bref));
  }
  if (trace_collection_entity_uri_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)257, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trace_collection_entity_uri.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE cell_traffic_trace_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 44: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_trace_id.unpack(bref));
        break;
      }
      case 43: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_cgi.unpack(bref));
        break;
      }
      case 109: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_collection_entity_ip_address.unpack(bref));
        break;
      }
      case 256: {
        privacy_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(privacy_ind.unpack(bref));
        break;
      }
      case 257: {
        trace_collection_entity_uri_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_collection_entity_uri.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void cell_traffic_trace_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 44);
  j.write_str("criticality", "ignore");
  j.write_str("Value", ngran_trace_id.to_string());
  j.write_int("id", 43);
  j.write_str("criticality", "ignore");
  ngran_cgi.to_json(j);
  j.write_int("id", 109);
  j.write_str("criticality", "ignore");
  j.write_str("Value", trace_collection_entity_ip_address.to_string());
  if (privacy_ind_present) {
    j.write_int("id", 256);
    j.write_str("criticality", "ignore");
    j.write_str("Value", privacy_ind.to_string());
  }
  if (trace_collection_entity_uri_present) {
    j.write_int("id", 257);
    j.write_str("criticality", "ignore");
    j.write_str("Value", trace_collection_entity_uri.to_string());
  }
  j.end_obj();
}

// ConnectionEstablishmentIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t conn_establishment_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 117, 226, 148, 0, 209, 212, 210, 205, 222, 264, 34};
  return map_enum_number(names, 13, idx, "id");
}
bool conn_establishment_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 117, 226, 148, 0, 209, 212, 210, 205, 222, 264, 34};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e conn_establishment_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 226:
      return crit_e::ignore;
    case 148:
      return crit_e::ignore;
    case 0:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 212:
      return crit_e::ignore;
    case 210:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 34:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
conn_establishment_ind_ies_o::value_c conn_establishment_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 226:
      ret.set(value_c::types::end_ind);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 212:
      ret.set(value_c::types::dl_cp_security_info);
      break;
    case 210:
      ret.set(value_c::types::nb_iot_ue_prio);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e conn_establishment_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 117:
      return presence_e::optional;
    case 226:
      return presence_e::optional;
    case 148:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 212:
      return presence_e::optional;
    case 210:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void conn_establishment_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::s_nssai:
      c.destroy<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::dl_cp_security_info:
      c.destroy<dl_cp_security_info_s>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    default:
      break;
  }
}
void conn_establishment_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::end_ind:
      break;
    case types::s_nssai:
      c.init<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::dl_cp_security_info:
      c.init<dl_cp_security_info_s>();
      break;
    case types::nb_iot_ue_prio:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
}
conn_establishment_ind_ies_o::value_c::value_c(const conn_establishment_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::end_ind:
      c.init(other.c.get<end_ind_e>());
      break;
    case types::s_nssai:
      c.init(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::dl_cp_security_info:
      c.init(other.c.get<dl_cp_security_info_s>());
      break;
    case types::nb_iot_ue_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
}
conn_establishment_ind_ies_o::value_c&
conn_establishment_ind_ies_o::value_c::operator=(const conn_establishment_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::end_ind:
      c.set(other.c.get<end_ind_e>());
      break;
    case types::s_nssai:
      c.set(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::dl_cp_security_info:
      c.set(other.c.get<dl_cp_security_info_s>());
      break;
    case types::nb_iot_ue_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& conn_establishment_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& conn_establishment_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
end_ind_e& conn_establishment_ind_ies_o::value_c::end_ind()
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
s_nssai_s& conn_establishment_ind_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
allowed_nssai_l& conn_establishment_ind_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
ue_diff_info_s& conn_establishment_ind_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
dl_cp_security_info_s& conn_establishment_ind_ies_o::value_c::dl_cp_security_info()
{
  assert_choice_type(types::dl_cp_security_info, type_, "Value");
  return c.get<dl_cp_security_info_s>();
}
uint16_t& conn_establishment_ind_ies_o::value_c::nb_iot_ue_prio()
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
enhanced_coverage_restrict_e& conn_establishment_ind_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
ce_mode_brestricted_e& conn_establishment_ind_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
fixed_bitstring<64, false, true>& conn_establishment_ind_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const uint64_t& conn_establishment_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& conn_establishment_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const end_ind_e& conn_establishment_ind_ies_o::value_c::end_ind() const
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
const s_nssai_s& conn_establishment_ind_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const allowed_nssai_l& conn_establishment_ind_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const ue_diff_info_s& conn_establishment_ind_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const dl_cp_security_info_s& conn_establishment_ind_ies_o::value_c::dl_cp_security_info() const
{
  assert_choice_type(types::dl_cp_security_info, type_, "Value");
  return c.get<dl_cp_security_info_s>();
}
const uint16_t& conn_establishment_ind_ies_o::value_c::nb_iot_ue_prio() const
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
const enhanced_coverage_restrict_e& conn_establishment_ind_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const ce_mode_brestricted_e& conn_establishment_ind_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const unbounded_octstring<true>& conn_establishment_ind_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const fixed_bitstring<64, false, true>& conn_establishment_ind_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
void conn_establishment_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::end_ind:
      j.write_str("EndIndication", c.get<end_ind_e>().to_string());
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::dl_cp_security_info:
      j.write_fieldname("DL-CP-SecurityInformation");
      c.get<dl_cp_security_info_s>().to_json(j);
      break;
    case types::nb_iot_ue_prio:
      j.write_int("INTEGER (0..255,...)", c.get<uint16_t>());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE conn_establishment_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().pack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::dl_cp_security_info:
      HANDLE_CODE(c.get<dl_cp_security_info_s>().pack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE conn_establishment_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().unpack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::dl_cp_security_info:
      HANDLE_CODE(c.get<dl_cp_security_info_s>().unpack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "conn_establishment_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE conn_establishment_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += end_ind_present ? 1 : 0;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += dl_cp_security_info_present ? 1 : 0;
  nof_ies += nb_iot_ue_prio_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (end_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)226, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(end_ind.pack(bref));
  }
  if (s_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)148, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (dl_cp_security_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)212, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(dl_cp_security_info.pack(bref));
  }
  if (nb_iot_ue_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)210, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, nb_iot_ue_prio, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)205, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)222, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)34, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(masked_imeisv.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE conn_establishment_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 226: {
        end_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(end_ind.unpack(bref));
        break;
      }
      case 148: {
        s_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.unpack(bref));
        break;
      }
      case 212: {
        dl_cp_security_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(dl_cp_security_info.unpack(bref));
        break;
      }
      case 210: {
        nb_iot_ue_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(nb_iot_ue_prio, bref, (uint16_t)0u, (uint16_t)255u, true, true));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void conn_establishment_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (ue_radio_cap_present) {
    j.write_int("id", 117);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ue_radio_cap.to_string());
  }
  if (end_ind_present) {
    j.write_int("id", 226);
    j.write_str("criticality", "ignore");
    j.write_str("Value", end_ind.to_string());
  }
  if (s_nssai_present) {
    j.write_int("id", 148);
    j.write_str("criticality", "ignore");
    s_nssai.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_int("id", 0);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : allowed_nssai) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ue_diff_info_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    ue_diff_info.to_json(j);
  }
  if (dl_cp_security_info_present) {
    j.write_int("id", 212);
    j.write_str("criticality", "ignore");
    dl_cp_security_info.to_json(j);
  }
  if (nb_iot_ue_prio_present) {
    j.write_int("id", 210);
    j.write_str("criticality", "ignore");
    j.write_int("Value", nb_iot_ue_prio);
  }
  if (enhanced_coverage_restrict_present) {
    j.write_int("id", 205);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "restricted");
  }
  if (ce_mode_brestricted_present) {
    j.write_int("id", 222);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ce_mode_brestricted.to_string());
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  if (masked_imeisv_present) {
    j.write_int("id", 34);
    j.write_str("criticality", "ignore");
    j.write_str("Value", masked_imeisv.to_string());
  }
  j.end_obj();
}

// DeactivateTraceIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t deactiv_trace_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 44};
  return map_enum_number(names, 3, idx, "id");
}
bool deactiv_trace_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 44};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e deactiv_trace_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 44:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
deactiv_trace_ies_o::value_c deactiv_trace_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 44:
      ret.set(value_c::types::ngran_trace_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e deactiv_trace_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 44:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void deactiv_trace_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ngran_trace_id:
      c.destroy<fixed_octstring<8, true>>();
      break;
    default:
      break;
  }
}
void deactiv_trace_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ngran_trace_id:
      c.init<fixed_octstring<8, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
}
deactiv_trace_ies_o::value_c::value_c(const deactiv_trace_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.init(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
}
deactiv_trace_ies_o::value_c& deactiv_trace_ies_o::value_c::operator=(const deactiv_trace_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.set(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }

  return *this;
}
uint64_t& deactiv_trace_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& deactiv_trace_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
fixed_octstring<8, true>& deactiv_trace_ies_o::value_c::ngran_trace_id()
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
const uint64_t& deactiv_trace_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& deactiv_trace_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const fixed_octstring<8, true>& deactiv_trace_ies_o::value_c::ngran_trace_id() const
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
void deactiv_trace_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE deactiv_trace_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE deactiv_trace_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "deactiv_trace_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE deactiv_trace_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)44, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ngran_trace_id.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE deactiv_trace_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 44: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_trace_id.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void deactiv_trace_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 44);
  j.write_str("criticality", "ignore");
  j.write_str("Value", ngran_trace_id.to_string());
  j.end_obj();
}

// DistributionReleaseRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 300, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool distribution_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 300, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 300:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_release_request_ies_o::value_c distribution_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 300:
      ret.set(value_c::types::mbs_distribution_release_request_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 300:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_release_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_distribution_release_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void distribution_release_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::mbs_distribution_release_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }
}
distribution_release_request_ies_o::value_c::value_c(const distribution_release_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_release_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }
}
distribution_release_request_ies_o::value_c&
distribution_release_request_ies_o::value_c::operator=(const distribution_release_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_release_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_release_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_release_request_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_release_request_ies_o::value_c::mbs_distribution_release_request_transfer()
{
  assert_choice_type(types::mbs_distribution_release_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& distribution_release_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const mbs_session_id_s& distribution_release_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_release_request_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
distribution_release_request_ies_o::value_c::mbs_distribution_release_request_transfer() const
{
  assert_choice_type(types::mbs_distribution_release_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& distribution_release_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void distribution_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_release_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_release_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_release_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE distribution_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)300, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_distribution_release_request_transfer.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 300: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_release_request_transfer.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  j.write_int("id", 300);
  j.write_str("criticality", "reject");
  j.write_str("Value", mbs_distribution_release_request_transfer.to_string());
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

// DistributionReleaseResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_release_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool distribution_release_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_release_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_release_resp_ies_o::value_c distribution_release_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_release_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_release_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void distribution_release_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }
}
distribution_release_resp_ies_o::value_c::value_c(const distribution_release_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }
}
distribution_release_resp_ies_o::value_c&
distribution_release_resp_ies_o::value_c::operator=(const distribution_release_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_release_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_release_resp_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
crit_diagnostics_s& distribution_release_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& distribution_release_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_release_resp_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const crit_diagnostics_s& distribution_release_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void distribution_release_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_release_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_release_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE distribution_release_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_release_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_release_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// DistributionSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 303, 15, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool distribution_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 303, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 303:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_setup_fail_ies_o::value_c distribution_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 303:
      ret.set(value_c::types::mbs_distribution_setup_unsuccessful_transfer);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 303:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void distribution_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }
}
distribution_setup_fail_ies_o::value_c::value_c(const distribution_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }
}
distribution_setup_fail_ies_o::value_c&
distribution_setup_fail_ies_o::value_c::operator=(const distribution_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_setup_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_setup_fail_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_setup_fail_ies_o::value_c::mbs_distribution_setup_unsuccessful_transfer()
{
  assert_choice_type(types::mbs_distribution_setup_unsuccessful_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& distribution_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& distribution_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& distribution_setup_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_setup_fail_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
distribution_setup_fail_ies_o::value_c::mbs_distribution_setup_unsuccessful_transfer() const
{
  assert_choice_type(types::mbs_distribution_setup_unsuccessful_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& distribution_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& distribution_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void distribution_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_unsuccessful_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE distribution_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)303, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_distribution_setup_unsuccessful_transfer.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 303: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_setup_unsuccessful_transfer.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  j.write_int("id", 303);
  j.write_str("criticality", "ignore");
  j.write_str("Value", mbs_distribution_setup_unsuccessful_transfer.to_string());
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// DistributionSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 301};
  return map_enum_number(names, 3, idx, "id");
}
bool distribution_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 301};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 301:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_setup_request_ies_o::value_c distribution_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 301:
      ret.set(value_c::types::mbs_distribution_setup_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 301:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_distribution_setup_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void distribution_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::mbs_distribution_setup_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }
}
distribution_setup_request_ies_o::value_c::value_c(const distribution_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }
}
distribution_setup_request_ies_o::value_c&
distribution_setup_request_ies_o::value_c::operator=(const distribution_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_setup_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_setup_request_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_setup_request_ies_o::value_c::mbs_distribution_setup_request_transfer()
{
  assert_choice_type(types::mbs_distribution_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& distribution_setup_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_setup_request_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
distribution_setup_request_ies_o::value_c::mbs_distribution_setup_request_transfer() const
{
  assert_choice_type(types::mbs_distribution_setup_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void distribution_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE distribution_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)301, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_distribution_setup_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 301: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_setup_request_transfer.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  j.write_int("id", 301);
  j.write_str("criticality", "reject");
  j.write_str("Value", mbs_distribution_setup_request_transfer.to_string());
  j.end_obj();
}

// DistributionSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t distribution_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 302, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool distribution_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 302, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e distribution_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 302:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
distribution_setup_resp_ies_o::value_c distribution_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 302:
      ret.set(value_c::types::mbs_distribution_setup_resp_transfer);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e distribution_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 302:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void distribution_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_distribution_setup_resp_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void distribution_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::mbs_distribution_setup_resp_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }
}
distribution_setup_resp_ies_o::value_c::value_c(const distribution_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_resp_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }
}
distribution_setup_resp_ies_o::value_c&
distribution_setup_resp_ies_o::value_c::operator=(const distribution_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_resp_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& distribution_setup_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& distribution_setup_resp_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& distribution_setup_resp_ies_o::value_c::mbs_distribution_setup_resp_transfer()
{
  assert_choice_type(types::mbs_distribution_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& distribution_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& distribution_setup_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& distribution_setup_resp_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>& distribution_setup_resp_ies_o::value_c::mbs_distribution_setup_resp_transfer() const
{
  assert_choice_type(types::mbs_distribution_setup_resp_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& distribution_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void distribution_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::mbs_distribution_setup_resp_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE distribution_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::mbs_distribution_setup_resp_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "distribution_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE distribution_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)302, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_distribution_setup_resp_transfer.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE distribution_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 302: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_distribution_setup_resp_transfer.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void distribution_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  j.write_int("id", 302);
  j.write_str("criticality", "reject");
  j.write_str("Value", mbs_distribution_setup_resp_transfer.to_string());
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// DownlinkNASTransport-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_nas_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  48,  83,  38,  36,  31,  110, 0,   177,
                                   205, 206, 209, 222, 117, 228, 226, 264, 334, 34};
  return map_enum_number(names, 20, idx, "id");
}
bool dl_nas_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  48,  83,  38,  36,  31,  110, 0,   177,
                                   205, 206, 209, 222, 117, 228, 226, 264, 334, 34};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_nas_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 48:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 38:
      return crit_e::reject;
    case 36:
      return crit_e::ignore;
    case 31:
      return crit_e::ignore;
    case 110:
      return crit_e::ignore;
    case 0:
      return crit_e::reject;
    case 177:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 117:
      return crit_e::ignore;
    case 228:
      return crit_e::ignore;
    case 226:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 334:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_nas_transport_ies_o::value_c dl_nas_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 48:
      ret.set(value_c::types::old_amf);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 36:
      ret.set(value_c::types::mob_restrict_list);
      break;
    case 31:
      ret.set(value_c::types::idx_to_rfsp);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 228:
      ret.set(value_c::types::ue_cap_info_request);
      break;
    case 226:
      ret.set(value_c::types::end_ind);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 334:
      ret.set(value_c::types::target_nssai_info);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_nas_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 48:
      return presence_e::optional;
    case 83:
      return presence_e::optional;
    case 38:
      return presence_e::mandatory;
    case 36:
      return presence_e::optional;
    case 31:
      return presence_e::optional;
    case 110:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 117:
      return presence_e::optional;
    case 228:
      return presence_e::optional;
    case 226:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 334:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_nas_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::old_amf:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::mob_restrict_list:
      c.destroy<mob_restrict_list_s>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::target_nssai_info:
      c.destroy<target_nssai_info_s>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    default:
      break;
  }
}
void dl_nas_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::old_amf:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::ran_paging_prio:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::mob_restrict_list:
      c.init<mob_restrict_list_s>();
      break;
    case types::idx_to_rfsp:
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::extended_connected_time:
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_cap_info_request:
      break;
    case types::end_ind:
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::target_nssai_info:
      c.init<target_nssai_info_s>();
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
}
dl_nas_transport_ies_o::value_c::value_c(const dl_nas_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::old_amf:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mob_restrict_list:
      c.init(other.c.get<mob_restrict_list_s>());
      break;
    case types::idx_to_rfsp:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_cap_info_request:
      c.init(other.c.get<ue_cap_info_request_e>());
      break;
    case types::end_ind:
      c.init(other.c.get<end_ind_e>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::target_nssai_info:
      c.init(other.c.get<target_nssai_info_s>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
}
dl_nas_transport_ies_o::value_c&
dl_nas_transport_ies_o::value_c::operator=(const dl_nas_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::old_amf:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mob_restrict_list:
      c.set(other.c.get<mob_restrict_list_s>());
      break;
    case types::idx_to_rfsp:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_cap_info_request:
      c.set(other.c.get<ue_cap_info_request_e>());
      break;
    case types::end_ind:
      c.set(other.c.get<end_ind_e>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::target_nssai_info:
      c.set(other.c.get<target_nssai_info_s>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_nas_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_nas_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
printable_string<1, 150, true, true>& dl_nas_transport_ies_o::value_c::old_amf()
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
uint16_t& dl_nas_transport_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mob_restrict_list_s& dl_nas_transport_ies_o::value_c::mob_restrict_list()
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
uint16_t& dl_nas_transport_ies_o::value_c::idx_to_rfsp()
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
ue_aggr_max_bit_rate_s& dl_nas_transport_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
allowed_nssai_l& dl_nas_transport_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
srvcc_operation_possible_e& dl_nas_transport_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
enhanced_coverage_restrict_e& dl_nas_transport_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
uint16_t& dl_nas_transport_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
ue_diff_info_s& dl_nas_transport_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
ce_mode_brestricted_e& dl_nas_transport_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
ue_cap_info_request_e& dl_nas_transport_ies_o::value_c::ue_cap_info_request()
{
  assert_choice_type(types::ue_cap_info_request, type_, "Value");
  return c.get<ue_cap_info_request_e>();
}
end_ind_e& dl_nas_transport_ies_o::value_c::end_ind()
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
target_nssai_info_s& dl_nas_transport_ies_o::value_c::target_nssai_info()
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
fixed_bitstring<64, false, true>& dl_nas_transport_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const uint64_t& dl_nas_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_nas_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const printable_string<1, 150, true, true>& dl_nas_transport_ies_o::value_c::old_amf() const
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const uint16_t& dl_nas_transport_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mob_restrict_list_s& dl_nas_transport_ies_o::value_c::mob_restrict_list() const
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
const uint16_t& dl_nas_transport_ies_o::value_c::idx_to_rfsp() const
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
const ue_aggr_max_bit_rate_s& dl_nas_transport_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const allowed_nssai_l& dl_nas_transport_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const srvcc_operation_possible_e& dl_nas_transport_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const enhanced_coverage_restrict_e& dl_nas_transport_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const uint16_t& dl_nas_transport_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const ue_diff_info_s& dl_nas_transport_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const ce_mode_brestricted_e& dl_nas_transport_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const ue_cap_info_request_e& dl_nas_transport_ies_o::value_c::ue_cap_info_request() const
{
  assert_choice_type(types::ue_cap_info_request, type_, "Value");
  return c.get<ue_cap_info_request_e>();
}
const end_ind_e& dl_nas_transport_ies_o::value_c::end_ind() const
{
  assert_choice_type(types::end_ind, type_, "Value");
  return c.get<end_ind_e>();
}
const unbounded_octstring<true>& dl_nas_transport_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const target_nssai_info_s& dl_nas_transport_ies_o::value_c::target_nssai_info() const
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
const fixed_bitstring<64, false, true>& dl_nas_transport_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
void dl_nas_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::old_amf:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::mob_restrict_list:
      j.write_fieldname("MobilityRestrictionList");
      c.get<mob_restrict_list_s>().to_json(j);
      break;
    case types::idx_to_rfsp:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_cap_info_request:
      j.write_str("UECapabilityInfoRequest", "requested");
      break;
    case types::end_ind:
      j.write_str("EndIndication", c.get<end_ind_e>().to_string());
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::target_nssai_info:
      j.write_fieldname("TargetNSSAIInformation");
      c.get<target_nssai_info_s>().to_json(j);
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_nas_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().pack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_cap_info_request:
      HANDLE_CODE(c.get<ue_cap_info_request_e>().pack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_nas_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().unpack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_cap_info_request:
      HANDLE_CODE(c.get<ue_cap_info_request_e>().unpack(bref));
      break;
    case types::end_ind:
      HANDLE_CODE(c.get<end_ind_e>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "dl_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE dl_nas_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += old_amf_present ? 1 : 0;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += mob_restrict_list_present ? 1 : 0;
  nof_ies += idx_to_rfsp_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += ue_cap_info_request_present ? 1 : 0;
  nof_ies += end_ind_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += target_nssai_info_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (old_amf_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)48, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(old_amf.pack(bref));
  }
  if (ran_paging_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)83, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_paging_prio, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  if (mob_restrict_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)36, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mob_restrict_list.pack(bref));
  }
  if (idx_to_rfsp_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)31, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, idx_to_rfsp, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)110, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)177, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)205, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)206, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, extended_connected_time, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)222, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (ue_cap_info_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)228, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_cap_info_request.pack(bref));
  }
  if (end_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)226, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(end_ind.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (target_nssai_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)334, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(target_nssai_info.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)34, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(masked_imeisv.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_nas_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 48: {
        old_amf_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(old_amf.unpack(bref));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_paging_prio, bref, (uint16_t)1u, (uint16_t)256u, false, true));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 36: {
        mob_restrict_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mob_restrict_list.unpack(bref));
        break;
      }
      case 31: {
        idx_to_rfsp_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(idx_to_rfsp, bref, (uint16_t)1u, (uint16_t)256u, true, true));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(extended_connected_time, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 228: {
        ue_cap_info_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_cap_info_request.unpack(bref));
        break;
      }
      case 226: {
        end_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(end_ind.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 334: {
        target_nssai_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_nssai_info.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_nas_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (old_amf_present) {
    j.write_int("id", 48);
    j.write_str("criticality", "reject");
    j.write_str("Value", old_amf.to_string());
  }
  if (ran_paging_prio_present) {
    j.write_int("id", 83);
    j.write_str("criticality", "ignore");
    j.write_int("Value", ran_paging_prio);
  }
  j.write_int("id", 38);
  j.write_str("criticality", "reject");
  j.write_str("Value", nas_pdu.to_string());
  if (mob_restrict_list_present) {
    j.write_int("id", 36);
    j.write_str("criticality", "ignore");
    mob_restrict_list.to_json(j);
  }
  if (idx_to_rfsp_present) {
    j.write_int("id", 31);
    j.write_str("criticality", "ignore");
    j.write_int("Value", idx_to_rfsp);
  }
  if (ue_aggr_max_bit_rate_present) {
    j.write_int("id", 110);
    j.write_str("criticality", "ignore");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_int("id", 0);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : allowed_nssai) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (srvcc_operation_possible_present) {
    j.write_int("id", 177);
    j.write_str("criticality", "ignore");
    j.write_str("Value", srvcc_operation_possible.to_string());
  }
  if (enhanced_coverage_restrict_present) {
    j.write_int("id", 205);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "restricted");
  }
  if (extended_connected_time_present) {
    j.write_int("id", 206);
    j.write_str("criticality", "ignore");
    j.write_int("Value", extended_connected_time);
  }
  if (ue_diff_info_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    ue_diff_info.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_int("id", 222);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ce_mode_brestricted.to_string());
  }
  if (ue_radio_cap_present) {
    j.write_int("id", 117);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ue_radio_cap.to_string());
  }
  if (ue_cap_info_request_present) {
    j.write_int("id", 228);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "requested");
  }
  if (end_ind_present) {
    j.write_int("id", 226);
    j.write_str("criticality", "ignore");
    j.write_str("Value", end_ind.to_string());
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  if (target_nssai_info_present) {
    j.write_int("id", 334);
    j.write_str("criticality", "ignore");
    target_nssai_info.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_int("id", 34);
    j.write_str("criticality", "ignore");
    j.write_str("Value", masked_imeisv.to_string());
  }
  j.end_obj();
}

// DownlinkNonUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_non_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {89, 46};
  return map_enum_number(names, 2, idx, "id");
}
bool dl_non_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_non_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_non_ue_associated_nrppa_transport_ies_o::value_c
dl_non_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_non_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_non_ue_associated_nrppa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::routing_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void dl_non_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::routing_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
dl_non_ue_associated_nrppa_transport_ies_o::value_c::value_c(
    const dl_non_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::routing_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
dl_non_ue_associated_nrppa_transport_ies_o::value_c& dl_non_ue_associated_nrppa_transport_ies_o::value_c::operator=(
    const dl_non_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::routing_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }

  return *this;
}
unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& dl_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void dl_non_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)89, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(routing_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)46, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nrppa_pdu.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_non_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 89: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_non_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 89);
  j.write_str("criticality", "reject");
  j.write_str("Value", routing_id.to_string());
  j.write_int("id", 46);
  j.write_str("criticality", "reject");
  j.write_str("Value", nrppa_pdu.to_string());
  j.end_obj();
}

// DownlinkRANConfigurationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ran_cfg_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {98, 157, 250};
  return map_enum_number(names, 3, idx, "id");
}
bool dl_ran_cfg_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {98, 157, 250};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ran_cfg_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 98:
      return crit_e::ignore;
    case 157:
      return crit_e::ignore;
    case 250:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ran_cfg_transfer_ies_o::value_c dl_ran_cfg_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 98:
      ret.set(value_c::types::son_cfg_transfer_dl);
      break;
    case 157:
      ret.set(value_c::types::endc_son_cfg_transfer_dl);
      break;
    case 250:
      ret.set(value_c::types::intersys_son_cfg_transfer_dl);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ran_cfg_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 98:
      return presence_e::optional;
    case 157:
      return presence_e::optional;
    case 250:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ran_cfg_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::son_cfg_transfer_dl:
      c.destroy<son_cfg_transfer_s>();
      break;
    case types::endc_son_cfg_transfer_dl:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::intersys_son_cfg_transfer_dl:
      c.destroy<intersys_son_cfg_transfer_s>();
      break;
    default:
      break;
  }
}
void dl_ran_cfg_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::son_cfg_transfer_dl:
      c.init<son_cfg_transfer_s>();
      break;
    case types::endc_son_cfg_transfer_dl:
      c.init<unbounded_octstring<true>>();
      break;
    case types::intersys_son_cfg_transfer_dl:
      c.init<intersys_son_cfg_transfer_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }
}
dl_ran_cfg_transfer_ies_o::value_c::value_c(const dl_ran_cfg_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::son_cfg_transfer_dl:
      c.init(other.c.get<son_cfg_transfer_s>());
      break;
    case types::endc_son_cfg_transfer_dl:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::intersys_son_cfg_transfer_dl:
      c.init(other.c.get<intersys_son_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }
}
dl_ran_cfg_transfer_ies_o::value_c&
dl_ran_cfg_transfer_ies_o::value_c::operator=(const dl_ran_cfg_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::son_cfg_transfer_dl:
      c.set(other.c.get<son_cfg_transfer_s>());
      break;
    case types::endc_son_cfg_transfer_dl:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::intersys_son_cfg_transfer_dl:
      c.set(other.c.get<intersys_son_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }

  return *this;
}
son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_dl()
{
  assert_choice_type(types::son_cfg_transfer_dl, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
unbounded_octstring<true>& dl_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_dl()
{
  assert_choice_type(types::endc_son_cfg_transfer_dl, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
intersys_son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_dl()
{
  assert_choice_type(types::intersys_son_cfg_transfer_dl, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
const son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_dl() const
{
  assert_choice_type(types::son_cfg_transfer_dl, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
const unbounded_octstring<true>& dl_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_dl() const
{
  assert_choice_type(types::endc_son_cfg_transfer_dl, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const intersys_son_cfg_transfer_s& dl_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_dl() const
{
  assert_choice_type(types::intersys_son_cfg_transfer_dl, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
void dl_ran_cfg_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::son_cfg_transfer_dl:
      j.write_fieldname("SONConfigurationTransfer");
      c.get<son_cfg_transfer_s>().to_json(j);
      break;
    case types::endc_son_cfg_transfer_dl:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::intersys_son_cfg_transfer_dl:
      j.write_fieldname("IntersystemSONConfigurationTransfer");
      c.get<intersys_son_cfg_transfer_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ran_cfg_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_dl:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().pack(bref));
      break;
    case types::endc_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::intersys_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_cfg_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_dl:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().unpack(bref));
      break;
    case types::endc_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::intersys_son_cfg_transfer_dl:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE dl_ran_cfg_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += son_cfg_transfer_dl_present ? 1 : 0;
  nof_ies += endc_son_cfg_transfer_dl_present ? 1 : 0;
  nof_ies += intersys_son_cfg_transfer_dl_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (son_cfg_transfer_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)98, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(son_cfg_transfer_dl.pack(bref));
  }
  if (endc_son_cfg_transfer_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)157, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(endc_son_cfg_transfer_dl.pack(bref));
  }
  if (intersys_son_cfg_transfer_dl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)250, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(intersys_son_cfg_transfer_dl.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_cfg_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 98: {
        son_cfg_transfer_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(son_cfg_transfer_dl.unpack(bref));
        break;
      }
      case 157: {
        endc_son_cfg_transfer_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(endc_son_cfg_transfer_dl.unpack(bref));
        break;
      }
      case 250: {
        intersys_son_cfg_transfer_dl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(intersys_son_cfg_transfer_dl.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void dl_ran_cfg_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (son_cfg_transfer_dl_present) {
    j.write_int("id", 98);
    j.write_str("criticality", "ignore");
    son_cfg_transfer_dl.to_json(j);
  }
  if (endc_son_cfg_transfer_dl_present) {
    j.write_int("id", 157);
    j.write_str("criticality", "ignore");
    j.write_str("Value", endc_son_cfg_transfer_dl.to_string());
  }
  if (intersys_son_cfg_transfer_dl_present) {
    j.write_int("id", 250);
    j.write_str("criticality", "ignore");
    intersys_son_cfg_transfer_dl.to_json(j);
  }
  j.end_obj();
}

// DownlinkRANEarlyStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ran_early_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 268};
  return map_enum_number(names, 3, idx, "id");
}
bool dl_ran_early_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 268};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ran_early_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 268:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ran_early_status_transfer_ies_o::value_c dl_ran_early_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 268:
      ret.set(value_c::types::early_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ran_early_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 268:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ran_early_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::early_status_transfer_transparent_container:
      c.destroy<early_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void dl_ran_early_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::early_status_transfer_transparent_container:
      c.init<early_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }
}
dl_ran_early_status_transfer_ies_o::value_c::value_c(const dl_ran_early_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      c.init(other.c.get<early_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }
}
dl_ran_early_status_transfer_ies_o::value_c&
dl_ran_early_status_transfer_ies_o::value_c::operator=(const dl_ran_early_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      c.set(other.c.get<early_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
early_status_transfer_transparent_container_s&
dl_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container()
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
const uint64_t& dl_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const early_status_transfer_transparent_container_s&
dl_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container() const
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
void dl_ran_early_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      j.write_fieldname("EarlyStatusTransfer-TransparentContainer");
      c.get<early_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ran_early_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_early_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE dl_ran_early_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)268, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(early_status_transfer_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_early_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 268: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(early_status_transfer_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_ran_early_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 268);
  j.write_str("criticality", "reject");
  early_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

// DownlinkRANStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ran_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 84};
  return map_enum_number(names, 3, idx, "id");
}
bool dl_ran_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 84};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ran_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 84:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ran_status_transfer_ies_o::value_c dl_ran_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 84:
      ret.set(value_c::types::ran_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ran_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 84:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ran_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ran_status_transfer_transparent_container:
      c.destroy<ran_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void dl_ran_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_status_transfer_transparent_container:
      c.init<ran_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }
}
dl_ran_status_transfer_ies_o::value_c::value_c(const dl_ran_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      c.init(other.c.get<ran_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }
}
dl_ran_status_transfer_ies_o::value_c&
dl_ran_status_transfer_ies_o::value_c::operator=(const dl_ran_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      c.set(other.c.get<ran_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ran_status_transfer_transparent_container_s&
dl_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container()
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
const uint64_t& dl_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ran_status_transfer_transparent_container_s&
dl_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container() const
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
void dl_ran_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      j.write_fieldname("RANStatusTransfer-TransparentContainer");
      c.get<ran_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ran_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE dl_ran_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)84, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ran_status_transfer_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ran_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 84: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_status_transfer_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_ran_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 84);
  j.write_str("criticality", "reject");
  ran_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

// DownlinkRIMInformationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_rim_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {175};
  return map_enum_number(names, 1, idx, "id");
}
bool dl_rim_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  return 175 == id;
}
crit_e dl_rim_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  if (id == 175) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
dl_rim_info_transfer_ies_o::value_c dl_rim_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 175) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_rim_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  if (id == 175) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void dl_rim_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("RIMInformationTransfer");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE dl_rim_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_rim_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// DownlinkUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t dl_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  return map_enum_number(names, 4, idx, "id");
}
bool dl_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e dl_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
dl_ue_associated_nrppa_transport_ies_o::value_c dl_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e dl_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void dl_ue_associated_nrppa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::routing_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void dl_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::routing_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
dl_ue_associated_nrppa_transport_ies_o::value_c::value_c(const dl_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::routing_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
dl_ue_associated_nrppa_transport_ies_o::value_c&
dl_ue_associated_nrppa_transport_ies_o::value_c::operator=(const dl_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::routing_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& dl_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& dl_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void dl_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "dl_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE dl_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)89, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(routing_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)46, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nrppa_pdu.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE dl_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 89: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void dl_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 89);
  j.write_str("criticality", "reject");
  j.write_str("Value", routing_id.to_string());
  j.write_int("id", 46);
  j.write_str("criticality", "reject");
  j.write_str("Value", nrppa_pdu.to_string());
  j.end_obj();
}

// ErrorIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t error_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19, 26};
  return map_enum_number(names, 5, idx, "id");
}
bool error_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19, 26};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e error_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 26:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
error_ind_ies_o::value_c error_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e error_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::optional;
    case 85:
      return presence_e::optional;
    case 15:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 26:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void error_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    default:
      break;
  }
}
void error_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
}
error_ind_ies_o::value_c::value_c(const error_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
}
error_ind_ies_o::value_c& error_ind_ies_o::value_c::operator=(const error_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& error_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& error_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& error_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& error_ind_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
five_g_s_tmsi_s& error_ind_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const uint64_t& error_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& error_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& error_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& error_ind_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const five_g_s_tmsi_s& error_ind_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
void error_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE error_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE error_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "error_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE error_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_ue_ngap_id_present ? 1 : 0;
  nof_ies += ran_ue_ngap_id_present ? 1 : 0;
  nof_ies += cause_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += five_g_s_tmsi_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_ue_ngap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  if (ran_ue_ngap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (cause_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (five_g_s_tmsi_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)26, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_s_tmsi.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE error_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        amf_ue_ngap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        ran_ue_ngap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        cause_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 26: {
        five_g_s_tmsi_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void error_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_ue_ngap_id_present) {
    j.write_int("id", 10);
    j.write_str("criticality", "ignore");
    j.write_int("Value", amf_ue_ngap_id);
  }
  if (ran_ue_ngap_id_present) {
    j.write_int("id", 85);
    j.write_str("criticality", "ignore");
    j.write_int("Value", ran_ue_ngap_id);
  }
  if (cause_present) {
    j.write_int("id", 15);
    j.write_str("criticality", "ignore");
    cause.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (five_g_s_tmsi_present) {
    j.write_int("id", 26);
    j.write_str("criticality", "ignore");
    five_g_s_tmsi.to_json(j);
  }
  j.end_obj();
}

// HandoverCancelIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_cancel_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15};
  return map_enum_number(names, 3, idx, "id");
}
bool ho_cancel_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cancel_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cancel_ies_o::value_c ho_cancel_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cancel_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cancel_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void ho_cancel_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
}
ho_cancel_ies_o::value_c::value_c(const ho_cancel_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
}
ho_cancel_ies_o::value_c& ho_cancel_ies_o::value_c::operator=(const ho_cancel_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_cancel_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_cancel_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ho_cancel_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& ho_cancel_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_cancel_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ho_cancel_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ho_cancel_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cancel_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE ho_cancel_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cancel_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

// HandoverCancelAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_cancel_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ho_cancel_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cancel_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cancel_ack_ies_o::value_c ho_cancel_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cancel_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cancel_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ho_cancel_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
}
ho_cancel_ack_ies_o::value_c::value_c(const ho_cancel_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
}
ho_cancel_ack_ies_o::value_c& ho_cancel_ack_ies_o::value_c::operator=(const ho_cancel_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_cancel_ack_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_cancel_ack_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
crit_diagnostics_s& ho_cancel_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ho_cancel_ack_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_cancel_ack_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const crit_diagnostics_s& ho_cancel_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ho_cancel_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cancel_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cancel_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE ho_cancel_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cancel_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cancel_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// HandoverCommandIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 29, 39, 59, 78, 106, 19};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 29, 39, 59, 78, 106, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 39:
      return crit_e::reject;
    case 59:
      return crit_e::ignore;
    case 78:
      return crit_e::ignore;
    case 106:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_cmd_ies_o::value_c ho_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 29:
      ret.set(value_c::types::handov_type);
      break;
    case 39:
      ret.set(value_c::types::nas_security_params_from_ngran);
      break;
    case 59:
      ret.set(value_c::types::pdu_session_res_ho_list);
      break;
    case 78:
      ret.set(value_c::types::pdu_session_res_to_release_list_ho_cmd);
      break;
    case 106:
      ret.set(value_c::types::target_to_source_transparent_container);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 29:
      return presence_e::mandatory;
    case 39:
      return presence_e::conditional;
    case 59:
      return presence_e::optional;
    case 78:
      return presence_e::optional;
    case 106:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_cmd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_security_params_from_ngran:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_ho_list:
      c.destroy<pdu_session_res_ho_list_l>();
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      c.destroy<pdu_session_res_to_release_list_ho_cmd_l>();
      break;
    case types::target_to_source_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ho_cmd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::handov_type:
      break;
    case types::nas_security_params_from_ngran:
      c.init<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_ho_list:
      c.init<pdu_session_res_ho_list_l>();
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      c.init<pdu_session_res_to_release_list_ho_cmd_l>();
      break;
    case types::target_to_source_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
}
ho_cmd_ies_o::value_c::value_c(const ho_cmd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.init(other.c.get<handov_type_e>());
      break;
    case types::nas_security_params_from_ngran:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_ho_list:
      c.init(other.c.get<pdu_session_res_ho_list_l>());
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      c.init(other.c.get<pdu_session_res_to_release_list_ho_cmd_l>());
      break;
    case types::target_to_source_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
}
ho_cmd_ies_o::value_c& ho_cmd_ies_o::value_c::operator=(const ho_cmd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.set(other.c.get<handov_type_e>());
      break;
    case types::nas_security_params_from_ngran:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_ho_list:
      c.set(other.c.get<pdu_session_res_ho_list_l>());
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      c.set(other.c.get<pdu_session_res_to_release_list_ho_cmd_l>());
      break;
    case types::target_to_source_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_cmd_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_cmd_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
handov_type_e& ho_cmd_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
unbounded_octstring<true>& ho_cmd_ies_o::value_c::nas_security_params_from_ngran()
{
  assert_choice_type(types::nas_security_params_from_ngran, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_ho_list_l& ho_cmd_ies_o::value_c::pdu_session_res_ho_list()
{
  assert_choice_type(types::pdu_session_res_ho_list, type_, "Value");
  return c.get<pdu_session_res_ho_list_l>();
}
pdu_session_res_to_release_list_ho_cmd_l& ho_cmd_ies_o::value_c::pdu_session_res_to_release_list_ho_cmd()
{
  assert_choice_type(types::pdu_session_res_to_release_list_ho_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_ho_cmd_l>();
}
unbounded_octstring<true>& ho_cmd_ies_o::value_c::target_to_source_transparent_container()
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& ho_cmd_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ho_cmd_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_cmd_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const handov_type_e& ho_cmd_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const unbounded_octstring<true>& ho_cmd_ies_o::value_c::nas_security_params_from_ngran() const
{
  assert_choice_type(types::nas_security_params_from_ngran, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_ho_list_l& ho_cmd_ies_o::value_c::pdu_session_res_ho_list() const
{
  assert_choice_type(types::pdu_session_res_ho_list, type_, "Value");
  return c.get<pdu_session_res_ho_list_l>();
}
const pdu_session_res_to_release_list_ho_cmd_l& ho_cmd_ies_o::value_c::pdu_session_res_to_release_list_ho_cmd() const
{
  assert_choice_type(types::pdu_session_res_to_release_list_ho_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_ho_cmd_l>();
}
const unbounded_octstring<true>& ho_cmd_ies_o::value_c::target_to_source_transparent_container() const
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& ho_cmd_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ho_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::nas_security_params_from_ngran:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_ho_list:
      j.start_array("PDUSessionResourceHandoverList");
      for (const auto& e1 : c.get<pdu_session_res_ho_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      j.start_array("PDUSessionResourceToReleaseListHOCmd");
      for (const auto& e1 : c.get<pdu_session_res_to_release_list_ho_cmd_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::target_to_source_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::nas_security_params_from_ngran:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_ho_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_ho_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_to_release_list_ho_cmd_l>(), 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::nas_security_params_from_ngran:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_ho_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_ho_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_to_release_list_ho_cmd:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_to_release_list_ho_cmd_l>(), bref, 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE ho_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += nas_security_params_from_ngran_present ? 1 : 0;
  nof_ies += pdu_session_res_ho_list_present ? 1 : 0;
  nof_ies += pdu_session_res_to_release_list_ho_cmd_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)29, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(handov_type.pack(bref));
  }
  if (nas_security_params_from_ngran_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)39, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_security_params_from_ngran.pack(bref));
  }
  if (pdu_session_res_ho_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)59, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_ho_list, 1, 256, true));
  }
  if (pdu_session_res_to_release_list_ho_cmd_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)78, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_to_release_list_ho_cmd, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)106, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(target_to_source_transparent_container.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 29: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(handov_type.unpack(bref));
        break;
      }
      case 39: {
        nas_security_params_from_ngran_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_security_params_from_ngran.unpack(bref));
        break;
      }
      case 59: {
        pdu_session_res_ho_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_ho_list, bref, 1, 256, true));
        break;
      }
      case 78: {
        pdu_session_res_to_release_list_ho_cmd_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_to_release_list_ho_cmd, bref, 1, 256, true));
        break;
      }
      case 106: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_to_source_transparent_container.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 29);
  j.write_str("criticality", "reject");
  j.write_str("Value", handov_type.to_string());
  if (nas_security_params_from_ngran_present) {
    j.write_int("id", 39);
    j.write_str("criticality", "reject");
    j.write_str("Value", nas_security_params_from_ngran.to_string());
  }
  if (pdu_session_res_ho_list_present) {
    j.write_int("id", 59);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_ho_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_to_release_list_ho_cmd_present) {
    j.write_int("id", 78);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_to_release_list_ho_cmd) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 106);
  j.write_str("criticality", "reject");
  j.write_str("Value", target_to_source_transparent_container.to_string());
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// HandoverFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 15, 19, 262};
  return map_enum_number(names, 4, idx, "id");
}
bool ho_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 15, 19, 262};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 262:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_fail_ies_o::value_c ho_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 262:
      ret.set(value_c::types::targetto_source_fail_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 262:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::targetto_source_fail_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ho_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::targetto_source_fail_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
}
ho_fail_ies_o::value_c::value_c(const ho_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::targetto_source_fail_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
}
ho_fail_ies_o::value_c& ho_fail_ies_o::value_c::operator=(const ho_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::targetto_source_fail_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ho_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ho_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
unbounded_octstring<true>& ho_fail_ies_o::value_c::targetto_source_fail_transparent_container()
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ho_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ho_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ho_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const unbounded_octstring<true>& ho_fail_ies_o::value_c::targetto_source_fail_transparent_container() const
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ho_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::targetto_source_fail_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE ho_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += targetto_source_fail_transparent_container_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (targetto_source_fail_transparent_container_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)262, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(targetto_source_fail_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 262: {
        targetto_source_fail_transparent_container_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(targetto_source_fail_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (targetto_source_fail_transparent_container_present) {
    j.write_int("id", 262);
    j.write_str("criticality", "ignore");
    j.write_str("Value", targetto_source_fail_transparent_container.to_string());
  }
  j.end_obj();
}

// HandoverNotifyIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_notify_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 121, 269};
  return map_enum_number(names, 4, idx, "id");
}
bool ho_notify_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 121, 269};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_notify_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 269:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_notify_ies_o::value_c ho_notify_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 269:
      ret.set(value_c::types::notify_source_ngran_node);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_notify_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 269:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_notify_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void ho_notify_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::notify_source_ngran_node:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
}
ho_notify_ies_o::value_c::value_c(const ho_notify_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::notify_source_ngran_node:
      c.init(other.c.get<notify_source_ngran_node_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
}
ho_notify_ies_o::value_c& ho_notify_ies_o::value_c::operator=(const ho_notify_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::notify_source_ngran_node:
      c.set(other.c.get<notify_source_ngran_node_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_notify_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_notify_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& ho_notify_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
notify_source_ngran_node_e& ho_notify_ies_o::value_c::notify_source_ngran_node()
{
  assert_choice_type(types::notify_source_ngran_node, type_, "Value");
  return c.get<notify_source_ngran_node_e>();
}
const uint64_t& ho_notify_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_notify_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& ho_notify_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const notify_source_ngran_node_e& ho_notify_ies_o::value_c::notify_source_ngran_node() const
{
  assert_choice_type(types::notify_source_ngran_node, type_, "Value");
  return c.get<notify_source_ngran_node_e>();
}
void ho_notify_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::notify_source_ngran_node:
      j.write_str("NotifySourceNGRANNode", "notifySource");
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_notify_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::notify_source_ngran_node:
      HANDLE_CODE(c.get<notify_source_ngran_node_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_notify_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::notify_source_ngran_node:
      HANDLE_CODE(c.get<notify_source_ngran_node_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_notify_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE ho_notify_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += notify_source_ngran_node_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (notify_source_ngran_node_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)269, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(notify_source_ngran_node.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_notify_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 269: {
        notify_source_ngran_node_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(notify_source_ngran_node.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_notify_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 121);
  j.write_str("criticality", "ignore");
  user_location_info.to_json(j);
  if (notify_source_ngran_node_present) {
    j.write_int("id", 269);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "notifySource");
  }
  j.end_obj();
}

// HandoverPreparationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_prep_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19, 262};
  return map_enum_number(names, 5, idx, "id");
}
bool ho_prep_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19, 262};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_prep_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 262:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_prep_fail_ies_o::value_c ho_prep_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 262:
      ret.set(value_c::types::targetto_source_fail_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_prep_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 262:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_prep_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::targetto_source_fail_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ho_prep_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::targetto_source_fail_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
}
ho_prep_fail_ies_o::value_c::value_c(const ho_prep_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::targetto_source_fail_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
}
ho_prep_fail_ies_o::value_c& ho_prep_fail_ies_o::value_c::operator=(const ho_prep_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::targetto_source_fail_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_prep_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_prep_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ho_prep_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ho_prep_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
unbounded_octstring<true>& ho_prep_fail_ies_o::value_c::targetto_source_fail_transparent_container()
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ho_prep_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_prep_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ho_prep_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ho_prep_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const unbounded_octstring<true>& ho_prep_fail_ies_o::value_c::targetto_source_fail_transparent_container() const
{
  assert_choice_type(types::targetto_source_fail_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ho_prep_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::targetto_source_fail_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_prep_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_prep_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::targetto_source_fail_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_prep_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE ho_prep_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += targetto_source_fail_transparent_container_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (targetto_source_fail_transparent_container_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)262, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(targetto_source_fail_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_prep_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 262: {
        targetto_source_fail_transparent_container_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(targetto_source_fail_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_prep_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (targetto_source_fail_transparent_container_present) {
    j.write_int("id", 262);
    j.write_str("criticality", "ignore");
    j.write_str("Value", targetto_source_fail_transparent_container.to_string());
  }
  j.end_obj();
}

// HandoverRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  29,  15,  110, 18,  119, 93,  41,  37,  73,  0,   108, 34,
                                   101, 36,  33,  91,  28,  146, 165, 177, 199, 205, 209, 216, 215,
                                   218, 217, 219, 222, 234, 254, 264, 206, 326, 335, 345, 346, 347};
  return map_enum_number(names, 39, idx, "id");
}
bool ho_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  29,  15,  110, 18,  119, 93,  41,  37,  73,  0,   108, 34,
                                   101, 36,  33,  91,  28,  146, 165, 177, 199, 205, 209, 216, 215,
                                   218, 217, 219, 222, 234, 254, 264, 206, 326, 335, 345, 346, 347};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 110:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 119:
      return crit_e::reject;
    case 93:
      return crit_e::reject;
    case 41:
      return crit_e::reject;
    case 37:
      return crit_e::reject;
    case 73:
      return crit_e::reject;
    case 0:
      return crit_e::reject;
    case 108:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    case 101:
      return crit_e::reject;
    case 36:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    case 91:
      return crit_e::ignore;
    case 28:
      return crit_e::reject;
    case 146:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 199:
      return crit_e::reject;
    case 205:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 254:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 206:
      return crit_e::ignore;
    case 326:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_request_ies_o::value_c ho_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 29:
      ret.set(value_c::types::handov_type);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 41:
      ret.set(value_c::types::new_security_context_ind);
      break;
    case 37:
      ret.set(value_c::types::nasc);
      break;
    case 73:
      ret.set(value_c::types::pdu_session_res_setup_list_ho_req);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 108:
      ret.set(value_c::types::trace_activation);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    case 101:
      ret.set(value_c::types::source_to_target_transparent_container);
      break;
    case 36:
      ret.set(value_c::types::mob_restrict_list);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 28:
      ret.set(value_c::types::guami);
      break;
    case 146:
      ret.set(value_c::types::redirection_voice_fallback);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 199:
      ret.set(value_c::types::iab_authorized);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 234:
      ret.set(value_c::types::ue_up_c_iot_support);
      break;
    case 254:
      ret.set(value_c::types::management_based_mdt_plmn_list);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 29:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 110:
      return presence_e::mandatory;
    case 18:
      return presence_e::optional;
    case 119:
      return presence_e::mandatory;
    case 93:
      return presence_e::mandatory;
    case 41:
      return presence_e::optional;
    case 37:
      return presence_e::optional;
    case 73:
      return presence_e::mandatory;
    case 0:
      return presence_e::mandatory;
    case 108:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    case 101:
      return presence_e::mandatory;
    case 36:
      return presence_e::optional;
    case 33:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 28:
      return presence_e::mandatory;
    case 146:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 199:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 254:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.destroy<core_network_assist_info_for_inactive_s>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::nasc:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_setup_list_ho_req:
      c.destroy<pdu_session_res_setup_list_ho_req_l>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::trace_activation:
      c.destroy<trace_activation_s>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    case types::source_to_target_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::mob_restrict_list:
      c.destroy<mob_restrict_list_s>();
      break;
    case types::location_report_request_type:
      c.destroy<location_report_request_type_s>();
      break;
    case types::guami:
      c.destroy<guami_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.destroy<cn_assisted_ran_tuning_s>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.destroy<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.destroy<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.destroy<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.destroy<pc5_qos_params_s>();
      break;
    case types::management_based_mdt_plmn_list:
      c.destroy<mdt_plmn_list_l>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.destroy<time_sync_assist_info_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.destroy<ue_slice_max_bit_rate_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.destroy<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.destroy<five_g_pro_se_pc5_qos_params_s>();
      break;
    default:
      break;
  }
}
void ho_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::handov_type:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.init<core_network_assist_info_for_inactive_s>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::new_security_context_ind:
      break;
    case types::nasc:
      c.init<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_setup_list_ho_req:
      c.init<pdu_session_res_setup_list_ho_req_l>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::trace_activation:
      c.init<trace_activation_s>();
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::source_to_target_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::mob_restrict_list:
      c.init<mob_restrict_list_s>();
      break;
    case types::location_report_request_type:
      c.init<location_report_request_type_s>();
      break;
    case types::rrc_inactive_transition_report_request:
      break;
    case types::guami:
      c.init<guami_s>();
      break;
    case types::redirection_voice_fallback:
      break;
    case types::cn_assisted_ran_tuning:
      c.init<cn_assisted_ran_tuning_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::iab_authorized:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.init<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.init<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.init<pc5_qos_params_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_up_c_iot_support:
      break;
    case types::management_based_mdt_plmn_list:
      c.init<mdt_plmn_list_l>();
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::extended_connected_time:
      break;
    case types::time_sync_assist_info:
      c.init<time_sync_assist_info_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init<ue_slice_max_bit_rate_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.init<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
}
ho_request_ies_o::value_c::value_c(const ho_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.init(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.init(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::new_security_context_ind:
      c.init(other.c.get<new_security_context_ind_e>());
      break;
    case types::nasc:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_setup_list_ho_req:
      c.init(other.c.get<pdu_session_res_setup_list_ho_req_l>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::trace_activation:
      c.init(other.c.get<trace_activation_s>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::source_to_target_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mob_restrict_list:
      c.init(other.c.get<mob_restrict_list_s>());
      break;
    case types::location_report_request_type:
      c.init(other.c.get<location_report_request_type_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.init(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::guami:
      c.init(other.c.get<guami_s>());
      break;
    case types::redirection_voice_fallback:
      c.init(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::cn_assisted_ran_tuning:
      c.init(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.init(other.c.get<iab_authorized_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.init(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.init(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.init(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.init(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::management_based_mdt_plmn_list:
      c.init(other.c.get<mdt_plmn_list_l>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::time_sync_assist_info:
      c.init(other.c.get<time_sync_assist_info_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.init(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
}
ho_request_ies_o::value_c& ho_request_ies_o::value_c::operator=(const ho_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.set(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.set(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::new_security_context_ind:
      c.set(other.c.get<new_security_context_ind_e>());
      break;
    case types::nasc:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_setup_list_ho_req:
      c.set(other.c.get<pdu_session_res_setup_list_ho_req_l>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::trace_activation:
      c.set(other.c.get<trace_activation_s>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::source_to_target_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::mob_restrict_list:
      c.set(other.c.get<mob_restrict_list_s>());
      break;
    case types::location_report_request_type:
      c.set(other.c.get<location_report_request_type_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.set(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::guami:
      c.set(other.c.get<guami_s>());
      break;
    case types::redirection_voice_fallback:
      c.set(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::cn_assisted_ran_tuning:
      c.set(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.set(other.c.get<iab_authorized_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.set(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.set(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.set(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.set(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::management_based_mdt_plmn_list:
      c.set(other.c.get<mdt_plmn_list_l>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::time_sync_assist_info:
      c.set(other.c.get<time_sync_assist_info_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.set(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.set(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.set(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
handov_type_e& ho_request_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
cause_c& ho_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
ue_aggr_max_bit_rate_s& ho_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
core_network_assist_info_for_inactive_s& ho_request_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
ue_security_cap_s& ho_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
security_context_s& ho_request_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
new_security_context_ind_e& ho_request_ies_o::value_c::new_security_context_ind()
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::nasc()
{
  assert_choice_type(types::nasc, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_setup_list_ho_req_l& ho_request_ies_o::value_c::pdu_session_res_setup_list_ho_req()
{
  assert_choice_type(types::pdu_session_res_setup_list_ho_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_ho_req_l>();
}
allowed_nssai_l& ho_request_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
trace_activation_s& ho_request_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
fixed_bitstring<64, false, true>& ho_request_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::source_to_target_transparent_container()
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mob_restrict_list_s& ho_request_ies_o::value_c::mob_restrict_list()
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
location_report_request_type_s& ho_request_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
rrc_inactive_transition_report_request_e& ho_request_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
guami_s& ho_request_ies_o::value_c::guami()
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
redirection_voice_fallback_e& ho_request_ies_o::value_c::redirection_voice_fallback()
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
cn_assisted_ran_tuning_s& ho_request_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& ho_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
iab_authorized_e& ho_request_ies_o::value_c::iab_authorized()
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
enhanced_coverage_restrict_e& ho_request_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
ue_diff_info_s& ho_request_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
nr_v2x_services_authorized_s& ho_request_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& ho_request_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& ho_request_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
ce_mode_brestricted_e& ho_request_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
ue_up_c_iot_support_e& ho_request_ies_o::value_c::ue_up_c_iot_support()
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
mdt_plmn_list_l& ho_request_ies_o::value_c::management_based_mdt_plmn_list()
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
unbounded_octstring<true>& ho_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
uint16_t& ho_request_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
time_sync_assist_info_s& ho_request_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
ue_slice_max_bit_rate_list_l& ho_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
five_g_pro_se_authorized_s& ho_request_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& ho_request_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const uint64_t& ho_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const handov_type_e& ho_request_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const cause_c& ho_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const ue_aggr_max_bit_rate_s& ho_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const core_network_assist_info_for_inactive_s& ho_request_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const ue_security_cap_s& ho_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const security_context_s& ho_request_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const new_security_context_ind_e& ho_request_ies_o::value_c::new_security_context_ind() const
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::nasc() const
{
  assert_choice_type(types::nasc, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_setup_list_ho_req_l& ho_request_ies_o::value_c::pdu_session_res_setup_list_ho_req() const
{
  assert_choice_type(types::pdu_session_res_setup_list_ho_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_ho_req_l>();
}
const allowed_nssai_l& ho_request_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const trace_activation_s& ho_request_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const fixed_bitstring<64, false, true>& ho_request_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::source_to_target_transparent_container() const
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mob_restrict_list_s& ho_request_ies_o::value_c::mob_restrict_list() const
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
const location_report_request_type_s& ho_request_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const rrc_inactive_transition_report_request_e&
ho_request_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const guami_s& ho_request_ies_o::value_c::guami() const
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
const redirection_voice_fallback_e& ho_request_ies_o::value_c::redirection_voice_fallback() const
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
const cn_assisted_ran_tuning_s& ho_request_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& ho_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const iab_authorized_e& ho_request_ies_o::value_c::iab_authorized() const
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
const enhanced_coverage_restrict_e& ho_request_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const ue_diff_info_s& ho_request_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const nr_v2x_services_authorized_s& ho_request_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& ho_request_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& ho_request_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const ce_mode_brestricted_e& ho_request_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const ue_up_c_iot_support_e& ho_request_ies_o::value_c::ue_up_c_iot_support() const
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
const mdt_plmn_list_l& ho_request_ies_o::value_c::management_based_mdt_plmn_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
const unbounded_octstring<true>& ho_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint16_t& ho_request_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const time_sync_assist_info_s& ho_request_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const ue_slice_max_bit_rate_list_l& ho_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const five_g_pro_se_authorized_s& ho_request_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& ho_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& ho_request_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
void ho_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::new_security_context_ind:
      j.write_str("NewSecurityContextInd", "true");
      break;
    case types::nasc:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_setup_list_ho_req:
      j.start_array("PDUSessionResourceSetupListHOReq");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_ho_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::source_to_target_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::mob_restrict_list:
      j.write_fieldname("MobilityRestrictionList");
      c.get<mob_restrict_list_s>().to_json(j);
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::guami:
      j.write_fieldname("GUAMI");
      c.get<guami_s>().to_json(j);
      break;
    case types::redirection_voice_fallback:
      j.write_str("RedirectionVoiceFallback", c.get<redirection_voice_fallback_e>().to_string());
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::iab_authorized:
      j.write_str("IAB-Authorized", c.get<iab_authorized_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_up_c_iot_support:
      j.write_str("UE-UP-CIoT-Support", "supported");
      break;
    case types::management_based_mdt_plmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdt_plmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().pack(bref));
      break;
    case types::nasc:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_setup_list_ho_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_ho_req_l>(), 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().pack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().pack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().pack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_list_l>(), 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().unpack(bref));
      break;
    case types::nasc:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_setup_list_ho_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_ho_req_l>(), bref, 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().unpack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().unpack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_list_l>(), bref, 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE ho_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 10;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += new_security_context_ind_present ? 1 : 0;
  nof_ies += nasc_present ? 1 : 0;
  nof_ies += trace_activation_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  nof_ies += mob_restrict_list_present ? 1 : 0;
  nof_ies += location_report_request_type_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += redirection_voice_fallback_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += iab_authorized_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_up_c_iot_support_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_list_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)29, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(handov_type.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)110, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)18, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)119, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)93, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_context.pack(bref));
  }
  if (new_security_context_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)41, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(new_security_context_ind.pack(bref));
  }
  if (nasc_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)37, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nasc.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)73, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_setup_list_ho_req, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (trace_activation_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)108, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trace_activation.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)34, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(masked_imeisv.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)101, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_to_target_transparent_container.pack(bref));
  }
  if (mob_restrict_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)36, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mob_restrict_list.pack(bref));
  }
  if (location_report_request_type_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)33, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(location_report_request_type.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)91, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)28, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(guami.pack(bref));
  }
  if (redirection_voice_fallback_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)146, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redirection_voice_fallback.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)165, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)177, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (iab_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)199, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(iab_authorized.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)205, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)215, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)218, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)217, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)222, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_up_c_iot_support_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)234, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_up_c_iot_support.pack(bref));
  }
  if (management_based_mdt_plmn_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)254, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, management_based_mdt_plmn_list, 1, 16, true));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)206, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, extended_connected_time, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)326, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)335, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_slice_max_bit_rate_list, 1, 8, true));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)345, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)346, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)347, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 10;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 29: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(handov_type.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 110: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.unpack(bref));
        break;
      }
      case 119: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.unpack(bref));
        break;
      }
      case 93: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.unpack(bref));
        break;
      }
      case 41: {
        new_security_context_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_security_context_ind.unpack(bref));
        break;
      }
      case 37: {
        nasc_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nasc.unpack(bref));
        break;
      }
      case 73: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_setup_list_ho_req, bref, 1, 256, true));
        break;
      }
      case 0: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 108: {
        trace_activation_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_activation.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.unpack(bref));
        break;
      }
      case 101: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_transparent_container.unpack(bref));
        break;
      }
      case 36: {
        mob_restrict_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mob_restrict_list.unpack(bref));
        break;
      }
      case 33: {
        location_report_request_type_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.unpack(bref));
        break;
      }
      case 28: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(guami.unpack(bref));
        break;
      }
      case 146: {
        redirection_voice_fallback_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redirection_voice_fallback.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.unpack(bref));
        break;
      }
      case 199: {
        iab_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_authorized.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.unpack(bref));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.unpack(bref));
        break;
      }
      case 234: {
        ue_up_c_iot_support_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_up_c_iot_support.unpack(bref));
        break;
      }
      case 254: {
        management_based_mdt_plmn_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(management_based_mdt_plmn_list, bref, 1, 16, true));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(extended_connected_time, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ue_slice_max_bit_rate_list, bref, 1, 8, true));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 29);
  j.write_str("criticality", "reject");
  j.write_str("Value", handov_type.to_string());
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.write_int("id", 110);
  j.write_str("criticality", "reject");
  ue_aggr_max_bit_rate.to_json(j);
  if (core_network_assist_info_for_inactive_present) {
    j.write_int("id", 18);
    j.write_str("criticality", "ignore");
    core_network_assist_info_for_inactive.to_json(j);
  }
  j.write_int("id", 119);
  j.write_str("criticality", "reject");
  ue_security_cap.to_json(j);
  j.write_int("id", 93);
  j.write_str("criticality", "reject");
  security_context.to_json(j);
  if (new_security_context_ind_present) {
    j.write_int("id", 41);
    j.write_str("criticality", "reject");
    j.write_str("Value", "true");
  }
  if (nasc_present) {
    j.write_int("id", 37);
    j.write_str("criticality", "reject");
    j.write_str("Value", nasc.to_string());
  }
  j.write_int("id", 73);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_setup_list_ho_req) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("id", 0);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : allowed_nssai) {
    e1.to_json(j);
  }
  j.end_array();
  if (trace_activation_present) {
    j.write_int("id", 108);
    j.write_str("criticality", "ignore");
    trace_activation.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_int("id", 34);
    j.write_str("criticality", "ignore");
    j.write_str("Value", masked_imeisv.to_string());
  }
  j.write_int("id", 101);
  j.write_str("criticality", "reject");
  j.write_str("Value", source_to_target_transparent_container.to_string());
  if (mob_restrict_list_present) {
    j.write_int("id", 36);
    j.write_str("criticality", "ignore");
    mob_restrict_list.to_json(j);
  }
  if (location_report_request_type_present) {
    j.write_int("id", 33);
    j.write_str("criticality", "ignore");
    location_report_request_type.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_int("id", 91);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rrc_inactive_transition_report_request.to_string());
  }
  j.write_int("id", 28);
  j.write_str("criticality", "reject");
  guami.to_json(j);
  if (redirection_voice_fallback_present) {
    j.write_int("id", 146);
    j.write_str("criticality", "ignore");
    j.write_str("Value", redirection_voice_fallback.to_string());
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_int("id", 165);
    j.write_str("criticality", "ignore");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_int("id", 177);
    j.write_str("criticality", "ignore");
    j.write_str("Value", srvcc_operation_possible.to_string());
  }
  if (iab_authorized_present) {
    j.write_int("id", 199);
    j.write_str("criticality", "reject");
    j.write_str("Value", iab_authorized.to_string());
  }
  if (enhanced_coverage_restrict_present) {
    j.write_int("id", 205);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "restricted");
  }
  if (ue_diff_info_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    ue_diff_info.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_int("id", 215);
    j.write_str("criticality", "ignore");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 218);
    j.write_str("criticality", "ignore");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 217);
    j.write_str("criticality", "ignore");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    pc5_qos_params.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_int("id", 222);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ce_mode_brestricted.to_string());
  }
  if (ue_up_c_iot_support_present) {
    j.write_int("id", 234);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "supported");
  }
  if (management_based_mdt_plmn_list_present) {
    j.write_int("id", 254);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : management_based_mdt_plmn_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  if (extended_connected_time_present) {
    j.write_int("id", 206);
    j.write_str("criticality", "ignore");
    j.write_int("Value", extended_connected_time);
  }
  if (time_sync_assist_info_present) {
    j.write_int("id", 326);
    j.write_str("criticality", "ignore");
    time_sync_assist_info.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_int("id", 335);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : ue_slice_max_bit_rate_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (five_g_pro_se_authorized_present) {
    j.write_int("id", 345);
    j.write_str("criticality", "ignore");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_int("id", 346);
    j.write_str("criticality", "ignore");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_int("id", 347);
    j.write_str("criticality", "ignore");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  j.end_obj();
}

// HandoverRequestAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_request_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 53, 56, 106, 19, 259, 333};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_request_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 53, 56, 106, 19, 259, 333};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_request_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 53:
      return crit_e::ignore;
    case 56:
      return crit_e::ignore;
    case 106:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    case 259:
      return crit_e::reject;
    case 333:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_request_ack_ies_o::value_c ho_request_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 53:
      ret.set(value_c::types::pdu_session_res_admitted_list);
      break;
    case 56:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_ho_ack);
      break;
    case 106:
      ret.set(value_c::types::target_to_source_transparent_container);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 259:
      ret.set(value_c::types::npn_access_info);
      break;
    case 333:
      ret.set(value_c::types::red_cap_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_request_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 53:
      return presence_e::mandatory;
    case 56:
      return presence_e::optional;
    case 106:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 259:
      return presence_e::optional;
    case 333:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_request_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_admitted_list:
      c.destroy<pdu_session_res_admitted_list_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      c.destroy<pdu_session_res_failed_to_setup_list_ho_ack_l>();
      break;
    case types::target_to_source_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::npn_access_info:
      c.destroy<npn_access_info_c>();
      break;
    default:
      break;
  }
}
void ho_request_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_admitted_list:
      c.init<pdu_session_res_admitted_list_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      c.init<pdu_session_res_failed_to_setup_list_ho_ack_l>();
      break;
    case types::target_to_source_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::npn_access_info:
      c.init<npn_access_info_c>();
      break;
    case types::red_cap_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
}
ho_request_ack_ies_o::value_c::value_c(const ho_request_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_admitted_list:
      c.init(other.c.get<pdu_session_res_admitted_list_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>());
      break;
    case types::target_to_source_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::npn_access_info:
      c.init(other.c.get<npn_access_info_c>());
      break;
    case types::red_cap_ind:
      c.init(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
}
ho_request_ack_ies_o::value_c& ho_request_ack_ies_o::value_c::operator=(const ho_request_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_admitted_list:
      c.set(other.c.get<pdu_session_res_admitted_list_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>());
      break;
    case types::target_to_source_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::npn_access_info:
      c.set(other.c.get<npn_access_info_c>());
      break;
    case types::red_cap_ind:
      c.set(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_request_ack_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_request_ack_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_admitted_list_l& ho_request_ack_ies_o::value_c::pdu_session_res_admitted_list()
{
  assert_choice_type(types::pdu_session_res_admitted_list, type_, "Value");
  return c.get<pdu_session_res_admitted_list_l>();
}
pdu_session_res_failed_to_setup_list_ho_ack_l&
ho_request_ack_ies_o::value_c::pdu_session_res_failed_to_setup_list_ho_ack()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ho_ack, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>();
}
unbounded_octstring<true>& ho_request_ack_ies_o::value_c::target_to_source_transparent_container()
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& ho_request_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
npn_access_info_c& ho_request_ack_ies_o::value_c::npn_access_info()
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
red_cap_ind_e& ho_request_ack_ies_o::value_c::red_cap_ind()
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
const uint64_t& ho_request_ack_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_request_ack_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_admitted_list_l& ho_request_ack_ies_o::value_c::pdu_session_res_admitted_list() const
{
  assert_choice_type(types::pdu_session_res_admitted_list, type_, "Value");
  return c.get<pdu_session_res_admitted_list_l>();
}
const pdu_session_res_failed_to_setup_list_ho_ack_l&
ho_request_ack_ies_o::value_c::pdu_session_res_failed_to_setup_list_ho_ack() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ho_ack, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>();
}
const unbounded_octstring<true>& ho_request_ack_ies_o::value_c::target_to_source_transparent_container() const
{
  assert_choice_type(types::target_to_source_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& ho_request_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const npn_access_info_c& ho_request_ack_ies_o::value_c::npn_access_info() const
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
const red_cap_ind_e& ho_request_ack_ies_o::value_c::red_cap_ind() const
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
void ho_request_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_admitted_list:
      j.start_array("PDUSessionResourceAdmittedList");
      for (const auto& e1 : c.get<pdu_session_res_admitted_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      j.start_array("PDUSessionResourceFailedToSetupListHOAck");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::target_to_source_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::npn_access_info:
      j.write_fieldname("NPN-AccessInformation");
      c.get<npn_access_info_c>().to_json(j);
      break;
    case types::red_cap_ind:
      j.write_str("RedCapIndication", "redcap");
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_request_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_admitted_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_admitted_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>(), 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().pack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_admitted_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_admitted_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ho_ack:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_ho_ack_l>(), bref, 1, 256, true));
      break;
    case types::target_to_source_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().unpack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_request_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE ho_request_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += pdu_session_res_failed_to_setup_list_ho_ack_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += npn_access_info_present ? 1 : 0;
  nof_ies += red_cap_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)53, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_admitted_list, 1, 256, true));
  }
  if (pdu_session_res_failed_to_setup_list_ho_ack_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)56, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_setup_list_ho_ack, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)106, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(target_to_source_transparent_container.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (npn_access_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)259, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_access_info.pack(bref));
  }
  if (red_cap_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)333, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(red_cap_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_request_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 53: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_admitted_list, bref, 1, 256, true));
        break;
      }
      case 56: {
        pdu_session_res_failed_to_setup_list_ho_ack_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_setup_list_ho_ack, bref, 1, 256, true));
        break;
      }
      case 106: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_to_source_transparent_container.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 259: {
        npn_access_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_access_info.unpack(bref));
        break;
      }
      case 333: {
        red_cap_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(red_cap_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_request_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 53);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_admitted_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (pdu_session_res_failed_to_setup_list_ho_ack_present) {
    j.write_int("id", 56);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_setup_list_ho_ack) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 106);
  j.write_str("criticality", "reject");
  j.write_str("Value", target_to_source_transparent_container.to_string());
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (npn_access_info_present) {
    j.write_int("id", 259);
    j.write_str("criticality", "reject");
    npn_access_info.to_json(j);
  }
  if (red_cap_ind_present) {
    j.write_int("id", 333);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "redcap");
  }
  j.end_obj();
}

// HandoverRequiredIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_required_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 29, 15, 105, 22, 61, 101};
  return map_enum_number(names, 8, idx, "id");
}
bool ho_required_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 29, 15, 105, 22, 61, 101};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_required_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 29:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 105:
      return crit_e::reject;
    case 22:
      return crit_e::ignore;
    case 61:
      return crit_e::reject;
    case 101:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_required_ies_o::value_c ho_required_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 29:
      ret.set(value_c::types::handov_type);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 105:
      ret.set(value_c::types::target_id);
      break;
    case 22:
      ret.set(value_c::types::direct_forwarding_path_availability);
      break;
    case 61:
      ret.set(value_c::types::pdu_session_res_list_ho_rqd);
      break;
    case 101:
      ret.set(value_c::types::source_to_target_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_required_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 29:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 105:
      return presence_e::mandatory;
    case 22:
      return presence_e::optional;
    case 61:
      return presence_e::mandatory;
    case 101:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_required_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::target_id:
      c.destroy<target_id_c>();
      break;
    case types::pdu_session_res_list_ho_rqd:
      c.destroy<pdu_session_res_list_ho_rqd_l>();
      break;
    case types::source_to_target_transparent_container:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ho_required_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::handov_type:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::target_id:
      c.init<target_id_c>();
      break;
    case types::direct_forwarding_path_availability:
      break;
    case types::pdu_session_res_list_ho_rqd:
      c.init<pdu_session_res_list_ho_rqd_l>();
      break;
    case types::source_to_target_transparent_container:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
}
ho_required_ies_o::value_c::value_c(const ho_required_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.init(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::target_id:
      c.init(other.c.get<target_id_c>());
      break;
    case types::direct_forwarding_path_availability:
      c.init(other.c.get<direct_forwarding_path_availability_e>());
      break;
    case types::pdu_session_res_list_ho_rqd:
      c.init(other.c.get<pdu_session_res_list_ho_rqd_l>());
      break;
    case types::source_to_target_transparent_container:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
}
ho_required_ies_o::value_c& ho_required_ies_o::value_c::operator=(const ho_required_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::handov_type:
      c.set(other.c.get<handov_type_e>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::target_id:
      c.set(other.c.get<target_id_c>());
      break;
    case types::direct_forwarding_path_availability:
      c.set(other.c.get<direct_forwarding_path_availability_e>());
      break;
    case types::pdu_session_res_list_ho_rqd:
      c.set(other.c.get<pdu_session_res_list_ho_rqd_l>());
      break;
    case types::source_to_target_transparent_container:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_required_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_required_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
handov_type_e& ho_required_ies_o::value_c::handov_type()
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
cause_c& ho_required_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
target_id_c& ho_required_ies_o::value_c::target_id()
{
  assert_choice_type(types::target_id, type_, "Value");
  return c.get<target_id_c>();
}
direct_forwarding_path_availability_e& ho_required_ies_o::value_c::direct_forwarding_path_availability()
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
pdu_session_res_list_ho_rqd_l& ho_required_ies_o::value_c::pdu_session_res_list_ho_rqd()
{
  assert_choice_type(types::pdu_session_res_list_ho_rqd, type_, "Value");
  return c.get<pdu_session_res_list_ho_rqd_l>();
}
unbounded_octstring<true>& ho_required_ies_o::value_c::source_to_target_transparent_container()
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ho_required_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_required_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const handov_type_e& ho_required_ies_o::value_c::handov_type() const
{
  assert_choice_type(types::handov_type, type_, "Value");
  return c.get<handov_type_e>();
}
const cause_c& ho_required_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const target_id_c& ho_required_ies_o::value_c::target_id() const
{
  assert_choice_type(types::target_id, type_, "Value");
  return c.get<target_id_c>();
}
const direct_forwarding_path_availability_e& ho_required_ies_o::value_c::direct_forwarding_path_availability() const
{
  assert_choice_type(types::direct_forwarding_path_availability, type_, "Value");
  return c.get<direct_forwarding_path_availability_e>();
}
const pdu_session_res_list_ho_rqd_l& ho_required_ies_o::value_c::pdu_session_res_list_ho_rqd() const
{
  assert_choice_type(types::pdu_session_res_list_ho_rqd, type_, "Value");
  return c.get<pdu_session_res_list_ho_rqd_l>();
}
const unbounded_octstring<true>& ho_required_ies_o::value_c::source_to_target_transparent_container() const
{
  assert_choice_type(types::source_to_target_transparent_container, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ho_required_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::handov_type:
      j.write_str("HandoverType", c.get<handov_type_e>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::target_id:
      j.write_fieldname("TargetID");
      c.get<target_id_c>().to_json(j);
      break;
    case types::direct_forwarding_path_availability:
      j.write_str("DirectForwardingPathAvailability", "direct-path-available");
      break;
    case types::pdu_session_res_list_ho_rqd:
      j.start_array("PDUSessionResourceListHORqd");
      for (const auto& e1 : c.get<pdu_session_res_list_ho_rqd_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::source_to_target_transparent_container:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_required_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::target_id:
      HANDLE_CODE(c.get<target_id_c>().pack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().pack(bref));
      break;
    case types::pdu_session_res_list_ho_rqd:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_list_ho_rqd_l>(), 1, 256, true));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_required_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::handov_type:
      HANDLE_CODE(c.get<handov_type_e>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::target_id:
      HANDLE_CODE(c.get<target_id_c>().unpack(bref));
      break;
    case types::direct_forwarding_path_availability:
      HANDLE_CODE(c.get<direct_forwarding_path_availability_e>().unpack(bref));
      break;
    case types::pdu_session_res_list_ho_rqd:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_list_ho_rqd_l>(), bref, 1, 256, true));
      break;
    case types::source_to_target_transparent_container:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ho_required_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE ho_required_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 7;
  nof_ies += direct_forwarding_path_availability_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)29, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(handov_type.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)105, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(target_id.pack(bref));
  }
  if (direct_forwarding_path_availability_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)22, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(direct_forwarding_path_availability.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)61, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_list_ho_rqd, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)101, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_to_target_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_required_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 7;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 29: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(handov_type.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 105: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_id.unpack(bref));
        break;
      }
      case 22: {
        direct_forwarding_path_availability_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(direct_forwarding_path_availability.unpack(bref));
        break;
      }
      case 61: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_list_ho_rqd, bref, 1, 256, true));
        break;
      }
      case 101: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_required_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 29);
  j.write_str("criticality", "reject");
  j.write_str("Value", handov_type.to_string());
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.write_int("id", 105);
  j.write_str("criticality", "reject");
  target_id.to_json(j);
  if (direct_forwarding_path_availability_present) {
    j.write_int("id", 22);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "direct-path-available");
  }
  j.write_int("id", 61);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_list_ho_rqd) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("id", 101);
  j.write_str("criticality", "reject");
  j.write_str("Value", source_to_target_transparent_container.to_string());
  j.end_obj();
}

// HandoverSuccessIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ho_success_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85};
  return map_enum_number(names, 2, idx, "id");
}
bool ho_success_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ho_success_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ho_success_ies_o::value_c ho_success_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ho_success_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ho_success_ies_o::value_c::destroy_() {}
void ho_success_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
ho_success_ies_o::value_c::value_c(const ho_success_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
  }
}
ho_success_ies_o::value_c& ho_success_ies_o::value_c::operator=(const ho_success_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
  }

  return *this;
}
uint64_t& ho_success_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ho_success_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_success_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ho_success_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
void ho_success_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ho_success_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_success_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ho_success_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE ho_success_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ho_success_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ho_success_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.end_obj();
}

// InitialContextSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_context_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 132, 15, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool init_context_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 132, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 132:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_context_setup_fail_ies_o::value_c init_context_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 132:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_cxt_fail);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 132:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      c.destroy<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void init_context_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      c.init<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
}
init_context_setup_fail_ies_o::value_c::value_c(const init_context_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
}
init_context_setup_fail_ies_o::value_c&
init_context_setup_fail_ies_o::value_c::operator=(const init_context_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_context_setup_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& init_context_setup_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_failed_to_setup_list_cxt_fail_l&
init_context_setup_fail_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_fail()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_fail, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
}
cause_c& init_context_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& init_context_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& init_context_setup_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& init_context_setup_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_failed_to_setup_list_cxt_fail_l&
init_context_setup_fail_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_fail() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_fail, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>();
}
const cause_c& init_context_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& init_context_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void init_context_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      j.start_array("PDUSessionResourceFailedToSetupListCxtFail");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>(), 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_fail:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_cxt_fail_l>(), bref, 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE init_context_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_res_failed_to_setup_list_cxt_fail_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_failed_to_setup_list_cxt_fail_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)132, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_setup_list_cxt_fail, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 132: {
        pdu_session_res_failed_to_setup_list_cxt_fail_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_setup_list_cxt_fail, bref, 1, 256, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_failed_to_setup_list_cxt_fail_present) {
    j.write_int("id", 132);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_setup_list_cxt_fail) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// InitialContextSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_context_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  48,  110, 18,  28,  71,  0,   119, 94,  108, 36,  117, 31,  34,
                                   38,  24,  91,  118, 146, 33,  165, 177, 199, 205, 206, 209, 216, 215, 218,
                                   217, 219, 222, 234, 238, 254, 264, 326, 328, 334, 335, 345, 346, 347};
  return map_enum_number(names, 44, idx, "id");
}
bool init_context_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  48,  110, 18,  28,  71,  0,   119, 94,  108, 36,  117, 31,  34,
                                   38,  24,  91,  118, 146, 33,  165, 177, 199, 205, 206, 209, 216, 215, 218,
                                   217, 219, 222, 234, 238, 254, 264, 326, 328, 334, 335, 345, 346, 347};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 48:
      return crit_e::reject;
    case 110:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 28:
      return crit_e::reject;
    case 71:
      return crit_e::reject;
    case 0:
      return crit_e::reject;
    case 119:
      return crit_e::reject;
    case 94:
      return crit_e::reject;
    case 108:
      return crit_e::ignore;
    case 36:
      return crit_e::ignore;
    case 117:
      return crit_e::ignore;
    case 31:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    case 38:
      return crit_e::ignore;
    case 24:
      return crit_e::reject;
    case 91:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 199:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 238:
      return crit_e::ignore;
    case 254:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 326:
      return crit_e::ignore;
    case 328:
      return crit_e::ignore;
    case 334:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_context_setup_request_ies_o::value_c init_context_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 48:
      ret.set(value_c::types::old_amf);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 28:
      ret.set(value_c::types::guami);
      break;
    case 71:
      ret.set(value_c::types::pdu_session_res_setup_list_cxt_req);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 94:
      ret.set(value_c::types::security_key);
      break;
    case 108:
      ret.set(value_c::types::trace_activation);
      break;
    case 36:
      ret.set(value_c::types::mob_restrict_list);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 31:
      ret.set(value_c::types::idx_to_rfsp);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 24:
      ret.set(value_c::types::emergency_fallback_ind);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 118:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 146:
      ret.set(value_c::types::redirection_voice_fallback);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 199:
      ret.set(value_c::types::iab_authorized);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 234:
      ret.set(value_c::types::ue_up_c_iot_support);
      break;
    case 238:
      ret.set(value_c::types::rg_level_wireline_access_characteristics);
      break;
    case 254:
      ret.set(value_c::types::management_based_mdt_plmn_list);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 328:
      ret.set(value_c::types::q_mcc_onfig_info);
      break;
    case 334:
      ret.set(value_c::types::target_nssai_info);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 48:
      return presence_e::optional;
    case 110:
      return presence_e::conditional;
    case 18:
      return presence_e::optional;
    case 28:
      return presence_e::mandatory;
    case 71:
      return presence_e::optional;
    case 0:
      return presence_e::mandatory;
    case 119:
      return presence_e::mandatory;
    case 94:
      return presence_e::mandatory;
    case 108:
      return presence_e::optional;
    case 36:
      return presence_e::optional;
    case 117:
      return presence_e::optional;
    case 31:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    case 38:
      return presence_e::optional;
    case 24:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 118:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 33:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 199:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 238:
      return presence_e::optional;
    case 254:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 328:
      return presence_e::optional;
    case 334:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::old_amf:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.destroy<core_network_assist_info_for_inactive_s>();
      break;
    case types::guami:
      c.destroy<guami_s>();
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      c.destroy<pdu_session_res_setup_list_cxt_req_l>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::security_key:
      c.destroy<fixed_bitstring<256, false, true>>();
      break;
    case types::trace_activation:
      c.destroy<trace_activation_s>();
      break;
    case types::mob_restrict_list:
      c.destroy<mob_restrict_list_s>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::emergency_fallback_ind:
      c.destroy<emergency_fallback_ind_s>();
      break;
    case types::ue_radio_cap_for_paging:
      c.destroy<ue_radio_cap_for_paging_s>();
      break;
    case types::location_report_request_type:
      c.destroy<location_report_request_type_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.destroy<cn_assisted_ran_tuning_s>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.destroy<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.destroy<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.destroy<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.destroy<pc5_qos_params_s>();
      break;
    case types::rg_level_wireline_access_characteristics:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::management_based_mdt_plmn_list:
      c.destroy<mdt_plmn_list_l>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.destroy<time_sync_assist_info_s>();
      break;
    case types::q_mcc_onfig_info:
      c.destroy<q_mcc_onfig_info_s>();
      break;
    case types::target_nssai_info:
      c.destroy<target_nssai_info_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.destroy<ue_slice_max_bit_rate_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.destroy<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.destroy<five_g_pro_se_pc5_qos_params_s>();
      break;
    default:
      break;
  }
}
void init_context_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::old_amf:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.init<core_network_assist_info_for_inactive_s>();
      break;
    case types::guami:
      c.init<guami_s>();
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      c.init<pdu_session_res_setup_list_cxt_req_l>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::security_key:
      c.init<fixed_bitstring<256, false, true>>();
      break;
    case types::trace_activation:
      c.init<trace_activation_s>();
      break;
    case types::mob_restrict_list:
      c.init<mob_restrict_list_s>();
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::idx_to_rfsp:
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::emergency_fallback_ind:
      c.init<emergency_fallback_ind_s>();
      break;
    case types::rrc_inactive_transition_report_request:
      break;
    case types::ue_radio_cap_for_paging:
      c.init<ue_radio_cap_for_paging_s>();
      break;
    case types::redirection_voice_fallback:
      break;
    case types::location_report_request_type:
      c.init<location_report_request_type_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.init<cn_assisted_ran_tuning_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::iab_authorized:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::extended_connected_time:
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.init<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.init<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.init<pc5_qos_params_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_up_c_iot_support:
      break;
    case types::rg_level_wireline_access_characteristics:
      c.init<unbounded_octstring<true>>();
      break;
    case types::management_based_mdt_plmn_list:
      c.init<mdt_plmn_list_l>();
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.init<time_sync_assist_info_s>();
      break;
    case types::q_mcc_onfig_info:
      c.init<q_mcc_onfig_info_s>();
      break;
    case types::target_nssai_info:
      c.init<target_nssai_info_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init<ue_slice_max_bit_rate_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.init<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
}
init_context_setup_request_ies_o::value_c::value_c(const init_context_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::old_amf:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.init(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::guami:
      c.init(other.c.get<guami_s>());
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      c.init(other.c.get<pdu_session_res_setup_list_cxt_req_l>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::security_key:
      c.init(other.c.get<fixed_bitstring<256, false, true>>());
      break;
    case types::trace_activation:
      c.init(other.c.get<trace_activation_s>());
      break;
    case types::mob_restrict_list:
      c.init(other.c.get<mob_restrict_list_s>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::idx_to_rfsp:
      c.init(other.c.get<uint16_t>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::emergency_fallback_ind:
      c.init(other.c.get<emergency_fallback_ind_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.init(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.init(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::redirection_voice_fallback:
      c.init(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::location_report_request_type:
      c.init(other.c.get<location_report_request_type_s>());
      break;
    case types::cn_assisted_ran_tuning:
      c.init(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.init(other.c.get<iab_authorized_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.init(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.init(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.init(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.init(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::rg_level_wireline_access_characteristics:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::management_based_mdt_plmn_list:
      c.init(other.c.get<mdt_plmn_list_l>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::time_sync_assist_info:
      c.init(other.c.get<time_sync_assist_info_s>());
      break;
    case types::q_mcc_onfig_info:
      c.init(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::target_nssai_info:
      c.init(other.c.get<target_nssai_info_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.init(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
}
init_context_setup_request_ies_o::value_c&
init_context_setup_request_ies_o::value_c::operator=(const init_context_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::old_amf:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.set(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::guami:
      c.set(other.c.get<guami_s>());
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      c.set(other.c.get<pdu_session_res_setup_list_cxt_req_l>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::security_key:
      c.set(other.c.get<fixed_bitstring<256, false, true>>());
      break;
    case types::trace_activation:
      c.set(other.c.get<trace_activation_s>());
      break;
    case types::mob_restrict_list:
      c.set(other.c.get<mob_restrict_list_s>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::idx_to_rfsp:
      c.set(other.c.get<uint16_t>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::emergency_fallback_ind:
      c.set(other.c.get<emergency_fallback_ind_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.set(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.set(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::redirection_voice_fallback:
      c.set(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::location_report_request_type:
      c.set(other.c.get<location_report_request_type_s>());
      break;
    case types::cn_assisted_ran_tuning:
      c.set(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.set(other.c.get<iab_authorized_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.set(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.set(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.set(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.set(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::rg_level_wireline_access_characteristics:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::management_based_mdt_plmn_list:
      c.set(other.c.get<mdt_plmn_list_l>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::time_sync_assist_info:
      c.set(other.c.get<time_sync_assist_info_s>());
      break;
    case types::q_mcc_onfig_info:
      c.set(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::target_nssai_info:
      c.set(other.c.get<target_nssai_info_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.set(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.set(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.set(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_context_setup_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& init_context_setup_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
printable_string<1, 150, true, true>& init_context_setup_request_ies_o::value_c::old_amf()
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
ue_aggr_max_bit_rate_s& init_context_setup_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
core_network_assist_info_for_inactive_s&
init_context_setup_request_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
guami_s& init_context_setup_request_ies_o::value_c::guami()
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
pdu_session_res_setup_list_cxt_req_l& init_context_setup_request_ies_o::value_c::pdu_session_res_setup_list_cxt_req()
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_req_l>();
}
allowed_nssai_l& init_context_setup_request_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
ue_security_cap_s& init_context_setup_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
fixed_bitstring<256, false, true>& init_context_setup_request_ies_o::value_c::security_key()
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
trace_activation_s& init_context_setup_request_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
mob_restrict_list_s& init_context_setup_request_ies_o::value_c::mob_restrict_list()
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
uint16_t& init_context_setup_request_ies_o::value_c::idx_to_rfsp()
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
fixed_bitstring<64, false, true>& init_context_setup_request_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
emergency_fallback_ind_s& init_context_setup_request_ies_o::value_c::emergency_fallback_ind()
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
rrc_inactive_transition_report_request_e&
init_context_setup_request_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
ue_radio_cap_for_paging_s& init_context_setup_request_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
redirection_voice_fallback_e& init_context_setup_request_ies_o::value_c::redirection_voice_fallback()
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
location_report_request_type_s& init_context_setup_request_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
cn_assisted_ran_tuning_s& init_context_setup_request_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& init_context_setup_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
iab_authorized_e& init_context_setup_request_ies_o::value_c::iab_authorized()
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
enhanced_coverage_restrict_e& init_context_setup_request_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
uint16_t& init_context_setup_request_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
ue_diff_info_s& init_context_setup_request_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
nr_v2x_services_authorized_s& init_context_setup_request_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& init_context_setup_request_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& init_context_setup_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& init_context_setup_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& init_context_setup_request_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
ce_mode_brestricted_e& init_context_setup_request_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
ue_up_c_iot_support_e& init_context_setup_request_ies_o::value_c::ue_up_c_iot_support()
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::rg_level_wireline_access_characteristics()
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mdt_plmn_list_l& init_context_setup_request_ies_o::value_c::management_based_mdt_plmn_list()
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
time_sync_assist_info_s& init_context_setup_request_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
q_mcc_onfig_info_s& init_context_setup_request_ies_o::value_c::q_mcc_onfig_info()
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
target_nssai_info_s& init_context_setup_request_ies_o::value_c::target_nssai_info()
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
ue_slice_max_bit_rate_list_l& init_context_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
five_g_pro_se_authorized_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const uint64_t& init_context_setup_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& init_context_setup_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const printable_string<1, 150, true, true>& init_context_setup_request_ies_o::value_c::old_amf() const
{
  assert_choice_type(types::old_amf, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const ue_aggr_max_bit_rate_s& init_context_setup_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const core_network_assist_info_for_inactive_s&
init_context_setup_request_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const guami_s& init_context_setup_request_ies_o::value_c::guami() const
{
  assert_choice_type(types::guami, type_, "Value");
  return c.get<guami_s>();
}
const pdu_session_res_setup_list_cxt_req_l&
init_context_setup_request_ies_o::value_c::pdu_session_res_setup_list_cxt_req() const
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_req_l>();
}
const allowed_nssai_l& init_context_setup_request_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const ue_security_cap_s& init_context_setup_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const fixed_bitstring<256, false, true>& init_context_setup_request_ies_o::value_c::security_key() const
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
const trace_activation_s& init_context_setup_request_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const mob_restrict_list_s& init_context_setup_request_ies_o::value_c::mob_restrict_list() const
{
  assert_choice_type(types::mob_restrict_list, type_, "Value");
  return c.get<mob_restrict_list_s>();
}
const unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint16_t& init_context_setup_request_ies_o::value_c::idx_to_rfsp() const
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
const fixed_bitstring<64, false, true>& init_context_setup_request_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const emergency_fallback_ind_s& init_context_setup_request_ies_o::value_c::emergency_fallback_ind() const
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
const rrc_inactive_transition_report_request_e&
init_context_setup_request_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const ue_radio_cap_for_paging_s& init_context_setup_request_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
const redirection_voice_fallback_e& init_context_setup_request_ies_o::value_c::redirection_voice_fallback() const
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
const location_report_request_type_s& init_context_setup_request_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const cn_assisted_ran_tuning_s& init_context_setup_request_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& init_context_setup_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const iab_authorized_e& init_context_setup_request_ies_o::value_c::iab_authorized() const
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
const enhanced_coverage_restrict_e& init_context_setup_request_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const uint16_t& init_context_setup_request_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const ue_diff_info_s& init_context_setup_request_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const nr_v2x_services_authorized_s& init_context_setup_request_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& init_context_setup_request_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
init_context_setup_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s&
init_context_setup_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& init_context_setup_request_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const ce_mode_brestricted_e& init_context_setup_request_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const ue_up_c_iot_support_e& init_context_setup_request_ies_o::value_c::ue_up_c_iot_support() const
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
const unbounded_octstring<true>&
init_context_setup_request_ies_o::value_c::rg_level_wireline_access_characteristics() const
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mdt_plmn_list_l& init_context_setup_request_ies_o::value_c::management_based_mdt_plmn_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
const unbounded_octstring<true>& init_context_setup_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const time_sync_assist_info_s& init_context_setup_request_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const q_mcc_onfig_info_s& init_context_setup_request_ies_o::value_c::q_mcc_onfig_info() const
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
const target_nssai_info_s& init_context_setup_request_ies_o::value_c::target_nssai_info() const
{
  assert_choice_type(types::target_nssai_info, type_, "Value");
  return c.get<target_nssai_info_s>();
}
const ue_slice_max_bit_rate_list_l& init_context_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const five_g_pro_se_authorized_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
init_context_setup_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& init_context_setup_request_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
void init_context_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::old_amf:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::guami:
      j.write_fieldname("GUAMI");
      c.get<guami_s>().to_json(j);
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      j.start_array("PDUSessionResourceSetupListCxtReq");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_cxt_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::security_key:
      j.write_str("BIT STRING", c.get<fixed_bitstring<256, false, true>>().to_string());
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    case types::mob_restrict_list:
      j.write_fieldname("MobilityRestrictionList");
      c.get<mob_restrict_list_s>().to_json(j);
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::idx_to_rfsp:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::emergency_fallback_ind:
      j.write_fieldname("EmergencyFallbackIndicator");
      c.get<emergency_fallback_ind_s>().to_json(j);
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::redirection_voice_fallback:
      j.write_str("RedirectionVoiceFallback", c.get<redirection_voice_fallback_e>().to_string());
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::iab_authorized:
      j.write_str("IAB-Authorized", c.get<iab_authorized_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_up_c_iot_support:
      j.write_str("UE-UP-CIoT-Support", "supported");
      break;
    case types::rg_level_wireline_access_characteristics:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::management_based_mdt_plmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdt_plmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::q_mcc_onfig_info:
      j.write_fieldname("QMCConfigInfo");
      c.get<q_mcc_onfig_info_s>().to_json(j);
      break;
    case types::target_nssai_info:
      j.write_fieldname("TargetNSSAIInformation");
      c.get<target_nssai_info_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().pack(bref));
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_cxt_req_l>(), 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().pack(bref)));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().pack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().pack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().pack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_list_l>(), 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().pack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::old_amf:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::guami:
      HANDLE_CODE(c.get<guami_s>().unpack(bref));
      break;
    case types::pdu_session_res_setup_list_cxt_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_cxt_req_l>(), bref, 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().unpack(bref)));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    case types::mob_restrict_list:
      HANDLE_CODE(c.get<mob_restrict_list_s>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().unpack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().unpack(bref));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().unpack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_list_l>(), bref, 1, 16, true));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().unpack(bref));
      break;
    case types::target_nssai_info:
      HANDLE_CODE(c.get<target_nssai_info_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE init_context_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 6;
  nof_ies += old_amf_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += pdu_session_res_setup_list_cxt_req_present ? 1 : 0;
  nof_ies += trace_activation_present ? 1 : 0;
  nof_ies += mob_restrict_list_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += idx_to_rfsp_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  nof_ies += nas_pdu_present ? 1 : 0;
  nof_ies += emergency_fallback_ind_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += redirection_voice_fallback_present ? 1 : 0;
  nof_ies += location_report_request_type_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += iab_authorized_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_up_c_iot_support_present ? 1 : 0;
  nof_ies += rg_level_wireline_access_characteristics_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_list_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += q_mcc_onfig_info_present ? 1 : 0;
  nof_ies += target_nssai_info_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (old_amf_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)48, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(old_amf.pack(bref));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)110, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)18, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)28, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(guami.pack(bref));
  }
  if (pdu_session_res_setup_list_cxt_req_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)71, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_setup_list_cxt_req, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)119, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)94, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_key.pack(bref));
  }
  if (trace_activation_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)108, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trace_activation.pack(bref));
  }
  if (mob_restrict_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)36, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mob_restrict_list.pack(bref));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (idx_to_rfsp_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)31, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, idx_to_rfsp, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)34, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(masked_imeisv.pack(bref));
  }
  if (nas_pdu_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  if (emergency_fallback_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)24, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(emergency_fallback_ind.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)91, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)118, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (redirection_voice_fallback_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)146, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redirection_voice_fallback.pack(bref));
  }
  if (location_report_request_type_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)33, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(location_report_request_type.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)165, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)177, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (iab_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)199, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(iab_authorized.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)205, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)206, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, extended_connected_time, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)215, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)218, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)217, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)222, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_up_c_iot_support_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)234, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_up_c_iot_support.pack(bref));
  }
  if (rg_level_wireline_access_characteristics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)238, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rg_level_wireline_access_characteristics.pack(bref));
  }
  if (management_based_mdt_plmn_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)254, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, management_based_mdt_plmn_list, 1, 16, true));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)326, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (q_mcc_onfig_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)328, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(q_mcc_onfig_info.pack(bref));
  }
  if (target_nssai_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)334, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(target_nssai_info.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)335, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_slice_max_bit_rate_list, 1, 8, true));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)345, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)346, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)347, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 6;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 48: {
        old_amf_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(old_amf.unpack(bref));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.unpack(bref));
        break;
      }
      case 28: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(guami.unpack(bref));
        break;
      }
      case 71: {
        pdu_session_res_setup_list_cxt_req_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_setup_list_cxt_req, bref, 1, 256, true));
        break;
      }
      case 0: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 119: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.unpack(bref));
        break;
      }
      case 94: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_key.unpack(bref));
        break;
      }
      case 108: {
        trace_activation_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_activation.unpack(bref));
        break;
      }
      case 36: {
        mob_restrict_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mob_restrict_list.unpack(bref));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 31: {
        idx_to_rfsp_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(idx_to_rfsp, bref, (uint16_t)1u, (uint16_t)256u, true, true));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.unpack(bref));
        break;
      }
      case 38: {
        nas_pdu_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 24: {
        emergency_fallback_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(emergency_fallback_ind.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.unpack(bref));
        break;
      }
      case 146: {
        redirection_voice_fallback_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redirection_voice_fallback.unpack(bref));
        break;
      }
      case 33: {
        location_report_request_type_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.unpack(bref));
        break;
      }
      case 199: {
        iab_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_authorized.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(extended_connected_time, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.unpack(bref));
        break;
      }
      case 234: {
        ue_up_c_iot_support_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_up_c_iot_support.unpack(bref));
        break;
      }
      case 238: {
        rg_level_wireline_access_characteristics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rg_level_wireline_access_characteristics.unpack(bref));
        break;
      }
      case 254: {
        management_based_mdt_plmn_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(management_based_mdt_plmn_list, bref, 1, 16, true));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.unpack(bref));
        break;
      }
      case 328: {
        q_mcc_onfig_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(q_mcc_onfig_info.unpack(bref));
        break;
      }
      case 334: {
        target_nssai_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(target_nssai_info.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ue_slice_max_bit_rate_list, bref, 1, 8, true));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (old_amf_present) {
    j.write_int("id", 48);
    j.write_str("criticality", "reject");
    j.write_str("Value", old_amf.to_string());
  }
  if (ue_aggr_max_bit_rate_present) {
    j.write_int("id", 110);
    j.write_str("criticality", "reject");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (core_network_assist_info_for_inactive_present) {
    j.write_int("id", 18);
    j.write_str("criticality", "ignore");
    core_network_assist_info_for_inactive.to_json(j);
  }
  j.write_int("id", 28);
  j.write_str("criticality", "reject");
  guami.to_json(j);
  if (pdu_session_res_setup_list_cxt_req_present) {
    j.write_int("id", 71);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_setup_list_cxt_req) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 0);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : allowed_nssai) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("id", 119);
  j.write_str("criticality", "reject");
  ue_security_cap.to_json(j);
  j.write_int("id", 94);
  j.write_str("criticality", "reject");
  j.write_str("Value", security_key.to_string());
  if (trace_activation_present) {
    j.write_int("id", 108);
    j.write_str("criticality", "ignore");
    trace_activation.to_json(j);
  }
  if (mob_restrict_list_present) {
    j.write_int("id", 36);
    j.write_str("criticality", "ignore");
    mob_restrict_list.to_json(j);
  }
  if (ue_radio_cap_present) {
    j.write_int("id", 117);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ue_radio_cap.to_string());
  }
  if (idx_to_rfsp_present) {
    j.write_int("id", 31);
    j.write_str("criticality", "ignore");
    j.write_int("Value", idx_to_rfsp);
  }
  if (masked_imeisv_present) {
    j.write_int("id", 34);
    j.write_str("criticality", "ignore");
    j.write_str("Value", masked_imeisv.to_string());
  }
  if (nas_pdu_present) {
    j.write_int("id", 38);
    j.write_str("criticality", "ignore");
    j.write_str("Value", nas_pdu.to_string());
  }
  if (emergency_fallback_ind_present) {
    j.write_int("id", 24);
    j.write_str("criticality", "reject");
    emergency_fallback_ind.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_int("id", 91);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rrc_inactive_transition_report_request.to_string());
  }
  if (ue_radio_cap_for_paging_present) {
    j.write_int("id", 118);
    j.write_str("criticality", "ignore");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (redirection_voice_fallback_present) {
    j.write_int("id", 146);
    j.write_str("criticality", "ignore");
    j.write_str("Value", redirection_voice_fallback.to_string());
  }
  if (location_report_request_type_present) {
    j.write_int("id", 33);
    j.write_str("criticality", "ignore");
    location_report_request_type.to_json(j);
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_int("id", 165);
    j.write_str("criticality", "ignore");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_int("id", 177);
    j.write_str("criticality", "ignore");
    j.write_str("Value", srvcc_operation_possible.to_string());
  }
  if (iab_authorized_present) {
    j.write_int("id", 199);
    j.write_str("criticality", "ignore");
    j.write_str("Value", iab_authorized.to_string());
  }
  if (enhanced_coverage_restrict_present) {
    j.write_int("id", 205);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "restricted");
  }
  if (extended_connected_time_present) {
    j.write_int("id", 206);
    j.write_str("criticality", "ignore");
    j.write_int("Value", extended_connected_time);
  }
  if (ue_diff_info_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    ue_diff_info.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_int("id", 215);
    j.write_str("criticality", "ignore");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 218);
    j.write_str("criticality", "ignore");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 217);
    j.write_str("criticality", "ignore");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    pc5_qos_params.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_int("id", 222);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ce_mode_brestricted.to_string());
  }
  if (ue_up_c_iot_support_present) {
    j.write_int("id", 234);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "supported");
  }
  if (rg_level_wireline_access_characteristics_present) {
    j.write_int("id", 238);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rg_level_wireline_access_characteristics.to_string());
  }
  if (management_based_mdt_plmn_list_present) {
    j.write_int("id", 254);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : management_based_mdt_plmn_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  if (time_sync_assist_info_present) {
    j.write_int("id", 326);
    j.write_str("criticality", "ignore");
    time_sync_assist_info.to_json(j);
  }
  if (q_mcc_onfig_info_present) {
    j.write_int("id", 328);
    j.write_str("criticality", "ignore");
    q_mcc_onfig_info.to_json(j);
  }
  if (target_nssai_info_present) {
    j.write_int("id", 334);
    j.write_str("criticality", "ignore");
    target_nssai_info.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_int("id", 335);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : ue_slice_max_bit_rate_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (five_g_pro_se_authorized_present) {
    j.write_int("id", 345);
    j.write_str("criticality", "ignore");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_int("id", 346);
    j.write_str("criticality", "ignore");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_int("id", 347);
    j.write_str("criticality", "ignore");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  j.end_obj();
}

// InitialContextSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_context_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 72, 55, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool init_context_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 72, 55, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_context_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 72:
      return crit_e::ignore;
    case 55:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_context_setup_resp_ies_o::value_c init_context_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 72:
      ret.set(value_c::types::pdu_session_res_setup_list_cxt_res);
      break;
    case 55:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_cxt_res);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_context_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 72:
      return presence_e::optional;
    case 55:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_context_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_setup_list_cxt_res:
      c.destroy<pdu_session_res_setup_list_cxt_res_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      c.destroy<pdu_session_res_failed_to_setup_list_cxt_res_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void init_context_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      c.init<pdu_session_res_setup_list_cxt_res_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      c.init<pdu_session_res_failed_to_setup_list_cxt_res_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
}
init_context_setup_resp_ies_o::value_c::value_c(const init_context_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      c.init(other.c.get<pdu_session_res_setup_list_cxt_res_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
}
init_context_setup_resp_ies_o::value_c&
init_context_setup_resp_ies_o::value_c::operator=(const init_context_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      c.set(other.c.get<pdu_session_res_setup_list_cxt_res_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_context_setup_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& init_context_setup_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_setup_list_cxt_res_l& init_context_setup_resp_ies_o::value_c::pdu_session_res_setup_list_cxt_res()
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_res_l>();
}
pdu_session_res_failed_to_setup_list_cxt_res_l&
init_context_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>();
}
crit_diagnostics_s& init_context_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& init_context_setup_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& init_context_setup_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_setup_list_cxt_res_l&
init_context_setup_resp_ies_o::value_c::pdu_session_res_setup_list_cxt_res() const
{
  assert_choice_type(types::pdu_session_res_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_cxt_res_l>();
}
const pdu_session_res_failed_to_setup_list_cxt_res_l&
init_context_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_cxt_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_cxt_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>();
}
const crit_diagnostics_s& init_context_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void init_context_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      j.start_array("PDUSessionResourceSetupListCxtRes");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_cxt_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      j.start_array("PDUSessionResourceFailedToSetupListCxtRes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_context_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_cxt_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_cxt_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_cxt_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_cxt_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_cxt_res_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_context_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE init_context_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_setup_list_cxt_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_setup_list_cxt_res_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_setup_list_cxt_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)72, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_setup_list_cxt_res, 1, 256, true));
  }
  if (pdu_session_res_failed_to_setup_list_cxt_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)55, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_setup_list_cxt_res, 1, 256, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_context_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 72: {
        pdu_session_res_setup_list_cxt_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_setup_list_cxt_res, bref, 1, 256, true));
        break;
      }
      case 55: {
        pdu_session_res_failed_to_setup_list_cxt_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_setup_list_cxt_res, bref, 1, 256, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_context_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_setup_list_cxt_res_present) {
    j.write_int("id", 72);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_setup_list_cxt_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_failed_to_setup_list_cxt_res_present) {
    j.write_int("id", 55);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_setup_list_cxt_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

// InitialUEMessage-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t init_ue_msg_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 38, 121, 90, 26, 3, 112, 0, 171, 174, 201, 224, 225, 227, 245, 259, 333};
  return map_enum_number(names, 17, idx, "id");
}
bool init_ue_msg_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 38, 121, 90, 26, 3, 112, 0, 171, 174, 201, 224, 225, 227, 245, 259, 333};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e init_ue_msg_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 38:
      return crit_e::reject;
    case 121:
      return crit_e::reject;
    case 90:
      return crit_e::ignore;
    case 26:
      return crit_e::reject;
    case 3:
      return crit_e::ignore;
    case 112:
      return crit_e::ignore;
    case 0:
      return crit_e::reject;
    case 171:
      return crit_e::ignore;
    case 174:
      return crit_e::ignore;
    case 201:
      return crit_e::reject;
    case 224:
      return crit_e::reject;
    case 225:
      return crit_e::ignore;
    case 227:
      return crit_e::ignore;
    case 245:
      return crit_e::ignore;
    case 259:
      return crit_e::reject;
    case 333:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
init_ue_msg_ies_o::value_c init_ue_msg_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 90:
      ret.set(value_c::types::rrc_establishment_cause);
      break;
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    case 3:
      ret.set(value_c::types::amf_set_id);
      break;
    case 112:
      ret.set(value_c::types::ue_context_request);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 171:
      ret.set(value_c::types::source_to_target_amf_info_reroute);
      break;
    case 174:
      ret.set(value_c::types::sel_plmn_id);
      break;
    case 201:
      ret.set(value_c::types::iab_node_ind);
      break;
    case 224:
      ret.set(value_c::types::ce_mode_b_support_ind);
      break;
    case 225:
      ret.set(value_c::types::ltem_ind);
      break;
    case 227:
      ret.set(value_c::types::edt_session);
      break;
    case 245:
      ret.set(value_c::types::authenticated_ind);
      break;
    case 259:
      ret.set(value_c::types::npn_access_info);
      break;
    case 333:
      ret.set(value_c::types::red_cap_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e init_ue_msg_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 38:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 90:
      return presence_e::mandatory;
    case 26:
      return presence_e::optional;
    case 3:
      return presence_e::optional;
    case 112:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 171:
      return presence_e::optional;
    case 174:
      return presence_e::optional;
    case 201:
      return presence_e::optional;
    case 224:
      return presence_e::optional;
    case 225:
      return presence_e::optional;
    case 227:
      return presence_e::optional;
    case 245:
      return presence_e::optional;
    case 259:
      return presence_e::optional;
    case 333:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void init_ue_msg_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    case types::amf_set_id:
      c.destroy<fixed_bitstring<10, false, true>>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::source_to_target_amf_info_reroute:
      c.destroy<source_to_target_amf_info_reroute_s>();
      break;
    case types::sel_plmn_id:
      c.destroy<fixed_octstring<3, true>>();
      break;
    case types::npn_access_info:
      c.destroy<npn_access_info_c>();
      break;
    default:
      break;
  }
}
void init_ue_msg_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::rrc_establishment_cause:
      break;
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::amf_set_id:
      c.init<fixed_bitstring<10, false, true>>();
      break;
    case types::ue_context_request:
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::source_to_target_amf_info_reroute:
      c.init<source_to_target_amf_info_reroute_s>();
      break;
    case types::sel_plmn_id:
      c.init<fixed_octstring<3, true>>();
      break;
    case types::iab_node_ind:
      break;
    case types::ce_mode_b_support_ind:
      break;
    case types::ltem_ind:
      break;
    case types::edt_session:
      break;
    case types::authenticated_ind:
      break;
    case types::npn_access_info:
      c.init<npn_access_info_c>();
      break;
    case types::red_cap_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
}
init_ue_msg_ies_o::value_c::value_c(const init_ue_msg_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::rrc_establishment_cause:
      c.init(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::amf_set_id:
      c.init(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::ue_context_request:
      c.init(other.c.get<ue_context_request_e>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::source_to_target_amf_info_reroute:
      c.init(other.c.get<source_to_target_amf_info_reroute_s>());
      break;
    case types::sel_plmn_id:
      c.init(other.c.get<fixed_octstring<3, true>>());
      break;
    case types::iab_node_ind:
      c.init(other.c.get<iab_node_ind_e>());
      break;
    case types::ce_mode_b_support_ind:
      c.init(other.c.get<ce_mode_b_support_ind_e>());
      break;
    case types::ltem_ind:
      c.init(other.c.get<ltem_ind_e>());
      break;
    case types::edt_session:
      c.init(other.c.get<edt_session_e>());
      break;
    case types::authenticated_ind:
      c.init(other.c.get<authenticated_ind_e>());
      break;
    case types::npn_access_info:
      c.init(other.c.get<npn_access_info_c>());
      break;
    case types::red_cap_ind:
      c.init(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
}
init_ue_msg_ies_o::value_c& init_ue_msg_ies_o::value_c::operator=(const init_ue_msg_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::rrc_establishment_cause:
      c.set(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::amf_set_id:
      c.set(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::ue_context_request:
      c.set(other.c.get<ue_context_request_e>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::source_to_target_amf_info_reroute:
      c.set(other.c.get<source_to_target_amf_info_reroute_s>());
      break;
    case types::sel_plmn_id:
      c.set(other.c.get<fixed_octstring<3, true>>());
      break;
    case types::iab_node_ind:
      c.set(other.c.get<iab_node_ind_e>());
      break;
    case types::ce_mode_b_support_ind:
      c.set(other.c.get<ce_mode_b_support_ind_e>());
      break;
    case types::ltem_ind:
      c.set(other.c.get<ltem_ind_e>());
      break;
    case types::edt_session:
      c.set(other.c.get<edt_session_e>());
      break;
    case types::authenticated_ind:
      c.set(other.c.get<authenticated_ind_e>());
      break;
    case types::npn_access_info:
      c.set(other.c.get<npn_access_info_c>());
      break;
    case types::red_cap_ind:
      c.set(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }

  return *this;
}
uint64_t& init_ue_msg_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& init_ue_msg_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
user_location_info_c& init_ue_msg_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
rrc_establishment_cause_e& init_ue_msg_ies_o::value_c::rrc_establishment_cause()
{
  assert_choice_type(types::rrc_establishment_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
five_g_s_tmsi_s& init_ue_msg_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
fixed_bitstring<10, false, true>& init_ue_msg_ies_o::value_c::amf_set_id()
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
ue_context_request_e& init_ue_msg_ies_o::value_c::ue_context_request()
{
  assert_choice_type(types::ue_context_request, type_, "Value");
  return c.get<ue_context_request_e>();
}
allowed_nssai_l& init_ue_msg_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
source_to_target_amf_info_reroute_s& init_ue_msg_ies_o::value_c::source_to_target_amf_info_reroute()
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
fixed_octstring<3, true>& init_ue_msg_ies_o::value_c::sel_plmn_id()
{
  assert_choice_type(types::sel_plmn_id, type_, "Value");
  return c.get<fixed_octstring<3, true>>();
}
iab_node_ind_e& init_ue_msg_ies_o::value_c::iab_node_ind()
{
  assert_choice_type(types::iab_node_ind, type_, "Value");
  return c.get<iab_node_ind_e>();
}
ce_mode_b_support_ind_e& init_ue_msg_ies_o::value_c::ce_mode_b_support_ind()
{
  assert_choice_type(types::ce_mode_b_support_ind, type_, "Value");
  return c.get<ce_mode_b_support_ind_e>();
}
ltem_ind_e& init_ue_msg_ies_o::value_c::ltem_ind()
{
  assert_choice_type(types::ltem_ind, type_, "Value");
  return c.get<ltem_ind_e>();
}
edt_session_e& init_ue_msg_ies_o::value_c::edt_session()
{
  assert_choice_type(types::edt_session, type_, "Value");
  return c.get<edt_session_e>();
}
authenticated_ind_e& init_ue_msg_ies_o::value_c::authenticated_ind()
{
  assert_choice_type(types::authenticated_ind, type_, "Value");
  return c.get<authenticated_ind_e>();
}
npn_access_info_c& init_ue_msg_ies_o::value_c::npn_access_info()
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
red_cap_ind_e& init_ue_msg_ies_o::value_c::red_cap_ind()
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
const uint64_t& init_ue_msg_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& init_ue_msg_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const user_location_info_c& init_ue_msg_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const rrc_establishment_cause_e& init_ue_msg_ies_o::value_c::rrc_establishment_cause() const
{
  assert_choice_type(types::rrc_establishment_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const five_g_s_tmsi_s& init_ue_msg_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const fixed_bitstring<10, false, true>& init_ue_msg_ies_o::value_c::amf_set_id() const
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
const ue_context_request_e& init_ue_msg_ies_o::value_c::ue_context_request() const
{
  assert_choice_type(types::ue_context_request, type_, "Value");
  return c.get<ue_context_request_e>();
}
const allowed_nssai_l& init_ue_msg_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const source_to_target_amf_info_reroute_s& init_ue_msg_ies_o::value_c::source_to_target_amf_info_reroute() const
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
const fixed_octstring<3, true>& init_ue_msg_ies_o::value_c::sel_plmn_id() const
{
  assert_choice_type(types::sel_plmn_id, type_, "Value");
  return c.get<fixed_octstring<3, true>>();
}
const iab_node_ind_e& init_ue_msg_ies_o::value_c::iab_node_ind() const
{
  assert_choice_type(types::iab_node_ind, type_, "Value");
  return c.get<iab_node_ind_e>();
}
const ce_mode_b_support_ind_e& init_ue_msg_ies_o::value_c::ce_mode_b_support_ind() const
{
  assert_choice_type(types::ce_mode_b_support_ind, type_, "Value");
  return c.get<ce_mode_b_support_ind_e>();
}
const ltem_ind_e& init_ue_msg_ies_o::value_c::ltem_ind() const
{
  assert_choice_type(types::ltem_ind, type_, "Value");
  return c.get<ltem_ind_e>();
}
const edt_session_e& init_ue_msg_ies_o::value_c::edt_session() const
{
  assert_choice_type(types::edt_session, type_, "Value");
  return c.get<edt_session_e>();
}
const authenticated_ind_e& init_ue_msg_ies_o::value_c::authenticated_ind() const
{
  assert_choice_type(types::authenticated_ind, type_, "Value");
  return c.get<authenticated_ind_e>();
}
const npn_access_info_c& init_ue_msg_ies_o::value_c::npn_access_info() const
{
  assert_choice_type(types::npn_access_info, type_, "Value");
  return c.get<npn_access_info_c>();
}
const red_cap_ind_e& init_ue_msg_ies_o::value_c::red_cap_ind() const
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
void init_ue_msg_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::rrc_establishment_cause:
      j.write_str("RRCEstablishmentCause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::amf_set_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<10, false, true>>().to_string());
      break;
    case types::ue_context_request:
      j.write_str("UEContextRequest", "requested");
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::source_to_target_amf_info_reroute:
      j.write_fieldname("SourceToTarget-AMFInformationReroute");
      c.get<source_to_target_amf_info_reroute_s>().to_json(j);
      break;
    case types::sel_plmn_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<3, true>>().to_string());
      break;
    case types::iab_node_ind:
      j.write_str("IABNodeIndication", "true");
      break;
    case types::ce_mode_b_support_ind:
      j.write_str("CEmodeBSupport-Indicator", "supported");
      break;
    case types::ltem_ind:
      j.write_str("LTEM-Indication", "lte-m");
      break;
    case types::edt_session:
      j.write_str("EDT-Session", "true");
      break;
    case types::authenticated_ind:
      j.write_str("AuthenticatedIndication", "true");
      break;
    case types::npn_access_info:
      j.write_fieldname("NPN-AccessInformation");
      c.get<npn_access_info_c>().to_json(j);
      break;
    case types::red_cap_ind:
      j.write_str("RedCapIndication", "redcap");
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE init_ue_msg_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::rrc_establishment_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().pack(bref)));
      break;
    case types::ue_context_request:
      HANDLE_CODE(c.get<ue_context_request_e>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().pack(bref));
      break;
    case types::sel_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().pack(bref)));
      break;
    case types::iab_node_ind:
      HANDLE_CODE(c.get<iab_node_ind_e>().pack(bref));
      break;
    case types::ce_mode_b_support_ind:
      HANDLE_CODE(c.get<ce_mode_b_support_ind_e>().pack(bref));
      break;
    case types::ltem_ind:
      HANDLE_CODE(c.get<ltem_ind_e>().pack(bref));
      break;
    case types::edt_session:
      HANDLE_CODE(c.get<edt_session_e>().pack(bref));
      break;
    case types::authenticated_ind:
      HANDLE_CODE(c.get<authenticated_ind_e>().pack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().pack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE init_ue_msg_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::rrc_establishment_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().unpack(bref)));
      break;
    case types::ue_context_request:
      HANDLE_CODE(c.get<ue_context_request_e>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().unpack(bref));
      break;
    case types::sel_plmn_id:
      HANDLE_CODE((c.get<fixed_octstring<3, true>>().unpack(bref)));
      break;
    case types::iab_node_ind:
      HANDLE_CODE(c.get<iab_node_ind_e>().unpack(bref));
      break;
    case types::ce_mode_b_support_ind:
      HANDLE_CODE(c.get<ce_mode_b_support_ind_e>().unpack(bref));
      break;
    case types::ltem_ind:
      HANDLE_CODE(c.get<ltem_ind_e>().unpack(bref));
      break;
    case types::edt_session:
      HANDLE_CODE(c.get<edt_session_e>().unpack(bref));
      break;
    case types::authenticated_ind:
      HANDLE_CODE(c.get<authenticated_ind_e>().unpack(bref));
      break;
    case types::npn_access_info:
      HANDLE_CODE(c.get<npn_access_info_c>().unpack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "init_ue_msg_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE init_ue_msg_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += five_g_s_tmsi_present ? 1 : 0;
  nof_ies += amf_set_id_present ? 1 : 0;
  nof_ies += ue_context_request_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += source_to_target_amf_info_reroute_present ? 1 : 0;
  nof_ies += sel_plmn_id_present ? 1 : 0;
  nof_ies += iab_node_ind_present ? 1 : 0;
  nof_ies += ce_mode_b_support_ind_present ? 1 : 0;
  nof_ies += ltem_ind_present ? 1 : 0;
  nof_ies += edt_session_present ? 1 : 0;
  nof_ies += authenticated_ind_present ? 1 : 0;
  nof_ies += npn_access_info_present ? 1 : 0;
  nof_ies += red_cap_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)90, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_establishment_cause.pack(bref));
  }
  if (five_g_s_tmsi_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)26, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_s_tmsi.pack(bref));
  }
  if (amf_set_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)3, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(amf_set_id.pack(bref));
  }
  if (ue_context_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)112, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_context_request.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (source_to_target_amf_info_reroute_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)171, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_to_target_amf_info_reroute.pack(bref));
  }
  if (sel_plmn_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)174, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(sel_plmn_id.pack(bref));
  }
  if (iab_node_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)201, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(iab_node_ind.pack(bref));
  }
  if (ce_mode_b_support_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)224, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_b_support_ind.pack(bref));
  }
  if (ltem_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)225, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ltem_ind.pack(bref));
  }
  if (edt_session_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)227, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(edt_session.pack(bref));
  }
  if (authenticated_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)245, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(authenticated_ind.pack(bref));
  }
  if (npn_access_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)259, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(npn_access_info.pack(bref));
  }
  if (red_cap_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)333, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(red_cap_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE init_ue_msg_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 90: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_establishment_cause.unpack(bref));
        break;
      }
      case 26: {
        five_g_s_tmsi_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.unpack(bref));
        break;
      }
      case 3: {
        amf_set_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_set_id.unpack(bref));
        break;
      }
      case 112: {
        ue_context_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_context_request.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 171: {
        source_to_target_amf_info_reroute_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_amf_info_reroute.unpack(bref));
        break;
      }
      case 174: {
        sel_plmn_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(sel_plmn_id.unpack(bref));
        break;
      }
      case 201: {
        iab_node_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_node_ind.unpack(bref));
        break;
      }
      case 224: {
        ce_mode_b_support_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_b_support_ind.unpack(bref));
        break;
      }
      case 225: {
        ltem_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltem_ind.unpack(bref));
        break;
      }
      case 227: {
        edt_session_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(edt_session.unpack(bref));
        break;
      }
      case 245: {
        authenticated_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(authenticated_ind.unpack(bref));
        break;
      }
      case 259: {
        npn_access_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(npn_access_info.unpack(bref));
        break;
      }
      case 333: {
        red_cap_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(red_cap_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void init_ue_msg_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 38);
  j.write_str("criticality", "reject");
  j.write_str("Value", nas_pdu.to_string());
  j.write_int("id", 121);
  j.write_str("criticality", "reject");
  user_location_info.to_json(j);
  j.write_int("id", 90);
  j.write_str("criticality", "ignore");
  j.write_str("Value", rrc_establishment_cause.to_string());
  if (five_g_s_tmsi_present) {
    j.write_int("id", 26);
    j.write_str("criticality", "reject");
    five_g_s_tmsi.to_json(j);
  }
  if (amf_set_id_present) {
    j.write_int("id", 3);
    j.write_str("criticality", "ignore");
    j.write_str("Value", amf_set_id.to_string());
  }
  if (ue_context_request_present) {
    j.write_int("id", 112);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "requested");
  }
  if (allowed_nssai_present) {
    j.write_int("id", 0);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : allowed_nssai) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (source_to_target_amf_info_reroute_present) {
    j.write_int("id", 171);
    j.write_str("criticality", "ignore");
    source_to_target_amf_info_reroute.to_json(j);
  }
  if (sel_plmn_id_present) {
    j.write_int("id", 174);
    j.write_str("criticality", "ignore");
    j.write_str("Value", sel_plmn_id.to_string());
  }
  if (iab_node_ind_present) {
    j.write_int("id", 201);
    j.write_str("criticality", "reject");
    j.write_str("Value", "true");
  }
  if (ce_mode_b_support_ind_present) {
    j.write_int("id", 224);
    j.write_str("criticality", "reject");
    j.write_str("Value", "supported");
  }
  if (ltem_ind_present) {
    j.write_int("id", 225);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "lte-m");
  }
  if (edt_session_present) {
    j.write_int("id", 227);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "true");
  }
  if (authenticated_ind_present) {
    j.write_int("id", 245);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "true");
  }
  if (npn_access_info_present) {
    j.write_int("id", 259);
    j.write_str("criticality", "reject");
    npn_access_info.to_json(j);
  }
  if (red_cap_ind_present) {
    j.write_int("id", 333);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "redcap");
  }
  j.end_obj();
}

// LocationReportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t location_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 121, 116, 33};
  return map_enum_number(names, 5, idx, "id");
}
bool location_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 121, 116, 33};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 116:
      return crit_e::ignore;
    case 33:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
location_report_ies_o::value_c location_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 116:
      ret.set(value_c::types::ue_presence_in_area_of_interest_list);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 116:
      return presence_e::optional;
    case 33:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::ue_presence_in_area_of_interest_list:
      c.destroy<ue_presence_in_area_of_interest_list_l>();
      break;
    case types::location_report_request_type:
      c.destroy<location_report_request_type_s>();
      break;
    default:
      break;
  }
}
void location_report_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::ue_presence_in_area_of_interest_list:
      c.init<ue_presence_in_area_of_interest_list_l>();
      break;
    case types::location_report_request_type:
      c.init<location_report_request_type_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
}
location_report_ies_o::value_c::value_c(const location_report_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::ue_presence_in_area_of_interest_list:
      c.init(other.c.get<ue_presence_in_area_of_interest_list_l>());
      break;
    case types::location_report_request_type:
      c.init(other.c.get<location_report_request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
}
location_report_ies_o::value_c& location_report_ies_o::value_c::operator=(const location_report_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::ue_presence_in_area_of_interest_list:
      c.set(other.c.get<ue_presence_in_area_of_interest_list_l>());
      break;
    case types::location_report_request_type:
      c.set(other.c.get<location_report_request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }

  return *this;
}
uint64_t& location_report_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& location_report_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& location_report_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
ue_presence_in_area_of_interest_list_l& location_report_ies_o::value_c::ue_presence_in_area_of_interest_list()
{
  assert_choice_type(types::ue_presence_in_area_of_interest_list, type_, "Value");
  return c.get<ue_presence_in_area_of_interest_list_l>();
}
location_report_request_type_s& location_report_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const uint64_t& location_report_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& location_report_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& location_report_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const ue_presence_in_area_of_interest_list_l&
location_report_ies_o::value_c::ue_presence_in_area_of_interest_list() const
{
  assert_choice_type(types::ue_presence_in_area_of_interest_list, type_, "Value");
  return c.get<ue_presence_in_area_of_interest_list_l>();
}
const location_report_request_type_s& location_report_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
void location_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::ue_presence_in_area_of_interest_list:
      j.start_array("UEPresenceInAreaOfInterestList");
      for (const auto& e1 : c.get<ue_presence_in_area_of_interest_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::ue_presence_in_area_of_interest_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_presence_in_area_of_interest_list_l>(), 1, 64, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::ue_presence_in_area_of_interest_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_presence_in_area_of_interest_list_l>(), bref, 1, 64, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// LocationReportingControlIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t location_report_ctrl_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 33};
  return map_enum_number(names, 3, idx, "id");
}
bool location_report_ctrl_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 33};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_ctrl_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 33:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
location_report_ctrl_ies_o::value_c location_report_ctrl_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 33:
      ret.set(value_c::types::location_report_request_type);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_ctrl_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 33:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_ctrl_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::location_report_request_type:
      c.destroy<location_report_request_type_s>();
      break;
    default:
      break;
  }
}
void location_report_ctrl_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::location_report_request_type:
      c.init<location_report_request_type_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
}
location_report_ctrl_ies_o::value_c::value_c(const location_report_ctrl_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::location_report_request_type:
      c.init(other.c.get<location_report_request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
}
location_report_ctrl_ies_o::value_c&
location_report_ctrl_ies_o::value_c::operator=(const location_report_ctrl_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::location_report_request_type:
      c.set(other.c.get<location_report_request_type_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }

  return *this;
}
uint64_t& location_report_ctrl_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& location_report_ctrl_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
location_report_request_type_s& location_report_ctrl_ies_o::value_c::location_report_request_type()
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
const uint64_t& location_report_ctrl_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& location_report_ctrl_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const location_report_request_type_s& location_report_ctrl_ies_o::value_c::location_report_request_type() const
{
  assert_choice_type(types::location_report_request_type, type_, "Value");
  return c.get<location_report_request_type_s>();
}
void location_report_ctrl_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::location_report_request_type:
      j.write_fieldname("LocationReportingRequestType");
      c.get<location_report_request_type_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_ctrl_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ctrl_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::location_report_request_type:
      HANDLE_CODE(c.get<location_report_request_type_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_ctrl_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// LocationReportingFailureIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t location_report_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15};
  return map_enum_number(names, 3, idx, "id");
}
bool location_report_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e location_report_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
location_report_fail_ind_ies_o::value_c location_report_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e location_report_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void location_report_fail_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void location_report_fail_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
}
location_report_fail_ind_ies_o::value_c::value_c(const location_report_fail_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
}
location_report_fail_ind_ies_o::value_c&
location_report_fail_ind_ies_o::value_c::operator=(const location_report_fail_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& location_report_fail_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& location_report_fail_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& location_report_fail_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& location_report_fail_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& location_report_fail_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& location_report_fail_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void location_report_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE location_report_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "location_report_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastGroupPagingIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_group_paging_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 298, 307};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_group_paging_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 298, 307};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_group_paging_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::ignore;
    case 298:
      return crit_e::ignore;
    case 307:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_group_paging_ies_o::value_c multicast_group_paging_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 298:
      ret.set(value_c::types::mbs_service_area);
      break;
    case 307:
      ret.set(value_c::types::multicast_group_paging_area_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_group_paging_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 298:
      return presence_e::optional;
    case 307:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_group_paging_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.destroy<mbs_service_area_c>();
      break;
    case types::multicast_group_paging_area_list:
      c.destroy<multicast_group_paging_area_list_l>();
      break;
    default:
      break;
  }
}
void multicast_group_paging_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_service_area:
      c.init<mbs_service_area_c>();
      break;
    case types::multicast_group_paging_area_list:
      c.init<multicast_group_paging_area_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }
}
multicast_group_paging_ies_o::value_c::value_c(const multicast_group_paging_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.init(other.c.get<mbs_service_area_c>());
      break;
    case types::multicast_group_paging_area_list:
      c.init(other.c.get<multicast_group_paging_area_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }
}
multicast_group_paging_ies_o::value_c&
multicast_group_paging_ies_o::value_c::operator=(const multicast_group_paging_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_service_area:
      c.set(other.c.get<mbs_service_area_c>());
      break;
    case types::multicast_group_paging_area_list:
      c.set(other.c.get<multicast_group_paging_area_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_group_paging_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
mbs_service_area_c& multicast_group_paging_ies_o::value_c::mbs_service_area()
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
multicast_group_paging_area_list_l& multicast_group_paging_ies_o::value_c::multicast_group_paging_area_list()
{
  assert_choice_type(types::multicast_group_paging_area_list, type_, "Value");
  return c.get<multicast_group_paging_area_list_l>();
}
const mbs_session_id_s& multicast_group_paging_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const mbs_service_area_c& multicast_group_paging_ies_o::value_c::mbs_service_area() const
{
  assert_choice_type(types::mbs_service_area, type_, "Value");
  return c.get<mbs_service_area_c>();
}
const multicast_group_paging_area_list_l&
multicast_group_paging_ies_o::value_c::multicast_group_paging_area_list() const
{
  assert_choice_type(types::multicast_group_paging_area_list, type_, "Value");
  return c.get<multicast_group_paging_area_list_l>();
}
void multicast_group_paging_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_service_area:
      j.write_fieldname("MBS-ServiceArea");
      c.get<mbs_service_area_c>().to_json(j);
      break;
    case types::multicast_group_paging_area_list:
      j.start_array("MulticastGroupPagingAreaList");
      for (const auto& e1 : c.get<multicast_group_paging_area_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_group_paging_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().pack(bref));
      break;
    case types::multicast_group_paging_area_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<multicast_group_paging_area_list_l>(), 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_group_paging_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_service_area:
      HANDLE_CODE(c.get<mbs_service_area_c>().unpack(bref));
      break;
    case types::multicast_group_paging_area_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<multicast_group_paging_area_list_l>(), bref, 1, 64, true));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_group_paging_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionActivationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_activation_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 15, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_session_activation_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_activation_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_activation_fail_ies_o::value_c multicast_session_activation_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_activation_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_activation_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_activation_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }
}
multicast_session_activation_fail_ies_o::value_c::value_c(const multicast_session_activation_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }
}
multicast_session_activation_fail_ies_o::value_c& multicast_session_activation_fail_ies_o::value_c::operator=(
    const multicast_session_activation_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_activation_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
cause_c& multicast_session_activation_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& multicast_session_activation_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_activation_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const cause_c& multicast_session_activation_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& multicast_session_activation_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_activation_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_activation_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionActivationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_activation_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 304};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_activation_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 304};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_activation_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 304:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_activation_request_ies_o::value_c
multicast_session_activation_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 304:
      ret.set(value_c::types::multicast_session_activation_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_activation_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 304:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_activation_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::multicast_session_activation_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void multicast_session_activation_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::multicast_session_activation_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }
}
multicast_session_activation_request_ies_o::value_c::value_c(
    const multicast_session_activation_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::multicast_session_activation_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }
}
multicast_session_activation_request_ies_o::value_c& multicast_session_activation_request_ies_o::value_c::operator=(
    const multicast_session_activation_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::multicast_session_activation_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_activation_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>&
multicast_session_activation_request_ies_o::value_c::multicast_session_activation_request_transfer()
{
  assert_choice_type(types::multicast_session_activation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& multicast_session_activation_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>&
multicast_session_activation_request_ies_o::value_c::multicast_session_activation_request_transfer() const
{
  assert_choice_type(types::multicast_session_activation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void multicast_session_activation_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::multicast_session_activation_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_activation_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::multicast_session_activation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::multicast_session_activation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionActivationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_activation_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 19};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_activation_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_activation_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_activation_resp_ies_o::value_c multicast_session_activation_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_activation_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_activation_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_activation_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }
}
multicast_session_activation_resp_ies_o::value_c::value_c(const multicast_session_activation_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }
}
multicast_session_activation_resp_ies_o::value_c& multicast_session_activation_resp_ies_o::value_c::operator=(
    const multicast_session_activation_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_activation_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
crit_diagnostics_s& multicast_session_activation_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_activation_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const crit_diagnostics_s& multicast_session_activation_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_activation_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_activation_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_activation_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionDeactivationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_deactivation_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 305};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_deactivation_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 305};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_deactivation_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 305:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_deactivation_request_ies_o::value_c
multicast_session_deactivation_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 305:
      ret.set(value_c::types::multicast_session_deactivation_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_deactivation_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 305:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_deactivation_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::multicast_session_deactivation_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void multicast_session_deactivation_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::multicast_session_deactivation_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }
}
multicast_session_deactivation_request_ies_o::value_c::value_c(
    const multicast_session_deactivation_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::multicast_session_deactivation_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }
}
multicast_session_deactivation_request_ies_o::value_c& multicast_session_deactivation_request_ies_o::value_c::operator=(
    const multicast_session_deactivation_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::multicast_session_deactivation_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_deactivation_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
unbounded_octstring<true>&
multicast_session_deactivation_request_ies_o::value_c::multicast_session_deactivation_request_transfer()
{
  assert_choice_type(types::multicast_session_deactivation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& multicast_session_deactivation_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const unbounded_octstring<true>&
multicast_session_deactivation_request_ies_o::value_c::multicast_session_deactivation_request_transfer() const
{
  assert_choice_type(types::multicast_session_deactivation_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void multicast_session_deactivation_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::multicast_session_deactivation_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_deactivation_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::multicast_session_deactivation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::multicast_session_deactivation_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionDeactivationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_deactivation_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 19};
  return map_enum_number(names, 2, idx, "id");
}
bool multicast_session_deactivation_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_deactivation_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_deactivation_resp_ies_o::value_c
multicast_session_deactivation_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_deactivation_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_deactivation_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_deactivation_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }
}
multicast_session_deactivation_resp_ies_o::value_c::value_c(
    const multicast_session_deactivation_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }
}
multicast_session_deactivation_resp_ies_o::value_c& multicast_session_deactivation_resp_ies_o::value_c::operator=(
    const multicast_session_deactivation_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_deactivation_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
crit_diagnostics_s& multicast_session_deactivation_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_deactivation_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const crit_diagnostics_s& multicast_session_deactivation_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_deactivation_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_deactivation_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_deactivation_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionUpdateFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool multicast_session_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_fail_ies_o::value_c multicast_session_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_upd_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }
}
multicast_session_upd_fail_ies_o::value_c::value_c(const multicast_session_upd_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }
}
multicast_session_upd_fail_ies_o::value_c&
multicast_session_upd_fail_ies_o::value_c::operator=(const multicast_session_upd_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_upd_fail_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& multicast_session_upd_fail_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
cause_c& multicast_session_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& multicast_session_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_upd_fail_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& multicast_session_upd_fail_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const cause_c& multicast_session_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& multicast_session_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionUpdateRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 306};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_session_upd_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 306};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 306:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_request_ies_o::value_c multicast_session_upd_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 306:
      ret.set(value_c::types::multicast_session_upd_request_transfer);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 306:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::multicast_session_upd_request_transfer:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void multicast_session_upd_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::multicast_session_upd_request_transfer:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }
}
multicast_session_upd_request_ies_o::value_c::value_c(const multicast_session_upd_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::multicast_session_upd_request_transfer:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }
}
multicast_session_upd_request_ies_o::value_c&
multicast_session_upd_request_ies_o::value_c::operator=(const multicast_session_upd_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::multicast_session_upd_request_transfer:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_upd_request_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& multicast_session_upd_request_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
unbounded_octstring<true>& multicast_session_upd_request_ies_o::value_c::multicast_session_upd_request_transfer()
{
  assert_choice_type(types::multicast_session_upd_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mbs_session_id_s& multicast_session_upd_request_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& multicast_session_upd_request_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const unbounded_octstring<true>&
multicast_session_upd_request_ies_o::value_c::multicast_session_upd_request_transfer() const
{
  assert_choice_type(types::multicast_session_upd_request_transfer, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void multicast_session_upd_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::multicast_session_upd_request_transfer:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::multicast_session_upd_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::multicast_session_upd_request_transfer:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// MulticastSessionUpdateResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t multicast_session_upd_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {299, 295, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool multicast_session_upd_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {299, 295, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e multicast_session_upd_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 299:
      return crit_e::reject;
    case 295:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
multicast_session_upd_resp_ies_o::value_c multicast_session_upd_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 299:
      ret.set(value_c::types::mbs_session_id);
      break;
    case 295:
      ret.set(value_c::types::mbs_area_session_id);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e multicast_session_upd_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 299:
      return presence_e::mandatory;
    case 295:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void multicast_session_upd_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::mbs_session_id:
      c.destroy<mbs_session_id_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void multicast_session_upd_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::mbs_session_id:
      c.init<mbs_session_id_s>();
      break;
    case types::mbs_area_session_id:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }
}
multicast_session_upd_resp_ies_o::value_c::value_c(const multicast_session_upd_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::mbs_session_id:
      c.init(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.init(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }
}
multicast_session_upd_resp_ies_o::value_c&
multicast_session_upd_resp_ies_o::value_c::operator=(const multicast_session_upd_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::mbs_session_id:
      c.set(other.c.get<mbs_session_id_s>());
      break;
    case types::mbs_area_session_id:
      c.set(other.c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }

  return *this;
}
mbs_session_id_s& multicast_session_upd_resp_ies_o::value_c::mbs_session_id()
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
uint32_t& multicast_session_upd_resp_ies_o::value_c::mbs_area_session_id()
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
crit_diagnostics_s& multicast_session_upd_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const mbs_session_id_s& multicast_session_upd_resp_ies_o::value_c::mbs_session_id() const
{
  assert_choice_type(types::mbs_session_id, type_, "Value");
  return c.get<mbs_session_id_s>();
}
const uint32_t& multicast_session_upd_resp_ies_o::value_c::mbs_area_session_id() const
{
  assert_choice_type(types::mbs_area_session_id, type_, "Value");
  return c.get<uint32_t>();
}
const crit_diagnostics_s& multicast_session_upd_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void multicast_session_upd_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::mbs_session_id:
      j.write_fieldname("MBS-SessionID");
      c.get<mbs_session_id_s>().to_json(j);
      break;
    case types::mbs_area_session_id:
      j.write_int("INTEGER (0..65535,...)", c.get<uint32_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE multicast_session_upd_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().pack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::mbs_session_id:
      HANDLE_CODE(c.get<mbs_session_id_s>().unpack(bref));
      break;
    case types::mbs_area_session_id:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, true, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "multicast_session_upd_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NASNonDeliveryIndication-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t nas_non_delivery_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 38, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool nas_non_delivery_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 38, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e nas_non_delivery_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 38:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
nas_non_delivery_ind_ies_o::value_c nas_non_delivery_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e nas_non_delivery_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 38:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void nas_non_delivery_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void nas_non_delivery_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
}
nas_non_delivery_ind_ies_o::value_c::value_c(const nas_non_delivery_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
}
nas_non_delivery_ind_ies_o::value_c&
nas_non_delivery_ind_ies_o::value_c::operator=(const nas_non_delivery_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& nas_non_delivery_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& nas_non_delivery_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& nas_non_delivery_ind_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
cause_c& nas_non_delivery_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& nas_non_delivery_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& nas_non_delivery_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& nas_non_delivery_ind_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const cause_c& nas_non_delivery_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void nas_non_delivery_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE nas_non_delivery_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_non_delivery_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "nas_non_delivery_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NGResetAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_reset_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {111, 19};
  return map_enum_number(names, 2, idx, "id");
}
bool ng_reset_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {111, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_reset_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 111:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_reset_ack_ies_o::value_c ng_reset_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 111:
      ret.set(value_c::types::ue_associated_lc_ng_conn_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_reset_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 111:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_reset_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      c.destroy<ue_associated_lc_ng_conn_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ng_reset_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      c.init<ue_associated_lc_ng_conn_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }
}
ng_reset_ack_ies_o::value_c::value_c(const ng_reset_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      c.init(other.c.get<ue_associated_lc_ng_conn_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }
}
ng_reset_ack_ies_o::value_c& ng_reset_ack_ies_o::value_c::operator=(const ng_reset_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      c.set(other.c.get<ue_associated_lc_ng_conn_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }

  return *this;
}
ue_associated_lc_ng_conn_list_l& ng_reset_ack_ies_o::value_c::ue_associated_lc_ng_conn_list()
{
  assert_choice_type(types::ue_associated_lc_ng_conn_list, type_, "Value");
  return c.get<ue_associated_lc_ng_conn_list_l>();
}
crit_diagnostics_s& ng_reset_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const ue_associated_lc_ng_conn_list_l& ng_reset_ack_ies_o::value_c::ue_associated_lc_ng_conn_list() const
{
  assert_choice_type(types::ue_associated_lc_ng_conn_list, type_, "Value");
  return c.get<ue_associated_lc_ng_conn_list_l>();
}
const crit_diagnostics_s& ng_reset_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ng_reset_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      j.start_array("UE-associatedLogicalNG-connectionList");
      for (const auto& e1 : c.get<ue_associated_lc_ng_conn_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_reset_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_associated_lc_ng_conn_list_l>(), 1, 65536, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_associated_lc_ng_conn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_associated_lc_ng_conn_list_l>(), bref, 1, 65536, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NGResetIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_reset_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 88};
  return map_enum_number(names, 2, idx, "id");
}
bool ng_reset_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 88};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_reset_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 88:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_reset_ies_o::value_c ng_reset_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 88:
      ret.set(value_c::types::reset_type);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_reset_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 88:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_reset_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::reset_type:
      c.destroy<reset_type_c>();
      break;
    default:
      break;
  }
}
void ng_reset_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::reset_type:
      c.init<reset_type_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }
}
ng_reset_ies_o::value_c::value_c(const ng_reset_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::reset_type:
      c.init(other.c.get<reset_type_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }
}
ng_reset_ies_o::value_c& ng_reset_ies_o::value_c::operator=(const ng_reset_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::reset_type:
      c.set(other.c.get<reset_type_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }

  return *this;
}
cause_c& ng_reset_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
reset_type_c& ng_reset_ies_o::value_c::reset_type()
{
  assert_choice_type(types::reset_type, type_, "Value");
  return c.get<reset_type_c>();
}
const cause_c& ng_reset_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const reset_type_c& ng_reset_ies_o::value_c::reset_type() const
{
  assert_choice_type(types::reset_type, type_, "Value");
  return c.get<reset_type_c>();
}
void ng_reset_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::reset_type:
      j.write_fieldname("ResetType");
      c.get<reset_type_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_reset_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::reset_type:
      HANDLE_CODE(c.get<reset_type_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::reset_type:
      HANDLE_CODE(c.get<reset_type_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_reset_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NGSetupFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_setup_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 107, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ng_setup_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 107, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_setup_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 107:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_setup_fail_ies_o::value_c ng_setup_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 107:
      ret.set(value_c::types::time_to_wait);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_setup_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 107:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_setup_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ng_setup_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::time_to_wait:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }
}
ng_setup_fail_ies_o::value_c::value_c(const ng_setup_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.init(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }
}
ng_setup_fail_ies_o::value_c& ng_setup_fail_ies_o::value_c::operator=(const ng_setup_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.set(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }

  return *this;
}
cause_c& ng_setup_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& ng_setup_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& ng_setup_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& ng_setup_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& ng_setup_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& ng_setup_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ng_setup_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_setup_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NGSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {27, 82, 102, 21, 147, 204, 273};
  return map_enum_number(names, 7, idx, "id");
}
bool ng_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {27, 82, 102, 21, 147, 204, 273};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 27:
      return crit_e::reject;
    case 82:
      return crit_e::ignore;
    case 102:
      return crit_e::reject;
    case 21:
      return crit_e::ignore;
    case 147:
      return crit_e::ignore;
    case 204:
      return crit_e::ignore;
    case 273:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_setup_request_ies_o::value_c ng_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    case 82:
      ret.set(value_c::types::ran_node_name);
      break;
    case 102:
      ret.set(value_c::types::supported_ta_list);
      break;
    case 21:
      ret.set(value_c::types::default_paging_drx);
      break;
    case 147:
      ret.set(value_c::types::ue_retention_info);
      break;
    case 204:
      ret.set(value_c::types::nb_iot_default_paging_drx);
      break;
    case 273:
      ret.set(value_c::types::extended_ran_node_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 27:
      return presence_e::mandatory;
    case 82:
      return presence_e::optional;
    case 102:
      return presence_e::mandatory;
    case 21:
      return presence_e::mandatory;
    case 147:
      return presence_e::optional;
    case 204:
      return presence_e::optional;
    case 273:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    case types::ran_node_name:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::supported_ta_list:
      c.destroy<supported_ta_list_l>();
      break;
    case types::extended_ran_node_name:
      c.destroy<extended_ran_node_name_s>();
      break;
    default:
      break;
  }
}
void ng_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::ran_node_name:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::supported_ta_list:
      c.init<supported_ta_list_l>();
      break;
    case types::default_paging_drx:
      break;
    case types::ue_retention_info:
      break;
    case types::nb_iot_default_paging_drx:
      break;
    case types::extended_ran_node_name:
      c.init<extended_ran_node_name_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }
}
ng_setup_request_ies_o::value_c::value_c(const ng_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::ran_node_name:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::supported_ta_list:
      c.init(other.c.get<supported_ta_list_l>());
      break;
    case types::default_paging_drx:
      c.init(other.c.get<paging_drx_e>());
      break;
    case types::ue_retention_info:
      c.init(other.c.get<ue_retention_info_e>());
      break;
    case types::nb_iot_default_paging_drx:
      c.init(other.c.get<nb_iot_default_paging_drx_e>());
      break;
    case types::extended_ran_node_name:
      c.init(other.c.get<extended_ran_node_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }
}
ng_setup_request_ies_o::value_c&
ng_setup_request_ies_o::value_c::operator=(const ng_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::ran_node_name:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::supported_ta_list:
      c.set(other.c.get<supported_ta_list_l>());
      break;
    case types::default_paging_drx:
      c.set(other.c.get<paging_drx_e>());
      break;
    case types::ue_retention_info:
      c.set(other.c.get<ue_retention_info_e>());
      break;
    case types::nb_iot_default_paging_drx:
      c.set(other.c.get<nb_iot_default_paging_drx_e>());
      break;
    case types::extended_ran_node_name:
      c.set(other.c.get<extended_ran_node_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }

  return *this;
}
global_ran_node_id_c& ng_setup_request_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
printable_string<1, 150, true, true>& ng_setup_request_ies_o::value_c::ran_node_name()
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
supported_ta_list_l& ng_setup_request_ies_o::value_c::supported_ta_list()
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
paging_drx_e& ng_setup_request_ies_o::value_c::default_paging_drx()
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
ue_retention_info_e& ng_setup_request_ies_o::value_c::ue_retention_info()
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
nb_iot_default_paging_drx_e& ng_setup_request_ies_o::value_c::nb_iot_default_paging_drx()
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
extended_ran_node_name_s& ng_setup_request_ies_o::value_c::extended_ran_node_name()
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
const global_ran_node_id_c& ng_setup_request_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const printable_string<1, 150, true, true>& ng_setup_request_ies_o::value_c::ran_node_name() const
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const supported_ta_list_l& ng_setup_request_ies_o::value_c::supported_ta_list() const
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
const paging_drx_e& ng_setup_request_ies_o::value_c::default_paging_drx() const
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const ue_retention_info_e& ng_setup_request_ies_o::value_c::ue_retention_info() const
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
const nb_iot_default_paging_drx_e& ng_setup_request_ies_o::value_c::nb_iot_default_paging_drx() const
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
const extended_ran_node_name_s& ng_setup_request_ies_o::value_c::extended_ran_node_name() const
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
void ng_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::ran_node_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::supported_ta_list:
      j.start_array("SupportedTAList");
      for (const auto& e1 : c.get<supported_ta_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::default_paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::ue_retention_info:
      j.write_str("UERetentionInformation", "ues-retained");
      break;
    case types::nb_iot_default_paging_drx:
      j.write_str("NB-IoT-DefaultPagingDRX", c.get<nb_iot_default_paging_drx_e>().to_string());
      break;
    case types::extended_ran_node_name:
      j.write_fieldname("Extended-RANNodeName");
      c.get<extended_ran_node_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<supported_ta_list_l>(), 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().pack(bref));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().pack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<supported_ta_list_l>(), bref, 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().unpack(bref));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().unpack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// NGSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ng_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {1, 96, 86, 80, 19, 147, 200, 274};
  return map_enum_number(names, 8, idx, "id");
}
bool ng_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {1, 96, 86, 80, 19, 147, 200, 274};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ng_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 1:
      return crit_e::reject;
    case 96:
      return crit_e::reject;
    case 86:
      return crit_e::ignore;
    case 80:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    case 147:
      return crit_e::ignore;
    case 200:
      return crit_e::ignore;
    case 274:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ng_setup_resp_ies_o::value_c ng_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 1:
      ret.set(value_c::types::amf_name);
      break;
    case 96:
      ret.set(value_c::types::served_guami_list);
      break;
    case 86:
      ret.set(value_c::types::relative_amf_capacity);
      break;
    case 80:
      ret.set(value_c::types::plmn_support_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 147:
      ret.set(value_c::types::ue_retention_info);
      break;
    case 200:
      ret.set(value_c::types::iab_supported);
      break;
    case 274:
      ret.set(value_c::types::extended_amf_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ng_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 1:
      return presence_e::mandatory;
    case 96:
      return presence_e::mandatory;
    case 86:
      return presence_e::mandatory;
    case 80:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    case 147:
      return presence_e::optional;
    case 200:
      return presence_e::optional;
    case 274:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ng_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::amf_name:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::served_guami_list:
      c.destroy<served_guami_list_l>();
      break;
    case types::plmn_support_list:
      c.destroy<plmn_support_list_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::extended_amf_name:
      c.destroy<extended_amf_name_s>();
      break;
    default:
      break;
  }
}
void ng_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_name:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::served_guami_list:
      c.init<served_guami_list_l>();
      break;
    case types::relative_amf_capacity:
      break;
    case types::plmn_support_list:
      c.init<plmn_support_list_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::ue_retention_info:
      break;
    case types::iab_supported:
      break;
    case types::extended_amf_name:
      c.init<extended_amf_name_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }
}
ng_setup_resp_ies_o::value_c::value_c(const ng_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_name:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::served_guami_list:
      c.init(other.c.get<served_guami_list_l>());
      break;
    case types::relative_amf_capacity:
      c.init(other.c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      c.init(other.c.get<plmn_support_list_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::ue_retention_info:
      c.init(other.c.get<ue_retention_info_e>());
      break;
    case types::iab_supported:
      c.init(other.c.get<iab_supported_e>());
      break;
    case types::extended_amf_name:
      c.init(other.c.get<extended_amf_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }
}
ng_setup_resp_ies_o::value_c& ng_setup_resp_ies_o::value_c::operator=(const ng_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_name:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::served_guami_list:
      c.set(other.c.get<served_guami_list_l>());
      break;
    case types::relative_amf_capacity:
      c.set(other.c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      c.set(other.c.get<plmn_support_list_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::ue_retention_info:
      c.set(other.c.get<ue_retention_info_e>());
      break;
    case types::iab_supported:
      c.set(other.c.get<iab_supported_e>());
      break;
    case types::extended_amf_name:
      c.set(other.c.get<extended_amf_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }

  return *this;
}
printable_string<1, 150, true, true>& ng_setup_resp_ies_o::value_c::amf_name()
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
served_guami_list_l& ng_setup_resp_ies_o::value_c::served_guami_list()
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
uint16_t& ng_setup_resp_ies_o::value_c::relative_amf_capacity()
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
plmn_support_list_l& ng_setup_resp_ies_o::value_c::plmn_support_list()
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
crit_diagnostics_s& ng_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
ue_retention_info_e& ng_setup_resp_ies_o::value_c::ue_retention_info()
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
iab_supported_e& ng_setup_resp_ies_o::value_c::iab_supported()
{
  assert_choice_type(types::iab_supported, type_, "Value");
  return c.get<iab_supported_e>();
}
extended_amf_name_s& ng_setup_resp_ies_o::value_c::extended_amf_name()
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
const printable_string<1, 150, true, true>& ng_setup_resp_ies_o::value_c::amf_name() const
{
  assert_choice_type(types::amf_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const served_guami_list_l& ng_setup_resp_ies_o::value_c::served_guami_list() const
{
  assert_choice_type(types::served_guami_list, type_, "Value");
  return c.get<served_guami_list_l>();
}
const uint16_t& ng_setup_resp_ies_o::value_c::relative_amf_capacity() const
{
  assert_choice_type(types::relative_amf_capacity, type_, "Value");
  return c.get<uint16_t>();
}
const plmn_support_list_l& ng_setup_resp_ies_o::value_c::plmn_support_list() const
{
  assert_choice_type(types::plmn_support_list, type_, "Value");
  return c.get<plmn_support_list_l>();
}
const crit_diagnostics_s& ng_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const ue_retention_info_e& ng_setup_resp_ies_o::value_c::ue_retention_info() const
{
  assert_choice_type(types::ue_retention_info, type_, "Value");
  return c.get<ue_retention_info_e>();
}
const iab_supported_e& ng_setup_resp_ies_o::value_c::iab_supported() const
{
  assert_choice_type(types::iab_supported, type_, "Value");
  return c.get<iab_supported_e>();
}
const extended_amf_name_s& ng_setup_resp_ies_o::value_c::extended_amf_name() const
{
  assert_choice_type(types::extended_amf_name, type_, "Value");
  return c.get<extended_amf_name_s>();
}
void ng_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::served_guami_list:
      j.start_array("ServedGUAMIList");
      for (const auto& e1 : c.get<served_guami_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::relative_amf_capacity:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::plmn_support_list:
      j.start_array("PLMNSupportList");
      for (const auto& e1 : c.get<plmn_support_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::ue_retention_info:
      j.write_str("UERetentionInformation", "ues-retained");
      break;
    case types::iab_supported:
      j.write_str("IAB-Supported", "true");
      break;
    case types::extended_amf_name:
      j.write_fieldname("Extended-AMFName");
      c.get<extended_amf_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ng_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<served_guami_list_l>(), 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<plmn_support_list_l>(), 1, 12, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().pack(bref));
      break;
    case types::iab_supported:
      HANDLE_CODE(c.get<iab_supported_e>().pack(bref));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::served_guami_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<served_guami_list_l>(), bref, 1, 256, true));
      break;
    case types::relative_amf_capacity:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::plmn_support_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<plmn_support_list_l>(), bref, 1, 12, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::ue_retention_info:
      HANDLE_CODE(c.get<ue_retention_info_e>().unpack(bref));
      break;
    case types::iab_supported:
      HANDLE_CODE(c.get<iab_supported_e>().unpack(bref));
      break;
    case types::extended_amf_name:
      HANDLE_CODE(c.get<extended_amf_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ng_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// OverloadStartIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t overload_start_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {2, 9, 49};
  return map_enum_number(names, 3, idx, "id");
}
bool overload_start_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {2, 9, 49};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e overload_start_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 2:
      return crit_e::reject;
    case 9:
      return crit_e::ignore;
    case 49:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
overload_start_ies_o::value_c overload_start_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 2:
      ret.set(value_c::types::amf_overload_resp);
      break;
    case 9:
      ret.set(value_c::types::amf_traffic_load_reduction_ind);
      break;
    case 49:
      ret.set(value_c::types::overload_start_nssai_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e overload_start_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 2:
      return presence_e::optional;
    case 9:
      return presence_e::optional;
    case 49:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void overload_start_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::amf_overload_resp:
      c.destroy<overload_resp_c>();
      break;
    case types::overload_start_nssai_list:
      c.destroy<overload_start_nssai_list_l>();
      break;
    default:
      break;
  }
}
void overload_start_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_overload_resp:
      c.init<overload_resp_c>();
      break;
    case types::amf_traffic_load_reduction_ind:
      break;
    case types::overload_start_nssai_list:
      c.init<overload_start_nssai_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
}
overload_start_ies_o::value_c::value_c(const overload_start_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_overload_resp:
      c.init(other.c.get<overload_resp_c>());
      break;
    case types::amf_traffic_load_reduction_ind:
      c.init(other.c.get<uint8_t>());
      break;
    case types::overload_start_nssai_list:
      c.init(other.c.get<overload_start_nssai_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
}
overload_start_ies_o::value_c& overload_start_ies_o::value_c::operator=(const overload_start_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_overload_resp:
      c.set(other.c.get<overload_resp_c>());
      break;
    case types::amf_traffic_load_reduction_ind:
      c.set(other.c.get<uint8_t>());
      break;
    case types::overload_start_nssai_list:
      c.set(other.c.get<overload_start_nssai_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }

  return *this;
}
overload_resp_c& overload_start_ies_o::value_c::amf_overload_resp()
{
  assert_choice_type(types::amf_overload_resp, type_, "Value");
  return c.get<overload_resp_c>();
}
uint8_t& overload_start_ies_o::value_c::amf_traffic_load_reduction_ind()
{
  assert_choice_type(types::amf_traffic_load_reduction_ind, type_, "Value");
  return c.get<uint8_t>();
}
overload_start_nssai_list_l& overload_start_ies_o::value_c::overload_start_nssai_list()
{
  assert_choice_type(types::overload_start_nssai_list, type_, "Value");
  return c.get<overload_start_nssai_list_l>();
}
const overload_resp_c& overload_start_ies_o::value_c::amf_overload_resp() const
{
  assert_choice_type(types::amf_overload_resp, type_, "Value");
  return c.get<overload_resp_c>();
}
const uint8_t& overload_start_ies_o::value_c::amf_traffic_load_reduction_ind() const
{
  assert_choice_type(types::amf_traffic_load_reduction_ind, type_, "Value");
  return c.get<uint8_t>();
}
const overload_start_nssai_list_l& overload_start_ies_o::value_c::overload_start_nssai_list() const
{
  assert_choice_type(types::overload_start_nssai_list, type_, "Value");
  return c.get<overload_start_nssai_list_l>();
}
void overload_start_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_overload_resp:
      j.write_fieldname("OverloadResponse");
      c.get<overload_resp_c>().to_json(j);
      break;
    case types::amf_traffic_load_reduction_ind:
      j.write_int("INTEGER (1..99)", c.get<uint8_t>());
      break;
    case types::overload_start_nssai_list:
      j.start_array("OverloadStartNSSAIList");
      for (const auto& e1 : c.get<overload_start_nssai_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE overload_start_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_overload_resp:
      HANDLE_CODE(c.get<overload_resp_c>().pack(bref));
      break;
    case types::amf_traffic_load_reduction_ind:
      HANDLE_CODE(pack_integer(bref, c.get<uint8_t>(), (uint8_t)1u, (uint8_t)99u, false, true));
      break;
    case types::overload_start_nssai_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<overload_start_nssai_list_l>(), 1, 1024, true));
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_start_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_overload_resp:
      HANDLE_CODE(c.get<overload_resp_c>().unpack(bref));
      break;
    case types::amf_traffic_load_reduction_ind:
      HANDLE_CODE(unpack_integer(c.get<uint8_t>(), bref, (uint8_t)1u, (uint8_t)99u, false, true));
      break;
    case types::overload_start_nssai_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<overload_start_nssai_list_l>(), bref, 1, 1024, true));
      break;
    default:
      log_invalid_choice_id(type_, "overload_start_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceModifyConfirmIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_confirm_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 62, 131, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_modify_confirm_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 62, 131, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_confirm_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 62:
      return crit_e::ignore;
    case 131:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_confirm_ies_o::value_c pdu_session_res_modify_confirm_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 62:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_cfm);
      break;
    case 131:
      ret.set(value_c::types::pdu_session_res_failed_to_modify_list_mod_cfm);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_confirm_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 62:
      return presence_e::optional;
    case 131:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_confirm_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_modify_list_mod_cfm:
      c.destroy<pdu_session_res_modify_list_mod_cfm_l>();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      c.destroy<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_confirm_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      c.init<pdu_session_res_modify_list_mod_cfm_l>();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      c.init<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }
}
pdu_session_res_modify_confirm_ies_o::value_c::value_c(const pdu_session_res_modify_confirm_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      c.init(other.c.get<pdu_session_res_modify_list_mod_cfm_l>());
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      c.init(other.c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }
}
pdu_session_res_modify_confirm_ies_o::value_c&
pdu_session_res_modify_confirm_ies_o::value_c::operator=(const pdu_session_res_modify_confirm_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      c.set(other.c.get<pdu_session_res_modify_list_mod_cfm_l>());
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      c.set(other.c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_modify_list_mod_cfm()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_cfm_l>();
}
pdu_session_res_failed_to_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_cfm()
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
}
crit_diagnostics_s& pdu_session_res_modify_confirm_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_confirm_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_modify_list_mod_cfm() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_cfm_l>();
}
const pdu_session_res_failed_to_modify_list_mod_cfm_l&
pdu_session_res_modify_confirm_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_cfm() const
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_cfm, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>();
}
const crit_diagnostics_s& pdu_session_res_modify_confirm_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pdu_session_res_modify_confirm_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      j.start_array("PDUSessionResourceModifyListModCfm");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_cfm_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      j.start_array("PDUSessionResourceFailedToModifyListModCfm");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_cfm_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_cfm:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_cfm_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_cfm:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_modify_list_mod_cfm_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_confirm_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceModifyIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 63, 121};
  return map_enum_number(names, 4, idx, "id");
}
bool pdu_session_res_modify_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 63, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 63:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_ind_ies_o::value_c pdu_session_res_modify_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 63:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_ind);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 63:
      return presence_e::mandatory;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_modify_list_mod_ind:
      c.destroy<pdu_session_res_modify_list_mod_ind_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      c.init<pdu_session_res_modify_list_mod_ind_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }
}
pdu_session_res_modify_ind_ies_o::value_c::value_c(const pdu_session_res_modify_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      c.init(other.c.get<pdu_session_res_modify_list_mod_ind_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }
}
pdu_session_res_modify_ind_ies_o::value_c&
pdu_session_res_modify_ind_ies_o::value_c::operator=(const pdu_session_res_modify_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      c.set(other.c.get<pdu_session_res_modify_list_mod_ind_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_modify_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_modify_list_mod_ind_l& pdu_session_res_modify_ind_ies_o::value_c::pdu_session_res_modify_list_mod_ind()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_ind, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_ind_l>();
}
user_location_info_c& pdu_session_res_modify_ind_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& pdu_session_res_modify_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_modify_list_mod_ind_l&
pdu_session_res_modify_ind_ies_o::value_c::pdu_session_res_modify_list_mod_ind() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_ind, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_ind_l>();
}
const user_location_info_c& pdu_session_res_modify_ind_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void pdu_session_res_modify_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      j.start_array("PDUSessionResourceModifyListModInd");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_ind_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_ind_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_ind:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_ind_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceModifyRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 83, 64};
  return map_enum_number(names, 4, idx, "id");
}
bool pdu_session_res_modify_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 83, 64};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 64:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_request_ies_o::value_c pdu_session_res_modify_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 64:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_req);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 64:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_modify_list_mod_req:
      c.destroy<pdu_session_res_modify_list_mod_req_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_paging_prio:
      break;
    case types::pdu_session_res_modify_list_mod_req:
      c.init<pdu_session_res_modify_list_mod_req_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }
}
pdu_session_res_modify_request_ies_o::value_c::value_c(const pdu_session_res_modify_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::pdu_session_res_modify_list_mod_req:
      c.init(other.c.get<pdu_session_res_modify_list_mod_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }
}
pdu_session_res_modify_request_ies_o::value_c&
pdu_session_res_modify_request_ies_o::value_c::operator=(const pdu_session_res_modify_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::pdu_session_res_modify_list_mod_req:
      c.set(other.c.get<pdu_session_res_modify_list_mod_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_modify_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& pdu_session_res_modify_request_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
pdu_session_res_modify_list_mod_req_l&
pdu_session_res_modify_request_ies_o::value_c::pdu_session_res_modify_list_mod_req()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_req, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_req_l>();
}
const uint64_t& pdu_session_res_modify_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& pdu_session_res_modify_request_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const pdu_session_res_modify_list_mod_req_l&
pdu_session_res_modify_request_ies_o::value_c::pdu_session_res_modify_list_mod_req() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_req, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_req_l>();
}
void pdu_session_res_modify_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::pdu_session_res_modify_list_mod_req:
      j.start_array("PDUSessionResourceModifyListModReq");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_req_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_req_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceModifyResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_modify_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 65, 54, 121, 19};
  return map_enum_number(names, 6, idx, "id");
}
bool pdu_session_res_modify_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 65, 54, 121, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_modify_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 65:
      return crit_e::ignore;
    case 54:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_modify_resp_ies_o::value_c pdu_session_res_modify_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 65:
      ret.set(value_c::types::pdu_session_res_modify_list_mod_res);
      break;
    case 54:
      ret.set(value_c::types::pdu_session_res_failed_to_modify_list_mod_res);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_modify_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 65:
      return presence_e::optional;
    case 54:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_modify_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_modify_list_mod_res:
      c.destroy<pdu_session_res_modify_list_mod_res_l>();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      c.destroy<pdu_session_res_failed_to_modify_list_mod_res_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void pdu_session_res_modify_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_modify_list_mod_res:
      c.init<pdu_session_res_modify_list_mod_res_l>();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      c.init<pdu_session_res_failed_to_modify_list_mod_res_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }
}
pdu_session_res_modify_resp_ies_o::value_c::value_c(const pdu_session_res_modify_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_res:
      c.init(other.c.get<pdu_session_res_modify_list_mod_res_l>());
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      c.init(other.c.get<pdu_session_res_failed_to_modify_list_mod_res_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }
}
pdu_session_res_modify_resp_ies_o::value_c&
pdu_session_res_modify_resp_ies_o::value_c::operator=(const pdu_session_res_modify_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_res:
      c.set(other.c.get<pdu_session_res_modify_list_mod_res_l>());
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      c.set(other.c.get<pdu_session_res_failed_to_modify_list_mod_res_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_modify_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_modify_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_modify_list_mod_res_l& pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_modify_list_mod_res()
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_res_l>();
}
pdu_session_res_failed_to_modify_list_mod_res_l&
pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_res_l>();
}
user_location_info_c& pdu_session_res_modify_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
crit_diagnostics_s& pdu_session_res_modify_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& pdu_session_res_modify_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_modify_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_modify_list_mod_res_l&
pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_modify_list_mod_res() const
{
  assert_choice_type(types::pdu_session_res_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_modify_list_mod_res_l>();
}
const pdu_session_res_failed_to_modify_list_mod_res_l&
pdu_session_res_modify_resp_ies_o::value_c::pdu_session_res_failed_to_modify_list_mod_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_modify_list_mod_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_modify_list_mod_res_l>();
}
const user_location_info_c& pdu_session_res_modify_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const crit_diagnostics_s& pdu_session_res_modify_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pdu_session_res_modify_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_modify_list_mod_res:
      j.start_array("PDUSessionResourceModifyListModRes");
      for (const auto& e1 : c.get<pdu_session_res_modify_list_mod_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      j.start_array("PDUSessionResourceFailedToModifyListModRes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_modify_list_mod_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_modify_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_modify_list_mod_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_modify_list_mod_res_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_modify_list_mod_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_modify_list_mod_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_modify_list_mod_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_modify_list_mod_res_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_modify_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceNotifyIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_notify_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 66, 67, 121};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_notify_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 66, 67, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_notify_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 66:
      return crit_e::reject;
    case 67:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_notify_ies_o::value_c pdu_session_res_notify_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 66:
      ret.set(value_c::types::pdu_session_res_notify_list);
      break;
    case 67:
      ret.set(value_c::types::pdu_session_res_released_list_not);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_notify_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 66:
      return presence_e::optional;
    case 67:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_notify_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_notify_list:
      c.destroy<pdu_session_res_notify_list_l>();
      break;
    case types::pdu_session_res_released_list_not:
      c.destroy<pdu_session_res_released_list_not_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void pdu_session_res_notify_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_notify_list:
      c.init<pdu_session_res_notify_list_l>();
      break;
    case types::pdu_session_res_released_list_not:
      c.init<pdu_session_res_released_list_not_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }
}
pdu_session_res_notify_ies_o::value_c::value_c(const pdu_session_res_notify_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_notify_list:
      c.init(other.c.get<pdu_session_res_notify_list_l>());
      break;
    case types::pdu_session_res_released_list_not:
      c.init(other.c.get<pdu_session_res_released_list_not_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }
}
pdu_session_res_notify_ies_o::value_c&
pdu_session_res_notify_ies_o::value_c::operator=(const pdu_session_res_notify_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_notify_list:
      c.set(other.c.get<pdu_session_res_notify_list_l>());
      break;
    case types::pdu_session_res_released_list_not:
      c.set(other.c.get<pdu_session_res_released_list_not_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_notify_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_notify_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_notify_list_l& pdu_session_res_notify_ies_o::value_c::pdu_session_res_notify_list()
{
  assert_choice_type(types::pdu_session_res_notify_list, type_, "Value");
  return c.get<pdu_session_res_notify_list_l>();
}
pdu_session_res_released_list_not_l& pdu_session_res_notify_ies_o::value_c::pdu_session_res_released_list_not()
{
  assert_choice_type(types::pdu_session_res_released_list_not, type_, "Value");
  return c.get<pdu_session_res_released_list_not_l>();
}
user_location_info_c& pdu_session_res_notify_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& pdu_session_res_notify_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_notify_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_notify_list_l& pdu_session_res_notify_ies_o::value_c::pdu_session_res_notify_list() const
{
  assert_choice_type(types::pdu_session_res_notify_list, type_, "Value");
  return c.get<pdu_session_res_notify_list_l>();
}
const pdu_session_res_released_list_not_l&
pdu_session_res_notify_ies_o::value_c::pdu_session_res_released_list_not() const
{
  assert_choice_type(types::pdu_session_res_released_list_not, type_, "Value");
  return c.get<pdu_session_res_released_list_not_l>();
}
const user_location_info_c& pdu_session_res_notify_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void pdu_session_res_notify_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_notify_list:
      j.start_array("PDUSessionResourceNotifyList");
      for (const auto& e1 : c.get<pdu_session_res_notify_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_released_list_not:
      j.start_array("PDUSessionResourceReleasedListNot");
      for (const auto& e1 : c.get<pdu_session_res_released_list_not_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_notify_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_notify_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_notify_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_released_list_not:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_not_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_notify_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_notify_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_released_list_not:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_not_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_notify_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceReleaseCommandIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_release_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 83, 38, 79};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_release_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 83, 38, 79};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_release_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 38:
      return crit_e::ignore;
    case 79:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_release_cmd_ies_o::value_c pdu_session_res_release_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 79:
      ret.set(value_c::types::pdu_session_res_to_release_list_rel_cmd);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_release_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 38:
      return presence_e::optional;
    case 79:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_release_cmd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      c.destroy<pdu_session_res_to_release_list_rel_cmd_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_release_cmd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_paging_prio:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      c.init<pdu_session_res_to_release_list_rel_cmd_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }
}
pdu_session_res_release_cmd_ies_o::value_c::value_c(const pdu_session_res_release_cmd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      c.init(other.c.get<pdu_session_res_to_release_list_rel_cmd_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }
}
pdu_session_res_release_cmd_ies_o::value_c&
pdu_session_res_release_cmd_ies_o::value_c::operator=(const pdu_session_res_release_cmd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      c.set(other.c.get<pdu_session_res_to_release_list_rel_cmd_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_release_cmd_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_release_cmd_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& pdu_session_res_release_cmd_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& pdu_session_res_release_cmd_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_to_release_list_rel_cmd_l&
pdu_session_res_release_cmd_ies_o::value_c::pdu_session_res_to_release_list_rel_cmd()
{
  assert_choice_type(types::pdu_session_res_to_release_list_rel_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_rel_cmd_l>();
}
const uint64_t& pdu_session_res_release_cmd_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_release_cmd_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& pdu_session_res_release_cmd_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& pdu_session_res_release_cmd_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_to_release_list_rel_cmd_l&
pdu_session_res_release_cmd_ies_o::value_c::pdu_session_res_to_release_list_rel_cmd() const
{
  assert_choice_type(types::pdu_session_res_to_release_list_rel_cmd, type_, "Value");
  return c.get<pdu_session_res_to_release_list_rel_cmd_l>();
}
void pdu_session_res_release_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      j.start_array("PDUSessionResourceToReleaseListRelCmd");
      for (const auto& e1 : c.get<pdu_session_res_to_release_list_rel_cmd_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_release_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_to_release_list_rel_cmd_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_to_release_list_rel_cmd:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_to_release_list_rel_cmd_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceReleaseResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_release_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 70, 121, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool pdu_session_res_release_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 70, 121, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_release_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 70:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_release_resp_ies_o::value_c pdu_session_res_release_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 70:
      ret.set(value_c::types::pdu_session_res_released_list_rel_res);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_release_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 70:
      return presence_e::mandatory;
    case 121:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_release_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_released_list_rel_res:
      c.destroy<pdu_session_res_released_list_rel_res_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void pdu_session_res_release_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_released_list_rel_res:
      c.init<pdu_session_res_released_list_rel_res_l>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }
}
pdu_session_res_release_resp_ies_o::value_c::value_c(const pdu_session_res_release_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_rel_res:
      c.init(other.c.get<pdu_session_res_released_list_rel_res_l>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }
}
pdu_session_res_release_resp_ies_o::value_c&
pdu_session_res_release_resp_ies_o::value_c::operator=(const pdu_session_res_release_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_rel_res:
      c.set(other.c.get<pdu_session_res_released_list_rel_res_l>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_release_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_release_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_released_list_rel_res_l&
pdu_session_res_release_resp_ies_o::value_c::pdu_session_res_released_list_rel_res()
{
  assert_choice_type(types::pdu_session_res_released_list_rel_res, type_, "Value");
  return c.get<pdu_session_res_released_list_rel_res_l>();
}
user_location_info_c& pdu_session_res_release_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
crit_diagnostics_s& pdu_session_res_release_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& pdu_session_res_release_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_release_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_released_list_rel_res_l&
pdu_session_res_release_resp_ies_o::value_c::pdu_session_res_released_list_rel_res() const
{
  assert_choice_type(types::pdu_session_res_released_list_rel_res, type_, "Value");
  return c.get<pdu_session_res_released_list_rel_res_l>();
}
const user_location_info_c& pdu_session_res_release_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const crit_diagnostics_s& pdu_session_res_release_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pdu_session_res_release_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_rel_res:
      j.start_array("PDUSessionResourceReleasedListRelRes");
      for (const auto& e1 : c.get<pdu_session_res_released_list_rel_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_release_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_rel_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_rel_res_l>(), 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_rel_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_rel_res_l>(), bref, 1, 256, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_release_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceSetupRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_setup_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 83, 38, 74, 110, 335};
  return map_enum_number(names, 7, idx, "id");
}
bool pdu_session_res_setup_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 83, 38, 74, 110, 335};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 38:
      return crit_e::reject;
    case 74:
      return crit_e::reject;
    case 110:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_request_ies_o::value_c pdu_session_res_setup_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 74:
      ret.set(value_c::types::pdu_session_res_setup_list_su_req);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 38:
      return presence_e::optional;
    case 74:
      return presence_e::mandatory;
    case 110:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_setup_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_setup_list_su_req:
      c.destroy<pdu_session_res_setup_list_su_req_l>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.destroy<ue_slice_max_bit_rate_list_l>();
      break;
    default:
      break;
  }
}
void pdu_session_res_setup_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_paging_prio:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::pdu_session_res_setup_list_su_req:
      c.init<pdu_session_res_setup_list_su_req_l>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init<ue_slice_max_bit_rate_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }
}
pdu_session_res_setup_request_ies_o::value_c::value_c(const pdu_session_res_setup_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_setup_list_su_req:
      c.init(other.c.get<pdu_session_res_setup_list_su_req_l>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }
}
pdu_session_res_setup_request_ies_o::value_c&
pdu_session_res_setup_request_ies_o::value_c::operator=(const pdu_session_res_setup_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::pdu_session_res_setup_list_su_req:
      c.set(other.c.get<pdu_session_res_setup_list_su_req_l>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.set(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_setup_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_setup_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& pdu_session_res_setup_request_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& pdu_session_res_setup_request_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
pdu_session_res_setup_list_su_req_l& pdu_session_res_setup_request_ies_o::value_c::pdu_session_res_setup_list_su_req()
{
  assert_choice_type(types::pdu_session_res_setup_list_su_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_req_l>();
}
ue_aggr_max_bit_rate_s& pdu_session_res_setup_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
ue_slice_max_bit_rate_list_l& pdu_session_res_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const uint64_t& pdu_session_res_setup_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_setup_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& pdu_session_res_setup_request_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& pdu_session_res_setup_request_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const pdu_session_res_setup_list_su_req_l&
pdu_session_res_setup_request_ies_o::value_c::pdu_session_res_setup_list_su_req() const
{
  assert_choice_type(types::pdu_session_res_setup_list_su_req, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_req_l>();
}
const ue_aggr_max_bit_rate_s& pdu_session_res_setup_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const ue_slice_max_bit_rate_list_l& pdu_session_res_setup_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
void pdu_session_res_setup_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::pdu_session_res_setup_list_su_req:
      j.start_array("PDUSessionResourceSetupListSUReq");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_su_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::pdu_session_res_setup_list_su_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_su_req_l>(), 1, 256, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::pdu_session_res_setup_list_su_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_su_req_l>(), bref, 1, 256, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PDUSessionResourceSetupResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pdu_session_res_setup_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 75, 58, 19, 121};
  return map_enum_number(names, 6, idx, "id");
}
bool pdu_session_res_setup_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 75, 58, 19, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pdu_session_res_setup_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 75:
      return crit_e::ignore;
    case 58:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pdu_session_res_setup_resp_ies_o::value_c pdu_session_res_setup_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 75:
      ret.set(value_c::types::pdu_session_res_setup_list_su_res);
      break;
    case 58:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_su_res);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pdu_session_res_setup_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 75:
      return presence_e::optional;
    case 58:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pdu_session_res_setup_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_setup_list_su_res:
      c.destroy<pdu_session_res_setup_list_su_res_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      c.destroy<pdu_session_res_failed_to_setup_list_su_res_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void pdu_session_res_setup_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_setup_list_su_res:
      c.init<pdu_session_res_setup_list_su_res_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      c.init<pdu_session_res_failed_to_setup_list_su_res_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }
}
pdu_session_res_setup_resp_ies_o::value_c::value_c(const pdu_session_res_setup_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_su_res:
      c.init(other.c.get<pdu_session_res_setup_list_su_res_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_su_res_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }
}
pdu_session_res_setup_resp_ies_o::value_c&
pdu_session_res_setup_resp_ies_o::value_c::operator=(const pdu_session_res_setup_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_su_res:
      c.set(other.c.get<pdu_session_res_setup_list_su_res_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_su_res_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& pdu_session_res_setup_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& pdu_session_res_setup_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_setup_list_su_res_l& pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_setup_list_su_res()
{
  assert_choice_type(types::pdu_session_res_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_res_l>();
}
pdu_session_res_failed_to_setup_list_su_res_l&
pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_su_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_su_res_l>();
}
crit_diagnostics_s& pdu_session_res_setup_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
user_location_info_c& pdu_session_res_setup_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& pdu_session_res_setup_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& pdu_session_res_setup_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_setup_list_su_res_l&
pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_setup_list_su_res() const
{
  assert_choice_type(types::pdu_session_res_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_setup_list_su_res_l>();
}
const pdu_session_res_failed_to_setup_list_su_res_l&
pdu_session_res_setup_resp_ies_o::value_c::pdu_session_res_failed_to_setup_list_su_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_su_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_su_res_l>();
}
const crit_diagnostics_s& pdu_session_res_setup_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const user_location_info_c& pdu_session_res_setup_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void pdu_session_res_setup_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_setup_list_su_res:
      j.start_array("PDUSessionResourceSetupListSURes");
      for (const auto& e1 : c.get<pdu_session_res_setup_list_su_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      j.start_array("PDUSessionResourceFailedToSetupListSURes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_su_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pdu_session_res_setup_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_su_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_setup_list_su_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_su_res_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_setup_list_su_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_setup_list_su_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_su_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_su_res_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pdu_session_res_setup_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PWSCancelRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_cancel_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 122, 14};
  return map_enum_number(names, 4, idx, "id");
}
bool pws_cancel_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 122, 14};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_cancel_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 122:
      return crit_e::ignore;
    case 14:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_cancel_request_ies_o::value_c pws_cancel_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 122:
      ret.set(value_c::types::warning_area_list);
      break;
    case 14:
      ret.set(value_c::types::cancel_all_warning_msgs);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_cancel_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 122:
      return presence_e::optional;
    case 14:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_cancel_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::warning_area_list:
      c.destroy<warning_area_list_c>();
      break;
    default:
      break;
  }
}
void pws_cancel_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::warning_area_list:
      c.init<warning_area_list_c>();
      break;
    case types::cancel_all_warning_msgs:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }
}
pws_cancel_request_ies_o::value_c::value_c(const pws_cancel_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::warning_area_list:
      c.init(other.c.get<warning_area_list_c>());
      break;
    case types::cancel_all_warning_msgs:
      c.init(other.c.get<cancel_all_warning_msgs_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }
}
pws_cancel_request_ies_o::value_c&
pws_cancel_request_ies_o::value_c::operator=(const pws_cancel_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::warning_area_list:
      c.set(other.c.get<warning_area_list_c>());
      break;
    case types::cancel_all_warning_msgs:
      c.set(other.c.get<cancel_all_warning_msgs_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
warning_area_list_c& pws_cancel_request_ies_o::value_c::warning_area_list()
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
cancel_all_warning_msgs_e& pws_cancel_request_ies_o::value_c::cancel_all_warning_msgs()
{
  assert_choice_type(types::cancel_all_warning_msgs, type_, "Value");
  return c.get<cancel_all_warning_msgs_e>();
}
const fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& pws_cancel_request_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const warning_area_list_c& pws_cancel_request_ies_o::value_c::warning_area_list() const
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
const cancel_all_warning_msgs_e& pws_cancel_request_ies_o::value_c::cancel_all_warning_msgs() const
{
  assert_choice_type(types::cancel_all_warning_msgs, type_, "Value");
  return c.get<cancel_all_warning_msgs_e>();
}
void pws_cancel_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::warning_area_list:
      j.write_fieldname("WarningAreaList");
      c.get<warning_area_list_c>().to_json(j);
      break;
    case types::cancel_all_warning_msgs:
      j.write_str("CancelAllWarningMessages", "true");
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_cancel_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().pack(bref));
      break;
    case types::cancel_all_warning_msgs:
      HANDLE_CODE(c.get<cancel_all_warning_msgs_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().unpack(bref));
      break;
    case types::cancel_all_warning_msgs:
      HANDLE_CODE(c.get<cancel_all_warning_msgs_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PWSCancelResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_cancel_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 12, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool pws_cancel_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 12, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_cancel_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 12:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_cancel_resp_ies_o::value_c pws_cancel_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 12:
      ret.set(value_c::types::broadcast_cancelled_area_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_cancel_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 12:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_cancel_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::broadcast_cancelled_area_list:
      c.destroy<broadcast_cancelled_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void pws_cancel_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::broadcast_cancelled_area_list:
      c.init<broadcast_cancelled_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }
}
pws_cancel_resp_ies_o::value_c::value_c(const pws_cancel_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::broadcast_cancelled_area_list:
      c.init(other.c.get<broadcast_cancelled_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }
}
pws_cancel_resp_ies_o::value_c& pws_cancel_resp_ies_o::value_c::operator=(const pws_cancel_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::broadcast_cancelled_area_list:
      c.set(other.c.get<broadcast_cancelled_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
broadcast_cancelled_area_list_c& pws_cancel_resp_ies_o::value_c::broadcast_cancelled_area_list()
{
  assert_choice_type(types::broadcast_cancelled_area_list, type_, "Value");
  return c.get<broadcast_cancelled_area_list_c>();
}
crit_diagnostics_s& pws_cancel_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& pws_cancel_resp_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const broadcast_cancelled_area_list_c& pws_cancel_resp_ies_o::value_c::broadcast_cancelled_area_list() const
{
  assert_choice_type(types::broadcast_cancelled_area_list, type_, "Value");
  return c.get<broadcast_cancelled_area_list_c>();
}
const crit_diagnostics_s& pws_cancel_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void pws_cancel_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::broadcast_cancelled_area_list:
      j.write_fieldname("BroadcastCancelledAreaList");
      c.get<broadcast_cancelled_area_list_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_cancel_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::broadcast_cancelled_area_list:
      HANDLE_CODE(c.get<broadcast_cancelled_area_list_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::broadcast_cancelled_area_list:
      HANDLE_CODE(c.get<broadcast_cancelled_area_list_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_cancel_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PWSFailureIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {81, 27};
  return map_enum_number(names, 2, idx, "id");
}
bool pws_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {81, 27};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 81:
      return crit_e::reject;
    case 27:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_fail_ind_ies_o::value_c pws_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 81:
      ret.set(value_c::types::pws_failed_cell_id_list);
      break;
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 81:
      return presence_e::mandatory;
    case 27:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_fail_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pws_failed_cell_id_list:
      c.destroy<pws_failed_cell_id_list_c>();
      break;
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    default:
      break;
  }
}
void pws_fail_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::pws_failed_cell_id_list:
      c.init<pws_failed_cell_id_list_c>();
      break;
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
}
pws_fail_ind_ies_o::value_c::value_c(const pws_fail_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::pws_failed_cell_id_list:
      c.init(other.c.get<pws_failed_cell_id_list_c>());
      break;
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
}
pws_fail_ind_ies_o::value_c& pws_fail_ind_ies_o::value_c::operator=(const pws_fail_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::pws_failed_cell_id_list:
      c.set(other.c.get<pws_failed_cell_id_list_c>());
      break;
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }

  return *this;
}
pws_failed_cell_id_list_c& pws_fail_ind_ies_o::value_c::pws_failed_cell_id_list()
{
  assert_choice_type(types::pws_failed_cell_id_list, type_, "Value");
  return c.get<pws_failed_cell_id_list_c>();
}
global_ran_node_id_c& pws_fail_ind_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const pws_failed_cell_id_list_c& pws_fail_ind_ies_o::value_c::pws_failed_cell_id_list() const
{
  assert_choice_type(types::pws_failed_cell_id_list, type_, "Value");
  return c.get<pws_failed_cell_id_list_c>();
}
const global_ran_node_id_c& pws_fail_ind_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
void pws_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::pws_failed_cell_id_list:
      j.write_fieldname("PWSFailedCellIDList");
      c.get<pws_failed_cell_id_list_c>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pws_failed_cell_id_list:
      HANDLE_CODE(c.get<pws_failed_cell_id_list_c>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::pws_failed_cell_id_list:
      HANDLE_CODE(c.get<pws_failed_cell_id_list_c>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "pws_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PWSRestartIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t pws_restart_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {16, 27, 104, 23};
  return map_enum_number(names, 4, idx, "id");
}
bool pws_restart_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {16, 27, 104, 23};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e pws_restart_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 16:
      return crit_e::reject;
    case 27:
      return crit_e::reject;
    case 104:
      return crit_e::reject;
    case 23:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
pws_restart_ind_ies_o::value_c pws_restart_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 16:
      ret.set(value_c::types::cell_id_list_for_restart);
      break;
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    case 104:
      ret.set(value_c::types::tai_list_for_restart);
      break;
    case 23:
      ret.set(value_c::types::emergency_area_id_list_for_restart);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e pws_restart_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 16:
      return presence_e::mandatory;
    case 27:
      return presence_e::mandatory;
    case 104:
      return presence_e::mandatory;
    case 23:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void pws_restart_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cell_id_list_for_restart:
      c.destroy<cell_id_list_for_restart_c>();
      break;
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    case types::tai_list_for_restart:
      c.destroy<tai_list_for_restart_l>();
      break;
    case types::emergency_area_id_list_for_restart:
      c.destroy<emergency_area_id_list_for_restart_l>();
      break;
    default:
      break;
  }
}
void pws_restart_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cell_id_list_for_restart:
      c.init<cell_id_list_for_restart_c>();
      break;
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::tai_list_for_restart:
      c.init<tai_list_for_restart_l>();
      break;
    case types::emergency_area_id_list_for_restart:
      c.init<emergency_area_id_list_for_restart_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
}
pws_restart_ind_ies_o::value_c::value_c(const pws_restart_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cell_id_list_for_restart:
      c.init(other.c.get<cell_id_list_for_restart_c>());
      break;
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::tai_list_for_restart:
      c.init(other.c.get<tai_list_for_restart_l>());
      break;
    case types::emergency_area_id_list_for_restart:
      c.init(other.c.get<emergency_area_id_list_for_restart_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
}
pws_restart_ind_ies_o::value_c& pws_restart_ind_ies_o::value_c::operator=(const pws_restart_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cell_id_list_for_restart:
      c.set(other.c.get<cell_id_list_for_restart_c>());
      break;
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::tai_list_for_restart:
      c.set(other.c.get<tai_list_for_restart_l>());
      break;
    case types::emergency_area_id_list_for_restart:
      c.set(other.c.get<emergency_area_id_list_for_restart_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }

  return *this;
}
cell_id_list_for_restart_c& pws_restart_ind_ies_o::value_c::cell_id_list_for_restart()
{
  assert_choice_type(types::cell_id_list_for_restart, type_, "Value");
  return c.get<cell_id_list_for_restart_c>();
}
global_ran_node_id_c& pws_restart_ind_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
tai_list_for_restart_l& pws_restart_ind_ies_o::value_c::tai_list_for_restart()
{
  assert_choice_type(types::tai_list_for_restart, type_, "Value");
  return c.get<tai_list_for_restart_l>();
}
emergency_area_id_list_for_restart_l& pws_restart_ind_ies_o::value_c::emergency_area_id_list_for_restart()
{
  assert_choice_type(types::emergency_area_id_list_for_restart, type_, "Value");
  return c.get<emergency_area_id_list_for_restart_l>();
}
const cell_id_list_for_restart_c& pws_restart_ind_ies_o::value_c::cell_id_list_for_restart() const
{
  assert_choice_type(types::cell_id_list_for_restart, type_, "Value");
  return c.get<cell_id_list_for_restart_c>();
}
const global_ran_node_id_c& pws_restart_ind_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const tai_list_for_restart_l& pws_restart_ind_ies_o::value_c::tai_list_for_restart() const
{
  assert_choice_type(types::tai_list_for_restart, type_, "Value");
  return c.get<tai_list_for_restart_l>();
}
const emergency_area_id_list_for_restart_l& pws_restart_ind_ies_o::value_c::emergency_area_id_list_for_restart() const
{
  assert_choice_type(types::emergency_area_id_list_for_restart, type_, "Value");
  return c.get<emergency_area_id_list_for_restart_l>();
}
void pws_restart_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cell_id_list_for_restart:
      j.write_fieldname("CellIDListForRestart");
      c.get<cell_id_list_for_restart_c>().to_json(j);
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::tai_list_for_restart:
      j.start_array("TAIListForRestart");
      for (const auto& e1 : c.get<tai_list_for_restart_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::emergency_area_id_list_for_restart:
      j.start_array("EmergencyAreaIDListForRestart");
      for (const auto& e1 : c.get<emergency_area_id_list_for_restart_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE pws_restart_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cell_id_list_for_restart:
      HANDLE_CODE(c.get<cell_id_list_for_restart_c>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::tai_list_for_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_list_for_restart_l>(), 1, 2048, true));
      break;
    case types::emergency_area_id_list_for_restart:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<emergency_area_id_list_for_restart_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_restart_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cell_id_list_for_restart:
      HANDLE_CODE(c.get<cell_id_list_for_restart_c>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::tai_list_for_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_list_for_restart_l>(), bref, 1, 2048, true));
      break;
    case types::emergency_area_id_list_for_restart:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<emergency_area_id_list_for_restart_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "pws_restart_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PagingIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t paging_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {115, 50, 103, 52, 118, 51, 11, 203, 202, 205, 208, 223, 222, 332, 342, 344};
  return map_enum_number(names, 16, idx, "id");
}
bool paging_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {115, 50, 103, 52, 118, 51, 11, 203, 202, 205, 208, 223, 222, 332, 342, 344};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e paging_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 115:
      return crit_e::ignore;
    case 50:
      return crit_e::ignore;
    case 103:
      return crit_e::ignore;
    case 52:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 51:
      return crit_e::ignore;
    case 11:
      return crit_e::ignore;
    case 203:
      return crit_e::ignore;
    case 202:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 208:
      return crit_e::ignore;
    case 223:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 332:
      return crit_e::ignore;
    case 342:
      return crit_e::ignore;
    case 344:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
paging_ies_o::value_c paging_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 115:
      ret.set(value_c::types::ue_paging_id);
      break;
    case 50:
      ret.set(value_c::types::paging_drx);
      break;
    case 103:
      ret.set(value_c::types::tai_list_for_paging);
      break;
    case 52:
      ret.set(value_c::types::paging_prio);
      break;
    case 118:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 51:
      ret.set(value_c::types::paging_origin);
      break;
    case 11:
      ret.set(value_c::types::assist_data_for_paging);
      break;
    case 203:
      ret.set(value_c::types::nb_iot_paging_e_drx_info);
      break;
    case 202:
      ret.set(value_c::types::nb_iot_paging_drx);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 208:
      ret.set(value_c::types::wus_assist_info);
      break;
    case 223:
      ret.set(value_c::types::eutra_paginge_drx_info);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 332:
      ret.set(value_c::types::nr_paginge_drx_info);
      break;
    case 342:
      ret.set(value_c::types::paging_cause);
      break;
    case 344:
      ret.set(value_c::types::pe_ip_sassist_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e paging_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 115:
      return presence_e::mandatory;
    case 50:
      return presence_e::optional;
    case 103:
      return presence_e::mandatory;
    case 52:
      return presence_e::optional;
    case 118:
      return presence_e::optional;
    case 51:
      return presence_e::optional;
    case 11:
      return presence_e::optional;
    case 203:
      return presence_e::optional;
    case 202:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 208:
      return presence_e::optional;
    case 223:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 332:
      return presence_e::optional;
    case 342:
      return presence_e::optional;
    case 344:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void paging_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_paging_id:
      c.destroy<ue_paging_id_c>();
      break;
    case types::tai_list_for_paging:
      c.destroy<tai_list_for_paging_l>();
      break;
    case types::ue_radio_cap_for_paging:
      c.destroy<ue_radio_cap_for_paging_s>();
      break;
    case types::assist_data_for_paging:
      c.destroy<assist_data_for_paging_s>();
      break;
    case types::nb_iot_paging_e_drx_info:
      c.destroy<nb_iot_paging_e_drx_info_s>();
      break;
    case types::wus_assist_info:
      c.destroy<wus_assist_info_s>();
      break;
    case types::eutra_paginge_drx_info:
      c.destroy<eutra_paginge_drx_info_s>();
      break;
    case types::nr_paginge_drx_info:
      c.destroy<nr_paginge_drx_info_s>();
      break;
    case types::pe_ip_sassist_info:
      c.destroy<pe_ip_sassist_info_s>();
      break;
    default:
      break;
  }
}
void paging_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_paging_id:
      c.init<ue_paging_id_c>();
      break;
    case types::paging_drx:
      break;
    case types::tai_list_for_paging:
      c.init<tai_list_for_paging_l>();
      break;
    case types::paging_prio:
      break;
    case types::ue_radio_cap_for_paging:
      c.init<ue_radio_cap_for_paging_s>();
      break;
    case types::paging_origin:
      break;
    case types::assist_data_for_paging:
      c.init<assist_data_for_paging_s>();
      break;
    case types::nb_iot_paging_e_drx_info:
      c.init<nb_iot_paging_e_drx_info_s>();
      break;
    case types::nb_iot_paging_drx:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::wus_assist_info:
      c.init<wus_assist_info_s>();
      break;
    case types::eutra_paginge_drx_info:
      c.init<eutra_paginge_drx_info_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::nr_paginge_drx_info:
      c.init<nr_paginge_drx_info_s>();
      break;
    case types::paging_cause:
      break;
    case types::pe_ip_sassist_info:
      c.init<pe_ip_sassist_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
}
paging_ies_o::value_c::value_c(const paging_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_paging_id:
      c.init(other.c.get<ue_paging_id_c>());
      break;
    case types::paging_drx:
      c.init(other.c.get<paging_drx_e>());
      break;
    case types::tai_list_for_paging:
      c.init(other.c.get<tai_list_for_paging_l>());
      break;
    case types::paging_prio:
      c.init(other.c.get<paging_prio_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.init(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::paging_origin:
      c.init(other.c.get<paging_origin_e>());
      break;
    case types::assist_data_for_paging:
      c.init(other.c.get<assist_data_for_paging_s>());
      break;
    case types::nb_iot_paging_e_drx_info:
      c.init(other.c.get<nb_iot_paging_e_drx_info_s>());
      break;
    case types::nb_iot_paging_drx:
      c.init(other.c.get<nb_iot_paging_drx_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::wus_assist_info:
      c.init(other.c.get<wus_assist_info_s>());
      break;
    case types::eutra_paginge_drx_info:
      c.init(other.c.get<eutra_paginge_drx_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::nr_paginge_drx_info:
      c.init(other.c.get<nr_paginge_drx_info_s>());
      break;
    case types::paging_cause:
      c.init(other.c.get<paging_cause_e>());
      break;
    case types::pe_ip_sassist_info:
      c.init(other.c.get<pe_ip_sassist_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
}
paging_ies_o::value_c& paging_ies_o::value_c::operator=(const paging_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_paging_id:
      c.set(other.c.get<ue_paging_id_c>());
      break;
    case types::paging_drx:
      c.set(other.c.get<paging_drx_e>());
      break;
    case types::tai_list_for_paging:
      c.set(other.c.get<tai_list_for_paging_l>());
      break;
    case types::paging_prio:
      c.set(other.c.get<paging_prio_e>());
      break;
    case types::ue_radio_cap_for_paging:
      c.set(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::paging_origin:
      c.set(other.c.get<paging_origin_e>());
      break;
    case types::assist_data_for_paging:
      c.set(other.c.get<assist_data_for_paging_s>());
      break;
    case types::nb_iot_paging_e_drx_info:
      c.set(other.c.get<nb_iot_paging_e_drx_info_s>());
      break;
    case types::nb_iot_paging_drx:
      c.set(other.c.get<nb_iot_paging_drx_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::wus_assist_info:
      c.set(other.c.get<wus_assist_info_s>());
      break;
    case types::eutra_paginge_drx_info:
      c.set(other.c.get<eutra_paginge_drx_info_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::nr_paginge_drx_info:
      c.set(other.c.get<nr_paginge_drx_info_s>());
      break;
    case types::paging_cause:
      c.set(other.c.get<paging_cause_e>());
      break;
    case types::pe_ip_sassist_info:
      c.set(other.c.get<pe_ip_sassist_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }

  return *this;
}
ue_paging_id_c& paging_ies_o::value_c::ue_paging_id()
{
  assert_choice_type(types::ue_paging_id, type_, "Value");
  return c.get<ue_paging_id_c>();
}
paging_drx_e& paging_ies_o::value_c::paging_drx()
{
  assert_choice_type(types::paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
tai_list_for_paging_l& paging_ies_o::value_c::tai_list_for_paging()
{
  assert_choice_type(types::tai_list_for_paging, type_, "Value");
  return c.get<tai_list_for_paging_l>();
}
paging_prio_e& paging_ies_o::value_c::paging_prio()
{
  assert_choice_type(types::paging_prio, type_, "Value");
  return c.get<paging_prio_e>();
}
ue_radio_cap_for_paging_s& paging_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
paging_origin_e& paging_ies_o::value_c::paging_origin()
{
  assert_choice_type(types::paging_origin, type_, "Value");
  return c.get<paging_origin_e>();
}
assist_data_for_paging_s& paging_ies_o::value_c::assist_data_for_paging()
{
  assert_choice_type(types::assist_data_for_paging, type_, "Value");
  return c.get<assist_data_for_paging_s>();
}
nb_iot_paging_e_drx_info_s& paging_ies_o::value_c::nb_iot_paging_e_drx_info()
{
  assert_choice_type(types::nb_iot_paging_e_drx_info, type_, "Value");
  return c.get<nb_iot_paging_e_drx_info_s>();
}
nb_iot_paging_drx_e& paging_ies_o::value_c::nb_iot_paging_drx()
{
  assert_choice_type(types::nb_iot_paging_drx, type_, "Value");
  return c.get<nb_iot_paging_drx_e>();
}
enhanced_coverage_restrict_e& paging_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
wus_assist_info_s& paging_ies_o::value_c::wus_assist_info()
{
  assert_choice_type(types::wus_assist_info, type_, "Value");
  return c.get<wus_assist_info_s>();
}
eutra_paginge_drx_info_s& paging_ies_o::value_c::eutra_paginge_drx_info()
{
  assert_choice_type(types::eutra_paginge_drx_info, type_, "Value");
  return c.get<eutra_paginge_drx_info_s>();
}
ce_mode_brestricted_e& paging_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
nr_paginge_drx_info_s& paging_ies_o::value_c::nr_paginge_drx_info()
{
  assert_choice_type(types::nr_paginge_drx_info, type_, "Value");
  return c.get<nr_paginge_drx_info_s>();
}
paging_cause_e& paging_ies_o::value_c::paging_cause()
{
  assert_choice_type(types::paging_cause, type_, "Value");
  return c.get<paging_cause_e>();
}
pe_ip_sassist_info_s& paging_ies_o::value_c::pe_ip_sassist_info()
{
  assert_choice_type(types::pe_ip_sassist_info, type_, "Value");
  return c.get<pe_ip_sassist_info_s>();
}
const ue_paging_id_c& paging_ies_o::value_c::ue_paging_id() const
{
  assert_choice_type(types::ue_paging_id, type_, "Value");
  return c.get<ue_paging_id_c>();
}
const paging_drx_e& paging_ies_o::value_c::paging_drx() const
{
  assert_choice_type(types::paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const tai_list_for_paging_l& paging_ies_o::value_c::tai_list_for_paging() const
{
  assert_choice_type(types::tai_list_for_paging, type_, "Value");
  return c.get<tai_list_for_paging_l>();
}
const paging_prio_e& paging_ies_o::value_c::paging_prio() const
{
  assert_choice_type(types::paging_prio, type_, "Value");
  return c.get<paging_prio_e>();
}
const ue_radio_cap_for_paging_s& paging_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
const paging_origin_e& paging_ies_o::value_c::paging_origin() const
{
  assert_choice_type(types::paging_origin, type_, "Value");
  return c.get<paging_origin_e>();
}
const assist_data_for_paging_s& paging_ies_o::value_c::assist_data_for_paging() const
{
  assert_choice_type(types::assist_data_for_paging, type_, "Value");
  return c.get<assist_data_for_paging_s>();
}
const nb_iot_paging_e_drx_info_s& paging_ies_o::value_c::nb_iot_paging_e_drx_info() const
{
  assert_choice_type(types::nb_iot_paging_e_drx_info, type_, "Value");
  return c.get<nb_iot_paging_e_drx_info_s>();
}
const nb_iot_paging_drx_e& paging_ies_o::value_c::nb_iot_paging_drx() const
{
  assert_choice_type(types::nb_iot_paging_drx, type_, "Value");
  return c.get<nb_iot_paging_drx_e>();
}
const enhanced_coverage_restrict_e& paging_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const wus_assist_info_s& paging_ies_o::value_c::wus_assist_info() const
{
  assert_choice_type(types::wus_assist_info, type_, "Value");
  return c.get<wus_assist_info_s>();
}
const eutra_paginge_drx_info_s& paging_ies_o::value_c::eutra_paginge_drx_info() const
{
  assert_choice_type(types::eutra_paginge_drx_info, type_, "Value");
  return c.get<eutra_paginge_drx_info_s>();
}
const ce_mode_brestricted_e& paging_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const nr_paginge_drx_info_s& paging_ies_o::value_c::nr_paginge_drx_info() const
{
  assert_choice_type(types::nr_paginge_drx_info, type_, "Value");
  return c.get<nr_paginge_drx_info_s>();
}
const paging_cause_e& paging_ies_o::value_c::paging_cause() const
{
  assert_choice_type(types::paging_cause, type_, "Value");
  return c.get<paging_cause_e>();
}
const pe_ip_sassist_info_s& paging_ies_o::value_c::pe_ip_sassist_info() const
{
  assert_choice_type(types::pe_ip_sassist_info, type_, "Value");
  return c.get<pe_ip_sassist_info_s>();
}
void paging_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_paging_id:
      j.write_fieldname("UEPagingIdentity");
      c.get<ue_paging_id_c>().to_json(j);
      break;
    case types::paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::tai_list_for_paging:
      j.start_array("TAIListForPaging");
      for (const auto& e1 : c.get<tai_list_for_paging_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::paging_prio:
      j.write_str("PagingPriority", c.get<paging_prio_e>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::paging_origin:
      j.write_str("PagingOrigin", "non-3gpp");
      break;
    case types::assist_data_for_paging:
      j.write_fieldname("AssistanceDataForPaging");
      c.get<assist_data_for_paging_s>().to_json(j);
      break;
    case types::nb_iot_paging_e_drx_info:
      j.write_fieldname("NB-IoT-Paging-eDRXInfo");
      c.get<nb_iot_paging_e_drx_info_s>().to_json(j);
      break;
    case types::nb_iot_paging_drx:
      j.write_str("NB-IoT-PagingDRX", c.get<nb_iot_paging_drx_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::wus_assist_info:
      j.write_fieldname("WUS-Assistance-Information");
      c.get<wus_assist_info_s>().to_json(j);
      break;
    case types::eutra_paginge_drx_info:
      j.write_fieldname("EUTRA-PagingeDRXInformation");
      c.get<eutra_paginge_drx_info_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::nr_paginge_drx_info:
      j.write_fieldname("NR-PagingeDRXInformation");
      c.get<nr_paginge_drx_info_s>().to_json(j);
      break;
    case types::paging_cause:
      j.write_str("PagingCause", "voice");
      break;
    case types::pe_ip_sassist_info:
      j.write_fieldname("PEIPSassistanceInformation");
      c.get<pe_ip_sassist_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE paging_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_paging_id:
      HANDLE_CODE(c.get<ue_paging_id_c>().pack(bref));
      break;
    case types::paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::tai_list_for_paging:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<tai_list_for_paging_l>(), 1, 16, true));
      break;
    case types::paging_prio:
      HANDLE_CODE(c.get<paging_prio_e>().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::paging_origin:
      HANDLE_CODE(c.get<paging_origin_e>().pack(bref));
      break;
    case types::assist_data_for_paging:
      HANDLE_CODE(c.get<assist_data_for_paging_s>().pack(bref));
      break;
    case types::nb_iot_paging_e_drx_info:
      HANDLE_CODE(c.get<nb_iot_paging_e_drx_info_s>().pack(bref));
      break;
    case types::nb_iot_paging_drx:
      HANDLE_CODE(c.get<nb_iot_paging_drx_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::wus_assist_info:
      HANDLE_CODE(c.get<wus_assist_info_s>().pack(bref));
      break;
    case types::eutra_paginge_drx_info:
      HANDLE_CODE(c.get<eutra_paginge_drx_info_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::nr_paginge_drx_info:
      HANDLE_CODE(c.get<nr_paginge_drx_info_s>().pack(bref));
      break;
    case types::paging_cause:
      HANDLE_CODE(c.get<paging_cause_e>().pack(bref));
      break;
    case types::pe_ip_sassist_info:
      HANDLE_CODE(c.get<pe_ip_sassist_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_paging_id:
      HANDLE_CODE(c.get<ue_paging_id_c>().unpack(bref));
      break;
    case types::paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::tai_list_for_paging:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<tai_list_for_paging_l>(), bref, 1, 16, true));
      break;
    case types::paging_prio:
      HANDLE_CODE(c.get<paging_prio_e>().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::paging_origin:
      HANDLE_CODE(c.get<paging_origin_e>().unpack(bref));
      break;
    case types::assist_data_for_paging:
      HANDLE_CODE(c.get<assist_data_for_paging_s>().unpack(bref));
      break;
    case types::nb_iot_paging_e_drx_info:
      HANDLE_CODE(c.get<nb_iot_paging_e_drx_info_s>().unpack(bref));
      break;
    case types::nb_iot_paging_drx:
      HANDLE_CODE(c.get<nb_iot_paging_drx_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::wus_assist_info:
      HANDLE_CODE(c.get<wus_assist_info_s>().unpack(bref));
      break;
    case types::eutra_paginge_drx_info:
      HANDLE_CODE(c.get<eutra_paginge_drx_info_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::nr_paginge_drx_info:
      HANDLE_CODE(c.get<nr_paginge_drx_info_s>().unpack(bref));
      break;
    case types::paging_cause:
      HANDLE_CODE(c.get<paging_cause_e>().unpack(bref));
      break;
    case types::pe_ip_sassist_info:
      HANDLE_CODE(c.get<pe_ip_sassist_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "paging_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PathSwitchRequestAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t path_switch_request_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  119, 93,  41,  77,  68,  0,   18,  91,  19,  146, 165, 177, 205, 206,
                                   209, 216, 215, 218, 217, 219, 222, 234, 264, 254, 326, 345, 346, 347, 359};
  return map_enum_number(names, 31, idx, "id");
}
bool path_switch_request_ack_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  119, 93,  41,  77,  68,  0,   18,  91,  19,  146, 165, 177, 205, 206,
                                   209, 216, 215, 218, 217, 219, 222, 234, 264, 254, 326, 345, 346, 347, 359};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_ack_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 119:
      return crit_e::reject;
    case 93:
      return crit_e::reject;
    case 41:
      return crit_e::reject;
    case 77:
      return crit_e::ignore;
    case 68:
      return crit_e::ignore;
    case 0:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 91:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    case 146:
      return crit_e::ignore;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 205:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 222:
      return crit_e::ignore;
    case 234:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 254:
      return crit_e::ignore;
    case 326:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    case 359:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_ack_ies_o::value_c path_switch_request_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 41:
      ret.set(value_c::types::new_security_context_ind);
      break;
    case 77:
      ret.set(value_c::types::pdu_session_res_switched_list);
      break;
    case 68:
      ret.set(value_c::types::pdu_session_res_released_list_ps_ack);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 146:
      ret.set(value_c::types::redirection_voice_fallback);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 205:
      ret.set(value_c::types::enhanced_coverage_restrict);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 222:
      ret.set(value_c::types::ce_mode_brestricted);
      break;
    case 234:
      ret.set(value_c::types::ue_up_c_iot_support);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 254:
      ret.set(value_c::types::management_based_mdt_plmn_list);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    case 359:
      ret.set(value_c::types::management_based_mdt_plmn_mod_list);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_ack_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 119:
      return presence_e::optional;
    case 93:
      return presence_e::mandatory;
    case 41:
      return presence_e::optional;
    case 77:
      return presence_e::mandatory;
    case 68:
      return presence_e::optional;
    case 0:
      return presence_e::mandatory;
    case 18:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 146:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 205:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 222:
      return presence_e::optional;
    case 234:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 254:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    case 359:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_ack_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::pdu_session_res_switched_list:
      c.destroy<pdu_session_res_switched_list_l>();
      break;
    case types::pdu_session_res_released_list_ps_ack:
      c.destroy<pdu_session_res_released_list_ps_ack_l>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.destroy<core_network_assist_info_for_inactive_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.destroy<cn_assisted_ran_tuning_s>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.destroy<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.destroy<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.destroy<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.destroy<pc5_qos_params_s>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::management_based_mdt_plmn_list:
      c.destroy<mdt_plmn_list_l>();
      break;
    case types::time_sync_assist_info:
      c.destroy<time_sync_assist_info_s>();
      break;
    case types::five_g_pro_se_authorized:
      c.destroy<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.destroy<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.destroy<mdt_plmn_mod_list_l>();
      break;
    default:
      break;
  }
}
void path_switch_request_ack_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::new_security_context_ind:
      break;
    case types::pdu_session_res_switched_list:
      c.init<pdu_session_res_switched_list_l>();
      break;
    case types::pdu_session_res_released_list_ps_ack:
      c.init<pdu_session_res_released_list_ps_ack_l>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.init<core_network_assist_info_for_inactive_s>();
      break;
    case types::rrc_inactive_transition_report_request:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::redirection_voice_fallback:
      break;
    case types::cn_assisted_ran_tuning:
      c.init<cn_assisted_ran_tuning_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::enhanced_coverage_restrict:
      break;
    case types::extended_connected_time:
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.init<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.init<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.init<pc5_qos_params_s>();
      break;
    case types::ce_mode_brestricted:
      break;
    case types::ue_up_c_iot_support:
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::management_based_mdt_plmn_list:
      c.init<mdt_plmn_list_l>();
      break;
    case types::time_sync_assist_info:
      c.init<time_sync_assist_info_s>();
      break;
    case types::five_g_pro_se_authorized:
      c.init<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.init<mdt_plmn_mod_list_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
}
path_switch_request_ack_ies_o::value_c::value_c(const path_switch_request_ack_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::new_security_context_ind:
      c.init(other.c.get<new_security_context_ind_e>());
      break;
    case types::pdu_session_res_switched_list:
      c.init(other.c.get<pdu_session_res_switched_list_l>());
      break;
    case types::pdu_session_res_released_list_ps_ack:
      c.init(other.c.get<pdu_session_res_released_list_ps_ack_l>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.init(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.init(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::redirection_voice_fallback:
      c.init(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::cn_assisted_ran_tuning:
      c.init(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.init(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.init(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.init(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.init(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.init(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.init(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::management_based_mdt_plmn_list:
      c.init(other.c.get<mdt_plmn_list_l>());
      break;
    case types::time_sync_assist_info:
      c.init(other.c.get<time_sync_assist_info_s>());
      break;
    case types::five_g_pro_se_authorized:
      c.init(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.init(other.c.get<mdt_plmn_mod_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
}
path_switch_request_ack_ies_o::value_c&
path_switch_request_ack_ies_o::value_c::operator=(const path_switch_request_ack_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::new_security_context_ind:
      c.set(other.c.get<new_security_context_ind_e>());
      break;
    case types::pdu_session_res_switched_list:
      c.set(other.c.get<pdu_session_res_switched_list_l>());
      break;
    case types::pdu_session_res_released_list_ps_ack:
      c.set(other.c.get<pdu_session_res_released_list_ps_ack_l>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.set(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.set(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::redirection_voice_fallback:
      c.set(other.c.get<redirection_voice_fallback_e>());
      break;
    case types::cn_assisted_ran_tuning:
      c.set(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::enhanced_coverage_restrict:
      c.set(other.c.get<enhanced_coverage_restrict_e>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::nr_v2x_services_authorized:
      c.set(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.set(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.set(other.c.get<pc5_qos_params_s>());
      break;
    case types::ce_mode_brestricted:
      c.set(other.c.get<ce_mode_brestricted_e>());
      break;
    case types::ue_up_c_iot_support:
      c.set(other.c.get<ue_up_c_iot_support_e>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::management_based_mdt_plmn_list:
      c.set(other.c.get<mdt_plmn_list_l>());
      break;
    case types::time_sync_assist_info:
      c.set(other.c.get<time_sync_assist_info_s>());
      break;
    case types::five_g_pro_se_authorized:
      c.set(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.set(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.set(other.c.get<mdt_plmn_mod_list_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }

  return *this;
}
uint64_t& path_switch_request_ack_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& path_switch_request_ack_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ue_security_cap_s& path_switch_request_ack_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
security_context_s& path_switch_request_ack_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
new_security_context_ind_e& path_switch_request_ack_ies_o::value_c::new_security_context_ind()
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
pdu_session_res_switched_list_l& path_switch_request_ack_ies_o::value_c::pdu_session_res_switched_list()
{
  assert_choice_type(types::pdu_session_res_switched_list, type_, "Value");
  return c.get<pdu_session_res_switched_list_l>();
}
pdu_session_res_released_list_ps_ack_l& path_switch_request_ack_ies_o::value_c::pdu_session_res_released_list_ps_ack()
{
  assert_choice_type(types::pdu_session_res_released_list_ps_ack, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_ack_l>();
}
allowed_nssai_l& path_switch_request_ack_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
core_network_assist_info_for_inactive_s& path_switch_request_ack_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
rrc_inactive_transition_report_request_e&
path_switch_request_ack_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
crit_diagnostics_s& path_switch_request_ack_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
redirection_voice_fallback_e& path_switch_request_ack_ies_o::value_c::redirection_voice_fallback()
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
cn_assisted_ran_tuning_s& path_switch_request_ack_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& path_switch_request_ack_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
enhanced_coverage_restrict_e& path_switch_request_ack_ies_o::value_c::enhanced_coverage_restrict()
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
uint16_t& path_switch_request_ack_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
ue_diff_info_s& path_switch_request_ack_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
nr_v2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
ce_mode_brestricted_e& path_switch_request_ack_ies_o::value_c::ce_mode_brestricted()
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
ue_up_c_iot_support_e& path_switch_request_ack_ies_o::value_c::ue_up_c_iot_support()
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
unbounded_octstring<true>& path_switch_request_ack_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
mdt_plmn_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_list()
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
time_sync_assist_info_s& path_switch_request_ack_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
five_g_pro_se_authorized_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
mdt_plmn_mod_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_mod_list()
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
const uint64_t& path_switch_request_ack_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& path_switch_request_ack_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ue_security_cap_s& path_switch_request_ack_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const security_context_s& path_switch_request_ack_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const new_security_context_ind_e& path_switch_request_ack_ies_o::value_c::new_security_context_ind() const
{
  assert_choice_type(types::new_security_context_ind, type_, "Value");
  return c.get<new_security_context_ind_e>();
}
const pdu_session_res_switched_list_l& path_switch_request_ack_ies_o::value_c::pdu_session_res_switched_list() const
{
  assert_choice_type(types::pdu_session_res_switched_list, type_, "Value");
  return c.get<pdu_session_res_switched_list_l>();
}
const pdu_session_res_released_list_ps_ack_l&
path_switch_request_ack_ies_o::value_c::pdu_session_res_released_list_ps_ack() const
{
  assert_choice_type(types::pdu_session_res_released_list_ps_ack, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_ack_l>();
}
const allowed_nssai_l& path_switch_request_ack_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const core_network_assist_info_for_inactive_s&
path_switch_request_ack_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const rrc_inactive_transition_report_request_e&
path_switch_request_ack_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const crit_diagnostics_s& path_switch_request_ack_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const redirection_voice_fallback_e& path_switch_request_ack_ies_o::value_c::redirection_voice_fallback() const
{
  assert_choice_type(types::redirection_voice_fallback, type_, "Value");
  return c.get<redirection_voice_fallback_e>();
}
const cn_assisted_ran_tuning_s& path_switch_request_ack_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& path_switch_request_ack_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const enhanced_coverage_restrict_e& path_switch_request_ack_ies_o::value_c::enhanced_coverage_restrict() const
{
  assert_choice_type(types::enhanced_coverage_restrict, type_, "Value");
  return c.get<enhanced_coverage_restrict_e>();
}
const uint16_t& path_switch_request_ack_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const ue_diff_info_s& path_switch_request_ack_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const nr_v2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& path_switch_request_ack_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& path_switch_request_ack_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s&
path_switch_request_ack_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const ce_mode_brestricted_e& path_switch_request_ack_ies_o::value_c::ce_mode_brestricted() const
{
  assert_choice_type(types::ce_mode_brestricted, type_, "Value");
  return c.get<ce_mode_brestricted_e>();
}
const ue_up_c_iot_support_e& path_switch_request_ack_ies_o::value_c::ue_up_c_iot_support() const
{
  assert_choice_type(types::ue_up_c_iot_support, type_, "Value");
  return c.get<ue_up_c_iot_support_e>();
}
const unbounded_octstring<true>& path_switch_request_ack_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const mdt_plmn_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_list, type_, "Value");
  return c.get<mdt_plmn_list_l>();
}
const time_sync_assist_info_s& path_switch_request_ack_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const five_g_pro_se_authorized_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
path_switch_request_ack_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& path_switch_request_ack_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const mdt_plmn_mod_list_l& path_switch_request_ack_ies_o::value_c::management_based_mdt_plmn_mod_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
void path_switch_request_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::new_security_context_ind:
      j.write_str("NewSecurityContextInd", "true");
      break;
    case types::pdu_session_res_switched_list:
      j.start_array("PDUSessionResourceSwitchedList");
      for (const auto& e1 : c.get<pdu_session_res_switched_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_released_list_ps_ack:
      j.start_array("PDUSessionResourceReleasedListPSAck");
      for (const auto& e1 : c.get<pdu_session_res_released_list_ps_ack_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::redirection_voice_fallback:
      j.write_str("RedirectionVoiceFallback", c.get<redirection_voice_fallback_e>().to_string());
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::enhanced_coverage_restrict:
      j.write_str("Enhanced-CoverageRestriction", "restricted");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ce_mode_brestricted:
      j.write_str("CEmodeBrestricted", c.get<ce_mode_brestricted_e>().to_string());
      break;
    case types::ue_up_c_iot_support:
      j.write_str("UE-UP-CIoT-Support", "supported");
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::management_based_mdt_plmn_list:
      j.start_array("MDTPLMNList");
      for (const auto& e1 : c.get<mdt_plmn_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    case types::management_based_mdt_plmn_mod_list:
      j.start_array("MDTPLMNModificationList");
      for (const auto& e1 : c.get<mdt_plmn_mod_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().pack(bref));
      break;
    case types::pdu_session_res_switched_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_switched_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_released_list_ps_ack:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_ps_ack_l>(), 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().pack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_list_l>(), 1, 16, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_mod_list_l>(), 0, 16, true));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::new_security_context_ind:
      HANDLE_CODE(c.get<new_security_context_ind_e>().unpack(bref));
      break;
    case types::pdu_session_res_switched_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_switched_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_released_list_ps_ack:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_ps_ack_l>(), bref, 1, 256, true));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::redirection_voice_fallback:
      HANDLE_CODE(c.get<redirection_voice_fallback_e>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::enhanced_coverage_restrict:
      HANDLE_CODE(c.get<enhanced_coverage_restrict_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ce_mode_brestricted:
      HANDLE_CODE(c.get<ce_mode_brestricted_e>().unpack(bref));
      break;
    case types::ue_up_c_iot_support:
      HANDLE_CODE(c.get<ue_up_c_iot_support_e>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_list_l>(), bref, 1, 16, true));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_mod_list_l>(), bref, 0, 16, true));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ack_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PathSwitchRequestFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t path_switch_request_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 69, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool path_switch_request_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 69, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 69:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_fail_ies_o::value_c path_switch_request_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 69:
      ret.set(value_c::types::pdu_session_res_released_list_ps_fail);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 69:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_released_list_ps_fail:
      c.destroy<pdu_session_res_released_list_ps_fail_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void path_switch_request_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_released_list_ps_fail:
      c.init<pdu_session_res_released_list_ps_fail_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
}
path_switch_request_fail_ies_o::value_c::value_c(const path_switch_request_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_ps_fail:
      c.init(other.c.get<pdu_session_res_released_list_ps_fail_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
}
path_switch_request_fail_ies_o::value_c&
path_switch_request_fail_ies_o::value_c::operator=(const path_switch_request_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_ps_fail:
      c.set(other.c.get<pdu_session_res_released_list_ps_fail_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& path_switch_request_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& path_switch_request_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_released_list_ps_fail_l&
path_switch_request_fail_ies_o::value_c::pdu_session_res_released_list_ps_fail()
{
  assert_choice_type(types::pdu_session_res_released_list_ps_fail, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_fail_l>();
}
crit_diagnostics_s& path_switch_request_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& path_switch_request_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& path_switch_request_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_released_list_ps_fail_l&
path_switch_request_fail_ies_o::value_c::pdu_session_res_released_list_ps_fail() const
{
  assert_choice_type(types::pdu_session_res_released_list_ps_fail, type_, "Value");
  return c.get<pdu_session_res_released_list_ps_fail_l>();
}
const crit_diagnostics_s& path_switch_request_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void path_switch_request_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_released_list_ps_fail:
      j.start_array("PDUSessionResourceReleasedListPSFail");
      for (const auto& e1 : c.get<pdu_session_res_released_list_ps_fail_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_ps_fail:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_released_list_ps_fail_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_released_list_ps_fail:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_released_list_ps_fail_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// PathSwitchRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t path_switch_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 100, 121, 119, 76, 57, 237, 333};
  return map_enum_number(names, 8, idx, "id");
}
bool path_switch_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 100, 121, 119, 76, 57, 237, 333};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e path_switch_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 100:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 119:
      return crit_e::ignore;
    case 76:
      return crit_e::reject;
    case 57:
      return crit_e::ignore;
    case 237:
      return crit_e::ignore;
    case 333:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
path_switch_request_ies_o::value_c path_switch_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 100:
      ret.set(value_c::types::source_amf_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 76:
      ret.set(value_c::types::pdu_session_res_to_be_switched_dl_list);
      break;
    case 57:
      ret.set(value_c::types::pdu_session_res_failed_to_setup_list_ps_req);
      break;
    case 237:
      ret.set(value_c::types::rrc_resume_cause);
      break;
    case 333:
      ret.set(value_c::types::red_cap_ind);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e path_switch_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 100:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 119:
      return presence_e::mandatory;
    case 76:
      return presence_e::mandatory;
    case 57:
      return presence_e::optional;
    case 237:
      return presence_e::optional;
    case 333:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void path_switch_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      c.destroy<pdu_session_res_to_be_switched_dl_list_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      c.destroy<pdu_session_res_failed_to_setup_list_ps_req_l>();
      break;
    default:
      break;
  }
}
void path_switch_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      break;
    case types::source_amf_ue_ngap_id:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      c.init<pdu_session_res_to_be_switched_dl_list_l>();
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      c.init<pdu_session_res_failed_to_setup_list_ps_req_l>();
      break;
    case types::rrc_resume_cause:
      break;
    case types::red_cap_ind:
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
}
path_switch_request_ies_o::value_c::value_c(const path_switch_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::source_amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      c.init(other.c.get<pdu_session_res_to_be_switched_dl_list_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      c.init(other.c.get<pdu_session_res_failed_to_setup_list_ps_req_l>());
      break;
    case types::rrc_resume_cause:
      c.init(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::red_cap_ind:
      c.init(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
}
path_switch_request_ies_o::value_c&
path_switch_request_ies_o::value_c::operator=(const path_switch_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::source_amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      c.set(other.c.get<pdu_session_res_to_be_switched_dl_list_l>());
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      c.set(other.c.get<pdu_session_res_failed_to_setup_list_ps_req_l>());
      break;
    case types::rrc_resume_cause:
      c.set(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::red_cap_ind:
      c.set(other.c.get<red_cap_ind_e>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& path_switch_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& path_switch_request_ies_o::value_c::source_amf_ue_ngap_id()
{
  assert_choice_type(types::source_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& path_switch_request_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
ue_security_cap_s& path_switch_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
pdu_session_res_to_be_switched_dl_list_l& path_switch_request_ies_o::value_c::pdu_session_res_to_be_switched_dl_list()
{
  assert_choice_type(types::pdu_session_res_to_be_switched_dl_list, type_, "Value");
  return c.get<pdu_session_res_to_be_switched_dl_list_l>();
}
pdu_session_res_failed_to_setup_list_ps_req_l&
path_switch_request_ies_o::value_c::pdu_session_res_failed_to_setup_list_ps_req()
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ps_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ps_req_l>();
}
rrc_establishment_cause_e& path_switch_request_ies_o::value_c::rrc_resume_cause()
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
red_cap_ind_e& path_switch_request_ies_o::value_c::red_cap_ind()
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
const uint64_t& path_switch_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& path_switch_request_ies_o::value_c::source_amf_ue_ngap_id() const
{
  assert_choice_type(types::source_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& path_switch_request_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const ue_security_cap_s& path_switch_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const pdu_session_res_to_be_switched_dl_list_l&
path_switch_request_ies_o::value_c::pdu_session_res_to_be_switched_dl_list() const
{
  assert_choice_type(types::pdu_session_res_to_be_switched_dl_list, type_, "Value");
  return c.get<pdu_session_res_to_be_switched_dl_list_l>();
}
const pdu_session_res_failed_to_setup_list_ps_req_l&
path_switch_request_ies_o::value_c::pdu_session_res_failed_to_setup_list_ps_req() const
{
  assert_choice_type(types::pdu_session_res_failed_to_setup_list_ps_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_setup_list_ps_req_l>();
}
const rrc_establishment_cause_e& path_switch_request_ies_o::value_c::rrc_resume_cause() const
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const red_cap_ind_e& path_switch_request_ies_o::value_c::red_cap_ind() const
{
  assert_choice_type(types::red_cap_ind, type_, "Value");
  return c.get<red_cap_ind_e>();
}
void path_switch_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::source_amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      j.start_array("PDUSessionResourceToBeSwitchedDLList");
      for (const auto& e1 : c.get<pdu_session_res_to_be_switched_dl_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      j.start_array("PDUSessionResourceFailedToSetupListPSReq");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_setup_list_ps_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::rrc_resume_cause:
      j.write_str("RRCEstablishmentCause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::red_cap_ind:
      j.write_str("RedCapIndication", "redcap");
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE path_switch_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::source_amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_to_be_switched_dl_list_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_setup_list_ps_req_l>(), 1, 256, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::source_amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::pdu_session_res_to_be_switched_dl_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_to_be_switched_dl_list_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_setup_list_ps_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_setup_list_ps_req_l>(), bref, 1, 256, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::red_cap_ind:
      HANDLE_CODE(c.get<red_cap_ind_e>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "path_switch_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RANCPRelocationIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cp_relocation_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 26, 25, 213, 211};
  return map_enum_number(names, 5, idx, "id");
}
bool ran_cp_relocation_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 26, 25, 213, 211};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ran_cp_relocation_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 26:
      return crit_e::reject;
    case 25:
      return crit_e::ignore;
    case 213:
      return crit_e::ignore;
    case 211:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ran_cp_relocation_ind_ies_o::value_c ran_cp_relocation_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    case 25:
      ret.set(value_c::types::eutra_cgi);
      break;
    case 213:
      ret.set(value_c::types::tai);
      break;
    case 211:
      ret.set(value_c::types::ul_cp_security_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cp_relocation_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 26:
      return presence_e::mandatory;
    case 25:
      return presence_e::mandatory;
    case 213:
      return presence_e::mandatory;
    case 211:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ran_cp_relocation_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    case types::eutra_cgi:
      c.destroy<eutra_cgi_s>();
      break;
    case types::tai:
      c.destroy<tai_s>();
      break;
    case types::ul_cp_security_info:
      c.destroy<ul_cp_security_info_s>();
      break;
    default:
      break;
  }
}
void ran_cp_relocation_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      break;
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::eutra_cgi:
      c.init<eutra_cgi_s>();
      break;
    case types::tai:
      c.init<tai_s>();
      break;
    case types::ul_cp_security_info:
      c.init<ul_cp_security_info_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }
}
ran_cp_relocation_ind_ies_o::value_c::value_c(const ran_cp_relocation_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::eutra_cgi:
      c.init(other.c.get<eutra_cgi_s>());
      break;
    case types::tai:
      c.init(other.c.get<tai_s>());
      break;
    case types::ul_cp_security_info:
      c.init(other.c.get<ul_cp_security_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }
}
ran_cp_relocation_ind_ies_o::value_c&
ran_cp_relocation_ind_ies_o::value_c::operator=(const ran_cp_relocation_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::eutra_cgi:
      c.set(other.c.get<eutra_cgi_s>());
      break;
    case types::tai:
      c.set(other.c.get<tai_s>());
      break;
    case types::ul_cp_security_info:
      c.set(other.c.get<ul_cp_security_info_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& ran_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
five_g_s_tmsi_s& ran_cp_relocation_ind_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
eutra_cgi_s& ran_cp_relocation_ind_ies_o::value_c::eutra_cgi()
{
  assert_choice_type(types::eutra_cgi, type_, "Value");
  return c.get<eutra_cgi_s>();
}
tai_s& ran_cp_relocation_ind_ies_o::value_c::tai()
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
ul_cp_security_info_s& ran_cp_relocation_ind_ies_o::value_c::ul_cp_security_info()
{
  assert_choice_type(types::ul_cp_security_info, type_, "Value");
  return c.get<ul_cp_security_info_s>();
}
const uint64_t& ran_cp_relocation_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const five_g_s_tmsi_s& ran_cp_relocation_ind_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const eutra_cgi_s& ran_cp_relocation_ind_ies_o::value_c::eutra_cgi() const
{
  assert_choice_type(types::eutra_cgi, type_, "Value");
  return c.get<eutra_cgi_s>();
}
const tai_s& ran_cp_relocation_ind_ies_o::value_c::tai() const
{
  assert_choice_type(types::tai, type_, "Value");
  return c.get<tai_s>();
}
const ul_cp_security_info_s& ran_cp_relocation_ind_ies_o::value_c::ul_cp_security_info() const
{
  assert_choice_type(types::ul_cp_security_info, type_, "Value");
  return c.get<ul_cp_security_info_s>();
}
void ran_cp_relocation_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::eutra_cgi:
      j.write_fieldname("EUTRA-CGI");
      c.get<eutra_cgi_s>().to_json(j);
      break;
    case types::tai:
      j.write_fieldname("TAI");
      c.get<tai_s>().to_json(j);
      break;
    case types::ul_cp_security_info:
      j.write_fieldname("UL-CP-SecurityInformation");
      c.get<ul_cp_security_info_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ran_cp_relocation_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::eutra_cgi:
      HANDLE_CODE(c.get<eutra_cgi_s>().pack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().pack(bref));
      break;
    case types::ul_cp_security_info:
      HANDLE_CODE(c.get<ul_cp_security_info_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cp_relocation_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::eutra_cgi:
      HANDLE_CODE(c.get<eutra_cgi_s>().unpack(bref));
      break;
    case types::tai:
      HANDLE_CODE(c.get<tai_s>().unpack(bref));
      break;
    case types::ul_cp_security_info:
      HANDLE_CODE(c.get<ul_cp_security_info_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cp_relocation_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RANConfigurationUpdateAcknowledgeIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cfg_upd_ack_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {19};
  return map_enum_number(names, 1, idx, "id");
}
bool ran_cfg_upd_ack_ies_o::is_id_valid(const uint32_t& id)
{
  return 19 == id;
}
crit_e ran_cfg_upd_ack_ies_o::get_crit(const uint32_t& id)
{
  if (id == 19) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ran_cfg_upd_ack_ies_o::value_c ran_cfg_upd_ack_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 19) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cfg_upd_ack_ies_o::get_presence(const uint32_t& id)
{
  if (id == 19) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ran_cfg_upd_ack_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("CriticalityDiagnostics");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE ran_cfg_upd_ack_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_ack_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// RANConfigurationUpdateFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cfg_upd_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {15, 107, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ran_cfg_upd_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {15, 107, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ran_cfg_upd_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 15:
      return crit_e::ignore;
    case 107:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ran_cfg_upd_fail_ies_o::value_c ran_cfg_upd_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 107:
      ret.set(value_c::types::time_to_wait);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cfg_upd_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 15:
      return presence_e::mandatory;
    case 107:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ran_cfg_upd_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ran_cfg_upd_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::cause:
      c.init<cause_c>();
      break;
    case types::time_to_wait:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }
}
ran_cfg_upd_fail_ies_o::value_c::value_c(const ran_cfg_upd_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.init(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }
}
ran_cfg_upd_fail_ies_o::value_c&
ran_cfg_upd_fail_ies_o::value_c::operator=(const ran_cfg_upd_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::time_to_wait:
      c.set(other.c.get<time_to_wait_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }

  return *this;
}
cause_c& ran_cfg_upd_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
time_to_wait_e& ran_cfg_upd_fail_ies_o::value_c::time_to_wait()
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
crit_diagnostics_s& ran_cfg_upd_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const cause_c& ran_cfg_upd_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const time_to_wait_e& ran_cfg_upd_fail_ies_o::value_c::time_to_wait() const
{
  assert_choice_type(types::time_to_wait, type_, "Value");
  return c.get<time_to_wait_e>();
}
const crit_diagnostics_s& ran_cfg_upd_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ran_cfg_upd_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::time_to_wait:
      j.write_str("TimeToWait", c.get<time_to_wait_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ran_cfg_upd_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::time_to_wait:
      HANDLE_CODE(c.get<time_to_wait_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RANConfigurationUpdateIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ran_cfg_upd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {82, 102, 21, 27, 167, 204, 273};
  return map_enum_number(names, 7, idx, "id");
}
bool ran_cfg_upd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {82, 102, 21, 27, 167, 204, 273};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ran_cfg_upd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 82:
      return crit_e::ignore;
    case 102:
      return crit_e::reject;
    case 21:
      return crit_e::ignore;
    case 27:
      return crit_e::ignore;
    case 167:
      return crit_e::reject;
    case 204:
      return crit_e::ignore;
    case 273:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ran_cfg_upd_ies_o::value_c ran_cfg_upd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 82:
      ret.set(value_c::types::ran_node_name);
      break;
    case 102:
      ret.set(value_c::types::supported_ta_list);
      break;
    case 21:
      ret.set(value_c::types::default_paging_drx);
      break;
    case 27:
      ret.set(value_c::types::global_ran_node_id);
      break;
    case 167:
      ret.set(value_c::types::ngran_tnl_assoc_to_rem_list);
      break;
    case 204:
      ret.set(value_c::types::nb_iot_default_paging_drx);
      break;
    case 273:
      ret.set(value_c::types::extended_ran_node_name);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ran_cfg_upd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 82:
      return presence_e::optional;
    case 102:
      return presence_e::optional;
    case 21:
      return presence_e::optional;
    case 27:
      return presence_e::optional;
    case 167:
      return presence_e::optional;
    case 204:
      return presence_e::optional;
    case 273:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ran_cfg_upd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ran_node_name:
      c.destroy<printable_string<1, 150, true, true>>();
      break;
    case types::supported_ta_list:
      c.destroy<supported_ta_list_l>();
      break;
    case types::global_ran_node_id:
      c.destroy<global_ran_node_id_c>();
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      c.destroy<ngran_tnl_assoc_to_rem_list_l>();
      break;
    case types::extended_ran_node_name:
      c.destroy<extended_ran_node_name_s>();
      break;
    default:
      break;
  }
}
void ran_cfg_upd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_node_name:
      c.init<printable_string<1, 150, true, true>>();
      break;
    case types::supported_ta_list:
      c.init<supported_ta_list_l>();
      break;
    case types::default_paging_drx:
      break;
    case types::global_ran_node_id:
      c.init<global_ran_node_id_c>();
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      c.init<ngran_tnl_assoc_to_rem_list_l>();
      break;
    case types::nb_iot_default_paging_drx:
      break;
    case types::extended_ran_node_name:
      c.init<extended_ran_node_name_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }
}
ran_cfg_upd_ies_o::value_c::value_c(const ran_cfg_upd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_node_name:
      c.init(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::supported_ta_list:
      c.init(other.c.get<supported_ta_list_l>());
      break;
    case types::default_paging_drx:
      c.init(other.c.get<paging_drx_e>());
      break;
    case types::global_ran_node_id:
      c.init(other.c.get<global_ran_node_id_c>());
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      c.init(other.c.get<ngran_tnl_assoc_to_rem_list_l>());
      break;
    case types::nb_iot_default_paging_drx:
      c.init(other.c.get<nb_iot_default_paging_drx_e>());
      break;
    case types::extended_ran_node_name:
      c.init(other.c.get<extended_ran_node_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }
}
ran_cfg_upd_ies_o::value_c& ran_cfg_upd_ies_o::value_c::operator=(const ran_cfg_upd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_node_name:
      c.set(other.c.get<printable_string<1, 150, true, true>>());
      break;
    case types::supported_ta_list:
      c.set(other.c.get<supported_ta_list_l>());
      break;
    case types::default_paging_drx:
      c.set(other.c.get<paging_drx_e>());
      break;
    case types::global_ran_node_id:
      c.set(other.c.get<global_ran_node_id_c>());
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      c.set(other.c.get<ngran_tnl_assoc_to_rem_list_l>());
      break;
    case types::nb_iot_default_paging_drx:
      c.set(other.c.get<nb_iot_default_paging_drx_e>());
      break;
    case types::extended_ran_node_name:
      c.set(other.c.get<extended_ran_node_name_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }

  return *this;
}
printable_string<1, 150, true, true>& ran_cfg_upd_ies_o::value_c::ran_node_name()
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
supported_ta_list_l& ran_cfg_upd_ies_o::value_c::supported_ta_list()
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
paging_drx_e& ran_cfg_upd_ies_o::value_c::default_paging_drx()
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
global_ran_node_id_c& ran_cfg_upd_ies_o::value_c::global_ran_node_id()
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
ngran_tnl_assoc_to_rem_list_l& ran_cfg_upd_ies_o::value_c::ngran_tnl_assoc_to_rem_list()
{
  assert_choice_type(types::ngran_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<ngran_tnl_assoc_to_rem_list_l>();
}
nb_iot_default_paging_drx_e& ran_cfg_upd_ies_o::value_c::nb_iot_default_paging_drx()
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
extended_ran_node_name_s& ran_cfg_upd_ies_o::value_c::extended_ran_node_name()
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
const printable_string<1, 150, true, true>& ran_cfg_upd_ies_o::value_c::ran_node_name() const
{
  assert_choice_type(types::ran_node_name, type_, "Value");
  return c.get<printable_string<1, 150, true, true>>();
}
const supported_ta_list_l& ran_cfg_upd_ies_o::value_c::supported_ta_list() const
{
  assert_choice_type(types::supported_ta_list, type_, "Value");
  return c.get<supported_ta_list_l>();
}
const paging_drx_e& ran_cfg_upd_ies_o::value_c::default_paging_drx() const
{
  assert_choice_type(types::default_paging_drx, type_, "Value");
  return c.get<paging_drx_e>();
}
const global_ran_node_id_c& ran_cfg_upd_ies_o::value_c::global_ran_node_id() const
{
  assert_choice_type(types::global_ran_node_id, type_, "Value");
  return c.get<global_ran_node_id_c>();
}
const ngran_tnl_assoc_to_rem_list_l& ran_cfg_upd_ies_o::value_c::ngran_tnl_assoc_to_rem_list() const
{
  assert_choice_type(types::ngran_tnl_assoc_to_rem_list, type_, "Value");
  return c.get<ngran_tnl_assoc_to_rem_list_l>();
}
const nb_iot_default_paging_drx_e& ran_cfg_upd_ies_o::value_c::nb_iot_default_paging_drx() const
{
  assert_choice_type(types::nb_iot_default_paging_drx, type_, "Value");
  return c.get<nb_iot_default_paging_drx_e>();
}
const extended_ran_node_name_s& ran_cfg_upd_ies_o::value_c::extended_ran_node_name() const
{
  assert_choice_type(types::extended_ran_node_name, type_, "Value");
  return c.get<extended_ran_node_name_s>();
}
void ran_cfg_upd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_node_name:
      j.write_str("PrintableString", c.get<printable_string<1, 150, true, true>>().to_string());
      break;
    case types::supported_ta_list:
      j.start_array("SupportedTAList");
      for (const auto& e1 : c.get<supported_ta_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::default_paging_drx:
      j.write_str("PagingDRX", c.get<paging_drx_e>().to_string());
      break;
    case types::global_ran_node_id:
      j.write_fieldname("GlobalRANNodeID");
      c.get<global_ran_node_id_c>().to_json(j);
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      j.start_array("NGRAN-TNLAssociationToRemoveList");
      for (const auto& e1 : c.get<ngran_tnl_assoc_to_rem_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::nb_iot_default_paging_drx:
      j.write_str("NB-IoT-DefaultPagingDRX", c.get<nb_iot_default_paging_drx_e>().to_string());
      break;
    case types::extended_ran_node_name:
      j.write_fieldname("Extended-RANNodeName");
      c.get<extended_ran_node_name_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ran_cfg_upd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().pack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<supported_ta_list_l>(), 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().pack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().pack(bref));
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ngran_tnl_assoc_to_rem_list_l>(), 1, 32, true));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().pack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_node_name:
      HANDLE_CODE((c.get<printable_string<1, 150, true, true>>().unpack(bref)));
      break;
    case types::supported_ta_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<supported_ta_list_l>(), bref, 1, 256, true));
      break;
    case types::default_paging_drx:
      HANDLE_CODE(c.get<paging_drx_e>().unpack(bref));
      break;
    case types::global_ran_node_id:
      HANDLE_CODE(c.get<global_ran_node_id_c>().unpack(bref));
      break;
    case types::ngran_tnl_assoc_to_rem_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ngran_tnl_assoc_to_rem_list_l>(), bref, 1, 32, true));
      break;
    case types::nb_iot_default_paging_drx:
      HANDLE_CODE(c.get<nb_iot_default_paging_drx_e>().unpack(bref));
      break;
    case types::extended_ran_node_name:
      HANDLE_CODE(c.get<extended_ran_node_name_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ran_cfg_upd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RRCInactiveTransitionReportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t rrc_inactive_transition_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 92, 121};
  return map_enum_number(names, 4, idx, "id");
}
bool rrc_inactive_transition_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 92, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e rrc_inactive_transition_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 92:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
rrc_inactive_transition_report_ies_o::value_c rrc_inactive_transition_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 92:
      ret.set(value_c::types::rrc_state);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e rrc_inactive_transition_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 92:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void rrc_inactive_transition_report_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void rrc_inactive_transition_report_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::rrc_state:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }
}
rrc_inactive_transition_report_ies_o::value_c::value_c(const rrc_inactive_transition_report_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::rrc_state:
      c.init(other.c.get<rrc_state_e>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }
}
rrc_inactive_transition_report_ies_o::value_c&
rrc_inactive_transition_report_ies_o::value_c::operator=(const rrc_inactive_transition_report_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::rrc_state:
      c.set(other.c.get<rrc_state_e>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }

  return *this;
}
uint64_t& rrc_inactive_transition_report_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& rrc_inactive_transition_report_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_state_e& rrc_inactive_transition_report_ies_o::value_c::rrc_state()
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
user_location_info_c& rrc_inactive_transition_report_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& rrc_inactive_transition_report_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& rrc_inactive_transition_report_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_state_e& rrc_inactive_transition_report_ies_o::value_c::rrc_state() const
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
const user_location_info_c& rrc_inactive_transition_report_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void rrc_inactive_transition_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::rrc_state:
      j.write_str("RRCState", c.get<rrc_state_e>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE rrc_inactive_transition_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_inactive_transition_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "rrc_inactive_transition_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RerouteNASRequest-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t reroute_nas_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {85, 10, 42, 3, 0, 171};
  return map_enum_number(names, 6, idx, "id");
}
bool reroute_nas_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {85, 10, 42, 3, 0, 171};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e reroute_nas_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 85:
      return crit_e::reject;
    case 10:
      return crit_e::ignore;
    case 42:
      return crit_e::reject;
    case 3:
      return crit_e::reject;
    case 0:
      return crit_e::reject;
    case 171:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
reroute_nas_request_ies_o::value_c reroute_nas_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 42:
      ret.set(value_c::types::ngap_msg);
      break;
    case 3:
      ret.set(value_c::types::amf_set_id);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 171:
      ret.set(value_c::types::source_to_target_amf_info_reroute);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e reroute_nas_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 85:
      return presence_e::mandatory;
    case 10:
      return presence_e::optional;
    case 42:
      return presence_e::mandatory;
    case 3:
      return presence_e::mandatory;
    case 0:
      return presence_e::optional;
    case 171:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void reroute_nas_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ngap_msg:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::amf_set_id:
      c.destroy<fixed_bitstring<10, false, true>>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::source_to_target_amf_info_reroute:
      c.destroy<source_to_target_amf_info_reroute_s>();
      break;
    default:
      break;
  }
}
void reroute_nas_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ran_ue_ngap_id:
      break;
    case types::amf_ue_ngap_id:
      break;
    case types::ngap_msg:
      c.init<unbounded_octstring<true>>();
      break;
    case types::amf_set_id:
      c.init<fixed_bitstring<10, false, true>>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::source_to_target_amf_info_reroute:
      c.init<source_to_target_amf_info_reroute_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
}
reroute_nas_request_ies_o::value_c::value_c(const reroute_nas_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ngap_msg:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::amf_set_id:
      c.init(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::source_to_target_amf_info_reroute:
      c.init(other.c.get<source_to_target_amf_info_reroute_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
}
reroute_nas_request_ies_o::value_c&
reroute_nas_request_ies_o::value_c::operator=(const reroute_nas_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ngap_msg:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::amf_set_id:
      c.set(other.c.get<fixed_bitstring<10, false, true>>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::source_to_target_amf_info_reroute:
      c.set(other.c.get<source_to_target_amf_info_reroute_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& reroute_nas_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& reroute_nas_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& reroute_nas_request_ies_o::value_c::ngap_msg()
{
  assert_choice_type(types::ngap_msg, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
fixed_bitstring<10, false, true>& reroute_nas_request_ies_o::value_c::amf_set_id()
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
allowed_nssai_l& reroute_nas_request_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
source_to_target_amf_info_reroute_s& reroute_nas_request_ies_o::value_c::source_to_target_amf_info_reroute()
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
const uint64_t& reroute_nas_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& reroute_nas_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& reroute_nas_request_ies_o::value_c::ngap_msg() const
{
  assert_choice_type(types::ngap_msg, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const fixed_bitstring<10, false, true>& reroute_nas_request_ies_o::value_c::amf_set_id() const
{
  assert_choice_type(types::amf_set_id, type_, "Value");
  return c.get<fixed_bitstring<10, false, true>>();
}
const allowed_nssai_l& reroute_nas_request_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const source_to_target_amf_info_reroute_s& reroute_nas_request_ies_o::value_c::source_to_target_amf_info_reroute() const
{
  assert_choice_type(types::source_to_target_amf_info_reroute, type_, "Value");
  return c.get<source_to_target_amf_info_reroute_s>();
}
void reroute_nas_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ngap_msg:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::amf_set_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<10, false, true>>().to_string());
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::source_to_target_amf_info_reroute:
      j.write_fieldname("SourceToTarget-AMFInformationReroute");
      c.get<source_to_target_amf_info_reroute_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE reroute_nas_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ngap_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().pack(bref)));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE reroute_nas_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ngap_msg:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::amf_set_id:
      HANDLE_CODE((c.get<fixed_bitstring<10, false, true>>().unpack(bref)));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::source_to_target_amf_info_reroute:
      HANDLE_CODE(c.get<source_to_target_amf_info_reroute_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "reroute_nas_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// RetrieveUEInformationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t retrieve_ue_info_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {26};
  return map_enum_number(names, 1, idx, "id");
}
bool retrieve_ue_info_ies_o::is_id_valid(const uint32_t& id)
{
  return 26 == id;
}
crit_e retrieve_ue_info_ies_o::get_crit(const uint32_t& id)
{
  if (id == 26) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
retrieve_ue_info_ies_o::value_c retrieve_ue_info_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 26) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e retrieve_ue_info_ies_o::get_presence(const uint32_t& id)
{
  if (id == 26) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void retrieve_ue_info_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("FiveG-S-TMSI");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE retrieve_ue_info_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE retrieve_ue_info_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// SecondaryRATDataUsageReportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t secondary_rat_data_usage_report_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 142, 143, 121};
  return map_enum_number(names, 5, idx, "id");
}
bool secondary_rat_data_usage_report_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 142, 143, 121};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e secondary_rat_data_usage_report_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 142:
      return crit_e::ignore;
    case 143:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
secondary_rat_data_usage_report_ies_o::value_c secondary_rat_data_usage_report_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 142:
      ret.set(value_c::types::pdu_session_res_secondary_rat_usage_list);
      break;
    case 143:
      ret.set(value_c::types::ho_flag);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e secondary_rat_data_usage_report_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 142:
      return presence_e::mandatory;
    case 143:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void secondary_rat_data_usage_report_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_secondary_rat_usage_list:
      c.destroy<pdu_session_res_secondary_rat_usage_list_l>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    default:
      break;
  }
}
void secondary_rat_data_usage_report_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      c.init<pdu_session_res_secondary_rat_usage_list_l>();
      break;
    case types::ho_flag:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
}
secondary_rat_data_usage_report_ies_o::value_c::value_c(const secondary_rat_data_usage_report_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      c.init(other.c.get<pdu_session_res_secondary_rat_usage_list_l>());
      break;
    case types::ho_flag:
      c.init(other.c.get<ho_flag_e>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
}
secondary_rat_data_usage_report_ies_o::value_c&
secondary_rat_data_usage_report_ies_o::value_c::operator=(const secondary_rat_data_usage_report_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      c.set(other.c.get<pdu_session_res_secondary_rat_usage_list_l>());
      break;
    case types::ho_flag:
      c.set(other.c.get<ho_flag_e>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }

  return *this;
}
uint64_t& secondary_rat_data_usage_report_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& secondary_rat_data_usage_report_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_secondary_rat_usage_list_l&
secondary_rat_data_usage_report_ies_o::value_c::pdu_session_res_secondary_rat_usage_list()
{
  assert_choice_type(types::pdu_session_res_secondary_rat_usage_list, type_, "Value");
  return c.get<pdu_session_res_secondary_rat_usage_list_l>();
}
ho_flag_e& secondary_rat_data_usage_report_ies_o::value_c::ho_flag()
{
  assert_choice_type(types::ho_flag, type_, "Value");
  return c.get<ho_flag_e>();
}
user_location_info_c& secondary_rat_data_usage_report_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const uint64_t& secondary_rat_data_usage_report_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& secondary_rat_data_usage_report_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_secondary_rat_usage_list_l&
secondary_rat_data_usage_report_ies_o::value_c::pdu_session_res_secondary_rat_usage_list() const
{
  assert_choice_type(types::pdu_session_res_secondary_rat_usage_list, type_, "Value");
  return c.get<pdu_session_res_secondary_rat_usage_list_l>();
}
const ho_flag_e& secondary_rat_data_usage_report_ies_o::value_c::ho_flag() const
{
  assert_choice_type(types::ho_flag, type_, "Value");
  return c.get<ho_flag_e>();
}
const user_location_info_c& secondary_rat_data_usage_report_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
void secondary_rat_data_usage_report_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      j.start_array("PDUSessionResourceSecondaryRATUsageList");
      for (const auto& e1 : c.get<pdu_session_res_secondary_rat_usage_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ho_flag:
      j.write_str("HandoverFlag", "handover-preparation");
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE secondary_rat_data_usage_report_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_secondary_rat_usage_list_l>(), 1, 256, true));
      break;
    case types::ho_flag:
      HANDLE_CODE(c.get<ho_flag_e>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_secondary_rat_usage_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_secondary_rat_usage_list_l>(), bref, 1, 256, true));
      break;
    case types::ho_flag:
      HANDLE_CODE(c.get<ho_flag_e>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "secondary_rat_data_usage_report_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// TraceFailureIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t trace_fail_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 44, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool trace_fail_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 44, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_fail_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 44:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trace_fail_ind_ies_o::value_c trace_fail_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 44:
      ret.set(value_c::types::ngran_trace_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trace_fail_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 44:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void trace_fail_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ngran_trace_id:
      c.destroy<fixed_octstring<8, true>>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void trace_fail_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ngran_trace_id:
      c.init<fixed_octstring<8, true>>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
}
trace_fail_ind_ies_o::value_c::value_c(const trace_fail_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.init(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
}
trace_fail_ind_ies_o::value_c& trace_fail_ind_ies_o::value_c::operator=(const trace_fail_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      c.set(other.c.get<fixed_octstring<8, true>>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& trace_fail_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& trace_fail_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
fixed_octstring<8, true>& trace_fail_ind_ies_o::value_c::ngran_trace_id()
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
cause_c& trace_fail_ind_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& trace_fail_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& trace_fail_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const fixed_octstring<8, true>& trace_fail_ind_ies_o::value_c::ngran_trace_id() const
{
  assert_choice_type(types::ngran_trace_id, type_, "Value");
  return c.get<fixed_octstring<8, true>>();
}
const cause_c& trace_fail_ind_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void trace_fail_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ngran_trace_id:
      j.write_str("OCTET STRING", c.get<fixed_octstring<8, true>>().to_string());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_fail_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().pack(bref)));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_fail_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ngran_trace_id:
      HANDLE_CODE((c.get<fixed_octstring<8, true>>().unpack(bref)));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_fail_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// TraceStartIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t trace_start_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 108};
  return map_enum_number(names, 3, idx, "id");
}
bool trace_start_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 108};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e trace_start_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 108:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
trace_start_ies_o::value_c trace_start_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 108:
      ret.set(value_c::types::trace_activation);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e trace_start_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 108:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void trace_start_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::trace_activation:
      c.destroy<trace_activation_s>();
      break;
    default:
      break;
  }
}
void trace_start_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::trace_activation:
      c.init<trace_activation_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
}
trace_start_ies_o::value_c::value_c(const trace_start_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::trace_activation:
      c.init(other.c.get<trace_activation_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
}
trace_start_ies_o::value_c& trace_start_ies_o::value_c::operator=(const trace_start_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::trace_activation:
      c.set(other.c.get<trace_activation_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }

  return *this;
}
uint64_t& trace_start_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& trace_start_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
trace_activation_s& trace_start_ies_o::value_c::trace_activation()
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
const uint64_t& trace_start_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& trace_start_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const trace_activation_s& trace_start_ies_o::value_c::trace_activation() const
{
  assert_choice_type(types::trace_activation, type_, "Value");
  return c.get<trace_activation_s>();
}
void trace_start_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::trace_activation:
      j.write_fieldname("TraceActivation");
      c.get<trace_activation_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE trace_start_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_start_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::trace_activation:
      HANDLE_CODE(c.get<trace_activation_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "trace_start_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextModificationFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_mod_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_mod_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_mod_fail_ies_o::value_c ue_context_mod_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_mod_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
}
ue_context_mod_fail_ies_o::value_c::value_c(const ue_context_mod_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
}
ue_context_mod_fail_ies_o::value_c&
ue_context_mod_fail_ies_o::value_c::operator=(const ue_context_mod_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_mod_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ue_context_mod_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_mod_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_mod_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_mod_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ue_context_mod_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_mod_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_mod_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextModificationRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_mod_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10,  85,  83,  94,  31,  110, 119, 18,  24,  40,  91,  162, 165, 177, 199,
                                   216, 215, 218, 217, 219, 264, 238, 326, 328, 329, 335, 359, 345, 346, 347};
  return map_enum_number(names, 30, idx, "id");
}
bool ue_context_mod_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10,  85,  83,  94,  31,  110, 119, 18,  24,  40,  91,  162, 165, 177, 199,
                                   216, 215, 218, 217, 219, 264, 238, 326, 328, 329, 335, 359, 345, 346, 347};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 83:
      return crit_e::ignore;
    case 94:
      return crit_e::reject;
    case 31:
      return crit_e::ignore;
    case 110:
      return crit_e::ignore;
    case 119:
      return crit_e::reject;
    case 18:
      return crit_e::ignore;
    case 24:
      return crit_e::reject;
    case 40:
      return crit_e::reject;
    case 91:
      return crit_e::ignore;
    case 162:
      return crit_e::reject;
    case 165:
      return crit_e::ignore;
    case 177:
      return crit_e::ignore;
    case 199:
      return crit_e::ignore;
    case 216:
      return crit_e::ignore;
    case 215:
      return crit_e::ignore;
    case 218:
      return crit_e::ignore;
    case 217:
      return crit_e::ignore;
    case 219:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    case 238:
      return crit_e::ignore;
    case 326:
      return crit_e::ignore;
    case 328:
      return crit_e::ignore;
    case 329:
      return crit_e::ignore;
    case 335:
      return crit_e::ignore;
    case 359:
      return crit_e::ignore;
    case 345:
      return crit_e::ignore;
    case 346:
      return crit_e::ignore;
    case 347:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_mod_request_ies_o::value_c ue_context_mod_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 83:
      ret.set(value_c::types::ran_paging_prio);
      break;
    case 94:
      ret.set(value_c::types::security_key);
      break;
    case 31:
      ret.set(value_c::types::idx_to_rfsp);
      break;
    case 110:
      ret.set(value_c::types::ue_aggr_max_bit_rate);
      break;
    case 119:
      ret.set(value_c::types::ue_security_cap);
      break;
    case 18:
      ret.set(value_c::types::core_network_assist_info_for_inactive);
      break;
    case 24:
      ret.set(value_c::types::emergency_fallback_ind);
      break;
    case 40:
      ret.set(value_c::types::new_amf_ue_ngap_id);
      break;
    case 91:
      ret.set(value_c::types::rrc_inactive_transition_report_request);
      break;
    case 162:
      ret.set(value_c::types::new_guami);
      break;
    case 165:
      ret.set(value_c::types::cn_assisted_ran_tuning);
      break;
    case 177:
      ret.set(value_c::types::srvcc_operation_possible);
      break;
    case 199:
      ret.set(value_c::types::iab_authorized);
      break;
    case 216:
      ret.set(value_c::types::nr_v2x_services_authorized);
      break;
    case 215:
      ret.set(value_c::types::ltev2x_services_authorized);
      break;
    case 218:
      ret.set(value_c::types::nr_ue_sidelink_aggr_max_bitrate);
      break;
    case 217:
      ret.set(value_c::types::lte_ue_sidelink_aggr_max_bitrate);
      break;
    case 219:
      ret.set(value_c::types::pc5_qos_params);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 238:
      ret.set(value_c::types::rg_level_wireline_access_characteristics);
      break;
    case 326:
      ret.set(value_c::types::time_sync_assist_info);
      break;
    case 328:
      ret.set(value_c::types::q_mcc_onfig_info);
      break;
    case 329:
      ret.set(value_c::types::qmc_deactivation);
      break;
    case 335:
      ret.set(value_c::types::ue_slice_max_bit_rate_list);
      break;
    case 359:
      ret.set(value_c::types::management_based_mdt_plmn_mod_list);
      break;
    case 345:
      ret.set(value_c::types::five_g_pro_se_authorized);
      break;
    case 346:
      ret.set(value_c::types::five_g_pro_se_ue_pc5_aggr_max_bit_rate);
      break;
    case 347:
      ret.set(value_c::types::five_g_pro_se_pc5_qos_params);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 83:
      return presence_e::optional;
    case 94:
      return presence_e::optional;
    case 31:
      return presence_e::optional;
    case 110:
      return presence_e::optional;
    case 119:
      return presence_e::optional;
    case 18:
      return presence_e::optional;
    case 24:
      return presence_e::optional;
    case 40:
      return presence_e::optional;
    case 91:
      return presence_e::optional;
    case 162:
      return presence_e::optional;
    case 165:
      return presence_e::optional;
    case 177:
      return presence_e::optional;
    case 199:
      return presence_e::optional;
    case 216:
      return presence_e::optional;
    case 215:
      return presence_e::optional;
    case 218:
      return presence_e::optional;
    case 217:
      return presence_e::optional;
    case 219:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    case 238:
      return presence_e::optional;
    case 326:
      return presence_e::optional;
    case 328:
      return presence_e::optional;
    case 329:
      return presence_e::optional;
    case 335:
      return presence_e::optional;
    case 359:
      return presence_e::optional;
    case 345:
      return presence_e::optional;
    case 346:
      return presence_e::optional;
    case 347:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::security_key:
      c.destroy<fixed_bitstring<256, false, true>>();
      break;
    case types::ue_aggr_max_bit_rate:
      c.destroy<ue_aggr_max_bit_rate_s>();
      break;
    case types::ue_security_cap:
      c.destroy<ue_security_cap_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.destroy<core_network_assist_info_for_inactive_s>();
      break;
    case types::emergency_fallback_ind:
      c.destroy<emergency_fallback_ind_s>();
      break;
    case types::new_guami:
      c.destroy<guami_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.destroy<cn_assisted_ran_tuning_s>();
      break;
    case types::nr_v2x_services_authorized:
      c.destroy<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.destroy<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.destroy<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.destroy<pc5_qos_params_s>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::rg_level_wireline_access_characteristics:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.destroy<time_sync_assist_info_s>();
      break;
    case types::q_mcc_onfig_info:
      c.destroy<q_mcc_onfig_info_s>();
      break;
    case types::qmc_deactivation:
      c.destroy<qmc_deactivation_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.destroy<ue_slice_max_bit_rate_list_l>();
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.destroy<mdt_plmn_mod_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.destroy<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.destroy<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.destroy<five_g_pro_se_pc5_qos_params_s>();
      break;
    default:
      break;
  }
}
void ue_context_mod_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_paging_prio:
      break;
    case types::security_key:
      c.init<fixed_bitstring<256, false, true>>();
      break;
    case types::idx_to_rfsp:
      break;
    case types::ue_aggr_max_bit_rate:
      c.init<ue_aggr_max_bit_rate_s>();
      break;
    case types::ue_security_cap:
      c.init<ue_security_cap_s>();
      break;
    case types::core_network_assist_info_for_inactive:
      c.init<core_network_assist_info_for_inactive_s>();
      break;
    case types::emergency_fallback_ind:
      c.init<emergency_fallback_ind_s>();
      break;
    case types::new_amf_ue_ngap_id:
      break;
    case types::rrc_inactive_transition_report_request:
      break;
    case types::new_guami:
      c.init<guami_s>();
      break;
    case types::cn_assisted_ran_tuning:
      c.init<cn_assisted_ran_tuning_s>();
      break;
    case types::srvcc_operation_possible:
      break;
    case types::iab_authorized:
      break;
    case types::nr_v2x_services_authorized:
      c.init<nr_v2x_services_authorized_s>();
      break;
    case types::ltev2x_services_authorized:
      c.init<ltev2x_services_authorized_s>();
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init<lte_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::pc5_qos_params:
      c.init<pc5_qos_params_s>();
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::rg_level_wireline_access_characteristics:
      c.init<unbounded_octstring<true>>();
      break;
    case types::time_sync_assist_info:
      c.init<time_sync_assist_info_s>();
      break;
    case types::q_mcc_onfig_info:
      c.init<q_mcc_onfig_info_s>();
      break;
    case types::qmc_deactivation:
      c.init<qmc_deactivation_s>();
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init<ue_slice_max_bit_rate_list_l>();
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.init<mdt_plmn_mod_list_l>();
      break;
    case types::five_g_pro_se_authorized:
      c.init<five_g_pro_se_authorized_s>();
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init<nr_ue_sidelink_aggr_max_bitrate_s>();
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init<five_g_pro_se_pc5_qos_params_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
}
ue_context_mod_request_ies_o::value_c::value_c(const ue_context_mod_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::security_key:
      c.init(other.c.get<fixed_bitstring<256, false, true>>());
      break;
    case types::idx_to_rfsp:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.init(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::ue_security_cap:
      c.init(other.c.get<ue_security_cap_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.init(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::emergency_fallback_ind:
      c.init(other.c.get<emergency_fallback_ind_s>());
      break;
    case types::new_amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.init(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::new_guami:
      c.init(other.c.get<guami_s>());
      break;
    case types::cn_assisted_ran_tuning:
      c.init(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.init(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.init(other.c.get<iab_authorized_e>());
      break;
    case types::nr_v2x_services_authorized:
      c.init(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.init(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.init(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.init(other.c.get<pc5_qos_params_s>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::rg_level_wireline_access_characteristics:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::time_sync_assist_info:
      c.init(other.c.get<time_sync_assist_info_s>());
      break;
    case types::q_mcc_onfig_info:
      c.init(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::qmc_deactivation:
      c.init(other.c.get<qmc_deactivation_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.init(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.init(other.c.get<mdt_plmn_mod_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.init(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.init(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.init(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
}
ue_context_mod_request_ies_o::value_c&
ue_context_mod_request_ies_o::value_c::operator=(const ue_context_mod_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::security_key:
      c.set(other.c.get<fixed_bitstring<256, false, true>>());
      break;
    case types::idx_to_rfsp:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      c.set(other.c.get<ue_aggr_max_bit_rate_s>());
      break;
    case types::ue_security_cap:
      c.set(other.c.get<ue_security_cap_s>());
      break;
    case types::core_network_assist_info_for_inactive:
      c.set(other.c.get<core_network_assist_info_for_inactive_s>());
      break;
    case types::emergency_fallback_ind:
      c.set(other.c.get<emergency_fallback_ind_s>());
      break;
    case types::new_amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::rrc_inactive_transition_report_request:
      c.set(other.c.get<rrc_inactive_transition_report_request_e>());
      break;
    case types::new_guami:
      c.set(other.c.get<guami_s>());
      break;
    case types::cn_assisted_ran_tuning:
      c.set(other.c.get<cn_assisted_ran_tuning_s>());
      break;
    case types::srvcc_operation_possible:
      c.set(other.c.get<srvcc_operation_possible_e>());
      break;
    case types::iab_authorized:
      c.set(other.c.get<iab_authorized_e>());
      break;
    case types::nr_v2x_services_authorized:
      c.set(other.c.get<nr_v2x_services_authorized_s>());
      break;
    case types::ltev2x_services_authorized:
      c.set(other.c.get<ltev2x_services_authorized_s>());
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      c.set(other.c.get<lte_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::pc5_qos_params:
      c.set(other.c.get<pc5_qos_params_s>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::rg_level_wireline_access_characteristics:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::time_sync_assist_info:
      c.set(other.c.get<time_sync_assist_info_s>());
      break;
    case types::q_mcc_onfig_info:
      c.set(other.c.get<q_mcc_onfig_info_s>());
      break;
    case types::qmc_deactivation:
      c.set(other.c.get<qmc_deactivation_s>());
      break;
    case types::ue_slice_max_bit_rate_list:
      c.set(other.c.get<ue_slice_max_bit_rate_list_l>());
      break;
    case types::management_based_mdt_plmn_mod_list:
      c.set(other.c.get<mdt_plmn_mod_list_l>());
      break;
    case types::five_g_pro_se_authorized:
      c.set(other.c.get<five_g_pro_se_authorized_s>());
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      c.set(other.c.get<nr_ue_sidelink_aggr_max_bitrate_s>());
      break;
    case types::five_g_pro_se_pc5_qos_params:
      c.set(other.c.get<five_g_pro_se_pc5_qos_params_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_mod_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint16_t& ue_context_mod_request_ies_o::value_c::ran_paging_prio()
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
fixed_bitstring<256, false, true>& ue_context_mod_request_ies_o::value_c::security_key()
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
uint16_t& ue_context_mod_request_ies_o::value_c::idx_to_rfsp()
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
ue_aggr_max_bit_rate_s& ue_context_mod_request_ies_o::value_c::ue_aggr_max_bit_rate()
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
ue_security_cap_s& ue_context_mod_request_ies_o::value_c::ue_security_cap()
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
core_network_assist_info_for_inactive_s& ue_context_mod_request_ies_o::value_c::core_network_assist_info_for_inactive()
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
emergency_fallback_ind_s& ue_context_mod_request_ies_o::value_c::emergency_fallback_ind()
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
uint64_t& ue_context_mod_request_ies_o::value_c::new_amf_ue_ngap_id()
{
  assert_choice_type(types::new_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_inactive_transition_report_request_e&
ue_context_mod_request_ies_o::value_c::rrc_inactive_transition_report_request()
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
guami_s& ue_context_mod_request_ies_o::value_c::new_guami()
{
  assert_choice_type(types::new_guami, type_, "Value");
  return c.get<guami_s>();
}
cn_assisted_ran_tuning_s& ue_context_mod_request_ies_o::value_c::cn_assisted_ran_tuning()
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
srvcc_operation_possible_e& ue_context_mod_request_ies_o::value_c::srvcc_operation_possible()
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
iab_authorized_e& ue_context_mod_request_ies_o::value_c::iab_authorized()
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
nr_v2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::nr_v2x_services_authorized()
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
ltev2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::ltev2x_services_authorized()
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
lte_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate()
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::pc5_qos_params()
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::rg_level_wireline_access_characteristics()
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
time_sync_assist_info_s& ue_context_mod_request_ies_o::value_c::time_sync_assist_info()
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
q_mcc_onfig_info_s& ue_context_mod_request_ies_o::value_c::q_mcc_onfig_info()
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
qmc_deactivation_s& ue_context_mod_request_ies_o::value_c::qmc_deactivation()
{
  assert_choice_type(types::qmc_deactivation, type_, "Value");
  return c.get<qmc_deactivation_s>();
}
ue_slice_max_bit_rate_list_l& ue_context_mod_request_ies_o::value_c::ue_slice_max_bit_rate_list()
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
mdt_plmn_mod_list_l& ue_context_mod_request_ies_o::value_c::management_based_mdt_plmn_mod_list()
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
five_g_pro_se_authorized_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_authorized()
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
nr_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate()
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
five_g_pro_se_pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_pc5_qos_params()
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
const uint64_t& ue_context_mod_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_mod_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint16_t& ue_context_mod_request_ies_o::value_c::ran_paging_prio() const
{
  assert_choice_type(types::ran_paging_prio, type_, "Value");
  return c.get<uint16_t>();
}
const fixed_bitstring<256, false, true>& ue_context_mod_request_ies_o::value_c::security_key() const
{
  assert_choice_type(types::security_key, type_, "Value");
  return c.get<fixed_bitstring<256, false, true>>();
}
const uint16_t& ue_context_mod_request_ies_o::value_c::idx_to_rfsp() const
{
  assert_choice_type(types::idx_to_rfsp, type_, "Value");
  return c.get<uint16_t>();
}
const ue_aggr_max_bit_rate_s& ue_context_mod_request_ies_o::value_c::ue_aggr_max_bit_rate() const
{
  assert_choice_type(types::ue_aggr_max_bit_rate, type_, "Value");
  return c.get<ue_aggr_max_bit_rate_s>();
}
const ue_security_cap_s& ue_context_mod_request_ies_o::value_c::ue_security_cap() const
{
  assert_choice_type(types::ue_security_cap, type_, "Value");
  return c.get<ue_security_cap_s>();
}
const core_network_assist_info_for_inactive_s&
ue_context_mod_request_ies_o::value_c::core_network_assist_info_for_inactive() const
{
  assert_choice_type(types::core_network_assist_info_for_inactive, type_, "Value");
  return c.get<core_network_assist_info_for_inactive_s>();
}
const emergency_fallback_ind_s& ue_context_mod_request_ies_o::value_c::emergency_fallback_ind() const
{
  assert_choice_type(types::emergency_fallback_ind, type_, "Value");
  return c.get<emergency_fallback_ind_s>();
}
const uint64_t& ue_context_mod_request_ies_o::value_c::new_amf_ue_ngap_id() const
{
  assert_choice_type(types::new_amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_inactive_transition_report_request_e&
ue_context_mod_request_ies_o::value_c::rrc_inactive_transition_report_request() const
{
  assert_choice_type(types::rrc_inactive_transition_report_request, type_, "Value");
  return c.get<rrc_inactive_transition_report_request_e>();
}
const guami_s& ue_context_mod_request_ies_o::value_c::new_guami() const
{
  assert_choice_type(types::new_guami, type_, "Value");
  return c.get<guami_s>();
}
const cn_assisted_ran_tuning_s& ue_context_mod_request_ies_o::value_c::cn_assisted_ran_tuning() const
{
  assert_choice_type(types::cn_assisted_ran_tuning, type_, "Value");
  return c.get<cn_assisted_ran_tuning_s>();
}
const srvcc_operation_possible_e& ue_context_mod_request_ies_o::value_c::srvcc_operation_possible() const
{
  assert_choice_type(types::srvcc_operation_possible, type_, "Value");
  return c.get<srvcc_operation_possible_e>();
}
const iab_authorized_e& ue_context_mod_request_ies_o::value_c::iab_authorized() const
{
  assert_choice_type(types::iab_authorized, type_, "Value");
  return c.get<iab_authorized_e>();
}
const nr_v2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::nr_v2x_services_authorized() const
{
  assert_choice_type(types::nr_v2x_services_authorized, type_, "Value");
  return c.get<nr_v2x_services_authorized_s>();
}
const ltev2x_services_authorized_s& ue_context_mod_request_ies_o::value_c::ltev2x_services_authorized() const
{
  assert_choice_type(types::ltev2x_services_authorized, type_, "Value");
  return c.get<ltev2x_services_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s& ue_context_mod_request_ies_o::value_c::nr_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::nr_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const lte_ue_sidelink_aggr_max_bitrate_s&
ue_context_mod_request_ies_o::value_c::lte_ue_sidelink_aggr_max_bitrate() const
{
  assert_choice_type(types::lte_ue_sidelink_aggr_max_bitrate, type_, "Value");
  return c.get<lte_ue_sidelink_aggr_max_bitrate_s>();
}
const pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::pc5_qos_params() const
{
  assert_choice_type(types::pc5_qos_params, type_, "Value");
  return c.get<pc5_qos_params_s>();
}
const unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ue_context_mod_request_ies_o::value_c::rg_level_wireline_access_characteristics() const
{
  assert_choice_type(types::rg_level_wireline_access_characteristics, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const time_sync_assist_info_s& ue_context_mod_request_ies_o::value_c::time_sync_assist_info() const
{
  assert_choice_type(types::time_sync_assist_info, type_, "Value");
  return c.get<time_sync_assist_info_s>();
}
const q_mcc_onfig_info_s& ue_context_mod_request_ies_o::value_c::q_mcc_onfig_info() const
{
  assert_choice_type(types::q_mcc_onfig_info, type_, "Value");
  return c.get<q_mcc_onfig_info_s>();
}
const qmc_deactivation_s& ue_context_mod_request_ies_o::value_c::qmc_deactivation() const
{
  assert_choice_type(types::qmc_deactivation, type_, "Value");
  return c.get<qmc_deactivation_s>();
}
const ue_slice_max_bit_rate_list_l& ue_context_mod_request_ies_o::value_c::ue_slice_max_bit_rate_list() const
{
  assert_choice_type(types::ue_slice_max_bit_rate_list, type_, "Value");
  return c.get<ue_slice_max_bit_rate_list_l>();
}
const mdt_plmn_mod_list_l& ue_context_mod_request_ies_o::value_c::management_based_mdt_plmn_mod_list() const
{
  assert_choice_type(types::management_based_mdt_plmn_mod_list, type_, "Value");
  return c.get<mdt_plmn_mod_list_l>();
}
const five_g_pro_se_authorized_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_authorized() const
{
  assert_choice_type(types::five_g_pro_se_authorized, type_, "Value");
  return c.get<five_g_pro_se_authorized_s>();
}
const nr_ue_sidelink_aggr_max_bitrate_s&
ue_context_mod_request_ies_o::value_c::five_g_pro_se_ue_pc5_aggr_max_bit_rate() const
{
  assert_choice_type(types::five_g_pro_se_ue_pc5_aggr_max_bit_rate, type_, "Value");
  return c.get<nr_ue_sidelink_aggr_max_bitrate_s>();
}
const five_g_pro_se_pc5_qos_params_s& ue_context_mod_request_ies_o::value_c::five_g_pro_se_pc5_qos_params() const
{
  assert_choice_type(types::five_g_pro_se_pc5_qos_params, type_, "Value");
  return c.get<five_g_pro_se_pc5_qos_params_s>();
}
void ue_context_mod_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_paging_prio:
      j.write_int("INTEGER (1..256)", c.get<uint16_t>());
      break;
    case types::security_key:
      j.write_str("BIT STRING", c.get<fixed_bitstring<256, false, true>>().to_string());
      break;
    case types::idx_to_rfsp:
      j.write_int("INTEGER (1..256,...)", c.get<uint16_t>());
      break;
    case types::ue_aggr_max_bit_rate:
      j.write_fieldname("UEAggregateMaximumBitRate");
      c.get<ue_aggr_max_bit_rate_s>().to_json(j);
      break;
    case types::ue_security_cap:
      j.write_fieldname("UESecurityCapabilities");
      c.get<ue_security_cap_s>().to_json(j);
      break;
    case types::core_network_assist_info_for_inactive:
      j.write_fieldname("CoreNetworkAssistanceInformationForInactive");
      c.get<core_network_assist_info_for_inactive_s>().to_json(j);
      break;
    case types::emergency_fallback_ind:
      j.write_fieldname("EmergencyFallbackIndicator");
      c.get<emergency_fallback_ind_s>().to_json(j);
      break;
    case types::new_amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::rrc_inactive_transition_report_request:
      j.write_str("RRCInactiveTransitionReportRequest", c.get<rrc_inactive_transition_report_request_e>().to_string());
      break;
    case types::new_guami:
      j.write_fieldname("GUAMI");
      c.get<guami_s>().to_json(j);
      break;
    case types::cn_assisted_ran_tuning:
      j.write_fieldname("CNAssistedRANTuning");
      c.get<cn_assisted_ran_tuning_s>().to_json(j);
      break;
    case types::srvcc_operation_possible:
      j.write_str("SRVCCOperationPossible", c.get<srvcc_operation_possible_e>().to_string());
      break;
    case types::iab_authorized:
      j.write_str("IAB-Authorized", c.get<iab_authorized_e>().to_string());
      break;
    case types::nr_v2x_services_authorized:
      j.write_fieldname("NRV2XServicesAuthorized");
      c.get<nr_v2x_services_authorized_s>().to_json(j);
      break;
    case types::ltev2x_services_authorized:
      j.write_fieldname("LTEV2XServicesAuthorized");
      c.get<ltev2x_services_authorized_s>().to_json(j);
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      j.write_fieldname("LTEUESidelinkAggregateMaximumBitrate");
      c.get<lte_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::pc5_qos_params:
      j.write_fieldname("PC5QoSParameters");
      c.get<pc5_qos_params_s>().to_json(j);
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::rg_level_wireline_access_characteristics:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::time_sync_assist_info:
      j.write_fieldname("TimeSyncAssistanceInfo");
      c.get<time_sync_assist_info_s>().to_json(j);
      break;
    case types::q_mcc_onfig_info:
      j.write_fieldname("QMCConfigInfo");
      c.get<q_mcc_onfig_info_s>().to_json(j);
      break;
    case types::qmc_deactivation:
      j.write_fieldname("QMCDeactivation");
      c.get<qmc_deactivation_s>().to_json(j);
      break;
    case types::ue_slice_max_bit_rate_list:
      j.start_array("UESliceMaximumBitRateList");
      for (const auto& e1 : c.get<ue_slice_max_bit_rate_list_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::management_based_mdt_plmn_mod_list:
      j.start_array("MDTPLMNModificationList");
      for (const auto& e1 : c.get<mdt_plmn_mod_list_l>()) {
        j.write_str(e1.to_string());
      }
      j.end_array();
      break;
    case types::five_g_pro_se_authorized:
      j.write_fieldname("FiveG-ProSeAuthorized");
      c.get<five_g_pro_se_authorized_s>().to_json(j);
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      j.write_fieldname("NRUESidelinkAggregateMaximumBitrate");
      c.get<nr_ue_sidelink_aggr_max_bitrate_s>().to_json(j);
      break;
    case types::five_g_pro_se_pc5_qos_params:
      j.write_fieldname("FiveG-ProSePC5QoSParameters");
      c.get<five_g_pro_se_pc5_qos_params_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().pack(bref)));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().pack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().pack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().pack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().pack(bref));
      break;
    case types::new_amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().pack(bref));
      break;
    case types::new_guami:
      HANDLE_CODE(c.get<guami_s>().pack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().pack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().pack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().pack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().pack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().pack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().pack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().pack(bref));
      break;
    case types::qmc_deactivation:
      HANDLE_CODE(c.get<qmc_deactivation_s>().pack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<ue_slice_max_bit_rate_list_l>(), 1, 8, true));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<mdt_plmn_mod_list_l>(), 0, 16, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().pack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().pack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_paging_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, false, true));
      break;
    case types::security_key:
      HANDLE_CODE((c.get<fixed_bitstring<256, false, true>>().unpack(bref)));
      break;
    case types::idx_to_rfsp:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)1u, (uint16_t)256u, true, true));
      break;
    case types::ue_aggr_max_bit_rate:
      HANDLE_CODE(c.get<ue_aggr_max_bit_rate_s>().unpack(bref));
      break;
    case types::ue_security_cap:
      HANDLE_CODE(c.get<ue_security_cap_s>().unpack(bref));
      break;
    case types::core_network_assist_info_for_inactive:
      HANDLE_CODE(c.get<core_network_assist_info_for_inactive_s>().unpack(bref));
      break;
    case types::emergency_fallback_ind:
      HANDLE_CODE(c.get<emergency_fallback_ind_s>().unpack(bref));
      break;
    case types::new_amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::rrc_inactive_transition_report_request:
      HANDLE_CODE(c.get<rrc_inactive_transition_report_request_e>().unpack(bref));
      break;
    case types::new_guami:
      HANDLE_CODE(c.get<guami_s>().unpack(bref));
      break;
    case types::cn_assisted_ran_tuning:
      HANDLE_CODE(c.get<cn_assisted_ran_tuning_s>().unpack(bref));
      break;
    case types::srvcc_operation_possible:
      HANDLE_CODE(c.get<srvcc_operation_possible_e>().unpack(bref));
      break;
    case types::iab_authorized:
      HANDLE_CODE(c.get<iab_authorized_e>().unpack(bref));
      break;
    case types::nr_v2x_services_authorized:
      HANDLE_CODE(c.get<nr_v2x_services_authorized_s>().unpack(bref));
      break;
    case types::ltev2x_services_authorized:
      HANDLE_CODE(c.get<ltev2x_services_authorized_s>().unpack(bref));
      break;
    case types::nr_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::lte_ue_sidelink_aggr_max_bitrate:
      HANDLE_CODE(c.get<lte_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::pc5_qos_params:
      HANDLE_CODE(c.get<pc5_qos_params_s>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::rg_level_wireline_access_characteristics:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::time_sync_assist_info:
      HANDLE_CODE(c.get<time_sync_assist_info_s>().unpack(bref));
      break;
    case types::q_mcc_onfig_info:
      HANDLE_CODE(c.get<q_mcc_onfig_info_s>().unpack(bref));
      break;
    case types::qmc_deactivation:
      HANDLE_CODE(c.get<qmc_deactivation_s>().unpack(bref));
      break;
    case types::ue_slice_max_bit_rate_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<ue_slice_max_bit_rate_list_l>(), bref, 1, 8, true));
      break;
    case types::management_based_mdt_plmn_mod_list:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<mdt_plmn_mod_list_l>(), bref, 0, 16, true));
      break;
    case types::five_g_pro_se_authorized:
      HANDLE_CODE(c.get<five_g_pro_se_authorized_s>().unpack(bref));
      break;
    case types::five_g_pro_se_ue_pc5_aggr_max_bit_rate:
      HANDLE_CODE(c.get<nr_ue_sidelink_aggr_max_bitrate_s>().unpack(bref));
      break;
    case types::five_g_pro_se_pc5_qos_params:
      HANDLE_CODE(c.get<five_g_pro_se_pc5_qos_params_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextModificationResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_mod_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 92, 121, 19};
  return map_enum_number(names, 5, idx, "id");
}
bool ue_context_mod_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 92, 121, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_mod_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 92:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_mod_resp_ies_o::value_c ue_context_mod_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 92:
      ret.set(value_c::types::rrc_state);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_mod_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 92:
      return presence_e::optional;
    case 121:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_mod_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_mod_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::rrc_state:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
}
ue_context_mod_resp_ies_o::value_c::value_c(const ue_context_mod_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::rrc_state:
      c.init(other.c.get<rrc_state_e>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
}
ue_context_mod_resp_ies_o::value_c&
ue_context_mod_resp_ies_o::value_c::operator=(const ue_context_mod_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::rrc_state:
      c.set(other.c.get<rrc_state_e>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_mod_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_mod_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_state_e& ue_context_mod_resp_ies_o::value_c::rrc_state()
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
user_location_info_c& ue_context_mod_resp_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
crit_diagnostics_s& ue_context_mod_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_mod_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_mod_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_state_e& ue_context_mod_resp_ies_o::value_c::rrc_state() const
{
  assert_choice_type(types::rrc_state, type_, "Value");
  return c.get<rrc_state_e>();
}
const user_location_info_c& ue_context_mod_resp_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const crit_diagnostics_s& ue_context_mod_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_mod_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::rrc_state:
      j.write_str("RRCState", c.get<rrc_state_e>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_mod_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_state:
      HANDLE_CODE(c.get<rrc_state_e>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_mod_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextReleaseCommand-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_release_cmd_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {114, 15};
  return map_enum_number(names, 2, idx, "id");
}
bool ue_context_release_cmd_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {114, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_cmd_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 114:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_release_cmd_ies_o::value_c ue_context_release_cmd_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 114:
      ret.set(value_c::types::ue_ngap_ids);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_cmd_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 114:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_cmd_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_ngap_ids:
      c.destroy<ue_ngap_ids_c>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void ue_context_release_cmd_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_ngap_ids:
      c.init<ue_ngap_ids_c>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
}
ue_context_release_cmd_ies_o::value_c::value_c(const ue_context_release_cmd_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_ngap_ids:
      c.init(other.c.get<ue_ngap_ids_c>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
}
ue_context_release_cmd_ies_o::value_c&
ue_context_release_cmd_ies_o::value_c::operator=(const ue_context_release_cmd_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_ngap_ids:
      c.set(other.c.get<ue_ngap_ids_c>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }

  return *this;
}
ue_ngap_ids_c& ue_context_release_cmd_ies_o::value_c::ue_ngap_ids()
{
  assert_choice_type(types::ue_ngap_ids, type_, "Value");
  return c.get<ue_ngap_ids_c>();
}
cause_c& ue_context_release_cmd_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const ue_ngap_ids_c& ue_context_release_cmd_ies_o::value_c::ue_ngap_ids() const
{
  assert_choice_type(types::ue_ngap_ids, type_, "Value");
  return c.get<ue_ngap_ids_c>();
}
const cause_c& ue_context_release_cmd_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ue_context_release_cmd_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_ngap_ids:
      j.write_fieldname("UE-NGAP-IDs");
      c.get<ue_ngap_ids_c>().to_json(j);
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_cmd_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_ngap_ids:
      HANDLE_CODE(c.get<ue_ngap_ids_c>().pack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_cmd_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_ngap_ids:
      HANDLE_CODE(c.get<ue_ngap_ids_c>().unpack(bref));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_cmd_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextReleaseComplete-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_release_complete_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 121, 32, 60, 19, 207};
  return map_enum_number(names, 7, idx, "id");
}
bool ue_context_release_complete_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 121, 32, 60, 19, 207};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_complete_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 121:
      return crit_e::ignore;
    case 32:
      return crit_e::ignore;
    case 60:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_release_complete_ies_o::value_c ue_context_release_complete_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 32:
      ret.set(value_c::types::info_on_recommended_cells_and_ran_nodes_for_paging);
      break;
    case 60:
      ret.set(value_c::types::pdu_session_res_list_cxt_rel_cpl);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    case 207:
      ret.set(value_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_complete_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 121:
      return presence_e::optional;
    case 32:
      return presence_e::optional;
    case 60:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_complete_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.destroy<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      c.destroy<pdu_session_res_list_cxt_rel_cpl_l>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.destroy<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    default:
      break;
  }
}
void ue_context_release_complete_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      c.init<pdu_session_res_list_cxt_rel_cpl_l>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
}
ue_context_release_complete_ies_o::value_c::value_c(const ue_context_release_complete_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      c.init(other.c.get<pdu_session_res_list_cxt_rel_cpl_l>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
}
ue_context_release_complete_ies_o::value_c&
ue_context_release_complete_ies_o::value_c::operator=(const ue_context_release_complete_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.set(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      c.set(other.c.get<pdu_session_res_list_cxt_rel_cpl_l>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.set(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_release_complete_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_release_complete_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
user_location_info_c& ue_context_release_complete_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_release_complete_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
pdu_session_res_list_cxt_rel_cpl_l& ue_context_release_complete_ies_o::value_c::pdu_session_res_list_cxt_rel_cpl()
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_cpl, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_cpl_l>();
}
crit_diagnostics_s& ue_context_release_complete_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
paging_assis_datafor_c_ecapab_ue_s& ue_context_release_complete_ies_o::value_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const uint64_t& ue_context_release_complete_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_release_complete_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const user_location_info_c& ue_context_release_complete_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_release_complete_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
const pdu_session_res_list_cxt_rel_cpl_l&
ue_context_release_complete_ies_o::value_c::pdu_session_res_list_cxt_rel_cpl() const
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_cpl, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_cpl_l>();
}
const crit_diagnostics_s& ue_context_release_complete_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const paging_assis_datafor_c_ecapab_ue_s&
ue_context_release_complete_ies_o::value_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
void ue_context_release_complete_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      j.write_fieldname("InfoOnRecommendedCellsAndRANNodesForPaging");
      c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().to_json(j);
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      j.start_array("PDUSessionResourceListCxtRelCpl");
      for (const auto& e1 : c.get<pdu_session_res_list_cxt_rel_cpl_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_complete_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().pack(bref));
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_list_cxt_rel_cpl_l>(), 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_complete_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().unpack(bref));
      break;
    case types::pdu_session_res_list_cxt_rel_cpl:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_list_cxt_rel_cpl_l>(), bref, 1, 256, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_complete_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextReleaseRequest-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 133, 15};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 133, 15};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 133:
      return crit_e::reject;
    case 15:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_release_request_ies_o::value_c ue_context_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 133:
      ret.set(value_c::types::pdu_session_res_list_cxt_rel_req);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 133:
      return presence_e::optional;
    case 15:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_release_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_list_cxt_rel_req:
      c.destroy<pdu_session_res_list_cxt_rel_req_l>();
      break;
    case types::cause:
      c.destroy<cause_c>();
      break;
    default:
      break;
  }
}
void ue_context_release_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      c.init<pdu_session_res_list_cxt_rel_req_l>();
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
}
ue_context_release_request_ies_o::value_c::value_c(const ue_context_release_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      c.init(other.c.get<pdu_session_res_list_cxt_rel_req_l>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
}
ue_context_release_request_ies_o::value_c&
ue_context_release_request_ies_o::value_c::operator=(const ue_context_release_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      c.set(other.c.get<pdu_session_res_list_cxt_rel_req_l>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_release_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_release_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_list_cxt_rel_req_l& ue_context_release_request_ies_o::value_c::pdu_session_res_list_cxt_rel_req()
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_req, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_req_l>();
}
cause_c& ue_context_release_request_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const uint64_t& ue_context_release_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_release_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_list_cxt_rel_req_l&
ue_context_release_request_ies_o::value_c::pdu_session_res_list_cxt_rel_req() const
{
  assert_choice_type(types::pdu_session_res_list_cxt_rel_req, type_, "Value");
  return c.get<pdu_session_res_list_cxt_rel_req_l>();
}
const cause_c& ue_context_release_request_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
void ue_context_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      j.start_array("PDUSessionResourceListCxtRelReq");
      for (const auto& e1 : c.get<pdu_session_res_list_cxt_rel_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_list_cxt_rel_req_l>(), 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_list_cxt_rel_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_list_cxt_rel_req_l>(), bref, 1, 256, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextResumeFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_resume_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_resume_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_resume_fail_ies_o::value_c ue_context_resume_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_resume_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
}
ue_context_resume_fail_ies_o::value_c::value_c(const ue_context_resume_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
}
ue_context_resume_fail_ies_o::value_c&
ue_context_resume_fail_ies_o::value_c::operator=(const ue_context_resume_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_resume_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_resume_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ue_context_resume_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_resume_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_resume_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_resume_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ue_context_resume_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_resume_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_resume_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextResumeRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_resume_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 237, 232, 229, 235, 32, 207};
  return map_enum_number(names, 8, idx, "id");
}
bool ue_context_resume_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 237, 232, 229, 235, 32, 207};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 237:
      return crit_e::ignore;
    case 232:
      return crit_e::reject;
    case 229:
      return crit_e::reject;
    case 235:
      return crit_e::ignore;
    case 32:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_resume_request_ies_o::value_c ue_context_resume_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 237:
      ret.set(value_c::types::rrc_resume_cause);
      break;
    case 232:
      ret.set(value_c::types::pdu_session_res_resume_list_res_req);
      break;
    case 229:
      ret.set(value_c::types::pdu_session_res_failed_to_resume_list_res_req);
      break;
    case 235:
      ret.set(value_c::types::suspend_request_ind);
      break;
    case 32:
      ret.set(value_c::types::info_on_recommended_cells_and_ran_nodes_for_paging);
      break;
    case 207:
      ret.set(value_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 237:
      return presence_e::mandatory;
    case 232:
      return presence_e::optional;
    case 229:
      return presence_e::optional;
    case 235:
      return presence_e::optional;
    case 32:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_resume_list_res_req:
      c.destroy<pdu_session_res_resume_list_res_req_l>();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      c.destroy<pdu_session_res_failed_to_resume_list_res_req_l>();
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.destroy<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.destroy<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    default:
      break;
  }
}
void ue_context_resume_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::rrc_resume_cause:
      break;
    case types::pdu_session_res_resume_list_res_req:
      c.init<pdu_session_res_resume_list_res_req_l>();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      c.init<pdu_session_res_failed_to_resume_list_res_req_l>();
      break;
    case types::suspend_request_ind:
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
}
ue_context_resume_request_ies_o::value_c::value_c(const ue_context_resume_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::rrc_resume_cause:
      c.init(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::pdu_session_res_resume_list_res_req:
      c.init(other.c.get<pdu_session_res_resume_list_res_req_l>());
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      c.init(other.c.get<pdu_session_res_failed_to_resume_list_res_req_l>());
      break;
    case types::suspend_request_ind:
      c.init(other.c.get<suspend_request_ind_e>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
}
ue_context_resume_request_ies_o::value_c&
ue_context_resume_request_ies_o::value_c::operator=(const ue_context_resume_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::rrc_resume_cause:
      c.set(other.c.get<rrc_establishment_cause_e>());
      break;
    case types::pdu_session_res_resume_list_res_req:
      c.set(other.c.get<pdu_session_res_resume_list_res_req_l>());
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      c.set(other.c.get<pdu_session_res_failed_to_resume_list_res_req_l>());
      break;
    case types::suspend_request_ind:
      c.set(other.c.get<suspend_request_ind_e>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.set(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.set(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_resume_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_resume_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
rrc_establishment_cause_e& ue_context_resume_request_ies_o::value_c::rrc_resume_cause()
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
pdu_session_res_resume_list_res_req_l& ue_context_resume_request_ies_o::value_c::pdu_session_res_resume_list_res_req()
{
  assert_choice_type(types::pdu_session_res_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_req_l>();
}
pdu_session_res_failed_to_resume_list_res_req_l&
ue_context_resume_request_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_req()
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_req_l>();
}
suspend_request_ind_e& ue_context_resume_request_ies_o::value_c::suspend_request_ind()
{
  assert_choice_type(types::suspend_request_ind, type_, "Value");
  return c.get<suspend_request_ind_e>();
}
info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_resume_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
paging_assis_datafor_c_ecapab_ue_s& ue_context_resume_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const uint64_t& ue_context_resume_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_resume_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const rrc_establishment_cause_e& ue_context_resume_request_ies_o::value_c::rrc_resume_cause() const
{
  assert_choice_type(types::rrc_resume_cause, type_, "Value");
  return c.get<rrc_establishment_cause_e>();
}
const pdu_session_res_resume_list_res_req_l&
ue_context_resume_request_ies_o::value_c::pdu_session_res_resume_list_res_req() const
{
  assert_choice_type(types::pdu_session_res_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_req_l>();
}
const pdu_session_res_failed_to_resume_list_res_req_l&
ue_context_resume_request_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_req() const
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_req, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_req_l>();
}
const suspend_request_ind_e& ue_context_resume_request_ies_o::value_c::suspend_request_ind() const
{
  assert_choice_type(types::suspend_request_ind, type_, "Value");
  return c.get<suspend_request_ind_e>();
}
const info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_resume_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
const paging_assis_datafor_c_ecapab_ue_s&
ue_context_resume_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
void ue_context_resume_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::rrc_resume_cause:
      j.write_str("RRCEstablishmentCause", c.get<rrc_establishment_cause_e>().to_string());
      break;
    case types::pdu_session_res_resume_list_res_req:
      j.start_array("PDUSessionResourceResumeListRESReq");
      for (const auto& e1 : c.get<pdu_session_res_resume_list_res_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      j.start_array("PDUSessionResourceFailedToResumeListRESReq");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_resume_list_res_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::suspend_request_ind:
      j.write_str("Suspend-Request-Indication", "suspend-requested");
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      j.write_fieldname("InfoOnRecommendedCellsAndRANNodesForPaging");
      c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().pack(bref));
      break;
    case types::pdu_session_res_resume_list_res_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_resume_list_res_req_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_resume_list_res_req_l>(), 1, 256, true));
      break;
    case types::suspend_request_ind:
      HANDLE_CODE(c.get<suspend_request_ind_e>().pack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::rrc_resume_cause:
      HANDLE_CODE(c.get<rrc_establishment_cause_e>().unpack(bref));
      break;
    case types::pdu_session_res_resume_list_res_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_resume_list_res_req_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_resume_list_res_req_l>(), bref, 1, 256, true));
      break;
    case types::suspend_request_ind:
      HANDLE_CODE(c.get<suspend_request_ind_e>().unpack(bref));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextResumeResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_resume_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 233, 230, 93, 236, 206, 19};
  return map_enum_number(names, 8, idx, "id");
}
bool ue_context_resume_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 233, 230, 93, 236, 206, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_resume_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 233:
      return crit_e::reject;
    case 230:
      return crit_e::reject;
    case 93:
      return crit_e::reject;
    case 236:
      return crit_e::ignore;
    case 206:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_resume_resp_ies_o::value_c ue_context_resume_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 233:
      ret.set(value_c::types::pdu_session_res_resume_list_res_res);
      break;
    case 230:
      ret.set(value_c::types::pdu_session_res_failed_to_resume_list_res_res);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 236:
      ret.set(value_c::types::suspend_resp_ind);
      break;
    case 206:
      ret.set(value_c::types::extended_connected_time);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_resume_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 233:
      return presence_e::optional;
    case 230:
      return presence_e::optional;
    case 93:
      return presence_e::optional;
    case 236:
      return presence_e::optional;
    case 206:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_resume_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::pdu_session_res_resume_list_res_res:
      c.destroy<pdu_session_res_resume_list_res_res_l>();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      c.destroy<pdu_session_res_failed_to_resume_list_res_res_l>();
      break;
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_resume_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::pdu_session_res_resume_list_res_res:
      c.init<pdu_session_res_resume_list_res_res_l>();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      c.init<pdu_session_res_failed_to_resume_list_res_res_l>();
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::suspend_resp_ind:
      break;
    case types::extended_connected_time:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
}
ue_context_resume_resp_ies_o::value_c::value_c(const ue_context_resume_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_resume_list_res_res:
      c.init(other.c.get<pdu_session_res_resume_list_res_res_l>());
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      c.init(other.c.get<pdu_session_res_failed_to_resume_list_res_res_l>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::suspend_resp_ind:
      c.init(other.c.get<suspend_resp_ind_e>());
      break;
    case types::extended_connected_time:
      c.init(other.c.get<uint16_t>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
}
ue_context_resume_resp_ies_o::value_c&
ue_context_resume_resp_ies_o::value_c::operator=(const ue_context_resume_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::pdu_session_res_resume_list_res_res:
      c.set(other.c.get<pdu_session_res_resume_list_res_res_l>());
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      c.set(other.c.get<pdu_session_res_failed_to_resume_list_res_res_l>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::suspend_resp_ind:
      c.set(other.c.get<suspend_resp_ind_e>());
      break;
    case types::extended_connected_time:
      c.set(other.c.get<uint16_t>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_resume_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_resume_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
pdu_session_res_resume_list_res_res_l& ue_context_resume_resp_ies_o::value_c::pdu_session_res_resume_list_res_res()
{
  assert_choice_type(types::pdu_session_res_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_res_l>();
}
pdu_session_res_failed_to_resume_list_res_res_l&
ue_context_resume_resp_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_res()
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_res_l>();
}
security_context_s& ue_context_resume_resp_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
suspend_resp_ind_e& ue_context_resume_resp_ies_o::value_c::suspend_resp_ind()
{
  assert_choice_type(types::suspend_resp_ind, type_, "Value");
  return c.get<suspend_resp_ind_e>();
}
uint16_t& ue_context_resume_resp_ies_o::value_c::extended_connected_time()
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
crit_diagnostics_s& ue_context_resume_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_resume_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_resume_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const pdu_session_res_resume_list_res_res_l&
ue_context_resume_resp_ies_o::value_c::pdu_session_res_resume_list_res_res() const
{
  assert_choice_type(types::pdu_session_res_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_resume_list_res_res_l>();
}
const pdu_session_res_failed_to_resume_list_res_res_l&
ue_context_resume_resp_ies_o::value_c::pdu_session_res_failed_to_resume_list_res_res() const
{
  assert_choice_type(types::pdu_session_res_failed_to_resume_list_res_res, type_, "Value");
  return c.get<pdu_session_res_failed_to_resume_list_res_res_l>();
}
const security_context_s& ue_context_resume_resp_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const suspend_resp_ind_e& ue_context_resume_resp_ies_o::value_c::suspend_resp_ind() const
{
  assert_choice_type(types::suspend_resp_ind, type_, "Value");
  return c.get<suspend_resp_ind_e>();
}
const uint16_t& ue_context_resume_resp_ies_o::value_c::extended_connected_time() const
{
  assert_choice_type(types::extended_connected_time, type_, "Value");
  return c.get<uint16_t>();
}
const crit_diagnostics_s& ue_context_resume_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_resume_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::pdu_session_res_resume_list_res_res:
      j.start_array("PDUSessionResourceResumeListRESRes");
      for (const auto& e1 : c.get<pdu_session_res_resume_list_res_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      j.start_array("PDUSessionResourceFailedToResumeListRESRes");
      for (const auto& e1 : c.get<pdu_session_res_failed_to_resume_list_res_res_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::suspend_resp_ind:
      j.write_str("Suspend-Response-Indication", "suspend-indicated");
      break;
    case types::extended_connected_time:
      j.write_int("INTEGER (0..255)", c.get<uint16_t>());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_resume_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_resume_list_res_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_resume_list_res_res_l>(), 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_failed_to_resume_list_res_res_l>(), 1, 256, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::suspend_resp_ind:
      HANDLE_CODE(c.get<suspend_resp_ind_e>().pack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::pdu_session_res_resume_list_res_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_resume_list_res_res_l>(), bref, 1, 256, true));
      break;
    case types::pdu_session_res_failed_to_resume_list_res_res:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_failed_to_resume_list_res_res_l>(), bref, 1, 256, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::suspend_resp_ind:
      HANDLE_CODE(c.get<suspend_resp_ind_e>().unpack(bref));
      break;
    case types::extended_connected_time:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, false, true));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_resume_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextSuspendFailureIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_suspend_fail_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_suspend_fail_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 15, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_fail_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 15:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_suspend_fail_ies_o::value_c ue_context_suspend_fail_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 15:
      ret.set(value_c::types::cause);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_fail_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 15:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_fail_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::cause:
      c.destroy<cause_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_suspend_fail_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::cause:
      c.init<cause_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }
}
ue_context_suspend_fail_ies_o::value_c::value_c(const ue_context_suspend_fail_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.init(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }
}
ue_context_suspend_fail_ies_o::value_c&
ue_context_suspend_fail_ies_o::value_c::operator=(const ue_context_suspend_fail_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::cause:
      c.set(other.c.get<cause_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_suspend_fail_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_suspend_fail_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
cause_c& ue_context_suspend_fail_ies_o::value_c::cause()
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
crit_diagnostics_s& ue_context_suspend_fail_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_suspend_fail_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_suspend_fail_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const cause_c& ue_context_suspend_fail_ies_o::value_c::cause() const
{
  assert_choice_type(types::cause, type_, "Value");
  return c.get<cause_c>();
}
const crit_diagnostics_s& ue_context_suspend_fail_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_suspend_fail_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::cause:
      j.write_fieldname("Cause");
      c.get<cause_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_fail_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_fail_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::cause:
      HANDLE_CODE(c.get<cause_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_fail_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextSuspendRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_suspend_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 32, 207, 231};
  return map_enum_number(names, 5, idx, "id");
}
bool ue_context_suspend_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 32, 207, 231};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 32:
      return crit_e::ignore;
    case 207:
      return crit_e::ignore;
    case 231:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_suspend_request_ies_o::value_c ue_context_suspend_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 32:
      ret.set(value_c::types::info_on_recommended_cells_and_ran_nodes_for_paging);
      break;
    case 207:
      ret.set(value_c::types::paging_assis_datafor_c_ecapab_ue);
      break;
    case 231:
      ret.set(value_c::types::pdu_session_res_suspend_list_sus_req);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 32:
      return presence_e::optional;
    case 207:
      return presence_e::optional;
    case 231:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.destroy<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.destroy<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      c.destroy<pdu_session_res_suspend_list_sus_req_l>();
      break;
    default:
      break;
  }
}
void ue_context_suspend_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init<paging_assis_datafor_c_ecapab_ue_s>();
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      c.init<pdu_session_res_suspend_list_sus_req_l>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
}
ue_context_suspend_request_ies_o::value_c::value_c(const ue_context_suspend_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.init(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.init(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      c.init(other.c.get<pdu_session_res_suspend_list_sus_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
}
ue_context_suspend_request_ies_o::value_c&
ue_context_suspend_request_ies_o::value_c::operator=(const ue_context_suspend_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      c.set(other.c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>());
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      c.set(other.c.get<paging_assis_datafor_c_ecapab_ue_s>());
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      c.set(other.c.get<pdu_session_res_suspend_list_sus_req_l>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_suspend_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_suspend_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_suspend_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging()
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
paging_assis_datafor_c_ecapab_ue_s& ue_context_suspend_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue()
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
pdu_session_res_suspend_list_sus_req_l&
ue_context_suspend_request_ies_o::value_c::pdu_session_res_suspend_list_sus_req()
{
  assert_choice_type(types::pdu_session_res_suspend_list_sus_req, type_, "Value");
  return c.get<pdu_session_res_suspend_list_sus_req_l>();
}
const uint64_t& ue_context_suspend_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_suspend_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const info_on_recommended_cells_and_ran_nodes_for_paging_s&
ue_context_suspend_request_ies_o::value_c::info_on_recommended_cells_and_ran_nodes_for_paging() const
{
  assert_choice_type(types::info_on_recommended_cells_and_ran_nodes_for_paging, type_, "Value");
  return c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>();
}
const paging_assis_datafor_c_ecapab_ue_s&
ue_context_suspend_request_ies_o::value_c::paging_assis_datafor_c_ecapab_ue() const
{
  assert_choice_type(types::paging_assis_datafor_c_ecapab_ue, type_, "Value");
  return c.get<paging_assis_datafor_c_ecapab_ue_s>();
}
const pdu_session_res_suspend_list_sus_req_l&
ue_context_suspend_request_ies_o::value_c::pdu_session_res_suspend_list_sus_req() const
{
  assert_choice_type(types::pdu_session_res_suspend_list_sus_req, type_, "Value");
  return c.get<pdu_session_res_suspend_list_sus_req_l>();
}
void ue_context_suspend_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      j.write_fieldname("InfoOnRecommendedCellsAndRANNodesForPaging");
      c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().to_json(j);
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      j.write_fieldname("PagingAssisDataforCEcapabUE");
      c.get<paging_assis_datafor_c_ecapab_ue_s>().to_json(j);
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      j.start_array("PDUSessionResourceSuspendListSUSReq");
      for (const auto& e1 : c.get<pdu_session_res_suspend_list_sus_req_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().pack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().pack(bref));
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<pdu_session_res_suspend_list_sus_req_l>(), 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::info_on_recommended_cells_and_ran_nodes_for_paging:
      HANDLE_CODE(c.get<info_on_recommended_cells_and_ran_nodes_for_paging_s>().unpack(bref));
      break;
    case types::paging_assis_datafor_c_ecapab_ue:
      HANDLE_CODE(c.get<paging_assis_datafor_c_ecapab_ue_s>().unpack(bref));
      break;
    case types::pdu_session_res_suspend_list_sus_req:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<pdu_session_res_suspend_list_sus_req_l>(), bref, 1, 256, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEContextSuspendResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_context_suspend_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 93, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_context_suspend_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 93, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_context_suspend_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 93:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_context_suspend_resp_ies_o::value_c ue_context_suspend_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 93:
      ret.set(value_c::types::security_context);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_context_suspend_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 93:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_context_suspend_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::security_context:
      c.destroy<security_context_s>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_context_suspend_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::security_context:
      c.init<security_context_s>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
}
ue_context_suspend_resp_ies_o::value_c::value_c(const ue_context_suspend_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::security_context:
      c.init(other.c.get<security_context_s>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
}
ue_context_suspend_resp_ies_o::value_c&
ue_context_suspend_resp_ies_o::value_c::operator=(const ue_context_suspend_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::security_context:
      c.set(other.c.get<security_context_s>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_context_suspend_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_context_suspend_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
security_context_s& ue_context_suspend_resp_ies_o::value_c::security_context()
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
crit_diagnostics_s& ue_context_suspend_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_context_suspend_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_context_suspend_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const security_context_s& ue_context_suspend_resp_ies_o::value_c::security_context() const
{
  assert_choice_type(types::security_context, type_, "Value");
  return c.get<security_context_s>();
}
const crit_diagnostics_s& ue_context_suspend_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_context_suspend_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::security_context:
      j.write_fieldname("SecurityContext");
      c.get<security_context_s>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_context_suspend_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::security_context:
      HANDLE_CODE(c.get<security_context_s>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_context_suspend_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UEInformationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {26, 210, 117, 148, 0, 209, 34};
  return map_enum_number(names, 7, idx, "id");
}
bool ue_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {26, 210, 117, 148, 0, 209, 34};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 26:
      return crit_e::reject;
    case 210:
      return crit_e::ignore;
    case 117:
      return crit_e::ignore;
    case 148:
      return crit_e::ignore;
    case 0:
      return crit_e::ignore;
    case 209:
      return crit_e::ignore;
    case 34:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_info_transfer_ies_o::value_c ue_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 26:
      ret.set(value_c::types::five_g_s_tmsi);
      break;
    case 210:
      ret.set(value_c::types::nb_iot_ue_prio);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 148:
      ret.set(value_c::types::s_nssai);
      break;
    case 0:
      ret.set(value_c::types::allowed_nssai);
      break;
    case 209:
      ret.set(value_c::types::ue_diff_info);
      break;
    case 34:
      ret.set(value_c::types::masked_imeisv);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 26:
      return presence_e::mandatory;
    case 210:
      return presence_e::optional;
    case 117:
      return presence_e::optional;
    case 148:
      return presence_e::optional;
    case 0:
      return presence_e::optional;
    case 209:
      return presence_e::optional;
    case 34:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_info_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::five_g_s_tmsi:
      c.destroy<five_g_s_tmsi_s>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::s_nssai:
      c.destroy<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.destroy<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.destroy<ue_diff_info_s>();
      break;
    case types::masked_imeisv:
      c.destroy<fixed_bitstring<64, false, true>>();
      break;
    default:
      break;
  }
}
void ue_info_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::five_g_s_tmsi:
      c.init<five_g_s_tmsi_s>();
      break;
    case types::nb_iot_ue_prio:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::s_nssai:
      c.init<s_nssai_s>();
      break;
    case types::allowed_nssai:
      c.init<allowed_nssai_l>();
      break;
    case types::ue_diff_info:
      c.init<ue_diff_info_s>();
      break;
    case types::masked_imeisv:
      c.init<fixed_bitstring<64, false, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
}
ue_info_transfer_ies_o::value_c::value_c(const ue_info_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::five_g_s_tmsi:
      c.init(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::nb_iot_ue_prio:
      c.init(other.c.get<uint16_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::s_nssai:
      c.init(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.init(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_diff_info:
      c.init(other.c.get<ue_diff_info_s>());
      break;
    case types::masked_imeisv:
      c.init(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
}
ue_info_transfer_ies_o::value_c&
ue_info_transfer_ies_o::value_c::operator=(const ue_info_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::five_g_s_tmsi:
      c.set(other.c.get<five_g_s_tmsi_s>());
      break;
    case types::nb_iot_ue_prio:
      c.set(other.c.get<uint16_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::s_nssai:
      c.set(other.c.get<s_nssai_s>());
      break;
    case types::allowed_nssai:
      c.set(other.c.get<allowed_nssai_l>());
      break;
    case types::ue_diff_info:
      c.set(other.c.get<ue_diff_info_s>());
      break;
    case types::masked_imeisv:
      c.set(other.c.get<fixed_bitstring<64, false, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }

  return *this;
}
five_g_s_tmsi_s& ue_info_transfer_ies_o::value_c::five_g_s_tmsi()
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
uint16_t& ue_info_transfer_ies_o::value_c::nb_iot_ue_prio()
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
unbounded_octstring<true>& ue_info_transfer_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
s_nssai_s& ue_info_transfer_ies_o::value_c::s_nssai()
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
allowed_nssai_l& ue_info_transfer_ies_o::value_c::allowed_nssai()
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
ue_diff_info_s& ue_info_transfer_ies_o::value_c::ue_diff_info()
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
fixed_bitstring<64, false, true>& ue_info_transfer_ies_o::value_c::masked_imeisv()
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
const five_g_s_tmsi_s& ue_info_transfer_ies_o::value_c::five_g_s_tmsi() const
{
  assert_choice_type(types::five_g_s_tmsi, type_, "Value");
  return c.get<five_g_s_tmsi_s>();
}
const uint16_t& ue_info_transfer_ies_o::value_c::nb_iot_ue_prio() const
{
  assert_choice_type(types::nb_iot_ue_prio, type_, "Value");
  return c.get<uint16_t>();
}
const unbounded_octstring<true>& ue_info_transfer_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const s_nssai_s& ue_info_transfer_ies_o::value_c::s_nssai() const
{
  assert_choice_type(types::s_nssai, type_, "Value");
  return c.get<s_nssai_s>();
}
const allowed_nssai_l& ue_info_transfer_ies_o::value_c::allowed_nssai() const
{
  assert_choice_type(types::allowed_nssai, type_, "Value");
  return c.get<allowed_nssai_l>();
}
const ue_diff_info_s& ue_info_transfer_ies_o::value_c::ue_diff_info() const
{
  assert_choice_type(types::ue_diff_info, type_, "Value");
  return c.get<ue_diff_info_s>();
}
const fixed_bitstring<64, false, true>& ue_info_transfer_ies_o::value_c::masked_imeisv() const
{
  assert_choice_type(types::masked_imeisv, type_, "Value");
  return c.get<fixed_bitstring<64, false, true>>();
}
void ue_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::five_g_s_tmsi:
      j.write_fieldname("FiveG-S-TMSI");
      c.get<five_g_s_tmsi_s>().to_json(j);
      break;
    case types::nb_iot_ue_prio:
      j.write_int("INTEGER (0..255,...)", c.get<uint16_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::s_nssai:
      j.write_fieldname("S-NSSAI");
      c.get<s_nssai_s>().to_json(j);
      break;
    case types::allowed_nssai:
      j.start_array("AllowedNSSAI");
      for (const auto& e1 : c.get<allowed_nssai_l>()) {
        e1.to_json(j);
      }
      j.end_array();
      break;
    case types::ue_diff_info:
      j.write_fieldname("UE-DifferentiationInfo");
      c.get<ue_diff_info_s>().to_json(j);
      break;
    case types::masked_imeisv:
      j.write_str("BIT STRING", c.get<fixed_bitstring<64, false, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().pack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(pack_integer(bref, c.get<uint16_t>(), (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().pack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(pack_dyn_seq_of(bref, c.get<allowed_nssai_l>(), 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().pack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::five_g_s_tmsi:
      HANDLE_CODE(c.get<five_g_s_tmsi_s>().unpack(bref));
      break;
    case types::nb_iot_ue_prio:
      HANDLE_CODE(unpack_integer(c.get<uint16_t>(), bref, (uint16_t)0u, (uint16_t)255u, true, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::s_nssai:
      HANDLE_CODE(c.get<s_nssai_s>().unpack(bref));
      break;
    case types::allowed_nssai:
      HANDLE_CODE(unpack_dyn_seq_of(c.get<allowed_nssai_l>(), bref, 1, 8, true));
      break;
    case types::ue_diff_info:
      HANDLE_CODE(c.get<ue_diff_info_s>().unpack(bref));
      break;
    case types::masked_imeisv:
      HANDLE_CODE((c.get<fixed_bitstring<64, false, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "ue_info_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UERadioCapabilityCheckRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_check_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 117, 264};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_radio_cap_check_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 117, 264};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_check_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 264:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_check_request_ies_o::value_c ue_radio_cap_check_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_check_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 117:
      return presence_e::optional;
    case 264:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_check_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ue_radio_cap_check_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }
}
ue_radio_cap_check_request_ies_o::value_c::value_c(const ue_radio_cap_check_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }
}
ue_radio_cap_check_request_ies_o::value_c&
ue_radio_cap_check_request_ies_o::value_c::operator=(const ue_radio_cap_check_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_radio_cap_check_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_radio_cap_check_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ue_radio_cap_check_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_radio_cap_check_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ue_radio_cap_check_request_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ue_radio_cap_check_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_check_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UERadioCapabilityCheckResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_check_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 30, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool ue_radio_cap_check_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 30, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_check_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::ignore;
    case 85:
      return crit_e::ignore;
    case 30:
      return crit_e::reject;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_check_resp_ies_o::value_c ue_radio_cap_check_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 30:
      ret.set(value_c::types::ims_voice_support_ind);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_check_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 30:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_check_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_radio_cap_check_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ims_voice_support_ind:
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }
}
ue_radio_cap_check_resp_ies_o::value_c::value_c(const ue_radio_cap_check_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ims_voice_support_ind:
      c.init(other.c.get<ims_voice_support_ind_e>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }
}
ue_radio_cap_check_resp_ies_o::value_c&
ue_radio_cap_check_resp_ies_o::value_c::operator=(const ue_radio_cap_check_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ims_voice_support_ind:
      c.set(other.c.get<ims_voice_support_ind_e>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_radio_cap_check_resp_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_radio_cap_check_resp_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ims_voice_support_ind_e& ue_radio_cap_check_resp_ies_o::value_c::ims_voice_support_ind()
{
  assert_choice_type(types::ims_voice_support_ind, type_, "Value");
  return c.get<ims_voice_support_ind_e>();
}
crit_diagnostics_s& ue_radio_cap_check_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const uint64_t& ue_radio_cap_check_resp_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_radio_cap_check_resp_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ims_voice_support_ind_e& ue_radio_cap_check_resp_ies_o::value_c::ims_voice_support_ind() const
{
  assert_choice_type(types::ims_voice_support_ind, type_, "Value");
  return c.get<ims_voice_support_ind_e>();
}
const crit_diagnostics_s& ue_radio_cap_check_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_radio_cap_check_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ims_voice_support_ind:
      j.write_str("IMSVoiceSupportIndicator", c.get<ims_voice_support_ind_e>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_check_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ims_voice_support_ind:
      HANDLE_CODE(c.get<ims_voice_support_ind_e>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ims_voice_support_ind:
      HANDLE_CODE(c.get<ims_voice_support_ind_e>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_check_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UERadioCapabilityIDMappingRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_id_map_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {264};
  return map_enum_number(names, 1, idx, "id");
}
bool ue_radio_cap_id_map_request_ies_o::is_id_valid(const uint32_t& id)
{
  return 264 == id;
}
crit_e ue_radio_cap_id_map_request_ies_o::get_crit(const uint32_t& id)
{
  if (id == 264) {
    return crit_e::reject;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ue_radio_cap_id_map_request_ies_o::value_c ue_radio_cap_id_map_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 264) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_id_map_request_ies_o::get_presence(const uint32_t& id)
{
  if (id == 264) {
    return presence_e::mandatory;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_id_map_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_str("OCTET STRING", c.to_string());
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_id_map_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_id_map_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// UERadioCapabilityIDMappingResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_id_map_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {264, 117, 19};
  return map_enum_number(names, 3, idx, "id");
}
bool ue_radio_cap_id_map_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {264, 117, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_id_map_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 264:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_id_map_resp_ies_o::value_c ue_radio_cap_id_map_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 264:
      ret.set(value_c::types::ue_radio_cap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_id_map_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 264:
      return presence_e::mandatory;
    case 117:
      return presence_e::mandatory;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_id_map_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void ue_radio_cap_id_map_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::ue_radio_cap_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }
}
ue_radio_cap_id_map_resp_ies_o::value_c::value_c(const ue_radio_cap_id_map_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::ue_radio_cap_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }
}
ue_radio_cap_id_map_resp_ies_o::value_c&
ue_radio_cap_id_map_resp_ies_o::value_c::operator=(const ue_radio_cap_id_map_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::ue_radio_cap_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }

  return *this;
}
unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap_id()
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
crit_diagnostics_s& ue_radio_cap_id_map_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap_id() const
{
  assert_choice_type(types::ue_radio_cap_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ue_radio_cap_id_map_resp_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const crit_diagnostics_s& ue_radio_cap_id_map_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void ue_radio_cap_id_map_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::ue_radio_cap_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::ue_radio_cap_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_id_map_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UERadioCapabilityInfoIndicationIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_radio_cap_info_ind_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 117, 118, 265};
  return map_enum_number(names, 5, idx, "id");
}
bool ue_radio_cap_info_ind_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 117, 118, 265};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_radio_cap_info_ind_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 117:
      return crit_e::ignore;
    case 118:
      return crit_e::ignore;
    case 265:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_radio_cap_info_ind_ies_o::value_c ue_radio_cap_info_ind_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 117:
      ret.set(value_c::types::ue_radio_cap);
      break;
    case 118:
      ret.set(value_c::types::ue_radio_cap_for_paging);
      break;
    case 265:
      ret.set(value_c::types::ue_radio_cap_eutra_format);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_radio_cap_info_ind_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 117:
      return presence_e::mandatory;
    case 118:
      return presence_e::optional;
    case 265:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_radio_cap_info_ind_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ue_radio_cap:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_for_paging:
      c.destroy<ue_radio_cap_for_paging_s>();
      break;
    case types::ue_radio_cap_eutra_format:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ue_radio_cap_info_ind_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ue_radio_cap:
      c.init<unbounded_octstring<true>>();
      break;
    case types::ue_radio_cap_for_paging:
      c.init<ue_radio_cap_for_paging_s>();
      break;
    case types::ue_radio_cap_eutra_format:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }
}
ue_radio_cap_info_ind_ies_o::value_c::value_c(const ue_radio_cap_info_ind_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap_for_paging:
      c.init(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::ue_radio_cap_eutra_format:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }
}
ue_radio_cap_info_ind_ies_o::value_c&
ue_radio_cap_info_ind_ies_o::value_c::operator=(const ue_radio_cap_info_ind_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::ue_radio_cap_for_paging:
      c.set(other.c.get<ue_radio_cap_for_paging_s>());
      break;
    case types::ue_radio_cap_eutra_format:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_radio_cap_info_ind_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_radio_cap_info_ind_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap()
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
ue_radio_cap_for_paging_s& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_for_paging()
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_eutra_format()
{
  assert_choice_type(types::ue_radio_cap_eutra_format, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ue_radio_cap_info_ind_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_radio_cap_info_ind_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap() const
{
  assert_choice_type(types::ue_radio_cap, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const ue_radio_cap_for_paging_s& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_for_paging() const
{
  assert_choice_type(types::ue_radio_cap_for_paging, type_, "Value");
  return c.get<ue_radio_cap_for_paging_s>();
}
const unbounded_octstring<true>& ue_radio_cap_info_ind_ies_o::value_c::ue_radio_cap_eutra_format() const
{
  assert_choice_type(types::ue_radio_cap_eutra_format, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ue_radio_cap_info_ind_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ue_radio_cap:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::ue_radio_cap_for_paging:
      j.write_fieldname("UERadioCapabilityForPaging");
      c.get<ue_radio_cap_for_paging_s>().to_json(j);
      break;
    case types::ue_radio_cap_eutra_format:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_radio_cap_info_ind_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().pack(bref));
      break;
    case types::ue_radio_cap_eutra_format:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_info_ind_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ue_radio_cap:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::ue_radio_cap_for_paging:
      HANDLE_CODE(c.get<ue_radio_cap_for_paging_s>().unpack(bref));
      break;
    case types::ue_radio_cap_eutra_format:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ue_radio_cap_info_ind_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UETNLABindingReleaseRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ue_tnla_binding_release_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85};
  return map_enum_number(names, 2, idx, "id");
}
bool ue_tnla_binding_release_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ue_tnla_binding_release_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ue_tnla_binding_release_request_ies_o::value_c ue_tnla_binding_release_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ue_tnla_binding_release_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ue_tnla_binding_release_request_ies_o::value_c::destroy_() {}
void ue_tnla_binding_release_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
}
ue_tnla_binding_release_request_ies_o::value_c::value_c(const ue_tnla_binding_release_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
  }
}
ue_tnla_binding_release_request_ies_o::value_c&
ue_tnla_binding_release_request_ies_o::value_c::operator=(const ue_tnla_binding_release_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
  }

  return *this;
}
uint64_t& ue_tnla_binding_release_request_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ue_tnla_binding_release_request_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_tnla_binding_release_request_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ue_tnla_binding_release_request_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
void ue_tnla_binding_release_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ue_tnla_binding_release_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_tnla_binding_release_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    default:
      log_invalid_choice_id(type_, "ue_tnla_binding_release_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UplinkNASTransport-IEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_nas_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 38, 121, 239, 246, 247};
  return map_enum_number(names, 7, idx, "id");
}
bool ul_nas_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 38, 121, 239, 246, 247};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_nas_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 38:
      return crit_e::reject;
    case 121:
      return crit_e::ignore;
    case 239:
      return crit_e::reject;
    case 246:
      return crit_e::reject;
    case 247:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_nas_transport_ies_o::value_c ul_nas_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 38:
      ret.set(value_c::types::nas_pdu);
      break;
    case 121:
      ret.set(value_c::types::user_location_info);
      break;
    case 239:
      ret.set(value_c::types::w_agf_id_info);
      break;
    case 246:
      ret.set(value_c::types::tngf_id_info);
      break;
    case 247:
      ret.set(value_c::types::twif_id_info);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_nas_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 38:
      return presence_e::mandatory;
    case 121:
      return presence_e::mandatory;
    case 239:
      return presence_e::optional;
    case 246:
      return presence_e::optional;
    case 247:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_nas_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::nas_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::user_location_info:
      c.destroy<user_location_info_c>();
      break;
    case types::w_agf_id_info:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::tngf_id_info:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::twif_id_info:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ul_nas_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::nas_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::user_location_info:
      c.init<user_location_info_c>();
      break;
    case types::w_agf_id_info:
      c.init<unbounded_octstring<true>>();
      break;
    case types::tngf_id_info:
      c.init<unbounded_octstring<true>>();
      break;
    case types::twif_id_info:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
}
ul_nas_transport_ies_o::value_c::value_c(const ul_nas_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::user_location_info:
      c.init(other.c.get<user_location_info_c>());
      break;
    case types::w_agf_id_info:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::tngf_id_info:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::twif_id_info:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
}
ul_nas_transport_ies_o::value_c&
ul_nas_transport_ies_o::value_c::operator=(const ul_nas_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::nas_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::user_location_info:
      c.set(other.c.get<user_location_info_c>());
      break;
    case types::w_agf_id_info:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::tngf_id_info:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::twif_id_info:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_nas_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_nas_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::nas_pdu()
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
user_location_info_c& ul_nas_transport_ies_o::value_c::user_location_info()
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::w_agf_id_info()
{
  assert_choice_type(types::w_agf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::tngf_id_info()
{
  assert_choice_type(types::tngf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::twif_id_info()
{
  assert_choice_type(types::twif_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ul_nas_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_nas_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::nas_pdu() const
{
  assert_choice_type(types::nas_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const user_location_info_c& ul_nas_transport_ies_o::value_c::user_location_info() const
{
  assert_choice_type(types::user_location_info, type_, "Value");
  return c.get<user_location_info_c>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::w_agf_id_info() const
{
  assert_choice_type(types::w_agf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::tngf_id_info() const
{
  assert_choice_type(types::tngf_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_nas_transport_ies_o::value_c::twif_id_info() const
{
  assert_choice_type(types::twif_id_info, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ul_nas_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::nas_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::user_location_info:
      j.write_fieldname("UserLocationInformation");
      c.get<user_location_info_c>().to_json(j);
      break;
    case types::w_agf_id_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::tngf_id_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::twif_id_info:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_nas_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().pack(bref));
      break;
    case types::w_agf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::tngf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::twif_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_nas_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::nas_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::user_location_info:
      HANDLE_CODE(c.get<user_location_info_c>().unpack(bref));
      break;
    case types::w_agf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::tngf_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::twif_id_info:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_nas_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UplinkNonUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_non_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {89, 46};
  return map_enum_number(names, 2, idx, "id");
}
bool ul_non_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_non_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_non_ue_associated_nrppa_transport_ies_o::value_c
ul_non_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_non_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_non_ue_associated_nrppa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::routing_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ul_non_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::routing_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
ul_non_ue_associated_nrppa_transport_ies_o::value_c::value_c(
    const ul_non_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::routing_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
ul_non_ue_associated_nrppa_transport_ies_o::value_c& ul_non_ue_associated_nrppa_transport_ies_o::value_c::operator=(
    const ul_non_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::routing_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }

  return *this;
}
unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_non_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ul_non_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_non_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UplinkRANConfigurationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ran_cfg_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {99, 158, 251};
  return map_enum_number(names, 3, idx, "id");
}
bool ul_ran_cfg_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {99, 158, 251};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ran_cfg_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 99:
      return crit_e::ignore;
    case 158:
      return crit_e::ignore;
    case 251:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ran_cfg_transfer_ies_o::value_c ul_ran_cfg_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 99:
      ret.set(value_c::types::son_cfg_transfer_ul);
      break;
    case 158:
      ret.set(value_c::types::endc_son_cfg_transfer_ul);
      break;
    case 251:
      ret.set(value_c::types::intersys_son_cfg_transfer_ul);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ran_cfg_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 99:
      return presence_e::optional;
    case 158:
      return presence_e::optional;
    case 251:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ran_cfg_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::son_cfg_transfer_ul:
      c.destroy<son_cfg_transfer_s>();
      break;
    case types::endc_son_cfg_transfer_ul:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::intersys_son_cfg_transfer_ul:
      c.destroy<intersys_son_cfg_transfer_s>();
      break;
    default:
      break;
  }
}
void ul_ran_cfg_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::son_cfg_transfer_ul:
      c.init<son_cfg_transfer_s>();
      break;
    case types::endc_son_cfg_transfer_ul:
      c.init<unbounded_octstring<true>>();
      break;
    case types::intersys_son_cfg_transfer_ul:
      c.init<intersys_son_cfg_transfer_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }
}
ul_ran_cfg_transfer_ies_o::value_c::value_c(const ul_ran_cfg_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::son_cfg_transfer_ul:
      c.init(other.c.get<son_cfg_transfer_s>());
      break;
    case types::endc_son_cfg_transfer_ul:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::intersys_son_cfg_transfer_ul:
      c.init(other.c.get<intersys_son_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }
}
ul_ran_cfg_transfer_ies_o::value_c&
ul_ran_cfg_transfer_ies_o::value_c::operator=(const ul_ran_cfg_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::son_cfg_transfer_ul:
      c.set(other.c.get<son_cfg_transfer_s>());
      break;
    case types::endc_son_cfg_transfer_ul:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::intersys_son_cfg_transfer_ul:
      c.set(other.c.get<intersys_son_cfg_transfer_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }

  return *this;
}
son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_ul()
{
  assert_choice_type(types::son_cfg_transfer_ul, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
unbounded_octstring<true>& ul_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_ul()
{
  assert_choice_type(types::endc_son_cfg_transfer_ul, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
intersys_son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_ul()
{
  assert_choice_type(types::intersys_son_cfg_transfer_ul, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
const son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::son_cfg_transfer_ul() const
{
  assert_choice_type(types::son_cfg_transfer_ul, type_, "Value");
  return c.get<son_cfg_transfer_s>();
}
const unbounded_octstring<true>& ul_ran_cfg_transfer_ies_o::value_c::endc_son_cfg_transfer_ul() const
{
  assert_choice_type(types::endc_son_cfg_transfer_ul, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const intersys_son_cfg_transfer_s& ul_ran_cfg_transfer_ies_o::value_c::intersys_son_cfg_transfer_ul() const
{
  assert_choice_type(types::intersys_son_cfg_transfer_ul, type_, "Value");
  return c.get<intersys_son_cfg_transfer_s>();
}
void ul_ran_cfg_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::son_cfg_transfer_ul:
      j.write_fieldname("SONConfigurationTransfer");
      c.get<son_cfg_transfer_s>().to_json(j);
      break;
    case types::endc_son_cfg_transfer_ul:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::intersys_son_cfg_transfer_ul:
      j.write_fieldname("IntersystemSONConfigurationTransfer");
      c.get<intersys_son_cfg_transfer_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ran_cfg_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_ul:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().pack(bref));
      break;
    case types::endc_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::intersys_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_cfg_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::son_cfg_transfer_ul:
      HANDLE_CODE(c.get<son_cfg_transfer_s>().unpack(bref));
      break;
    case types::endc_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::intersys_son_cfg_transfer_ul:
      HANDLE_CODE(c.get<intersys_son_cfg_transfer_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_cfg_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UplinkRANEarlyStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ran_early_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 268};
  return map_enum_number(names, 3, idx, "id");
}
bool ul_ran_early_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 268};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ran_early_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 268:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ran_early_status_transfer_ies_o::value_c ul_ran_early_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 268:
      ret.set(value_c::types::early_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ran_early_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 268:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ran_early_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::early_status_transfer_transparent_container:
      c.destroy<early_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void ul_ran_early_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::early_status_transfer_transparent_container:
      c.init<early_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }
}
ul_ran_early_status_transfer_ies_o::value_c::value_c(const ul_ran_early_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      c.init(other.c.get<early_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }
}
ul_ran_early_status_transfer_ies_o::value_c&
ul_ran_early_status_transfer_ies_o::value_c::operator=(const ul_ran_early_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      c.set(other.c.get<early_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
early_status_transfer_transparent_container_s&
ul_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container()
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
const uint64_t& ul_ran_early_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_ran_early_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const early_status_transfer_transparent_container_s&
ul_ran_early_status_transfer_ies_o::value_c::early_status_transfer_transparent_container() const
{
  assert_choice_type(types::early_status_transfer_transparent_container, type_, "Value");
  return c.get<early_status_transfer_transparent_container_s>();
}
void ul_ran_early_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::early_status_transfer_transparent_container:
      j.write_fieldname("EarlyStatusTransfer-TransparentContainer");
      c.get<early_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ran_early_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_early_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::early_status_transfer_transparent_container:
      HANDLE_CODE(c.get<early_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_early_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UplinkRANStatusTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ran_status_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 84};
  return map_enum_number(names, 3, idx, "id");
}
bool ul_ran_status_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 84};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ran_status_transfer_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 84:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ran_status_transfer_ies_o::value_c ul_ran_status_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 84:
      ret.set(value_c::types::ran_status_transfer_transparent_container);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ran_status_transfer_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 84:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ran_status_transfer_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::ran_status_transfer_transparent_container:
      c.destroy<ran_status_transfer_transparent_container_s>();
      break;
    default:
      break;
  }
}
void ul_ran_status_transfer_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::ran_status_transfer_transparent_container:
      c.init<ran_status_transfer_transparent_container_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }
}
ul_ran_status_transfer_ies_o::value_c::value_c(const ul_ran_status_transfer_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      c.init(other.c.get<ran_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }
}
ul_ran_status_transfer_ies_o::value_c&
ul_ran_status_transfer_ies_o::value_c::operator=(const ul_ran_status_transfer_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      c.set(other.c.get<ran_status_transfer_transparent_container_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
ran_status_transfer_transparent_container_s&
ul_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container()
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
const uint64_t& ul_ran_status_transfer_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_ran_status_transfer_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const ran_status_transfer_transparent_container_s&
ul_ran_status_transfer_ies_o::value_c::ran_status_transfer_transparent_container() const
{
  assert_choice_type(types::ran_status_transfer_transparent_container, type_, "Value");
  return c.get<ran_status_transfer_transparent_container_s>();
}
void ul_ran_status_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::ran_status_transfer_transparent_container:
      j.write_fieldname("RANStatusTransfer-TransparentContainer");
      c.get<ran_status_transfer_transparent_container_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ran_status_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_status_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::ran_status_transfer_transparent_container:
      HANDLE_CODE(c.get<ran_status_transfer_transparent_container_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ran_status_transfer_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// UplinkRIMInformationTransferIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_rim_info_transfer_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {175};
  return map_enum_number(names, 1, idx, "id");
}
bool ul_rim_info_transfer_ies_o::is_id_valid(const uint32_t& id)
{
  return 175 == id;
}
crit_e ul_rim_info_transfer_ies_o::get_crit(const uint32_t& id)
{
  if (id == 175) {
    return crit_e::ignore;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}
ul_rim_info_transfer_ies_o::value_c ul_rim_info_transfer_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  if (id != 175) {
    asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_rim_info_transfer_ies_o::get_presence(const uint32_t& id)
{
  if (id == 175) {
    return presence_e::optional;
  }
  asn1::log_error("The id={} is not recognized", id);
  return {};
}

// Value ::= OPEN TYPE
void ul_rim_info_transfer_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_fieldname("RIMInformationTransfer");
  c.to_json(j);
  j.end_obj();
}
SRSASN_CODE ul_rim_info_transfer_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.pack(bref));
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_rim_info_transfer_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  HANDLE_CODE(c.unpack(bref));
  return SRSASN_SUCCESS;
}

// UplinkUEAssociatedNRPPaTransportIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t ul_ue_associated_nrppa_transport_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  return map_enum_number(names, 4, idx, "id");
}
bool ul_ue_associated_nrppa_transport_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {10, 85, 89, 46};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e ul_ue_associated_nrppa_transport_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 10:
      return crit_e::reject;
    case 85:
      return crit_e::reject;
    case 89:
      return crit_e::reject;
    case 46:
      return crit_e::reject;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
ul_ue_associated_nrppa_transport_ies_o::value_c ul_ue_associated_nrppa_transport_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 10:
      ret.set(value_c::types::amf_ue_ngap_id);
      break;
    case 85:
      ret.set(value_c::types::ran_ue_ngap_id);
      break;
    case 89:
      ret.set(value_c::types::routing_id);
      break;
    case 46:
      ret.set(value_c::types::nrppa_pdu);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e ul_ue_associated_nrppa_transport_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 10:
      return presence_e::mandatory;
    case 85:
      return presence_e::mandatory;
    case 89:
      return presence_e::mandatory;
    case 46:
      return presence_e::mandatory;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void ul_ue_associated_nrppa_transport_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::routing_id:
      c.destroy<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.destroy<unbounded_octstring<true>>();
      break;
    default:
      break;
  }
}
void ul_ue_associated_nrppa_transport_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::amf_ue_ngap_id:
      break;
    case types::ran_ue_ngap_id:
      break;
    case types::routing_id:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nrppa_pdu:
      c.init<unbounded_octstring<true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
ul_ue_associated_nrppa_transport_ies_o::value_c::value_c(const ul_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.init(other.c.get<uint64_t>());
      break;
    case types::routing_id:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.init(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }
}
ul_ue_associated_nrppa_transport_ies_o::value_c&
ul_ue_associated_nrppa_transport_ies_o::value_c::operator=(const ul_ue_associated_nrppa_transport_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::amf_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      c.set(other.c.get<uint64_t>());
      break;
    case types::routing_id:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nrppa_pdu:
      c.set(other.c.get<unbounded_octstring<true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }

  return *this;
}
uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id()
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id()
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::routing_id()
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu()
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::amf_ue_ngap_id() const
{
  assert_choice_type(types::amf_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const uint64_t& ul_ue_associated_nrppa_transport_ies_o::value_c::ran_ue_ngap_id() const
{
  assert_choice_type(types::ran_ue_ngap_id, type_, "Value");
  return c.get<uint64_t>();
}
const unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::routing_id() const
{
  assert_choice_type(types::routing_id, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
const unbounded_octstring<true>& ul_ue_associated_nrppa_transport_ies_o::value_c::nrppa_pdu() const
{
  assert_choice_type(types::nrppa_pdu, type_, "Value");
  return c.get<unbounded_octstring<true>>();
}
void ul_ue_associated_nrppa_transport_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::amf_ue_ngap_id:
      j.write_int("INTEGER (0..1099511627775)", c.get<uint64_t>());
      break;
    case types::ran_ue_ngap_id:
      j.write_int("INTEGER (0..4294967295)", c.get<uint64_t>());
      break;
    case types::routing_id:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    case types::nrppa_pdu:
      j.write_str("OCTET STRING", c.get<unbounded_octstring<true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(pack_integer(bref, c.get<uint64_t>(), (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::amf_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
      break;
    case types::ran_ue_ngap_id:
      HANDLE_CODE(unpack_integer(c.get<uint64_t>(), bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
      break;
    case types::routing_id:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    case types::nrppa_pdu:
      HANDLE_CODE(c.get<unbounded_octstring<true>>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "ul_ue_associated_nrppa_transport_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// WriteReplaceWarningRequestIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t write_replace_warning_request_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 122, 87, 47, 125, 124, 20, 123, 17, 141};
  return map_enum_number(names, 11, idx, "id");
}
bool write_replace_warning_request_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 122, 87, 47, 125, 124, 20, 123, 17, 141};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e write_replace_warning_request_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 122:
      return crit_e::ignore;
    case 87:
      return crit_e::reject;
    case 47:
      return crit_e::reject;
    case 125:
      return crit_e::ignore;
    case 124:
      return crit_e::ignore;
    case 20:
      return crit_e::ignore;
    case 123:
      return crit_e::ignore;
    case 17:
      return crit_e::reject;
    case 141:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
write_replace_warning_request_ies_o::value_c write_replace_warning_request_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 122:
      ret.set(value_c::types::warning_area_list);
      break;
    case 87:
      ret.set(value_c::types::repeat_period);
      break;
    case 47:
      ret.set(value_c::types::nof_broadcasts_requested);
      break;
    case 125:
      ret.set(value_c::types::warning_type);
      break;
    case 124:
      ret.set(value_c::types::warning_security_info);
      break;
    case 20:
      ret.set(value_c::types::data_coding_scheme);
      break;
    case 123:
      ret.set(value_c::types::warning_msg_contents);
      break;
    case 17:
      ret.set(value_c::types::concurrent_warning_msg_ind);
      break;
    case 141:
      ret.set(value_c::types::warning_area_coordinates);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e write_replace_warning_request_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 122:
      return presence_e::optional;
    case 87:
      return presence_e::mandatory;
    case 47:
      return presence_e::mandatory;
    case 125:
      return presence_e::optional;
    case 124:
      return presence_e::optional;
    case 20:
      return presence_e::optional;
    case 123:
      return presence_e::optional;
    case 17:
      return presence_e::optional;
    case 141:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void write_replace_warning_request_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::warning_area_list:
      c.destroy<warning_area_list_c>();
      break;
    case types::warning_type:
      c.destroy<fixed_octstring<2, true>>();
      break;
    case types::warning_security_info:
      c.destroy<fixed_octstring<50, true>>();
      break;
    case types::data_coding_scheme:
      c.destroy<fixed_bitstring<8, false, true>>();
      break;
    case types::warning_msg_contents:
      c.destroy<bounded_octstring<1, 9600, true>>();
      break;
    case types::warning_area_coordinates:
      c.destroy<bounded_octstring<1, 1024, true>>();
      break;
    default:
      break;
  }
}
void write_replace_warning_request_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::warning_area_list:
      c.init<warning_area_list_c>();
      break;
    case types::repeat_period:
      break;
    case types::nof_broadcasts_requested:
      break;
    case types::warning_type:
      c.init<fixed_octstring<2, true>>();
      break;
    case types::warning_security_info:
      c.init<fixed_octstring<50, true>>();
      break;
    case types::data_coding_scheme:
      c.init<fixed_bitstring<8, false, true>>();
      break;
    case types::warning_msg_contents:
      c.init<bounded_octstring<1, 9600, true>>();
      break;
    case types::concurrent_warning_msg_ind:
      break;
    case types::warning_area_coordinates:
      c.init<bounded_octstring<1, 1024, true>>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
}
write_replace_warning_request_ies_o::value_c::value_c(const write_replace_warning_request_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::warning_area_list:
      c.init(other.c.get<warning_area_list_c>());
      break;
    case types::repeat_period:
      c.init(other.c.get<uint32_t>());
      break;
    case types::nof_broadcasts_requested:
      c.init(other.c.get<uint32_t>());
      break;
    case types::warning_type:
      c.init(other.c.get<fixed_octstring<2, true>>());
      break;
    case types::warning_security_info:
      c.init(other.c.get<fixed_octstring<50, true>>());
      break;
    case types::data_coding_scheme:
      c.init(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::warning_msg_contents:
      c.init(other.c.get<bounded_octstring<1, 9600, true>>());
      break;
    case types::concurrent_warning_msg_ind:
      c.init(other.c.get<concurrent_warning_msg_ind_e>());
      break;
    case types::warning_area_coordinates:
      c.init(other.c.get<bounded_octstring<1, 1024, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
}
write_replace_warning_request_ies_o::value_c&
write_replace_warning_request_ies_o::value_c::operator=(const write_replace_warning_request_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::warning_area_list:
      c.set(other.c.get<warning_area_list_c>());
      break;
    case types::repeat_period:
      c.set(other.c.get<uint32_t>());
      break;
    case types::nof_broadcasts_requested:
      c.set(other.c.get<uint32_t>());
      break;
    case types::warning_type:
      c.set(other.c.get<fixed_octstring<2, true>>());
      break;
    case types::warning_security_info:
      c.set(other.c.get<fixed_octstring<50, true>>());
      break;
    case types::data_coding_scheme:
      c.set(other.c.get<fixed_bitstring<8, false, true>>());
      break;
    case types::warning_msg_contents:
      c.set(other.c.get<bounded_octstring<1, 9600, true>>());
      break;
    case types::concurrent_warning_msg_ind:
      c.set(other.c.get<concurrent_warning_msg_ind_e>());
      break;
    case types::warning_area_coordinates:
      c.set(other.c.get<bounded_octstring<1, 1024, true>>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
warning_area_list_c& write_replace_warning_request_ies_o::value_c::warning_area_list()
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
uint32_t& write_replace_warning_request_ies_o::value_c::repeat_period()
{
  assert_choice_type(types::repeat_period, type_, "Value");
  return c.get<uint32_t>();
}
uint32_t& write_replace_warning_request_ies_o::value_c::nof_broadcasts_requested()
{
  assert_choice_type(types::nof_broadcasts_requested, type_, "Value");
  return c.get<uint32_t>();
}
fixed_octstring<2, true>& write_replace_warning_request_ies_o::value_c::warning_type()
{
  assert_choice_type(types::warning_type, type_, "Value");
  return c.get<fixed_octstring<2, true>>();
}
fixed_octstring<50, true>& write_replace_warning_request_ies_o::value_c::warning_security_info()
{
  assert_choice_type(types::warning_security_info, type_, "Value");
  return c.get<fixed_octstring<50, true>>();
}
fixed_bitstring<8, false, true>& write_replace_warning_request_ies_o::value_c::data_coding_scheme()
{
  assert_choice_type(types::data_coding_scheme, type_, "Value");
  return c.get<fixed_bitstring<8, false, true>>();
}
bounded_octstring<1, 9600, true>& write_replace_warning_request_ies_o::value_c::warning_msg_contents()
{
  assert_choice_type(types::warning_msg_contents, type_, "Value");
  return c.get<bounded_octstring<1, 9600, true>>();
}
concurrent_warning_msg_ind_e& write_replace_warning_request_ies_o::value_c::concurrent_warning_msg_ind()
{
  assert_choice_type(types::concurrent_warning_msg_ind, type_, "Value");
  return c.get<concurrent_warning_msg_ind_e>();
}
bounded_octstring<1, 1024, true>& write_replace_warning_request_ies_o::value_c::warning_area_coordinates()
{
  assert_choice_type(types::warning_area_coordinates, type_, "Value");
  return c.get<bounded_octstring<1, 1024, true>>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_request_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const warning_area_list_c& write_replace_warning_request_ies_o::value_c::warning_area_list() const
{
  assert_choice_type(types::warning_area_list, type_, "Value");
  return c.get<warning_area_list_c>();
}
const uint32_t& write_replace_warning_request_ies_o::value_c::repeat_period() const
{
  assert_choice_type(types::repeat_period, type_, "Value");
  return c.get<uint32_t>();
}
const uint32_t& write_replace_warning_request_ies_o::value_c::nof_broadcasts_requested() const
{
  assert_choice_type(types::nof_broadcasts_requested, type_, "Value");
  return c.get<uint32_t>();
}
const fixed_octstring<2, true>& write_replace_warning_request_ies_o::value_c::warning_type() const
{
  assert_choice_type(types::warning_type, type_, "Value");
  return c.get<fixed_octstring<2, true>>();
}
const fixed_octstring<50, true>& write_replace_warning_request_ies_o::value_c::warning_security_info() const
{
  assert_choice_type(types::warning_security_info, type_, "Value");
  return c.get<fixed_octstring<50, true>>();
}
const fixed_bitstring<8, false, true>& write_replace_warning_request_ies_o::value_c::data_coding_scheme() const
{
  assert_choice_type(types::data_coding_scheme, type_, "Value");
  return c.get<fixed_bitstring<8, false, true>>();
}
const bounded_octstring<1, 9600, true>& write_replace_warning_request_ies_o::value_c::warning_msg_contents() const
{
  assert_choice_type(types::warning_msg_contents, type_, "Value");
  return c.get<bounded_octstring<1, 9600, true>>();
}
const concurrent_warning_msg_ind_e& write_replace_warning_request_ies_o::value_c::concurrent_warning_msg_ind() const
{
  assert_choice_type(types::concurrent_warning_msg_ind, type_, "Value");
  return c.get<concurrent_warning_msg_ind_e>();
}
const bounded_octstring<1, 1024, true>& write_replace_warning_request_ies_o::value_c::warning_area_coordinates() const
{
  assert_choice_type(types::warning_area_coordinates, type_, "Value");
  return c.get<bounded_octstring<1, 1024, true>>();
}
void write_replace_warning_request_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::warning_area_list:
      j.write_fieldname("WarningAreaList");
      c.get<warning_area_list_c>().to_json(j);
      break;
    case types::repeat_period:
      j.write_int("INTEGER (0..131071)", c.get<uint32_t>());
      break;
    case types::nof_broadcasts_requested:
      j.write_int("INTEGER (0..65535)", c.get<uint32_t>());
      break;
    case types::warning_type:
      j.write_str("OCTET STRING", c.get<fixed_octstring<2, true>>().to_string());
      break;
    case types::warning_security_info:
      j.write_str("OCTET STRING", c.get<fixed_octstring<50, true>>().to_string());
      break;
    case types::data_coding_scheme:
      j.write_str("BIT STRING", c.get<fixed_bitstring<8, false, true>>().to_string());
      break;
    case types::warning_msg_contents:
      j.write_str("OCTET STRING", c.get<bounded_octstring<1, 9600, true>>().to_string());
      break;
    case types::concurrent_warning_msg_ind:
      j.write_str("ConcurrentWarningMessageInd", "true");
      break;
    case types::warning_area_coordinates:
      j.write_str("OCTET STRING", c.get<bounded_octstring<1, 1024, true>>().to_string());
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE write_replace_warning_request_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().pack(bref));
      break;
    case types::repeat_period:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)131071u, false, true));
      break;
    case types::nof_broadcasts_requested:
      HANDLE_CODE(pack_integer(bref, c.get<uint32_t>(), (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::warning_type:
      HANDLE_CODE((c.get<fixed_octstring<2, true>>().pack(bref)));
      break;
    case types::warning_security_info:
      HANDLE_CODE((c.get<fixed_octstring<50, true>>().pack(bref)));
      break;
    case types::data_coding_scheme:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().pack(bref)));
      break;
    case types::warning_msg_contents:
      HANDLE_CODE((c.get<bounded_octstring<1, 9600, true>>().pack(bref)));
      break;
    case types::concurrent_warning_msg_ind:
      HANDLE_CODE(c.get<concurrent_warning_msg_ind_e>().pack(bref));
      break;
    case types::warning_area_coordinates:
      HANDLE_CODE((c.get<bounded_octstring<1, 1024, true>>().pack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_request_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::warning_area_list:
      HANDLE_CODE(c.get<warning_area_list_c>().unpack(bref));
      break;
    case types::repeat_period:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)131071u, false, true));
      break;
    case types::nof_broadcasts_requested:
      HANDLE_CODE(unpack_integer(c.get<uint32_t>(), bref, (uint32_t)0u, (uint32_t)65535u, false, true));
      break;
    case types::warning_type:
      HANDLE_CODE((c.get<fixed_octstring<2, true>>().unpack(bref)));
      break;
    case types::warning_security_info:
      HANDLE_CODE((c.get<fixed_octstring<50, true>>().unpack(bref)));
      break;
    case types::data_coding_scheme:
      HANDLE_CODE((c.get<fixed_bitstring<8, false, true>>().unpack(bref)));
      break;
    case types::warning_msg_contents:
      HANDLE_CODE((c.get<bounded_octstring<1, 9600, true>>().unpack(bref)));
      break;
    case types::concurrent_warning_msg_ind:
      HANDLE_CODE(c.get<concurrent_warning_msg_ind_e>().unpack(bref));
      break;
    case types::warning_area_coordinates:
      HANDLE_CODE((c.get<bounded_octstring<1, 1024, true>>().unpack(bref)));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_request_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

// WriteReplaceWarningResponseIEs ::= OBJECT SET OF NGAP-PROTOCOL-IES
uint32_t write_replace_warning_resp_ies_o::idx_to_id(uint32_t idx)
{
  static const uint32_t names[] = {35, 95, 13, 19};
  return map_enum_number(names, 4, idx, "id");
}
bool write_replace_warning_resp_ies_o::is_id_valid(const uint32_t& id)
{
  static const uint32_t names[] = {35, 95, 13, 19};
  for (const auto& o : names) {
    if (o == id) {
      return true;
    }
  }
  return false;
}
crit_e write_replace_warning_resp_ies_o::get_crit(const uint32_t& id)
{
  switch (id) {
    case 35:
      return crit_e::reject;
    case 95:
      return crit_e::reject;
    case 13:
      return crit_e::ignore;
    case 19:
      return crit_e::ignore;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}
write_replace_warning_resp_ies_o::value_c write_replace_warning_resp_ies_o::get_value(const uint32_t& id)
{
  value_c ret{};
  switch (id) {
    case 35:
      ret.set(value_c::types::msg_id);
      break;
    case 95:
      ret.set(value_c::types::serial_num);
      break;
    case 13:
      ret.set(value_c::types::broadcast_completed_area_list);
      break;
    case 19:
      ret.set(value_c::types::crit_diagnostics);
      break;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return ret;
}
presence_e write_replace_warning_resp_ies_o::get_presence(const uint32_t& id)
{
  switch (id) {
    case 35:
      return presence_e::mandatory;
    case 95:
      return presence_e::mandatory;
    case 13:
      return presence_e::optional;
    case 19:
      return presence_e::optional;
    default:
      asn1::log_error("The id={} is not recognized", id);
  }
  return {};
}

// Value ::= OPEN TYPE
void write_replace_warning_resp_ies_o::value_c::destroy_()
{
  switch (type_) {
    case types::msg_id:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.destroy<fixed_bitstring<16, false, true>>();
      break;
    case types::broadcast_completed_area_list:
      c.destroy<broadcast_completed_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.destroy<crit_diagnostics_s>();
      break;
    default:
      break;
  }
}
void write_replace_warning_resp_ies_o::value_c::set(types::options e)
{
  destroy_();
  type_ = e;
  switch (type_) {
    case types::msg_id:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::serial_num:
      c.init<fixed_bitstring<16, false, true>>();
      break;
    case types::broadcast_completed_area_list:
      c.init<broadcast_completed_area_list_c>();
      break;
    case types::crit_diagnostics:
      c.init<crit_diagnostics_s>();
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
}
write_replace_warning_resp_ies_o::value_c::value_c(const write_replace_warning_resp_ies_o::value_c& other)
{
  type_ = other.type();
  switch (type_) {
    case types::msg_id:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.init(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::broadcast_completed_area_list:
      c.init(other.c.get<broadcast_completed_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.init(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
}
write_replace_warning_resp_ies_o::value_c&
write_replace_warning_resp_ies_o::value_c::operator=(const write_replace_warning_resp_ies_o::value_c& other)
{
  if (this == &other) {
    return *this;
  }
  set(other.type());
  switch (type_) {
    case types::msg_id:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::serial_num:
      c.set(other.c.get<fixed_bitstring<16, false, true>>());
      break;
    case types::broadcast_completed_area_list:
      c.set(other.c.get<broadcast_completed_area_list_c>());
      break;
    case types::crit_diagnostics:
      c.set(other.c.get<crit_diagnostics_s>());
      break;
    case types::nulltype:
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }

  return *this;
}
fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::msg_id()
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::serial_num()
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
broadcast_completed_area_list_c& write_replace_warning_resp_ies_o::value_c::broadcast_completed_area_list()
{
  assert_choice_type(types::broadcast_completed_area_list, type_, "Value");
  return c.get<broadcast_completed_area_list_c>();
}
crit_diagnostics_s& write_replace_warning_resp_ies_o::value_c::crit_diagnostics()
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::msg_id() const
{
  assert_choice_type(types::msg_id, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const fixed_bitstring<16, false, true>& write_replace_warning_resp_ies_o::value_c::serial_num() const
{
  assert_choice_type(types::serial_num, type_, "Value");
  return c.get<fixed_bitstring<16, false, true>>();
}
const broadcast_completed_area_list_c& write_replace_warning_resp_ies_o::value_c::broadcast_completed_area_list() const
{
  assert_choice_type(types::broadcast_completed_area_list, type_, "Value");
  return c.get<broadcast_completed_area_list_c>();
}
const crit_diagnostics_s& write_replace_warning_resp_ies_o::value_c::crit_diagnostics() const
{
  assert_choice_type(types::crit_diagnostics, type_, "Value");
  return c.get<crit_diagnostics_s>();
}
void write_replace_warning_resp_ies_o::value_c::to_json(json_writer& j) const
{
  j.start_obj();
  switch (type_) {
    case types::msg_id:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::serial_num:
      j.write_str("BIT STRING", c.get<fixed_bitstring<16, false, true>>().to_string());
      break;
    case types::broadcast_completed_area_list:
      j.write_fieldname("BroadcastCompletedAreaList");
      c.get<broadcast_completed_area_list_c>().to_json(j);
      break;
    case types::crit_diagnostics:
      j.write_fieldname("CriticalityDiagnostics");
      c.get<crit_diagnostics_s>().to_json(j);
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
  }
  j.end_obj();
}
SRSASN_CODE write_replace_warning_resp_ies_o::value_c::pack(bit_ref& bref) const
{
  varlength_field_pack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().pack(bref)));
      break;
    case types::broadcast_completed_area_list:
      HANDLE_CODE(c.get<broadcast_completed_area_list_c>().pack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().pack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
      return SRSASN_ERROR_ENCODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_resp_ies_o::value_c::unpack(cbit_ref& bref)
{
  varlength_field_unpack_guard varlen_scope(bref, true);
  switch (type_) {
    case types::msg_id:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::serial_num:
      HANDLE_CODE((c.get<fixed_bitstring<16, false, true>>().unpack(bref)));
      break;
    case types::broadcast_completed_area_list:
      HANDLE_CODE(c.get<broadcast_completed_area_list_c>().unpack(bref));
      break;
    case types::crit_diagnostics:
      HANDLE_CODE(c.get<crit_diagnostics_s>().unpack(bref));
      break;
    default:
      log_invalid_choice_id(type_, "write_replace_warning_resp_ies_o::value_c");
      return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}

SRSASN_CODE location_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += ue_presence_in_area_of_interest_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (ue_presence_in_area_of_interest_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)116, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_presence_in_area_of_interest_list, 1, 64, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)33, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(location_report_request_type.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 116: {
        ue_presence_in_area_of_interest_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ue_presence_in_area_of_interest_list, bref, 1, 64, true));
        break;
      }
      case 33: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 121);
  j.write_str("criticality", "ignore");
  user_location_info.to_json(j);
  if (ue_presence_in_area_of_interest_list_present) {
    j.write_int("id", 116);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : ue_presence_in_area_of_interest_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 33);
  j.write_str("criticality", "ignore");
  location_report_request_type.to_json(j);
  j.end_obj();
}

SRSASN_CODE location_report_ctrl_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)33, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(location_report_request_type.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_ctrl_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 33: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(location_report_request_type.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_ctrl_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 33);
  j.write_str("criticality", "ignore");
  location_report_request_type.to_json(j);
  j.end_obj();
}

SRSASN_CODE location_report_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE location_report_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void location_report_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

SRSASN_CODE multicast_group_paging_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_service_area_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_service_area_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)298, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_service_area.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)307, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, multicast_group_paging_area_list, 1, 64, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_group_paging_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 298: {
        mbs_service_area_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_service_area.unpack(bref));
        break;
      }
      case 307: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(multicast_group_paging_area_list, bref, 1, 64, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_group_paging_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "ignore");
  mbs_session_id.to_json(j);
  if (mbs_service_area_present) {
    j.write_int("id", 298);
    j.write_str("criticality", "ignore");
    mbs_service_area.to_json(j);
  }
  j.write_int("id", 307);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : multicast_group_paging_area_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}

SRSASN_CODE multicast_session_activation_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_activation_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE multicast_session_activation_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)304, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(multicast_session_activation_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 304: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_session_activation_request_transfer.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_activation_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  j.write_int("id", 304);
  j.write_str("criticality", "reject");
  j.write_str("Value", multicast_session_activation_request_transfer.to_string());
  j.end_obj();
}

SRSASN_CODE multicast_session_activation_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_activation_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_activation_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE multicast_session_deactivation_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)305, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(multicast_session_deactivation_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 305: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_session_deactivation_request_transfer.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_deactivation_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  j.write_int("id", 305);
  j.write_str("criticality", "reject");
  j.write_str("Value", multicast_session_deactivation_request_transfer.to_string());
  j.end_obj();
}

SRSASN_CODE multicast_session_deactivation_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_deactivation_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_deactivation_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE multicast_session_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE multicast_session_upd_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)306, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(multicast_session_upd_request_transfer.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 306: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(multicast_session_upd_request_transfer.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  j.write_int("id", 306);
  j.write_str("criticality", "reject");
  j.write_str("Value", multicast_session_upd_request_transfer.to_string());
  j.end_obj();
}

SRSASN_CODE multicast_session_upd_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += mbs_area_session_id_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)299, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(mbs_session_id.pack(bref));
  }
  if (mbs_area_session_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)295, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, mbs_area_session_id, (uint32_t)0u, (uint32_t)65535u, true, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE multicast_session_upd_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 299: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(mbs_session_id.unpack(bref));
        break;
      }
      case 295: {
        mbs_area_session_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(mbs_area_session_id, bref, (uint32_t)0u, (uint32_t)65535u, true, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void multicast_session_upd_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 299);
  j.write_str("criticality", "reject");
  mbs_session_id.to_json(j);
  if (mbs_area_session_id_present) {
    j.write_int("id", 295);
    j.write_str("criticality", "reject");
    j.write_int("Value", mbs_area_session_id);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE nas_non_delivery_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE nas_non_delivery_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void nas_non_delivery_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 38);
  j.write_str("criticality", "ignore");
  j.write_str("Value", nas_pdu.to_string());
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

SRSASN_CODE ng_reset_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)88, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(reset_type.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 88: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(reset_type.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_reset_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.write_int("id", 88);
  j.write_str("criticality", "reject");
  reset_type.to_json(j);
  j.end_obj();
}

SRSASN_CODE ng_reset_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ue_associated_lc_ng_conn_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (ue_associated_lc_ng_conn_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)111, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_associated_lc_ng_conn_list, 1, 65536, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_reset_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 111: {
        ue_associated_lc_ng_conn_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ue_associated_lc_ng_conn_list, bref, 1, 65536, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ng_reset_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ue_associated_lc_ng_conn_list_present) {
    j.write_int("id", 111);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : ue_associated_lc_ng_conn_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ng_setup_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (time_to_wait_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)107, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 107: {
        time_to_wait_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_to_wait.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_setup_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_int("id", 107);
    j.write_str("criticality", "ignore");
    j.write_str("Value", time_to_wait.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ng_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_node_name_present ? 1 : 0;
  nof_ies += ue_retention_info_present ? 1 : 0;
  nof_ies += nb_iot_default_paging_drx_present ? 1 : 0;
  nof_ies += extended_ran_node_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)27, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  if (ran_node_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)82, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ran_node_name.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)102, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, supported_ta_list, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)21, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(default_paging_drx.pack(bref));
  }
  if (ue_retention_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)147, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_retention_info.pack(bref));
  }
  if (nb_iot_default_paging_drx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)204, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nb_iot_default_paging_drx.pack(bref));
  }
  if (extended_ran_node_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)273, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(extended_ran_node_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 27: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.unpack(bref));
        break;
      }
      case 82: {
        ran_node_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_node_name.unpack(bref));
        break;
      }
      case 102: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(supported_ta_list, bref, 1, 256, true));
        break;
      }
      case 21: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(default_paging_drx.unpack(bref));
        break;
      }
      case 147: {
        ue_retention_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_retention_info.unpack(bref));
        break;
      }
      case 204: {
        nb_iot_default_paging_drx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_default_paging_drx.unpack(bref));
        break;
      }
      case 273: {
        extended_ran_node_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_ran_node_name.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 27);
  j.write_str("criticality", "reject");
  global_ran_node_id.to_json(j);
  if (ran_node_name_present) {
    j.write_int("id", 82);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ran_node_name.to_string());
  }
  j.write_int("id", 102);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : supported_ta_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("id", 21);
  j.write_str("criticality", "ignore");
  j.write_str("Value", default_paging_drx.to_string());
  if (ue_retention_info_present) {
    j.write_int("id", 147);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "ues-retained");
  }
  if (nb_iot_default_paging_drx_present) {
    j.write_int("id", 204);
    j.write_str("criticality", "ignore");
    j.write_str("Value", nb_iot_default_paging_drx.to_string());
  }
  if (extended_ran_node_name_present) {
    j.write_int("id", 273);
    j.write_str("criticality", "ignore");
    extended_ran_node_name.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ng_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += ue_retention_info_present ? 1 : 0;
  nof_ies += iab_supported_present ? 1 : 0;
  nof_ies += extended_amf_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)1, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(amf_name.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)96, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, served_guami_list, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)86, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, relative_amf_capacity, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)80, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, plmn_support_list, 1, 12, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (ue_retention_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)147, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_retention_info.pack(bref));
  }
  if (iab_supported_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)200, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(iab_supported.pack(bref));
  }
  if (extended_amf_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)274, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(extended_amf_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ng_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 1: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_name.unpack(bref));
        break;
      }
      case 96: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(served_guami_list, bref, 1, 256, true));
        break;
      }
      case 86: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(relative_amf_capacity, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 80: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(plmn_support_list, bref, 1, 12, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 147: {
        ue_retention_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_retention_info.unpack(bref));
        break;
      }
      case 200: {
        iab_supported_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_supported.unpack(bref));
        break;
      }
      case 274: {
        extended_amf_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_amf_name.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ng_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 1);
  j.write_str("criticality", "reject");
  j.write_str("Value", amf_name.to_string());
  j.write_int("id", 96);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : served_guami_list) {
    e1.to_json(j);
  }
  j.end_array();
  j.write_int("id", 86);
  j.write_str("criticality", "ignore");
  j.write_int("Value", relative_amf_capacity);
  j.write_int("id", 80);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : plmn_support_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (ue_retention_info_present) {
    j.write_int("id", 147);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "ues-retained");
  }
  if (iab_supported_present) {
    j.write_int("id", 200);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "true");
  }
  if (extended_amf_name_present) {
    j.write_int("id", 274);
    j.write_str("criticality", "ignore");
    extended_amf_name.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE overload_start_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += amf_overload_resp_present ? 1 : 0;
  nof_ies += amf_traffic_load_reduction_ind_present ? 1 : 0;
  nof_ies += overload_start_nssai_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (amf_overload_resp_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)2, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(amf_overload_resp.pack(bref));
  }
  if (amf_traffic_load_reduction_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)9, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_traffic_load_reduction_ind, (uint8_t)1u, (uint8_t)99u, false, true));
  }
  if (overload_start_nssai_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)49, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, overload_start_nssai_list, 1, 1024, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE overload_start_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 2: {
        amf_overload_resp_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_overload_resp.unpack(bref));
        break;
      }
      case 9: {
        amf_traffic_load_reduction_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_traffic_load_reduction_ind, bref, (uint8_t)1u, (uint8_t)99u, false, true));
        break;
      }
      case 49: {
        overload_start_nssai_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(overload_start_nssai_list, bref, 1, 1024, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void overload_start_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (amf_overload_resp_present) {
    j.write_int("id", 2);
    j.write_str("criticality", "reject");
    amf_overload_resp.to_json(j);
  }
  if (amf_traffic_load_reduction_ind_present) {
    j.write_int("id", 9);
    j.write_str("criticality", "ignore");
    j.write_int("Value", amf_traffic_load_reduction_ind);
  }
  if (overload_start_nssai_list_present) {
    j.write_int("id", 49);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : overload_start_nssai_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

SRSASN_CODE pdu_session_res_modify_confirm_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_modify_list_mod_cfm_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_modify_list_mod_cfm_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_modify_list_mod_cfm_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)62, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_modify_list_mod_cfm, 1, 256, true));
  }
  if (pdu_session_res_failed_to_modify_list_mod_cfm_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)131, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_modify_list_mod_cfm, 1, 256, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_confirm_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 62: {
        pdu_session_res_modify_list_mod_cfm_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_modify_list_mod_cfm, bref, 1, 256, true));
        break;
      }
      case 131: {
        pdu_session_res_failed_to_modify_list_mod_cfm_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_modify_list_mod_cfm, bref, 1, 256, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_confirm_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_modify_list_mod_cfm_present) {
    j.write_int("id", 62);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_modify_list_mod_cfm) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_failed_to_modify_list_mod_cfm_present) {
    j.write_int("id", 131);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_modify_list_mod_cfm) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE pdu_session_res_modify_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)63, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_modify_list_mod_ind, 1, 256, true));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 63: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_modify_list_mod_ind, bref, 1, 256, true));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 63);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_modify_list_mod_ind) {
    e1.to_json(j);
  }
  j.end_array();
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE pdu_session_res_modify_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ran_paging_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)83, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_paging_prio, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)64, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_modify_list_mod_req, 1, 256, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_paging_prio, bref, (uint16_t)1u, (uint16_t)256u, false, true));
        break;
      }
      case 64: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_modify_list_mod_req, bref, 1, 256, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (ran_paging_prio_present) {
    j.write_int("id", 83);
    j.write_str("criticality", "ignore");
    j.write_int("Value", ran_paging_prio);
  }
  j.write_int("id", 64);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_modify_list_mod_req) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}

SRSASN_CODE pdu_session_res_modify_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_modify_list_mod_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_modify_list_mod_res_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_modify_list_mod_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)65, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_modify_list_mod_res, 1, 256, true));
  }
  if (pdu_session_res_failed_to_modify_list_mod_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)54, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_modify_list_mod_res, 1, 256, true));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_modify_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 65: {
        pdu_session_res_modify_list_mod_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_modify_list_mod_res, bref, 1, 256, true));
        break;
      }
      case 54: {
        pdu_session_res_failed_to_modify_list_mod_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_modify_list_mod_res, bref, 1, 256, true));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_modify_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_modify_list_mod_res_present) {
    j.write_int("id", 65);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_modify_list_mod_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_failed_to_modify_list_mod_res_present) {
    j.write_int("id", 54);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_modify_list_mod_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE pdu_session_res_notify_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_notify_list_present ? 1 : 0;
  nof_ies += pdu_session_res_released_list_not_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_notify_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)66, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_notify_list, 1, 256, true));
  }
  if (pdu_session_res_released_list_not_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)67, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_released_list_not, 1, 256, true));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_notify_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 66: {
        pdu_session_res_notify_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_notify_list, bref, 1, 256, true));
        break;
      }
      case 67: {
        pdu_session_res_released_list_not_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_released_list_not, bref, 1, 256, true));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_notify_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_notify_list_present) {
    j.write_int("id", 66);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_notify_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_released_list_not_present) {
    j.write_int("id", 67);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_released_list_not) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE pdu_session_res_release_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += nas_pdu_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ran_paging_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)83, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_paging_prio, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (nas_pdu_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)79, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_to_release_list_rel_cmd, 1, 256, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_paging_prio, bref, (uint16_t)1u, (uint16_t)256u, false, true));
        break;
      }
      case 38: {
        nas_pdu_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 79: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_to_release_list_rel_cmd, bref, 1, 256, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_release_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (ran_paging_prio_present) {
    j.write_int("id", 83);
    j.write_str("criticality", "ignore");
    j.write_int("Value", ran_paging_prio);
  }
  if (nas_pdu_present) {
    j.write_int("id", 38);
    j.write_str("criticality", "ignore");
    j.write_str("Value", nas_pdu.to_string());
  }
  j.write_int("id", 79);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_to_release_list_rel_cmd) {
    e1.to_json(j);
  }
  j.end_array();
  j.end_obj();
}

SRSASN_CODE pdu_session_res_release_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)70, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_released_list_rel_res, 1, 256, true));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_release_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 70: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_released_list_rel_res, bref, 1, 256, true));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_release_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 70);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_released_list_rel_res) {
    e1.to_json(j);
  }
  j.end_array();
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE pdu_session_res_setup_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += nas_pdu_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ran_paging_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)83, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_paging_prio, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (nas_pdu_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)74, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_setup_list_su_req, 1, 256, true));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)110, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)335, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_slice_max_bit_rate_list, 1, 8, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_paging_prio, bref, (uint16_t)1u, (uint16_t)256u, false, true));
        break;
      }
      case 38: {
        nas_pdu_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 74: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_setup_list_su_req, bref, 1, 256, true));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ue_slice_max_bit_rate_list, bref, 1, 8, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (ran_paging_prio_present) {
    j.write_int("id", 83);
    j.write_str("criticality", "ignore");
    j.write_int("Value", ran_paging_prio);
  }
  if (nas_pdu_present) {
    j.write_int("id", 38);
    j.write_str("criticality", "reject");
    j.write_str("Value", nas_pdu.to_string());
  }
  j.write_int("id", 74);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_setup_list_su_req) {
    e1.to_json(j);
  }
  j.end_array();
  if (ue_aggr_max_bit_rate_present) {
    j.write_int("id", 110);
    j.write_str("criticality", "ignore");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_int("id", 335);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : ue_slice_max_bit_rate_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

SRSASN_CODE pdu_session_res_setup_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_setup_list_su_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_setup_list_su_res_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_setup_list_su_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)75, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_setup_list_su_res, 1, 256, true));
  }
  if (pdu_session_res_failed_to_setup_list_su_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)58, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_setup_list_su_res, 1, 256, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pdu_session_res_setup_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 75: {
        pdu_session_res_setup_list_su_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_setup_list_su_res, bref, 1, 256, true));
        break;
      }
      case 58: {
        pdu_session_res_failed_to_setup_list_su_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_setup_list_su_res, bref, 1, 256, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pdu_session_res_setup_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_setup_list_su_res_present) {
    j.write_int("id", 75);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_setup_list_su_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_failed_to_setup_list_su_res_present) {
    j.write_int("id", 58);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_setup_list_su_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE pws_cancel_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += warning_area_list_present ? 1 : 0;
  nof_ies += cancel_all_warning_msgs_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)35, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(msg_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)95, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(serial_num.pack(bref));
  }
  if (warning_area_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)122, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(warning_area_list.pack(bref));
  }
  if (cancel_all_warning_msgs_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)14, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cancel_all_warning_msgs.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.unpack(bref));
        break;
      }
      case 122: {
        warning_area_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_area_list.unpack(bref));
        break;
      }
      case 14: {
        cancel_all_warning_msgs_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cancel_all_warning_msgs.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_cancel_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 35);
  j.write_str("criticality", "reject");
  j.write_str("Value", msg_id.to_string());
  j.write_int("id", 95);
  j.write_str("criticality", "reject");
  j.write_str("Value", serial_num.to_string());
  if (warning_area_list_present) {
    j.write_int("id", 122);
    j.write_str("criticality", "ignore");
    warning_area_list.to_json(j);
  }
  if (cancel_all_warning_msgs_present) {
    j.write_int("id", 14);
    j.write_str("criticality", "reject");
    j.write_str("Value", "true");
  }
  j.end_obj();
}

SRSASN_CODE pws_cancel_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += broadcast_cancelled_area_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)35, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(msg_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)95, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(serial_num.pack(bref));
  }
  if (broadcast_cancelled_area_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)12, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(broadcast_cancelled_area_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_cancel_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.unpack(bref));
        break;
      }
      case 12: {
        broadcast_cancelled_area_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(broadcast_cancelled_area_list.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_cancel_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 35);
  j.write_str("criticality", "reject");
  j.write_str("Value", msg_id.to_string());
  j.write_int("id", 95);
  j.write_str("criticality", "reject");
  j.write_str("Value", serial_num.to_string());
  if (broadcast_cancelled_area_list_present) {
    j.write_int("id", 12);
    j.write_str("criticality", "ignore");
    broadcast_cancelled_area_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE pws_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)81, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pws_failed_cell_id_list.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)27, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 81: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pws_failed_cell_id_list.unpack(bref));
        break;
      }
      case 27: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 81);
  j.write_str("criticality", "reject");
  pws_failed_cell_id_list.to_json(j);
  j.write_int("id", 27);
  j.write_str("criticality", "reject");
  global_ran_node_id.to_json(j);
  j.end_obj();
}

SRSASN_CODE pws_restart_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += emergency_area_id_list_for_restart_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)16, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cell_id_list_for_restart.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)27, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)104, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, tai_list_for_restart, 1, 2048, true));
  }
  if (emergency_area_id_list_for_restart_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)23, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, emergency_area_id_list_for_restart, 1, 256, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE pws_restart_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 16: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cell_id_list_for_restart.unpack(bref));
        break;
      }
      case 27: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.unpack(bref));
        break;
      }
      case 104: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(tai_list_for_restart, bref, 1, 2048, true));
        break;
      }
      case 23: {
        emergency_area_id_list_for_restart_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(emergency_area_id_list_for_restart, bref, 1, 256, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void pws_restart_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 16);
  j.write_str("criticality", "reject");
  cell_id_list_for_restart.to_json(j);
  j.write_int("id", 27);
  j.write_str("criticality", "reject");
  global_ran_node_id.to_json(j);
  j.write_int("id", 104);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : tai_list_for_restart) {
    e1.to_json(j);
  }
  j.end_array();
  if (emergency_area_id_list_for_restart_present) {
    j.write_int("id", 23);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : emergency_area_id_list_for_restart) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  j.end_obj();
}

SRSASN_CODE paging_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += paging_drx_present ? 1 : 0;
  nof_ies += paging_prio_present ? 1 : 0;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += paging_origin_present ? 1 : 0;
  nof_ies += assist_data_for_paging_present ? 1 : 0;
  nof_ies += nb_iot_paging_e_drx_info_present ? 1 : 0;
  nof_ies += nb_iot_paging_drx_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += wus_assist_info_present ? 1 : 0;
  nof_ies += eutra_paginge_drx_info_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += nr_paginge_drx_info_present ? 1 : 0;
  nof_ies += paging_cause_present ? 1 : 0;
  nof_ies += pe_ip_sassist_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)115, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_paging_id.pack(bref));
  }
  if (paging_drx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)50, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_drx.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)103, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, tai_list_for_paging, 1, 16, true));
  }
  if (paging_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)52, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_prio.pack(bref));
  }
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)118, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (paging_origin_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)51, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_origin.pack(bref));
  }
  if (assist_data_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)11, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(assist_data_for_paging.pack(bref));
  }
  if (nb_iot_paging_e_drx_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)203, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nb_iot_paging_e_drx_info.pack(bref));
  }
  if (nb_iot_paging_drx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)202, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nb_iot_paging_drx.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)205, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (wus_assist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)208, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(wus_assist_info.pack(bref));
  }
  if (eutra_paginge_drx_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)223, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(eutra_paginge_drx_info.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)222, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (nr_paginge_drx_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)332, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_paginge_drx_info.pack(bref));
  }
  if (paging_cause_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)342, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_cause.pack(bref));
  }
  if (pe_ip_sassist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)344, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pe_ip_sassist_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE paging_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 115: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_paging_id.unpack(bref));
        break;
      }
      case 50: {
        paging_drx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_drx.unpack(bref));
        break;
      }
      case 103: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(tai_list_for_paging, bref, 1, 16, true));
        break;
      }
      case 52: {
        paging_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_prio.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.unpack(bref));
        break;
      }
      case 51: {
        paging_origin_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_origin.unpack(bref));
        break;
      }
      case 11: {
        assist_data_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(assist_data_for_paging.unpack(bref));
        break;
      }
      case 203: {
        nb_iot_paging_e_drx_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_paging_e_drx_info.unpack(bref));
        break;
      }
      case 202: {
        nb_iot_paging_drx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_paging_drx.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.unpack(bref));
        break;
      }
      case 208: {
        wus_assist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(wus_assist_info.unpack(bref));
        break;
      }
      case 223: {
        eutra_paginge_drx_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(eutra_paginge_drx_info.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.unpack(bref));
        break;
      }
      case 332: {
        nr_paginge_drx_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_paginge_drx_info.unpack(bref));
        break;
      }
      case 342: {
        paging_cause_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_cause.unpack(bref));
        break;
      }
      case 344: {
        pe_ip_sassist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pe_ip_sassist_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void paging_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 115);
  j.write_str("criticality", "ignore");
  ue_paging_id.to_json(j);
  if (paging_drx_present) {
    j.write_int("id", 50);
    j.write_str("criticality", "ignore");
    j.write_str("Value", paging_drx.to_string());
  }
  j.write_int("id", 103);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : tai_list_for_paging) {
    e1.to_json(j);
  }
  j.end_array();
  if (paging_prio_present) {
    j.write_int("id", 52);
    j.write_str("criticality", "ignore");
    j.write_str("Value", paging_prio.to_string());
  }
  if (ue_radio_cap_for_paging_present) {
    j.write_int("id", 118);
    j.write_str("criticality", "ignore");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (paging_origin_present) {
    j.write_int("id", 51);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "non-3gpp");
  }
  if (assist_data_for_paging_present) {
    j.write_int("id", 11);
    j.write_str("criticality", "ignore");
    assist_data_for_paging.to_json(j);
  }
  if (nb_iot_paging_e_drx_info_present) {
    j.write_int("id", 203);
    j.write_str("criticality", "ignore");
    nb_iot_paging_e_drx_info.to_json(j);
  }
  if (nb_iot_paging_drx_present) {
    j.write_int("id", 202);
    j.write_str("criticality", "ignore");
    j.write_str("Value", nb_iot_paging_drx.to_string());
  }
  if (enhanced_coverage_restrict_present) {
    j.write_int("id", 205);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "restricted");
  }
  if (wus_assist_info_present) {
    j.write_int("id", 208);
    j.write_str("criticality", "ignore");
    wus_assist_info.to_json(j);
  }
  if (eutra_paginge_drx_info_present) {
    j.write_int("id", 223);
    j.write_str("criticality", "ignore");
    eutra_paginge_drx_info.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_int("id", 222);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ce_mode_brestricted.to_string());
  }
  if (nr_paginge_drx_info_present) {
    j.write_int("id", 332);
    j.write_str("criticality", "ignore");
    nr_paginge_drx_info.to_json(j);
  }
  if (paging_cause_present) {
    j.write_int("id", 342);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "voice");
  }
  if (pe_ip_sassist_info_present) {
    j.write_int("id", 344);
    j.write_str("criticality", "ignore");
    pe_ip_sassist_info.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE path_switch_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += pdu_session_res_failed_to_setup_list_ps_req_present ? 1 : 0;
  nof_ies += rrc_resume_cause_present ? 1 : 0;
  nof_ies += red_cap_ind_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)100, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, source_amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)119, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)76, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_to_be_switched_dl_list, 1, 256, true));
  }
  if (pdu_session_res_failed_to_setup_list_ps_req_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)57, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_setup_list_ps_req, 1, 256, true));
  }
  if (rrc_resume_cause_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)237, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_resume_cause.pack(bref));
  }
  if (red_cap_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)333, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(red_cap_ind.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 100: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(source_amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 119: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.unpack(bref));
        break;
      }
      case 76: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_to_be_switched_dl_list, bref, 1, 256, true));
        break;
      }
      case 57: {
        pdu_session_res_failed_to_setup_list_ps_req_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_setup_list_ps_req, bref, 1, 256, true));
        break;
      }
      case 237: {
        rrc_resume_cause_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_resume_cause.unpack(bref));
        break;
      }
      case 333: {
        red_cap_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(red_cap_ind.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 100);
  j.write_str("criticality", "reject");
  j.write_int("Value", source_amf_ue_ngap_id);
  j.write_int("id", 121);
  j.write_str("criticality", "ignore");
  user_location_info.to_json(j);
  j.write_int("id", 119);
  j.write_str("criticality", "ignore");
  ue_security_cap.to_json(j);
  j.write_int("id", 76);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_to_be_switched_dl_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (pdu_session_res_failed_to_setup_list_ps_req_present) {
    j.write_int("id", 57);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_setup_list_ps_req) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (rrc_resume_cause_present) {
    j.write_int("id", 237);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rrc_resume_cause.to_string());
  }
  if (red_cap_ind_present) {
    j.write_int("id", 333);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "redcap");
  }
  j.end_obj();
}

SRSASN_CODE path_switch_request_ack_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  nof_ies += ue_security_cap_present ? 1 : 0;
  nof_ies += new_security_context_ind_present ? 1 : 0;
  nof_ies += pdu_session_res_released_list_ps_ack_present ? 1 : 0;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += redirection_voice_fallback_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += enhanced_coverage_restrict_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ce_mode_brestricted_present ? 1 : 0;
  nof_ies += ue_up_c_iot_support_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_list_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_mod_list_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ue_security_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)119, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)93, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_context.pack(bref));
  }
  if (new_security_context_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)41, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(new_security_context_ind.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)77, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_switched_list, 1, 256, true));
  }
  if (pdu_session_res_released_list_ps_ack_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)68, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_released_list_ps_ack, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)18, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)91, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (redirection_voice_fallback_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)146, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(redirection_voice_fallback.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)165, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)177, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (enhanced_coverage_restrict_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)205, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(enhanced_coverage_restrict.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)206, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, extended_connected_time, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)215, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)218, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)217, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ce_mode_brestricted_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)222, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ce_mode_brestricted.pack(bref));
  }
  if (ue_up_c_iot_support_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)234, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_up_c_iot_support.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (management_based_mdt_plmn_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)254, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, management_based_mdt_plmn_list, 1, 16, true));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)326, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)345, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)346, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)347, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }
  if (management_based_mdt_plmn_mod_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)359, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, management_based_mdt_plmn_mod_list, 0, 16, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_ack_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 119: {
        ue_security_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.unpack(bref));
        break;
      }
      case 93: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.unpack(bref));
        break;
      }
      case 41: {
        new_security_context_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_security_context_ind.unpack(bref));
        break;
      }
      case 77: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_switched_list, bref, 1, 256, true));
        break;
      }
      case 68: {
        pdu_session_res_released_list_ps_ack_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_released_list_ps_ack, bref, 1, 256, true));
        break;
      }
      case 0: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.unpack(bref));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 146: {
        redirection_voice_fallback_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(redirection_voice_fallback.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.unpack(bref));
        break;
      }
      case 205: {
        enhanced_coverage_restrict_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(enhanced_coverage_restrict.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(extended_connected_time, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.unpack(bref));
        break;
      }
      case 222: {
        ce_mode_brestricted_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ce_mode_brestricted.unpack(bref));
        break;
      }
      case 234: {
        ue_up_c_iot_support_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_up_c_iot_support.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 254: {
        management_based_mdt_plmn_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(management_based_mdt_plmn_list, bref, 1, 16, true));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.unpack(bref));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.unpack(bref));
        break;
      }
      case 359: {
        management_based_mdt_plmn_mod_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(management_based_mdt_plmn_mod_list, bref, 0, 16, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_ack_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (ue_security_cap_present) {
    j.write_int("id", 119);
    j.write_str("criticality", "reject");
    ue_security_cap.to_json(j);
  }
  j.write_int("id", 93);
  j.write_str("criticality", "reject");
  security_context.to_json(j);
  if (new_security_context_ind_present) {
    j.write_int("id", 41);
    j.write_str("criticality", "reject");
    j.write_str("Value", "true");
  }
  j.write_int("id", 77);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_switched_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (pdu_session_res_released_list_ps_ack_present) {
    j.write_int("id", 68);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_released_list_ps_ack) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 0);
  j.write_str("criticality", "reject");
  j.start_array("Value");
  for (const auto& e1 : allowed_nssai) {
    e1.to_json(j);
  }
  j.end_array();
  if (core_network_assist_info_for_inactive_present) {
    j.write_int("id", 18);
    j.write_str("criticality", "ignore");
    core_network_assist_info_for_inactive.to_json(j);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_int("id", 91);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rrc_inactive_transition_report_request.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (redirection_voice_fallback_present) {
    j.write_int("id", 146);
    j.write_str("criticality", "ignore");
    j.write_str("Value", redirection_voice_fallback.to_string());
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_int("id", 165);
    j.write_str("criticality", "ignore");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_int("id", 177);
    j.write_str("criticality", "ignore");
    j.write_str("Value", srvcc_operation_possible.to_string());
  }
  if (enhanced_coverage_restrict_present) {
    j.write_int("id", 205);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "restricted");
  }
  if (extended_connected_time_present) {
    j.write_int("id", 206);
    j.write_str("criticality", "ignore");
    j.write_int("Value", extended_connected_time);
  }
  if (ue_diff_info_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    ue_diff_info.to_json(j);
  }
  if (nr_v2x_services_authorized_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_int("id", 215);
    j.write_str("criticality", "ignore");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 218);
    j.write_str("criticality", "ignore");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 217);
    j.write_str("criticality", "ignore");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    pc5_qos_params.to_json(j);
  }
  if (ce_mode_brestricted_present) {
    j.write_int("id", 222);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ce_mode_brestricted.to_string());
  }
  if (ue_up_c_iot_support_present) {
    j.write_int("id", 234);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "supported");
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  if (management_based_mdt_plmn_list_present) {
    j.write_int("id", 254);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : management_based_mdt_plmn_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (time_sync_assist_info_present) {
    j.write_int("id", 326);
    j.write_str("criticality", "ignore");
    time_sync_assist_info.to_json(j);
  }
  if (five_g_pro_se_authorized_present) {
    j.write_int("id", 345);
    j.write_str("criticality", "ignore");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_int("id", 346);
    j.write_str("criticality", "ignore");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_int("id", 347);
    j.write_str("criticality", "ignore");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  if (management_based_mdt_plmn_mod_list_present) {
    j.write_int("id", 359);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : management_based_mdt_plmn_mod_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  j.end_obj();
}

SRSASN_CODE path_switch_request_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)69, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_released_list_ps_fail, 1, 256, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE path_switch_request_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 69: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_released_list_ps_fail, bref, 1, 256, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void path_switch_request_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 69);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_released_list_ps_fail) {
    e1.to_json(j);
  }
  j.end_array();
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE private_ie_container_empty_l::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  pack_length(bref, nof_ies, 1u, 65535u, true);

  return SRSASN_SUCCESS;
}
SRSASN_CODE private_ie_container_empty_l::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 1u, 65535u, true);
  if (nof_ies > 0) {
    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void private_ie_container_empty_l::to_json(json_writer& j) const
{
  j.start_obj();
  j.end_obj();
}

// PrivateMessage ::= SEQUENCE
SRSASN_CODE private_msg_s::pack(bit_ref& bref) const
{
  bref.pack(ext, 1);
  HANDLE_CODE(private_ies.pack(bref));

  bref.align_bytes_zero();

  return SRSASN_SUCCESS;
}
SRSASN_CODE private_msg_s::unpack(cbit_ref& bref)
{
  bref.unpack(ext, 1);
  HANDLE_CODE(private_ies.unpack(bref));

  bref.align_bytes();

  return SRSASN_SUCCESS;
}
void private_msg_s::to_json(json_writer& j) const
{
  j.start_array();
  j.start_obj();
  j.start_obj("PrivateMessage");
  j.write_fieldname("privateIEs");
  private_ies.to_json(j);
  j.end_obj();
  j.end_obj();
  j.end_array();
}

SRSASN_CODE ran_cp_relocation_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 5;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)26, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_s_tmsi.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)25, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(eutra_cgi.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)213, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tai.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)211, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ul_cp_security_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cp_relocation_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 5;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 26: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.unpack(bref));
        break;
      }
      case 25: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(eutra_cgi.unpack(bref));
        break;
      }
      case 213: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tai.unpack(bref));
        break;
      }
      case 211: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ul_cp_security_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ran_cp_relocation_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 26);
  j.write_str("criticality", "reject");
  five_g_s_tmsi.to_json(j);
  j.write_int("id", 25);
  j.write_str("criticality", "ignore");
  eutra_cgi.to_json(j);
  j.write_int("id", 213);
  j.write_str("criticality", "ignore");
  tai.to_json(j);
  j.write_int("id", 211);
  j.write_str("criticality", "reject");
  ul_cp_security_info.to_json(j);
  j.end_obj();
}

SRSASN_CODE ran_cfg_upd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += ran_node_name_present ? 1 : 0;
  nof_ies += supported_ta_list_present ? 1 : 0;
  nof_ies += default_paging_drx_present ? 1 : 0;
  nof_ies += global_ran_node_id_present ? 1 : 0;
  nof_ies += ngran_tnl_assoc_to_rem_list_present ? 1 : 0;
  nof_ies += nb_iot_default_paging_drx_present ? 1 : 0;
  nof_ies += extended_ran_node_name_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (ran_node_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)82, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ran_node_name.pack(bref));
  }
  if (supported_ta_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)102, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, supported_ta_list, 1, 256, true));
  }
  if (default_paging_drx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)21, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(default_paging_drx.pack(bref));
  }
  if (global_ran_node_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)27, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(global_ran_node_id.pack(bref));
  }
  if (ngran_tnl_assoc_to_rem_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)167, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ngran_tnl_assoc_to_rem_list, 1, 32, true));
  }
  if (nb_iot_default_paging_drx_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)204, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nb_iot_default_paging_drx.pack(bref));
  }
  if (extended_ran_node_name_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)273, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(extended_ran_node_name.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 82: {
        ran_node_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_node_name.unpack(bref));
        break;
      }
      case 102: {
        supported_ta_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(supported_ta_list, bref, 1, 256, true));
        break;
      }
      case 21: {
        default_paging_drx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(default_paging_drx.unpack(bref));
        break;
      }
      case 27: {
        global_ran_node_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(global_ran_node_id.unpack(bref));
        break;
      }
      case 167: {
        ngran_tnl_assoc_to_rem_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ngran_tnl_assoc_to_rem_list, bref, 1, 32, true));
        break;
      }
      case 204: {
        nb_iot_default_paging_drx_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nb_iot_default_paging_drx.unpack(bref));
        break;
      }
      case 273: {
        extended_ran_node_name_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(extended_ran_node_name.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ran_cfg_upd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (ran_node_name_present) {
    j.write_int("id", 82);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ran_node_name.to_string());
  }
  if (supported_ta_list_present) {
    j.write_int("id", 102);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : supported_ta_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (default_paging_drx_present) {
    j.write_int("id", 21);
    j.write_str("criticality", "ignore");
    j.write_str("Value", default_paging_drx.to_string());
  }
  if (global_ran_node_id_present) {
    j.write_int("id", 27);
    j.write_str("criticality", "ignore");
    global_ran_node_id.to_json(j);
  }
  if (ngran_tnl_assoc_to_rem_list_present) {
    j.write_int("id", 167);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : ngran_tnl_assoc_to_rem_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (nb_iot_default_paging_drx_present) {
    j.write_int("id", 204);
    j.write_str("criticality", "ignore");
    j.write_str("Value", nb_iot_default_paging_drx.to_string());
  }
  if (extended_ran_node_name_present) {
    j.write_int("id", 273);
    j.write_str("criticality", "ignore");
    extended_ran_node_name.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ran_cfg_upd_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += time_to_wait_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (time_to_wait_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)107, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_to_wait.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ran_cfg_upd_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 107: {
        time_to_wait_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_to_wait.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ran_cfg_upd_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (time_to_wait_present) {
    j.write_int("id", 107);
    j.write_str("criticality", "ignore");
    j.write_str("Value", time_to_wait.to_string());
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE rrc_inactive_transition_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)92, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_state.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE rrc_inactive_transition_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 92: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_state.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void rrc_inactive_transition_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 92);
  j.write_str("criticality", "ignore");
  j.write_str("Value", rrc_state.to_string());
  j.write_int("id", 121);
  j.write_str("criticality", "ignore");
  user_location_info.to_json(j);
  j.end_obj();
}

SRSASN_CODE reroute_nas_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += amf_ue_ngap_id_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += source_to_target_amf_info_reroute_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (amf_ue_ngap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)42, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ngap_msg.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)3, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(amf_set_id.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (source_to_target_amf_info_reroute_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)171, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(source_to_target_amf_info_reroute.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE reroute_nas_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 10: {
        amf_ue_ngap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 42: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngap_msg.unpack(bref));
        break;
      }
      case 3: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(amf_set_id.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 171: {
        source_to_target_amf_info_reroute_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(source_to_target_amf_info_reroute.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void reroute_nas_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (amf_ue_ngap_id_present) {
    j.write_int("id", 10);
    j.write_str("criticality", "ignore");
    j.write_int("Value", amf_ue_ngap_id);
  }
  j.write_int("id", 42);
  j.write_str("criticality", "reject");
  j.write_str("Value", ngap_msg.to_string());
  j.write_int("id", 3);
  j.write_str("criticality", "reject");
  j.write_str("Value", amf_set_id.to_string());
  if (allowed_nssai_present) {
    j.write_int("id", 0);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : allowed_nssai) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (source_to_target_amf_info_reroute_present) {
    j.write_int("id", 171);
    j.write_str("criticality", "ignore");
    source_to_target_amf_info_reroute.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE secondary_rat_data_usage_report_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ho_flag_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)142, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_secondary_rat_usage_list, 1, 256, true));
  }
  if (ho_flag_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)143, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ho_flag.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE secondary_rat_data_usage_report_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 142: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_secondary_rat_usage_list, bref, 1, 256, true));
        break;
      }
      case 143: {
        ho_flag_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ho_flag.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void secondary_rat_data_usage_report_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 142);
  j.write_str("criticality", "ignore");
  j.start_array("Value");
  for (const auto& e1 : pdu_session_res_secondary_rat_usage_list) {
    e1.to_json(j);
  }
  j.end_array();
  if (ho_flag_present) {
    j.write_int("id", 143);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "handover-preparation");
  }
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE trace_fail_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)44, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ngran_trace_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_fail_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 44: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ngran_trace_id.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void trace_fail_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 44);
  j.write_str("criticality", "ignore");
  j.write_str("Value", ngran_trace_id.to_string());
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

SRSASN_CODE trace_start_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)108, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(trace_activation.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE trace_start_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 108: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(trace_activation.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void trace_start_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 108);
  j.write_str("criticality", "ignore");
  trace_activation.to_json(j);
  j.end_obj();
}

SRSASN_CODE ue_context_mod_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ue_context_mod_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ran_paging_prio_present ? 1 : 0;
  nof_ies += security_key_present ? 1 : 0;
  nof_ies += idx_to_rfsp_present ? 1 : 0;
  nof_ies += ue_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += ue_security_cap_present ? 1 : 0;
  nof_ies += core_network_assist_info_for_inactive_present ? 1 : 0;
  nof_ies += emergency_fallback_ind_present ? 1 : 0;
  nof_ies += new_amf_ue_ngap_id_present ? 1 : 0;
  nof_ies += rrc_inactive_transition_report_request_present ? 1 : 0;
  nof_ies += new_guami_present ? 1 : 0;
  nof_ies += cn_assisted_ran_tuning_present ? 1 : 0;
  nof_ies += srvcc_operation_possible_present ? 1 : 0;
  nof_ies += iab_authorized_present ? 1 : 0;
  nof_ies += nr_v2x_services_authorized_present ? 1 : 0;
  nof_ies += ltev2x_services_authorized_present ? 1 : 0;
  nof_ies += nr_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += lte_ue_sidelink_aggr_max_bitrate_present ? 1 : 0;
  nof_ies += pc5_qos_params_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  nof_ies += rg_level_wireline_access_characteristics_present ? 1 : 0;
  nof_ies += time_sync_assist_info_present ? 1 : 0;
  nof_ies += q_mcc_onfig_info_present ? 1 : 0;
  nof_ies += qmc_deactivation_present ? 1 : 0;
  nof_ies += ue_slice_max_bit_rate_list_present ? 1 : 0;
  nof_ies += management_based_mdt_plmn_mod_list_present ? 1 : 0;
  nof_ies += five_g_pro_se_authorized_present ? 1 : 0;
  nof_ies += five_g_pro_se_ue_pc5_aggr_max_bit_rate_present ? 1 : 0;
  nof_ies += five_g_pro_se_pc5_qos_params_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ran_paging_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)83, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_paging_prio, (uint16_t)1u, (uint16_t)256u, false, true));
  }
  if (security_key_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)94, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_key.pack(bref));
  }
  if (idx_to_rfsp_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)31, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, idx_to_rfsp, (uint16_t)1u, (uint16_t)256u, true, true));
  }
  if (ue_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)110, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_aggr_max_bit_rate.pack(bref));
  }
  if (ue_security_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)119, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_security_cap.pack(bref));
  }
  if (core_network_assist_info_for_inactive_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)18, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(core_network_assist_info_for_inactive.pack(bref));
  }
  if (emergency_fallback_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)24, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(emergency_fallback_ind.pack(bref));
  }
  if (new_amf_ue_ngap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)40, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, new_amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  if (rrc_inactive_transition_report_request_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)91, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_inactive_transition_report_request.pack(bref));
  }
  if (new_guami_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)162, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(new_guami.pack(bref));
  }
  if (cn_assisted_ran_tuning_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)165, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cn_assisted_ran_tuning.pack(bref));
  }
  if (srvcc_operation_possible_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)177, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(srvcc_operation_possible.pack(bref));
  }
  if (iab_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)199, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(iab_authorized.pack(bref));
  }
  if (nr_v2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)216, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_v2x_services_authorized.pack(bref));
  }
  if (ltev2x_services_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)215, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ltev2x_services_authorized.pack(bref));
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)218, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)217, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.pack(bref));
  }
  if (pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)219, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pc5_qos_params.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  if (rg_level_wireline_access_characteristics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)238, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rg_level_wireline_access_characteristics.pack(bref));
  }
  if (time_sync_assist_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)326, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(time_sync_assist_info.pack(bref));
  }
  if (q_mcc_onfig_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)328, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(q_mcc_onfig_info.pack(bref));
  }
  if (qmc_deactivation_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)329, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(qmc_deactivation.pack(bref));
  }
  if (ue_slice_max_bit_rate_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)335, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, ue_slice_max_bit_rate_list, 1, 8, true));
  }
  if (management_based_mdt_plmn_mod_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)359, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, management_based_mdt_plmn_mod_list, 0, 16, true));
  }
  if (five_g_pro_se_authorized_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)345, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_authorized.pack(bref));
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)346, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.pack(bref));
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)347, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_pro_se_pc5_qos_params.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 83: {
        ran_paging_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_paging_prio, bref, (uint16_t)1u, (uint16_t)256u, false, true));
        break;
      }
      case 94: {
        security_key_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_key.unpack(bref));
        break;
      }
      case 31: {
        idx_to_rfsp_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(idx_to_rfsp, bref, (uint16_t)1u, (uint16_t)256u, true, true));
        break;
      }
      case 110: {
        ue_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 119: {
        ue_security_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_security_cap.unpack(bref));
        break;
      }
      case 18: {
        core_network_assist_info_for_inactive_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(core_network_assist_info_for_inactive.unpack(bref));
        break;
      }
      case 24: {
        emergency_fallback_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(emergency_fallback_ind.unpack(bref));
        break;
      }
      case 40: {
        new_amf_ue_ngap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(new_amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 91: {
        rrc_inactive_transition_report_request_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_inactive_transition_report_request.unpack(bref));
        break;
      }
      case 162: {
        new_guami_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(new_guami.unpack(bref));
        break;
      }
      case 165: {
        cn_assisted_ran_tuning_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cn_assisted_ran_tuning.unpack(bref));
        break;
      }
      case 177: {
        srvcc_operation_possible_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(srvcc_operation_possible.unpack(bref));
        break;
      }
      case 199: {
        iab_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(iab_authorized.unpack(bref));
        break;
      }
      case 216: {
        nr_v2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_v2x_services_authorized.unpack(bref));
        break;
      }
      case 215: {
        ltev2x_services_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ltev2x_services_authorized.unpack(bref));
        break;
      }
      case 218: {
        nr_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nr_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 217: {
        lte_ue_sidelink_aggr_max_bitrate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(lte_ue_sidelink_aggr_max_bitrate.unpack(bref));
        break;
      }
      case 219: {
        pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(pc5_qos_params.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 238: {
        rg_level_wireline_access_characteristics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rg_level_wireline_access_characteristics.unpack(bref));
        break;
      }
      case 326: {
        time_sync_assist_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(time_sync_assist_info.unpack(bref));
        break;
      }
      case 328: {
        q_mcc_onfig_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(q_mcc_onfig_info.unpack(bref));
        break;
      }
      case 329: {
        qmc_deactivation_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(qmc_deactivation.unpack(bref));
        break;
      }
      case 335: {
        ue_slice_max_bit_rate_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(ue_slice_max_bit_rate_list, bref, 1, 8, true));
        break;
      }
      case 359: {
        management_based_mdt_plmn_mod_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(management_based_mdt_plmn_mod_list, bref, 0, 16, true));
        break;
      }
      case 345: {
        five_g_pro_se_authorized_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_authorized.unpack(bref));
        break;
      }
      case 346: {
        five_g_pro_se_ue_pc5_aggr_max_bit_rate_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_ue_pc5_aggr_max_bit_rate.unpack(bref));
        break;
      }
      case 347: {
        five_g_pro_se_pc5_qos_params_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_pro_se_pc5_qos_params.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (ran_paging_prio_present) {
    j.write_int("id", 83);
    j.write_str("criticality", "ignore");
    j.write_int("Value", ran_paging_prio);
  }
  if (security_key_present) {
    j.write_int("id", 94);
    j.write_str("criticality", "reject");
    j.write_str("Value", security_key.to_string());
  }
  if (idx_to_rfsp_present) {
    j.write_int("id", 31);
    j.write_str("criticality", "ignore");
    j.write_int("Value", idx_to_rfsp);
  }
  if (ue_aggr_max_bit_rate_present) {
    j.write_int("id", 110);
    j.write_str("criticality", "ignore");
    ue_aggr_max_bit_rate.to_json(j);
  }
  if (ue_security_cap_present) {
    j.write_int("id", 119);
    j.write_str("criticality", "reject");
    ue_security_cap.to_json(j);
  }
  if (core_network_assist_info_for_inactive_present) {
    j.write_int("id", 18);
    j.write_str("criticality", "ignore");
    core_network_assist_info_for_inactive.to_json(j);
  }
  if (emergency_fallback_ind_present) {
    j.write_int("id", 24);
    j.write_str("criticality", "reject");
    emergency_fallback_ind.to_json(j);
  }
  if (new_amf_ue_ngap_id_present) {
    j.write_int("id", 40);
    j.write_str("criticality", "reject");
    j.write_int("Value", new_amf_ue_ngap_id);
  }
  if (rrc_inactive_transition_report_request_present) {
    j.write_int("id", 91);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rrc_inactive_transition_report_request.to_string());
  }
  if (new_guami_present) {
    j.write_int("id", 162);
    j.write_str("criticality", "reject");
    new_guami.to_json(j);
  }
  if (cn_assisted_ran_tuning_present) {
    j.write_int("id", 165);
    j.write_str("criticality", "ignore");
    cn_assisted_ran_tuning.to_json(j);
  }
  if (srvcc_operation_possible_present) {
    j.write_int("id", 177);
    j.write_str("criticality", "ignore");
    j.write_str("Value", srvcc_operation_possible.to_string());
  }
  if (iab_authorized_present) {
    j.write_int("id", 199);
    j.write_str("criticality", "ignore");
    j.write_str("Value", iab_authorized.to_string());
  }
  if (nr_v2x_services_authorized_present) {
    j.write_int("id", 216);
    j.write_str("criticality", "ignore");
    nr_v2x_services_authorized.to_json(j);
  }
  if (ltev2x_services_authorized_present) {
    j.write_int("id", 215);
    j.write_str("criticality", "ignore");
    ltev2x_services_authorized.to_json(j);
  }
  if (nr_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 218);
    j.write_str("criticality", "ignore");
    nr_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (lte_ue_sidelink_aggr_max_bitrate_present) {
    j.write_int("id", 217);
    j.write_str("criticality", "ignore");
    lte_ue_sidelink_aggr_max_bitrate.to_json(j);
  }
  if (pc5_qos_params_present) {
    j.write_int("id", 219);
    j.write_str("criticality", "ignore");
    pc5_qos_params.to_json(j);
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  if (rg_level_wireline_access_characteristics_present) {
    j.write_int("id", 238);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rg_level_wireline_access_characteristics.to_string());
  }
  if (time_sync_assist_info_present) {
    j.write_int("id", 326);
    j.write_str("criticality", "ignore");
    time_sync_assist_info.to_json(j);
  }
  if (q_mcc_onfig_info_present) {
    j.write_int("id", 328);
    j.write_str("criticality", "ignore");
    q_mcc_onfig_info.to_json(j);
  }
  if (qmc_deactivation_present) {
    j.write_int("id", 329);
    j.write_str("criticality", "ignore");
    qmc_deactivation.to_json(j);
  }
  if (ue_slice_max_bit_rate_list_present) {
    j.write_int("id", 335);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : ue_slice_max_bit_rate_list) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (management_based_mdt_plmn_mod_list_present) {
    j.write_int("id", 359);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : management_based_mdt_plmn_mod_list) {
      j.write_str(e1.to_string());
    }
    j.end_array();
  }
  if (five_g_pro_se_authorized_present) {
    j.write_int("id", 345);
    j.write_str("criticality", "ignore");
    five_g_pro_se_authorized.to_json(j);
  }
  if (five_g_pro_se_ue_pc5_aggr_max_bit_rate_present) {
    j.write_int("id", 346);
    j.write_str("criticality", "ignore");
    five_g_pro_se_ue_pc5_aggr_max_bit_rate.to_json(j);
  }
  if (five_g_pro_se_pc5_qos_params_present) {
    j.write_int("id", 347);
    j.write_str("criticality", "ignore");
    five_g_pro_se_pc5_qos_params.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ue_context_mod_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += rrc_state_present ? 1 : 0;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (rrc_state_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)92, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_state.pack(bref));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_mod_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 92: {
        rrc_state_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_state.unpack(bref));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_mod_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (rrc_state_present) {
    j.write_int("id", 92);
    j.write_str("criticality", "ignore");
    j.write_str("Value", rrc_state.to_string());
  }
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ue_context_release_cmd_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)114, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_ngap_ids.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_cmd_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 114: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_ngap_ids.unpack(bref));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_cmd_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 114);
  j.write_str("criticality", "reject");
  ue_ngap_ids.to_json(j);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

SRSASN_CODE ue_context_release_complete_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += user_location_info_present ? 1 : 0;
  nof_ies += info_on_recommended_cells_and_ran_nodes_for_paging_present ? 1 : 0;
  nof_ies += pdu_session_res_list_cxt_rel_cpl_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (user_location_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)32, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.pack(bref));
  }
  if (pdu_session_res_list_cxt_rel_cpl_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)60, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_list_cxt_rel_cpl, 1, 256, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)207, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_complete_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 121: {
        user_location_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 32: {
        info_on_recommended_cells_and_ran_nodes_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.unpack(bref));
        break;
      }
      case 60: {
        pdu_session_res_list_cxt_rel_cpl_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_list_cxt_rel_cpl, bref, 1, 256, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_complete_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (user_location_info_present) {
    j.write_int("id", 121);
    j.write_str("criticality", "ignore");
    user_location_info.to_json(j);
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    j.write_int("id", 32);
    j.write_str("criticality", "ignore");
    info_on_recommended_cells_and_ran_nodes_for_paging.to_json(j);
  }
  if (pdu_session_res_list_cxt_rel_cpl_present) {
    j.write_int("id", 60);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_list_cxt_rel_cpl) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_int("id", 207);
    j.write_str("criticality", "ignore");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ue_context_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_res_list_cxt_rel_req_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_list_cxt_rel_req_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)133, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_list_cxt_rel_req, 1, 256, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 133: {
        pdu_session_res_list_cxt_rel_req_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_list_cxt_rel_req, bref, 1, 256, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_list_cxt_rel_req_present) {
    j.write_int("id", 133);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_list_cxt_rel_req) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  j.end_obj();
}

SRSASN_CODE ue_context_resume_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ue_context_resume_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += pdu_session_res_resume_list_res_req_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_resume_list_res_req_present ? 1 : 0;
  nof_ies += suspend_request_ind_present ? 1 : 0;
  nof_ies += info_on_recommended_cells_and_ran_nodes_for_paging_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)237, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(rrc_resume_cause.pack(bref));
  }
  if (pdu_session_res_resume_list_res_req_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)232, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_resume_list_res_req, 1, 256, true));
  }
  if (pdu_session_res_failed_to_resume_list_res_req_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)229, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_resume_list_res_req, 1, 256, true));
  }
  if (suspend_request_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)235, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(suspend_request_ind.pack(bref));
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)32, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)207, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 237: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(rrc_resume_cause.unpack(bref));
        break;
      }
      case 232: {
        pdu_session_res_resume_list_res_req_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_resume_list_res_req, bref, 1, 256, true));
        break;
      }
      case 229: {
        pdu_session_res_failed_to_resume_list_res_req_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_resume_list_res_req, bref, 1, 256, true));
        break;
      }
      case 235: {
        suspend_request_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(suspend_request_ind.unpack(bref));
        break;
      }
      case 32: {
        info_on_recommended_cells_and_ran_nodes_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 237);
  j.write_str("criticality", "ignore");
  j.write_str("Value", rrc_resume_cause.to_string());
  if (pdu_session_res_resume_list_res_req_present) {
    j.write_int("id", 232);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_resume_list_res_req) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_failed_to_resume_list_res_req_present) {
    j.write_int("id", 229);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_resume_list_res_req) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (suspend_request_ind_present) {
    j.write_int("id", 235);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "suspend-requested");
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    j.write_int("id", 32);
    j.write_str("criticality", "ignore");
    info_on_recommended_cells_and_ran_nodes_for_paging.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_int("id", 207);
    j.write_str("criticality", "ignore");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ue_context_resume_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += pdu_session_res_resume_list_res_res_present ? 1 : 0;
  nof_ies += pdu_session_res_failed_to_resume_list_res_res_present ? 1 : 0;
  nof_ies += security_context_present ? 1 : 0;
  nof_ies += suspend_resp_ind_present ? 1 : 0;
  nof_ies += extended_connected_time_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (pdu_session_res_resume_list_res_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)233, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_resume_list_res_res, 1, 256, true));
  }
  if (pdu_session_res_failed_to_resume_list_res_res_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)230, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_failed_to_resume_list_res_res, 1, 256, true));
  }
  if (security_context_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)93, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_context.pack(bref));
  }
  if (suspend_resp_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)236, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(suspend_resp_ind.pack(bref));
  }
  if (extended_connected_time_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)206, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, extended_connected_time, (uint16_t)0u, (uint16_t)255u, false, true));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_resume_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 233: {
        pdu_session_res_resume_list_res_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_resume_list_res_res, bref, 1, 256, true));
        break;
      }
      case 230: {
        pdu_session_res_failed_to_resume_list_res_res_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_failed_to_resume_list_res_res, bref, 1, 256, true));
        break;
      }
      case 93: {
        security_context_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.unpack(bref));
        break;
      }
      case 236: {
        suspend_resp_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(suspend_resp_ind.unpack(bref));
        break;
      }
      case 206: {
        extended_connected_time_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(extended_connected_time, bref, (uint16_t)0u, (uint16_t)255u, false, true));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_resume_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (pdu_session_res_resume_list_res_res_present) {
    j.write_int("id", 233);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_resume_list_res_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (pdu_session_res_failed_to_resume_list_res_res_present) {
    j.write_int("id", 230);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_failed_to_resume_list_res_res) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (security_context_present) {
    j.write_int("id", 93);
    j.write_str("criticality", "reject");
    security_context.to_json(j);
  }
  if (suspend_resp_ind_present) {
    j.write_int("id", 236);
    j.write_str("criticality", "ignore");
    j.write_str("Value", "suspend-indicated");
  }
  if (extended_connected_time_present) {
    j.write_int("id", 206);
    j.write_str("criticality", "ignore");
    j.write_int("Value", extended_connected_time);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ue_context_suspend_fail_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)15, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(cause.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_fail_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 15: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(cause.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_fail_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 15);
  j.write_str("criticality", "ignore");
  cause.to_json(j);
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ue_context_suspend_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += info_on_recommended_cells_and_ran_nodes_for_paging_present ? 1 : 0;
  nof_ies += paging_assis_datafor_c_ecapab_ue_present ? 1 : 0;
  nof_ies += pdu_session_res_suspend_list_sus_req_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)32, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.pack(bref));
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)207, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.pack(bref));
  }
  if (pdu_session_res_suspend_list_sus_req_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)231, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, pdu_session_res_suspend_list_sus_req, 1, 256, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 32: {
        info_on_recommended_cells_and_ran_nodes_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(info_on_recommended_cells_and_ran_nodes_for_paging.unpack(bref));
        break;
      }
      case 207: {
        paging_assis_datafor_c_ecapab_ue_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(paging_assis_datafor_c_ecapab_ue.unpack(bref));
        break;
      }
      case 231: {
        pdu_session_res_suspend_list_sus_req_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(pdu_session_res_suspend_list_sus_req, bref, 1, 256, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (info_on_recommended_cells_and_ran_nodes_for_paging_present) {
    j.write_int("id", 32);
    j.write_str("criticality", "ignore");
    info_on_recommended_cells_and_ran_nodes_for_paging.to_json(j);
  }
  if (paging_assis_datafor_c_ecapab_ue_present) {
    j.write_int("id", 207);
    j.write_str("criticality", "ignore");
    paging_assis_datafor_c_ecapab_ue.to_json(j);
  }
  if (pdu_session_res_suspend_list_sus_req_present) {
    j.write_int("id", 231);
    j.write_str("criticality", "reject");
    j.start_array("Value");
    for (const auto& e1 : pdu_session_res_suspend_list_sus_req) {
      e1.to_json(j);
    }
    j.end_array();
  }
  j.end_obj();
}

SRSASN_CODE ue_context_suspend_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += security_context_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (security_context_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)93, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(security_context.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_context_suspend_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 93: {
        security_context_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(security_context.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_context_suspend_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  if (security_context_present) {
    j.write_int("id", 93);
    j.write_str("criticality", "reject");
    security_context.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ue_info_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 1;
  nof_ies += nb_iot_ue_prio_present ? 1 : 0;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += s_nssai_present ? 1 : 0;
  nof_ies += allowed_nssai_present ? 1 : 0;
  nof_ies += ue_diff_info_present ? 1 : 0;
  nof_ies += masked_imeisv_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)26, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(five_g_s_tmsi.pack(bref));
  }
  if (nb_iot_ue_prio_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)210, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, nb_iot_ue_prio, (uint16_t)0u, (uint16_t)255u, true, true));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (s_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)148, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(s_nssai.pack(bref));
  }
  if (allowed_nssai_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)0, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_dyn_seq_of(bref, allowed_nssai, 1, 8, true));
  }
  if (ue_diff_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)209, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_diff_info.pack(bref));
  }
  if (masked_imeisv_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)34, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(masked_imeisv.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_info_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 1;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 26: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(five_g_s_tmsi.unpack(bref));
        break;
      }
      case 210: {
        nb_iot_ue_prio_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(nb_iot_ue_prio, bref, (uint16_t)0u, (uint16_t)255u, true, true));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 148: {
        s_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(s_nssai.unpack(bref));
        break;
      }
      case 0: {
        allowed_nssai_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_dyn_seq_of(allowed_nssai, bref, 1, 8, true));
        break;
      }
      case 209: {
        ue_diff_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_diff_info.unpack(bref));
        break;
      }
      case 34: {
        masked_imeisv_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(masked_imeisv.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_info_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 26);
  j.write_str("criticality", "reject");
  five_g_s_tmsi.to_json(j);
  if (nb_iot_ue_prio_present) {
    j.write_int("id", 210);
    j.write_str("criticality", "ignore");
    j.write_int("Value", nb_iot_ue_prio);
  }
  if (ue_radio_cap_present) {
    j.write_int("id", 117);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ue_radio_cap.to_string());
  }
  if (s_nssai_present) {
    j.write_int("id", 148);
    j.write_str("criticality", "ignore");
    s_nssai.to_json(j);
  }
  if (allowed_nssai_present) {
    j.write_int("id", 0);
    j.write_str("criticality", "ignore");
    j.start_array("Value");
    for (const auto& e1 : allowed_nssai) {
      e1.to_json(j);
    }
    j.end_array();
  }
  if (ue_diff_info_present) {
    j.write_int("id", 209);
    j.write_str("criticality", "ignore");
    ue_diff_info.to_json(j);
  }
  if (masked_imeisv_present) {
    j.write_int("id", 34);
    j.write_str("criticality", "ignore");
    j.write_str("Value", masked_imeisv.to_string());
  }
  j.end_obj();
}

SRSASN_CODE ue_radio_cap_check_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += ue_radio_cap_present ? 1 : 0;
  nof_ies += ue_radio_cap_id_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  if (ue_radio_cap_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (ue_radio_cap_id_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 117: {
        ue_radio_cap_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 264: {
        ue_radio_cap_id_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_check_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  if (ue_radio_cap_present) {
    j.write_int("id", 117);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ue_radio_cap.to_string());
  }
  if (ue_radio_cap_id_present) {
    j.write_int("id", 264);
    j.write_str("criticality", "reject");
    j.write_str("Value", ue_radio_cap_id.to_string());
  }
  j.end_obj();
}

SRSASN_CODE ue_radio_cap_check_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)30, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ims_voice_support_ind.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_check_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 30: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ims_voice_support_ind.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_check_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "ignore");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "ignore");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 30);
  j.write_str("criticality", "reject");
  j.write_str("Value", ims_voice_support_ind.to_string());
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ue_radio_cap_id_map_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)264, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_id_map_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 264: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_id.unpack(bref));
        break;
      }
      case 117: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_id_map_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 264);
  j.write_str("criticality", "reject");
  j.write_str("Value", ue_radio_cap_id.to_string());
  j.write_int("id", 117);
  j.write_str("criticality", "ignore");
  j.write_str("Value", ue_radio_cap.to_string());
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ue_radio_cap_info_ind_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  nof_ies += ue_radio_cap_for_paging_present ? 1 : 0;
  nof_ies += ue_radio_cap_eutra_format_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)117, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap.pack(bref));
  }
  if (ue_radio_cap_for_paging_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)118, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_for_paging.pack(bref));
  }
  if (ue_radio_cap_eutra_format_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)265, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ue_radio_cap_eutra_format.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_radio_cap_info_ind_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 117: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap.unpack(bref));
        break;
      }
      case 118: {
        ue_radio_cap_for_paging_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_for_paging.unpack(bref));
        break;
      }
      case 265: {
        ue_radio_cap_eutra_format_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ue_radio_cap_eutra_format.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_radio_cap_info_ind_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 117);
  j.write_str("criticality", "ignore");
  j.write_str("Value", ue_radio_cap.to_string());
  if (ue_radio_cap_for_paging_present) {
    j.write_int("id", 118);
    j.write_str("criticality", "ignore");
    ue_radio_cap_for_paging.to_json(j);
  }
  if (ue_radio_cap_eutra_format_present) {
    j.write_int("id", 265);
    j.write_str("criticality", "ignore");
    j.write_str("Value", ue_radio_cap_eutra_format.to_string());
  }
  j.end_obj();
}

SRSASN_CODE ue_tnla_binding_release_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ue_tnla_binding_release_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ue_tnla_binding_release_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.end_obj();
}

SRSASN_CODE ul_nas_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += w_agf_id_info_present ? 1 : 0;
  nof_ies += tngf_id_info_present ? 1 : 0;
  nof_ies += twif_id_info_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)38, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nas_pdu.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)121, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(user_location_info.pack(bref));
  }
  if (w_agf_id_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)239, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(w_agf_id_info.pack(bref));
  }
  if (tngf_id_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)246, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(tngf_id_info.pack(bref));
  }
  if (twif_id_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)247, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(twif_id_info.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_nas_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 38: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nas_pdu.unpack(bref));
        break;
      }
      case 121: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(user_location_info.unpack(bref));
        break;
      }
      case 239: {
        w_agf_id_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(w_agf_id_info.unpack(bref));
        break;
      }
      case 246: {
        tngf_id_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(tngf_id_info.unpack(bref));
        break;
      }
      case 247: {
        twif_id_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(twif_id_info.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_nas_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 38);
  j.write_str("criticality", "reject");
  j.write_str("Value", nas_pdu.to_string());
  j.write_int("id", 121);
  j.write_str("criticality", "ignore");
  user_location_info.to_json(j);
  if (w_agf_id_info_present) {
    j.write_int("id", 239);
    j.write_str("criticality", "reject");
    j.write_str("Value", w_agf_id_info.to_string());
  }
  if (tngf_id_info_present) {
    j.write_int("id", 246);
    j.write_str("criticality", "reject");
    j.write_str("Value", tngf_id_info.to_string());
  }
  if (twif_id_info_present) {
    j.write_int("id", 247);
    j.write_str("criticality", "reject");
    j.write_str("Value", twif_id_info.to_string());
  }
  j.end_obj();
}

SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)89, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(routing_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)46, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nrppa_pdu.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_non_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 89: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_non_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 89);
  j.write_str("criticality", "reject");
  j.write_str("Value", routing_id.to_string());
  j.write_int("id", 46);
  j.write_str("criticality", "reject");
  j.write_str("Value", nrppa_pdu.to_string());
  j.end_obj();
}

SRSASN_CODE ul_ran_cfg_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 0;
  nof_ies += son_cfg_transfer_ul_present ? 1 : 0;
  nof_ies += endc_son_cfg_transfer_ul_present ? 1 : 0;
  nof_ies += intersys_son_cfg_transfer_ul_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  if (son_cfg_transfer_ul_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)99, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(son_cfg_transfer_ul.pack(bref));
  }
  if (endc_son_cfg_transfer_ul_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)158, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(endc_son_cfg_transfer_ul.pack(bref));
  }
  if (intersys_son_cfg_transfer_ul_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)251, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(intersys_son_cfg_transfer_ul.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_cfg_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 99: {
        son_cfg_transfer_ul_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(son_cfg_transfer_ul.unpack(bref));
        break;
      }
      case 158: {
        endc_son_cfg_transfer_ul_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(endc_son_cfg_transfer_ul.unpack(bref));
        break;
      }
      case 251: {
        intersys_son_cfg_transfer_ul_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(intersys_son_cfg_transfer_ul.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }

  return SRSASN_SUCCESS;
}
void ul_ran_cfg_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  if (son_cfg_transfer_ul_present) {
    j.write_int("id", 99);
    j.write_str("criticality", "ignore");
    son_cfg_transfer_ul.to_json(j);
  }
  if (endc_son_cfg_transfer_ul_present) {
    j.write_int("id", 158);
    j.write_str("criticality", "ignore");
    j.write_str("Value", endc_son_cfg_transfer_ul.to_string());
  }
  if (intersys_son_cfg_transfer_ul_present) {
    j.write_int("id", 251);
    j.write_str("criticality", "ignore");
    intersys_son_cfg_transfer_ul.to_json(j);
  }
  j.end_obj();
}

SRSASN_CODE ul_ran_early_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)268, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(early_status_transfer_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_early_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 268: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(early_status_transfer_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_ran_early_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 268);
  j.write_str("criticality", "reject");
  early_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

SRSASN_CODE ul_ran_status_transfer_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 3;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)84, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(ran_status_transfer_transparent_container.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ran_status_transfer_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 3;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 84: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(ran_status_transfer_transparent_container.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_ran_status_transfer_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 84);
  j.write_str("criticality", "reject");
  ran_status_transfer_transparent_container.to_json(j);
  j.end_obj();
}

SRSASN_CODE ul_ue_associated_nrppa_transport_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)10, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, amf_ue_ngap_id, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)85, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, ran_ue_ngap_id, (uint64_t)0u, (uint64_t)4294967295u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)89, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(routing_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)46, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(nrppa_pdu.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE ul_ue_associated_nrppa_transport_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 10: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(amf_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)1099511627775u, false, true));
        break;
      }
      case 85: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(ran_ue_ngap_id, bref, (uint64_t)0u, (uint64_t)4294967295u, false, true));
        break;
      }
      case 89: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(routing_id.unpack(bref));
        break;
      }
      case 46: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(nrppa_pdu.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void ul_ue_associated_nrppa_transport_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 10);
  j.write_str("criticality", "reject");
  j.write_int("Value", amf_ue_ngap_id);
  j.write_int("id", 85);
  j.write_str("criticality", "reject");
  j.write_int("Value", ran_ue_ngap_id);
  j.write_int("id", 89);
  j.write_str("criticality", "reject");
  j.write_str("Value", routing_id.to_string());
  j.write_int("id", 46);
  j.write_str("criticality", "reject");
  j.write_str("Value", nrppa_pdu.to_string());
  j.end_obj();
}

SRSASN_CODE write_replace_warning_request_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 4;
  nof_ies += warning_area_list_present ? 1 : 0;
  nof_ies += warning_type_present ? 1 : 0;
  nof_ies += warning_security_info_present ? 1 : 0;
  nof_ies += data_coding_scheme_present ? 1 : 0;
  nof_ies += warning_msg_contents_present ? 1 : 0;
  nof_ies += concurrent_warning_msg_ind_present ? 1 : 0;
  nof_ies += warning_area_coordinates_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)35, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(msg_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)95, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(serial_num.pack(bref));
  }
  if (warning_area_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)122, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(warning_area_list.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)87, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, repeat_period, (uint32_t)0u, (uint32_t)131071u, false, true));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)47, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(pack_integer(bref, nof_broadcasts_requested, (uint32_t)0u, (uint32_t)65535u, false, true));
  }
  if (warning_type_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)125, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(warning_type.pack(bref));
  }
  if (warning_security_info_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)124, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(warning_security_info.pack(bref));
  }
  if (data_coding_scheme_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)20, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(data_coding_scheme.pack(bref));
  }
  if (warning_msg_contents_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)123, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(warning_msg_contents.pack(bref));
  }
  if (concurrent_warning_msg_ind_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)17, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(concurrent_warning_msg_ind.pack(bref));
  }
  if (warning_area_coordinates_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)141, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(warning_area_coordinates.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_request_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 4;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.unpack(bref));
        break;
      }
      case 122: {
        warning_area_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_area_list.unpack(bref));
        break;
      }
      case 87: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(repeat_period, bref, (uint32_t)0u, (uint32_t)131071u, false, true));
        break;
      }
      case 47: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(unpack_integer(nof_broadcasts_requested, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
        break;
      }
      case 125: {
        warning_type_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_type.unpack(bref));
        break;
      }
      case 124: {
        warning_security_info_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_security_info.unpack(bref));
        break;
      }
      case 20: {
        data_coding_scheme_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(data_coding_scheme.unpack(bref));
        break;
      }
      case 123: {
        warning_msg_contents_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_msg_contents.unpack(bref));
        break;
      }
      case 17: {
        concurrent_warning_msg_ind_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(concurrent_warning_msg_ind.unpack(bref));
        break;
      }
      case 141: {
        warning_area_coordinates_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(warning_area_coordinates.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void write_replace_warning_request_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 35);
  j.write_str("criticality", "reject");
  j.write_str("Value", msg_id.to_string());
  j.write_int("id", 95);
  j.write_str("criticality", "reject");
  j.write_str("Value", serial_num.to_string());
  if (warning_area_list_present) {
    j.write_int("id", 122);
    j.write_str("criticality", "ignore");
    warning_area_list.to_json(j);
  }
  j.write_int("id", 87);
  j.write_str("criticality", "reject");
  j.write_int("Value", repeat_period);
  j.write_int("id", 47);
  j.write_str("criticality", "reject");
  j.write_int("Value", nof_broadcasts_requested);
  if (warning_type_present) {
    j.write_int("id", 125);
    j.write_str("criticality", "ignore");
    j.write_str("Value", warning_type.to_string());
  }
  if (warning_security_info_present) {
    j.write_int("id", 124);
    j.write_str("criticality", "ignore");
    j.write_str("Value", warning_security_info.to_string());
  }
  if (data_coding_scheme_present) {
    j.write_int("id", 20);
    j.write_str("criticality", "ignore");
    j.write_str("Value", data_coding_scheme.to_string());
  }
  if (warning_msg_contents_present) {
    j.write_int("id", 123);
    j.write_str("criticality", "ignore");
    j.write_str("Value", warning_msg_contents.to_string());
  }
  if (concurrent_warning_msg_ind_present) {
    j.write_int("id", 17);
    j.write_str("criticality", "reject");
    j.write_str("Value", "true");
  }
  if (warning_area_coordinates_present) {
    j.write_int("id", 141);
    j.write_str("criticality", "ignore");
    j.write_str("Value", warning_area_coordinates.to_string());
  }
  j.end_obj();
}

SRSASN_CODE write_replace_warning_resp_ies_container::pack(bit_ref& bref) const
{
  uint32_t nof_ies = 2;
  nof_ies += broadcast_completed_area_list_present ? 1 : 0;
  nof_ies += crit_diagnostics_present ? 1 : 0;
  pack_length(bref, nof_ies, 0u, 65535u, true);

  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)35, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(msg_id.pack(bref));
  }
  {
    HANDLE_CODE(pack_integer(bref, (uint32_t)95, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::reject}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(serial_num.pack(bref));
  }
  if (broadcast_completed_area_list_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)13, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(broadcast_completed_area_list.pack(bref));
  }
  if (crit_diagnostics_present) {
    HANDLE_CODE(pack_integer(bref, (uint32_t)19, (uint32_t)0u, (uint32_t)65535u, false, true));
    HANDLE_CODE(crit_e{crit_e::ignore}.pack(bref));
    varlength_field_pack_guard varlen_scope(bref, true);
    HANDLE_CODE(crit_diagnostics.pack(bref));
  }

  return SRSASN_SUCCESS;
}
SRSASN_CODE write_replace_warning_resp_ies_container::unpack(cbit_ref& bref)
{
  uint32_t nof_ies = 0;
  unpack_length(nof_ies, bref, 0u, 65535u, true);

  uint32_t nof_mandatory_ies = 2;

  for (; nof_ies > 0; --nof_ies) {
    uint32_t id;
    HANDLE_CODE(unpack_integer(id, bref, (uint32_t)0u, (uint32_t)65535u, false, true));
    crit_e crit;
    HANDLE_CODE(crit.unpack(bref));

    switch (id) {
      case 35: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(msg_id.unpack(bref));
        break;
      }
      case 95: {
        nof_mandatory_ies--;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(serial_num.unpack(bref));
        break;
      }
      case 13: {
        broadcast_completed_area_list_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(broadcast_completed_area_list.unpack(bref));
        break;
      }
      case 19: {
        crit_diagnostics_present = true;
        varlength_field_unpack_guard varlen_scope(bref, true);
        HANDLE_CODE(crit_diagnostics.unpack(bref));
        break;
      }
      default:
        asn1::log_error("Unpacked object ID={} is not recognized\n", id);
        return SRSASN_ERROR_DECODE_FAIL;
    }
  }
  if (nof_mandatory_ies > 0) {
    asn1::log_error("Mandatory fields are missing\n");

    return SRSASN_ERROR_DECODE_FAIL;
  }
  return SRSASN_SUCCESS;
}
void write_replace_warning_resp_ies_container::to_json(json_writer& j) const
{
  j.start_obj();
  j.write_int("id", 35);
  j.write_str("criticality", "reject");
  j.write_str("Value", msg_id.to_string());
  j.write_int("id", 95);
  j.write_str("criticality", "reject");
  j.write_str("Value", serial_num.to_string());
  if (broadcast_completed_area_list_present) {
    j.write_int("id", 13);
    j.write_str("criticality", "ignore");
    broadcast_completed_area_list.to_json(j);
  }
  if (crit_diagnostics_present) {
    j.write_int("id", 19);
    j.write_str("criticality", "ignore");
    crit_diagnostics.to_json(j);
  }
  j.end_obj();
}
